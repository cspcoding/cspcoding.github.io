<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>（三）宽度小于等于m的区间的“最大的和值”问题</title>
      <link href="/2025/01/01/%EF%BC%88%E4%B8%89%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"/>
      <url>/2025/01/01/%EF%BC%88%E4%B8%89%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>　　本帖是“最大子段和”系列问题的第3帖，主要研究固定宽度小于等于m的区间的“最大的和值”这个问题。</p><h1 id="一.-理论教学">一. 理论教学</h1><p>　　教学视频：<ahref="https://www.bilibili.com/video/BV1m54y117uu/?">单调队列连续子序列的最大和</a></p><h1 id="二.实战练习">二.实战练习</h1><h2 id="例-2最大连续和">2.1 1598：【 例 2】最大连续和</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<ahref="https://ybt.ssoier.cn/problem_show.php?pid=1598">1598：【 例2】最大连续和</a></p><h3 id="分析">2.1.2 分析</h3><p>　　之前我们练习过“不限区间宽度”及“区间宽度<spanclass="math inline">\(==m\)</span>”的情况。在“不限区间宽度”时，我们曾经在方法２中的版本２代码中，用单调队列来解决问题。已经记不太清楚的同学请看<a href="/2024/12/24/%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E5%BA%A6%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/#jump1"><font color="red">这里</font></a>。在单调队列进行处理时，因为并没有限制滑窗（即区间）宽度，所以在代码中并不需要处理队头的出队操作。</p><p>　　在本帖的1598这种题中，要求“区间宽度<spanclass="math inline">\(\leqm\)</span>”，只需要在单调队列代码模板里维护好滑窗宽度，做好队头的出队操作即可。单调队列本来就可以处理滑窗宽度<spanclass="math inline">\(\leqm\)</span>的情况。另外需要注意的是，在用单调队列求解时，是针对原始数据的<strong>“前缀和数组s[]”</strong>，在第i个元素<strong>左侧</strong>的宽度为ｍ（当<spanclass="math inline">\(i &lt; m\)</span>时允许滑窗宽度<spanclass="math inline">\(&lt;m\)</span>）的滑窗内求其<strong>最小值</strong>。而这正好也是“单调队列求最值”能做到的事情。</p><p>　　<span id="jump1">假设<spanclass="math inline">\(m=3\)</span>，</span>原始数组为<spanclass="math inline">\(a[1..n]\)</span>，对应的前缀和数组为<spanclass="math inline">\(s[1..n]\)</span>，<spanclass="math inline">\(dpmax[i]\)</span>表示"<strong>在选定<spanclass="math inline">\(a[i]\)</span>的前提下，在<spanclass="math inline">\(a[i-m+1..i]\)</span> 这<spanclass="math inline">\(m\)</span>个元素中选择的连续子段内所有数的最大和值</strong>"，写法"<spanclass="math inline">\(a[3..5]\)</span>"表示"<spanclass="math inline">\(a[3]+a[4]+a[5]\)</span>"，则有 $$ <spanclass="math display">\[\begin{align}dpmax[1]&amp;=max(\ a[1..1]\ ) \tag{1}  \\&amp;=max(s[1]-s[0]) \\&amp;=s[1]-min(s[0])（无它，保持和公式(2..5)一致的公式模式而已）\\&amp;= s[1]-0=s[1] = a[1]\\\\dpmax[2]&amp;=max(\ a[1..2],\ \ a[2..2]\ ) \\&amp;=max(s[2]-s[0],\ s[2]-s[1]) \\&amp;=s[2]-min(\ s[0], s[1])  \tag{2}\\\\dpmax[3]&amp;=max(\ \ a[1..3],\ \ \qquad \quad a[2..3],\ \ \qquad \quada[3..3]\ \ ) \\&amp;=max(\ s[3]-s[0],\ \quad s[3]-s[1],\ \quad s[3]-s[2]\ ) \\&amp;=s3-min(\ s[0],\ s[1],\ s[2]\ ) \tag{3}\\\\dpmax[4]&amp;=max(\ \ a[2..4],\ \ \qquad\quad  a[3..4],\ \ \qquad \quada[4..4]\ \ )  \\&amp;=max(\ s[4]-s[1],\ \quad s[4]-s[2],\ \quad s[4]-s[3]\ ) \\&amp;=s[4]-min(\ s[1],\ s[2],\ s[3]\ ) \tag{4}\\\\dpmax[5]&amp;=max(\ \ a[3..5],\ \ \qquad\quad  a[4..5],\ \ \qquad \quada[5..5]\ \ )  \\&amp;=max(\ s[5]-s[2],\ \quad s[5]-s[3],\ \quad s[5]-s[4]\ ) \\&amp;=s[5]-min(\ s[2],\ s[3],\ s[4]\ ) \tag{5}\\\\\end{align}\]</span> <span class="math display">\[则有一般性公式推导如下：\]</span> <span class="math display">\[\begin{align}dpmax[i]&amp;=max(\ \ a[i-m+1..i],\ \ \quad  a[i-m+2..i],\quad ......\,\ \quad a[i-1..i],\ \qquad \quad a[i..i]\qquad\ )  \\&amp;=max(\ s[i]-s[i-m],\ \quad s[i]-s[i-m+1],\ ......\ ,\quads[i]-s[i-2],\quad s[i]-s[i-1]\ ) \\&amp;=s[i]-\textcolor[RGB]{255,0,0}{min(\ s[i-m],\qquads[i-m+1]\qquad,\  ......\ ,\qquad \quad s[i-2],\qquad s[i-1]\ \qquad\ )}\tag{6}\\\\\end{align}\]</span> $$ 　　从上面的公式（６）可以看出：</p><p>１）我们把一个求最大值的问题，变成了一个求最小值的问题。</p><p>２）原本是求<spanclass="math inline">\(a[]\)</span>的“和值”，现在改成了求<spanclass="math inline">\(s[]\)</span>的最值。</p><p>３）在第<spanclass="math inline">\(i\)</span>轮，对应的滑窗下标是<spanclass="math inline">\(s[i-m..i-1]\)</span>，单调队列考虑进队的新元素为<spanclass="math inline">\(s[i-1]\)</span>，队尾进队的值是<spanclass="math inline">\(i-1\)</span>（存下标）。</p><h3 id="ac代码">2.1.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">求子段长度不大于m的最大子段和</span><br><span class="hljs-comment">用单调队列来进行优化 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>,INF=<span class="hljs-number">1e9</span>,M=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> dq[M];  <span class="hljs-comment">// 单调队列，规模看M即可</span><br><span class="hljs-type">int</span> s[N];   <span class="hljs-comment">// 前缀和数组 </span><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;s[i]), s[i]+=s[i<span class="hljs-number">-1</span>];<span class="hljs-comment">//输入原始数据的同时算出前缀和数组 </span><br>    <span class="hljs-type">int</span> h=<span class="hljs-number">1</span>,t=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> res =-INF;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<span class="hljs-comment">//单调队列保存下标</span><br>     <span class="hljs-comment">//根据方法2的公式6得，用单调队列在第i轮处理min(s[i-m..i-1])这m个前缀和值的最小值 </span><br>        <span class="hljs-keyword">while</span>(h&lt;=t&amp;&amp;s[i<span class="hljs-number">-1</span>]&lt;=s[dq[t]]) t--;<span class="hljs-comment">//如果当前对头元素比当前元素大，并且队列不空就滑出队列</span><br>        dq[++t]=i<span class="hljs-number">-1</span>;        <br><br>        <span class="hljs-keyword">if</span>((i<span class="hljs-number">-1</span>)-dq[h]+<span class="hljs-number">1</span> &gt; m ) h++;<span class="hljs-comment">//如果队尾下标不在m范围的话就划出队列</span><br>        <br>        res=<span class="hljs-built_in">max</span>(res,s[i]-s[dq[h]]);<br>    &#125;<br>    cout&lt;&lt;res&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">6 4</span><br><span class="hljs-comment">1 -3 5 1 -2 3</span><br><span class="hljs-comment">7</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线性结构编程技巧 </category>
          
          <category> 最大子段和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（二）固定宽度为m的区间的“最大的和值”问题</title>
      <link href="/2025/01/01/%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9B%BA%E5%AE%9A%E5%AE%BD%E5%BA%A6%E4%B8%BAm%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"/>
      <url>/2025/01/01/%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9B%BA%E5%AE%9A%E5%AE%BD%E5%BA%A6%E4%B8%BAm%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>　　本帖是“最大子段和”系列问题的第2帖，主要研究固定宽度为m的区间的“最大的和值”问题。内容比较简单，橙标题，就直接上题目了。</p><h1 id="一.-p3353-在你窗外闪耀的星星">一. P3353 在你窗外闪耀的星星</h1><h2 id="原题链接">1.1 原题链接</h2><p>　　<a href="https://www.luogu.com.cn/problem/P3353">P3353在你窗外闪耀的星星</a></p><p>　　概要题意：</p><p>　　录入<spanclass="math inline">\(n\)</span>个数的一维坐标整数值<spanclass="math inline">\(pos\)</span>和整数值<spanclass="math inline">\(w\)</span>，求所有坐标宽度为<spanclass="math inline">\(m\)</span>的区间内（含整数边界点）的数之和的最大值。假设<spanclass="math inline">\(m=3\)</span>，则即求<spanclass="math inline">\(max(sum[1..3],\ sum[2..4],\ sum[3..5], \......)\)</span>。</p><h2 id="分析">1.2 分析</h2><p>　　此题最明显的特征就是区间宽度固定不变，为<spanclass="math inline">\(m\)</span>。用前缀和来解本题最为方便。需要小心的是，根据题意，这<spanclass="math inline">\(n\)</span>个点的坐标是可以重复的，所以需要先叠加好每个坐标上的数值，然后再来做前缀和。在<spanclass="math inline">\(a[i]\)</span>值还没有完全确定时就去做<spanclass="math inline">\(sum[1..i]\)</span>，这样会不准确。</p><p>　　另外，<spanclass="math inline">\(n\)</span>并不是这些数的最大下标值，仅仅只是初始数据规模而已，在填入<spanclass="math inline">\(a[]\)</span>后，建议求出下标的最大值<spanclass="math inline">\(maxp\)</span>，适当简化后续的数据遍历操作。</p><h2 id="ac代码">1.3 AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[maxn];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> pos, w, maxp;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;pos, &amp;w), a[pos]+=w, maxp=<span class="hljs-built_in">max</span>(maxp, pos);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=maxp; i++) a[i]+=a[i<span class="hljs-number">-1</span>];<br><br><span class="hljs-type">int</span> mmax=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=m; i&lt;=maxp; i++)mmax= <span class="hljs-built_in">max</span>(mmax, a[i]-a[i-m]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, mmax);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二.-at_joi2007ho_a-最大の和">二. AT_joi2007ho_a 最大の和</h1><h2 id="原题链接-1">2.1 原题链接</h2><p>　　<ahref="https://www.luogu.com.cn/problem/AT_joi2007ho_a">AT_joi2007ho_a最大の和</a>　／　<ahref="https://atcoder.jp/contests/joi2007ho/tasks/joi2007ho_a"><strong>A- 最大の和</strong></a></p><h2 id="分析-1">2.2 分析</h2><p>　　和P3353基本上类似。</p><h2 id="ac代码-1">2.3 AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">固定区间宽度的最大子段和，用前缀和思想来解决即可 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[maxn];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);<br>a[i]+=a[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-type">int</span> mmax=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=m; i&lt;=n; i++) mmax= <span class="hljs-built_in">max</span>(mmax, a[i]-a[i-m]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, mmax); <span class="hljs-comment">// 此处必须要有\n，ATcoder的变态规则 </span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线性结构编程技巧 </category>
          
          <category> 最大子段和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（七）不限宽的m子段的“最大的和值”问题</title>
      <link href="/2025/01/01/%EF%BC%88%E4%B8%83%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84m%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"/>
      <url>/2025/01/01/%EF%BC%88%E4%B8%83%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84m%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>　　本帖是“最大子段和”系列问题的第7帖，主要研究不限宽的m子段的“最大的和值”问题。</p><h1 id="一.-原题链接">一. 原题链接</h1><p>　　<a href="https://acm.hdu.edu.cn/showproblem.php?pid=1024">HDU1024Max Sum Plus Plus</a></p><p>　　中文大意如下：</p><p>　　给定一个连续的整数序列 <spanclass="math inline">\(a[1:n]=\{a_1、a_2、a_3、a_4、 ... a_i、... a_n\}(1 ≤ i ≤ n ≤ 1,000,000，-32768 ≤ a_i ≤ 32767)\)</span>。有函数 <spanclass="math inline">\(sum(le, ri) = a_{le} + ... + a_{ri} \quad(1 ≤ le ≤ri ≤ n)\)</span>。现在给定一个整数 <span class="math inline">\(m (m &gt;0)\)</span>，你的任务是找出$ m $（不能多，也不能少）对 <spanclass="math inline">\(le\)</span> 和<spanclass="math inline">\(ri\)</span>，使得 $sum(le_1 , ri_1 ) + sum(le_2 ,ri_2 ) + ... + sum(le_m , ri_m ) <spanclass="math inline">\(最大。（不允许\)</span>le_i ≤ le_j ≤ ri_i<spanclass="math inline">\(或\)</span> le_i ≤ ri_j ≤ri_i$，即不允许区间之间有重叠或交叉）。</p><p>　　输入的行数不确定，每一行代表了一个测试样例，该行第１个数是<spanclass="math inline">\(m\)</span>，第２个数是<spanclass="math inline">\(n\)</span>，后续跟着<spanclass="math inline">\(n\)</span>个整数。</p><p>　　输出多行，和输入行数一致，每行为一个测试样例中的ｍ段最大和值。</p><h1 id="二.-分析">二. 分析</h1><p>　　之前我们学过不限宽的２段的最大的和值问题，本题要做的是<spanclass="math inline">\(ｍ(m&gt;0)\)</span>段。感觉这个题是之前旧题的升级版。能不能在原有题型的基础上进行拓展来解决本题型呢？对于２段，我们枚举了分隔点，利用它把整个数组分成了左半段和右半段，然后正推，逆推。但如果是４段、１０段等，明显原来的方法不再适用了。需要重新换思路了，怎么搞？</p><p>　　目前已经学过的方法有贪心、分治、递推（ｄｐ）、深搜、二分等。对于给定的数组<spanclass="math inline">\(a[1..n]\)</span>，原始顺序肯定不能随意改变，否则题解肯定会大变。所以肯定不能排序了。分治和递推实际上是同一种思路，只不过是范围从大到小或从小到大的区别。深搜肯定不行，绝对TLE。二分主要用于在单调性函数中确定一个点的值，这里好像对不上。现在试着来递推一下看看。</p><p>　　递推和ｄｐ是相通的。下面尝试采用ｄｐ的思路来思考。</p><p>　　本题要求在ｎ个数中选择ｍ个连续子段，求其最大子段和。ｎ不同，结果不同；ｍ不同，结果也会不同。所以，ｎ和ｍ都会影响最终的结果值。一个状态由数组元素个数ｊ和子段数ｉ共同确定。鉴于子段数据的连续性，为了方便研究，所以有如下：</p><p>一）状态数组定义</p><p>　　<span class="math inline">\(dp[i][j]\)</span>表示在<spanclass="math inline">\(a[1..j]\)</span>中选择<spanclass="math inline">\(i\)</span>个子段，且<spanclass="math inline">\(a[j]\)</span>属于第<spanclass="math inline">\(i\)</span>个子段后的最大子段和值。（之所以让子段数在第一维，是为后续的dp数组空间优化做准备，这纯属经验；之所以要求<spanclass="math inline">\(a[j]\)</span>必须要在最末子段内，也属经验）</p><p>二）所求目标</p><p>　　<span class="math inline">\(max(\ dp[m][m:n]\ )\)</span></p><p>三）状态转移方程</p><p>　　因为每个子段内的数据必然是连续性的，所以对于每个新元素<spanclass="math inline">\(a[j]\)</span>有如下两种情况：</p><p>　　１）已有<spanclass="math inline">\(i-1\)</span>个子段，新开第<spanclass="math inline">\(i\)</span>个子段，且把<spanclass="math inline">\(a[j]\)</span>作为该新子段的第一个元素；</p><p>　　　　<span class="math inline">\(a[j]\)</span>左侧已经选出了<spanclass="math inline">\(i-1\)</span>个子段，可以模拟个数据来分析一下。假设<spanclass="math inline">\(m=5,n=7\)</span>，现在要求<spanclass="math inline">\(dp[3][5]\)</span>，则在情况１）下，有"前５个数选３个子段的和＝max(前２个数各自成子段且第５个数成第３子段，前３个数选出２子段且第５个数成第３子段，　前４个数选出２个子段且第５个数成第３子段)"，写成公式如下：<span class="math display">\[dp[3][5]=max(\ a[5]+dp[2][2],\ \ \ a[5]+dp[2][3],\ \ \ a[5]+dp[2][4]\ )\]</span> 　　　　将其一般化，有下面的公式（１）： <spanclass="math display">\[dp[i][j]=a[j]\ +\ max(\ dp[i-1][k]\ );\quad(i \in [1:m];\j\in[i:i+n-m];\ k \in[i-1:j-1]\ )\tag{1}\]</span> 　　２）已有<spanclass="math inline">\(i\)</span>个子段，把<spanclass="math inline">\(a[j]\)</span>作为第<spanclass="math inline">\(i\)</span>个子段的元素，总的子段数不变仍为<spanclass="math inline">\(i\)</span>个； <span class="math display">\[dp[i][j]=a[j]+dp[i][j-1];\quad (\ i\in[1:m];\ j\in[i:i+n-m]\ )\tag{2}\]</span> 　　将公式（１）和（２）整合一下，得到最后的状态转移方程如下：<span class="math display">\[dp[i][j]=a[j]+max\textcolor[RGB]{255,0,0}(\ dp[i][j-1]\+\  max\textcolor[RGB]{255,255,0}(\ dp[i-1][k]\\textcolor[RGB]{255,255,0})\ \textcolor[RGB]{255,0,0});\quad(i \in[1:m];\ j\in[i:i+n-m];\ k \in[i-1:j-1]\ )\tag{3}\]</span> 四）循环顺序和边界</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic/img/%EF%BC%88%E4%B8%83%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84m%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%981.png" alt="image-20250101143316213" style="zoom: 80%;" /></p><p>　　对于<span class="math inline">\(i\)</span>，肯定是<spanclass="math inline">\([1:m]\)</span>，根据公式（３），需要用到上一行的内容，所以<spanclass="math inline">\(i\)</span>只能从上往下增序。</p><p>　　对于<spanclass="math inline">\(j\)</span>，我们的目的是要算出<spanclass="math inline">\(dp[m][m:n]\)</span>，例如求<spanclass="math inline">\(dp[4][7]\)</span>，我们没必要去计算和填写<spanclass="math inline">\(dp[1][5]、dp[2][6]\)</span>等数据，为什么呢？因为要想在前７个数中选出４个子段，那么就不可能在前６个数中选出２个子段，因为仅剩７－６＝１个数了，没办法把１个数划分出4－２＝２个子段，也没办法把２个数划分出４－１＝３个子段。所以虽然<spanclass="math inline">\(dp[1][5]、dp[2][6]\)</span>存在，但对我们的所求目标没有任何贡献，自然不需要去计算了（如上图灰色区域格子）。准确地说，剩余的数的个数<spanclass="math inline">\(n-j\)</span>要大于等于剩余的子段数<spanclass="math inline">\(m-i\)</span>，即有<spanclass="math inline">\(n-j\geq m-i\quad \Rightarrow\quad j \leq i+n-m\\)</span>。另外，我们也没必要去填写诸如<spanclass="math inline">\(dp[5][2]\)</span>这类数据（如上图红色区域格子），因为前２个数据不可能被分为５个子段，因为每个子段至少要有１个数据。也就是说，<spanclass="math inline">\(j\geq i\)</span>。归纳一下得<spanclass="math inline">\(j \in[i:i+n-m]\)</span>，每行填写<spanclass="math inline">\(n-m+1\)</span>个数即可。因为需要用到第<spanclass="math inline">\(j-1\)</span>列的数据，所以<spanclass="math inline">\(j\)</span>只能从左往右增序。</p><p>　　对于<spanclass="math inline">\(k\)</span>，来自于公式（３）中的<spanclass="math inline">\(max(dp[i-1][k])\)</span>，对应的<spanclass="math inline">\(dp[][]\)</span>数据来自于上一行，全都已知，故<spanclass="math inline">\(k\)</span>增序降序都可以。假设第<spanclass="math inline">\(i-1\)</span>个子段的最右侧元素下标为<spanclass="math inline">\(k\)</span>，则<spanclass="math inline">\(k\)</span>可能的最小值为<spanclass="math inline">\(i-1\)</span>（前面的每１个元素都自成１个子段，则第<spanclass="math inline">\(i-1\)</span>个子段为<spanclass="math inline">\(a[i-1:i-1]\)</span>）。<spanclass="math inline">\(k\)</span>可能的最大值是<spanclass="math inline">\(j-1\)</span>。总结后<spanclass="math inline">\(k\)</span>的范围就是<spanclass="math inline">\([i-1:j-1]\)</span>。</p><p>五）特例和初始化</p><p>　　对于对角线和第１行的数据，均来自于左侧一列、上一行和<spanclass="math inline">\(a[]\)</span>，当默认数据为０时公式（３）并不冲突，所以直接初始化<spanclass="math inline">\(dp[0:m][0:n]\)</span>为全０即可。</p><p>六）复杂度分析</p><p>　　可以看到，公式（３）的时间复杂度和空间复杂度都是比较高的，时间复杂度为<spanclass="math inline">\(O(m*(n-m)^2)\)</span>，空间复杂度为<spanclass="math inline">\(O(m*n)\)</span>。</p><p>七）时间复杂度优化</p><p>　　对于上图中求红色长方框内区域的最大值，没必要针对每个<spanclass="math inline">\(dp[i][j]\)</span>去循环<spanclass="math inline">\(k\)</span>来重新计算当前的最大值，完全可以利用上一轮计算的结果来刷新最大值。需要注意的是，随着<spanclass="math inline">\(j\)</span>的循环，需要比较最大值的元素是<spanclass="math inline">\(dp[i-1][j-1]\)</span>。这样可以把三重循环降为二重循环，时间复杂度变为<spanclass="math inline">\(O(m*(n-m))\)</span>。</p><p>八）空间复杂度优化</p><p>　　从上图和公式（３）可以看到，每次填写一个网格，只需要用到上一行和当前行左侧一格的数据，但此处不能用滚动数组，因为根据分析，我们必须要从左往右去循环<spanclass="math inline">\(j\)</span>（不能从右往左），且需要用到的是<spanclass="math inline">\(dp[i-1][i-1:j-1]\)</span>，而不是<spanclass="math inline">\(dp[i][i-1:j-1]\)</span>。但所幸的是，只需要用到当前行和上一行的完整数据，所以没必要设定<spanclass="math inline">\(dp[][]\)</span>为<spanclass="math inline">\(m\)</span>行。故而只需要设定<spanclass="math inline">\(dp[2][0..n]\)</span>这２行即可，空间复杂度降为<spanclass="math inline">\(O(2*n)\)</span>。</p><p>　　我们没必要每次填完之后去来回复制整行，这里可以学习一个小的编程技巧。我们知道<spanclass="math inline">\(0\oplus 1=1;1\oplus 1=0;\)</span>（<spanclass="math inline">\(\oplus\)</span>表示“按位异或”），也就是说，不管起初变量a=1或者a=0，在做<spanclass="math inline">\(\oplus1\)</span>操作后的算式值都会恰好相反（即从０变成１，或从１变成０），所以在提取上一行值时可以用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">maxpre=<span class="hljs-built_in">max</span>(maxpre, dp[k^<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]);  <span class="hljs-comment">// k^1表示上一行。当k==0时k^1的值为1,当k==1时k^1的值为0</span><br></code></pre></td></tr></table></figure><p>　　这样设置后，第<spanclass="math inline">\(m\)</span>行的结果最后是存放在<spanclass="math inline">\(dp[0][...]\)</span>或者<spanclass="math inline">\(dp[1][...]\)</span>呢？当<spanclass="math inline">\(m=1\)</span>时最终结果在第１行，当<spanclass="math inline">\(m=2\)</span>时最终结果在第０行，当<spanclass="math inline">\(m=3\)</span>时最终结果在第１行，当<spanclass="math inline">\(m=4\)</span>时最终结果在第０行，当<spanclass="math inline">\(m=5\)</span>时最终结果在第１行，……。可以看出，ｍ若为奇数则在１，ｍ若为偶数则在０。故结果可以写成<spanclass="math inline">\(dp[m\%2][...]\)</span>或者<spanclass="math inline">\(dp[m\&amp;1][...]\)</span>。</p><h1 id="三.-ac代码">三. AC代码</h1><p>　　注意一下，longlong类型的最大值为LLONG_MAX。不过本题数据弱，使用INT_MAX也没报错～～</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>; <br><span class="hljs-type">int</span> n,m;<br>ll a[N],dp[<span class="hljs-number">2</span>][N];   <span class="hljs-comment">//只保存上一行和当前行 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;m,&amp;n))&#123;   <span class="hljs-comment">//n个数字，m子段和 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,a+i);  <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) dp[<span class="hljs-number">0</span>][i]=<span class="hljs-number">0</span>,dp[<span class="hljs-number">1</span>][i]=<span class="hljs-number">0</span>;    <br><span class="hljs-comment">// 仍然需要设定i来标识出j的左右边界值，k只是0或1，无法代替这一个功能，k只在存入和读取dp的时候起作用 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,k=<span class="hljs-number">1</span>; i&lt;=m; i++,k^=<span class="hljs-number">1</span>)&#123;    <span class="hljs-comment">//分为i段，k为两行之间的切换</span><br>        dp[k][i<span class="hljs-number">-1</span>]= -LLONG_MAX;    <span class="hljs-comment">// 让同行左侧的dp[i][i-1]值不去影响dp[i][i]的填写，此时也需用到 k </span><br>            ll maxpre = -LLONG_MAX;    <span class="hljs-comment">// maxpre记录上一行的最大值，在每一行开始时需要重新置初始值 </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n-m+i;j++)&#123;<br>                maxpre=<span class="hljs-built_in">max</span>(maxpre,dp[k^<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]);      <span class="hljs-comment">//随时更新上一行最大值</span><br>                dp[k][j]=<span class="hljs-built_in">max</span>(dp[k][j<span class="hljs-number">-1</span>],maxpre)+a[j]; <span class="hljs-comment">//对应公式３</span><br>            &#125;<br>        &#125;<br>        ll ans= -LLONG_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m;i&lt;=n;i++) ans=<span class="hljs-built_in">max</span>(ans,dp[m&amp;<span class="hljs-number">1</span>][i]);  <span class="hljs-comment">//找到第m行的最大值，即为答案</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>    &#125;  <br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入 </span><br><span class="hljs-comment">4 7 -2 11 -4 13 -5 6 -2</span><br><span class="hljs-comment">输出</span><br><span class="hljs-comment">28 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线性结构编程技巧 </category>
          
          <category> 最大子段和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（六）不限宽的2子段的“最大的和值”问题</title>
      <link href="/2024/12/31/%EF%BC%88%E5%85%AD%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%842%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"/>
      <url>/2024/12/31/%EF%BC%88%E5%85%AD%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%842%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>　　本帖是“最大子段和”系列问题的第6帖，主要研究不限宽的2个子段区间内的“最大的和值”这个问题。要求学生已学过<spanclass="math inline">\(dp\)</span>入门类的题目。本题是后续的“不限宽的ｍ个子段区间内的最大的和值”的特殊情况<spanclass="math inline">\((m=2)\)</span>，可以用比较简单的做法来做，所以本帖先搞定简单的做法。（<del>其实也不简单，若不看题解，可能会搞死一些小朋友的</del>）</p><h1 id="一.-原题链接">一. 原题链接</h1><p>　　<a href="https://www.luogu.com.cn/problem/P2642">P2642双子序列最大和</a></p><h1 id="二.-分析">二. 分析</h1><p>　　我们之前已经学过了“不限宽的区间的“最大的和值”问题”，只需要求１个子段，是本系列的第一个帖子。现在要求２个子段，这该怎么办呢？</p><p>　　我们可以枚举一个分隔点<spanclass="math inline">\(i\)</span>，然后在<spanclass="math inline">\(a[0:i-1]\)</span>和<spanclass="math inline">\(a[i+1:n-1]\)</span>这两个数组中各自选出１个最大子段和，再相加即可。根据题意，<spanclass="math inline">\(a[i]\)</span>不属于左段，也不属于右段。</p><p>　　因为<spanclass="math inline">\(i\)</span>是枚举的变量，是不断在变化的，在求<spanclass="math inline">\(a[0:i-1]\)</span>中的最大子段和时，可以<strong>设定<spanclass="math inline">\(dp1[k]\)</span>为“在选定<spanclass="math inline">\(a[k]\)</span>的前提下，在<spanclass="math inline">\(a[0:k]\)</span>数组中选择１个子段后得到的最大的和值”</strong>，可以在<font color="red">从左往右</font>枚举<spanclass="math inline">\(i\)</span>的时候同步填写<spanclass="math inline">\(dp[k]\)</span>（即<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(k\)</span>同步，不需要专门定义变量<spanclass="math inline">\(k\)</span>），其解决思想和“<ahref="https://www.luogu.com.cn/problem/P1115">P1115最大子段和</a>”很相似，需要用到贪心的思想去递推即可。</p><p>　　但要去求<spanclass="math inline">\(a[i+1:n-1]\)</span>的１个最大子段和时，因为右子段的起始位置不再是０，而是变化的位置<spanclass="math inline">\(i+1\)</span>，这使得程序变得复杂。但如果我们反过来思考，<strong>设定<spanclass="math inline">\(dp2[k]\)</span>为“在选定a[k]的前提下，在<spanclass="math inline">\(a[k:n-1]\)</span>数组中选择１个子段后得到的最大的和值”</strong>，<font color="red">从右端往左端</font>使用贪心的思想来递推即可。这种思想，和以前练过的“<ahref="https://www.luogu.com.cn/problem/P1091">P1091 [NOIP2004 提高组]合唱队形</a>”的思想很相似。</p><p>　　但是，所求的目标并不等于<spanclass="math inline">\(max(dp1[i]+dp2[i])\quad(i\in[0..n-1])\)</span>，也不等于<spanclass="math inline">\(max(dp1[i]+dp2[i]-a[i])\)</span>，为什么呢？请看下图：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic/img/%EF%BC%88%E5%85%AD%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%842%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%981.png" alt="image-20241231161546354" style="zoom: 67%;" /></p><p>　　在上面的图中，我们把整个数组分成了<spanclass="math inline">\(a[0:i-1]、\ \ a[i]、\ \a[i+1:n]\)</span>这三段。红框表示左半段中选择的最大子段，绿框表示右半段中选择的最大子段，橙色表示选中子段的最左／最右的那个元素。根据题意，图（ａ）肯定是不可能的，因为题意说了两个子段必须要分开，至少间隔１个元素，不能视为一个子段。图（ｂ）和图（ｃ）都是符合题意的。但是根据我们对<spanclass="math inline">\(dp1[i]\)</span>和<spanclass="math inline">\(dp2[i]\)</span>的定义，<spanclass="math inline">\(dp1[i]+dp2[i]\)</span>只能表达出图（ａ），是不符合题意规定的；而<spanclass="math inline">\(dp1[i-1]+dp2[i+1]\)</span>也只能表达出图（ｂ）的情况，而无法表达图（ｃ）。那该怎么办呢？</p><p>　　我们仔细看图（ｃ）的左半段，可以发现，<font color="red">红框内元素之和，是<spanclass="math inline">\(a[0:i-1]\)</span>这个左半段中的最大子段和（<strong>不一定要以<spanclass="math inline">\(a[i-1]\)</span>结尾</strong>），设其为<spanclass="math inline">\(dple[i-1]\)</span>；绿框内元素之和，是<spanclass="math inline">\(a[i+1:n-1]\)</span>这个右半段中的最大子段和（<strong>不一定要以<spanclass="math inline">\(a[i+1]\)</span>开头</strong>），设其为<spanclass="math inline">\(dpri[i+1]\)</span></font>。可以发现，这样定义涵盖了图（ｂ）和图（ｃ）这两种情况。最终所求目标就为<spanclass="math inline">\(\textcolor[RGB]{250,250,100}{max(\dple[i-1]+dpri[i+1]\ )\quad(\ i \in[1..n-2]\ )}\)</span>。</p><p>　　现在只剩最后一个问题：如何求出这样定义下的<spanclass="math inline">\(dple[]\)</span>和<spanclass="math inline">\(dpri[]\)</span>？</p><p>　　还记得我们做过的P1115题要求的是什么吗？给定<spanclass="math inline">\(a[0..n-1]\)</span>，求这<spanclass="math inline">\(n\)</span>个数中的最大子段和。该题并没有说一定要以<spanclass="math inline">\(a[n-1]\)</span>为最大子段的末尾元素哦！　我们是怎么求的？　弄了一个前缀和变量<spanclass="math inline">\(sum\)</span>（表示选定<spanclass="math inline">\(a[i]\)</span>的前提下前<spanclass="math inline">\(i\)</span>个数中选出的最大子段和值），不断累加<spanclass="math inline">\(a[i]\)</span>，一旦变负就清零继续累加，同时<strong>搞了一个<spanclass="math inline">\(maxSum\)</span>来保存出现过的<spanclass="math inline">\(sum\)</span>的最大值</strong>，采用的方法是<spanclass="math inline">\(maxSum=max(maxSum, sum)\)</span>。</p><p>　　但此时我们要的并不是一个值，而是<spanclass="math inline">\(dple[0:n-1]\)</span>，即一堆的值。上面提到的<spanclass="math inline">\(maxSum\)</span>就对应着<spanclass="math inline">\(dple[i]\)</span>，而上面提到的<spanclass="math inline">\(sum\)</span>就对应着我们之前已求出的<spanclass="math inline">\(dp1[i]\)</span>。所以有如下的公式（对<spanclass="math inline">\(dpri[]\)</span>的分析类似，只是需要从右往左逆推）：$$ <span class="math display">\[\begin{align}dple[i]=max(\ dple[i-1],\quad dp1[i]\ ) \qquad(\ i \in[\\textcolor[RGB]{255,0,0}1:n-1\ ]\ )\tag{1} \\dpri[i]=max(\ dpri[i+1],\quad dp2[i]\ ) \qquad(\ i \in[\\textcolor[RGB]{255,0,0}{n-2}:0\ ]\ )\tag{2} \\\end{align}\]</span> $$</p><p>#　三. dp归纳总结</p><p>　　下面用<spanclass="math inline">\(dp\)</span>的套路来归纳所有的细节。</p><p>（一）状态数组定义</p><p>　　<span class="math inline">\(dp1[i]\)</span>为“在选定<spanclass="math inline">\(a[i]\)</span>的前提下，在<spanclass="math inline">\(a[0:i]\)</span>数组中选择１个子段后得到的最大的和值”；</p><p>　　<spanclass="math inline">\(dple[i]\)</span>为“在不限制是否选定<spanclass="math inline">\(a[i]\)</span>的前提下，在<spanclass="math inline">\(a[0:i]\)</span>数组中选择１个子段后得到的最大的和值”；</p><p>　　<spanclass="math inline">\(dp2[i]\)</span>为“在选定a[i]的前提下，在<spanclass="math inline">\(a[i:n-1]\)</span>数组中选择１个子段后得到的最大的和值”；</p><p>　　<spanclass="math inline">\(dpri[i]\)</span>为“在不限制是否选定<spanclass="math inline">\(a[i]\)</span>的前提下，在<spanclass="math inline">\(a[0:i]\)</span>数组中选择１个子段后得到的最大的和值”；</p><p>（二）所求目标</p><p>　　<span class="math inline">\(max(\ dple[i]+dpri[i]\ )\qquad (i \in[1..n-2])\)</span> （分隔点不能在两个端点，否则无法分成左右两段 ）</p><p>（三）状态转移方程 <span class="math display">\[\begin{align}dp1[i]&amp;=max(\ dp1[i-1],\quad 0\ )+a[i]\qquad(\ i\in[\textcolor[RGB]{255,0,0}{1}:n-1]\ ) \tag{3}\\dple[i]&amp;=max(\ dple[i-1],\quad dp1[i]\ ) \qquad(\ i \in[\\textcolor[RGB]{255,0,0}1:n-1\ ]\ )\tag{4} \\\\dp2[i]&amp;=max(\ dp2[i\textcolor[RGB]{255,0,0}+1],\quad 0\)+a[i]\qquad(\ i \in[\textcolor[RGB]{255,0,0}{n-2}:0]\ ) \tag{5}\\dpri[i]&amp;=max(\ dpri[i\textcolor[RGB]{255,0,0}+1],\quad dp2[i]\ )\qquad(\ i \in[\ \textcolor[RGB]{255,0,0}{n-2}:0\ ]\ )\tag{6} \\\end{align}\]</span> （四）循环顺序和边界</p><p>　　上面公式的附属条件中已经写得很清楚了。</p><p>（五）特例和初始化</p><p>　　<span class="math inline">\(dp1[0]=a[0];\qquaddp2[n-1]=a[n-1];\)</span></p><p>　　需要注意的是，当<spanclass="math inline">\(i\)</span>位于两个端点坐标时，因为必须要选至少１个数而形成１个子段，所以会有<spanclass="math inline">\(dple[0]=a[0];\ \)</span>。在不限制是否选定<spanclass="math inline">\(a[0]\)</span>的前提下，在<spanclass="math inline">\(a[0:0]\)</span>数组中选择１个子段后得到的最大的和值，这……必须得选<spanclass="math inline">\(a[0]\)</span>啊！否则子段就要为空了（本题要求子段不能为空，否则就不叫做２段了）。同理有<spanclass="math inline">\(dpri[n-1]=a[n-1];\ \)</span>。</p><h1 id="四.-ac代码">四. AC代码　</h1><p>　　注意要设置long long ，不然可能要见祖宗了～</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> a[maxn], n;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp1[maxn], dp2[maxn];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dple[maxn], dpri[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; ++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);<br>dp1[<span class="hljs-number">0</span>]=a[<span class="hljs-number">0</span>], dple[<span class="hljs-number">0</span>]= a[<span class="hljs-number">0</span>];<br>dp2[n<span class="hljs-number">-1</span>]=a[n<span class="hljs-number">-1</span>], dpri[n<span class="hljs-number">-1</span>]= a[n<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++) dp1[i]=<span class="hljs-built_in">max</span>(dp1[i<span class="hljs-number">-1</span>],<span class="hljs-number">0LL</span>)+a[i], dple[i]= <span class="hljs-built_in">max</span>(dple[i<span class="hljs-number">-1</span>], dp1[i]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>; i&gt;=<span class="hljs-number">0</span>; i--) dp2[i]=<span class="hljs-built_in">max</span>(dp2[i+<span class="hljs-number">1</span>],<span class="hljs-number">0LL</span>)+a[i], dpri[i]= <span class="hljs-built_in">max</span>(dpri[i+<span class="hljs-number">1</span>], dp2[i]);;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> mmax=<span class="hljs-number">-1e18</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n<span class="hljs-number">-1</span>; i++) mmax= <span class="hljs-built_in">max</span>(mmax, dple[i<span class="hljs-number">-1</span>]+dpri[i+<span class="hljs-number">1</span>]);<br>cout &lt;&lt; mmax;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">20 50 -10 1300 -900</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线性结构编程技巧 </category>
          
          <category> 最大子段和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（五）环状的不限宽的区间的“最大的和值”问题</title>
      <link href="/2024/12/30/%EF%BC%88%E4%BA%94%EF%BC%89%E7%8E%AF%E7%8A%B6%E7%9A%84%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"/>
      <url>/2024/12/30/%EF%BC%88%E4%BA%94%EF%BC%89%E7%8E%AF%E7%8A%B6%E7%9A%84%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>　　本帖是“最大子段和”系列问题的第5帖，主要研究环状的不限宽的区间的“最大的和值”这个问题。</p><h1 id="一.-理论教学">一. 理论教学</h1><p>　　在学习本题型之前，需要学生先掌握“（一）不限宽的区间的“最大的和值”问题，如果不会，请点击<a href="/2024/12/24/%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E5%BA%A6%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/#jump2"><font color="red">这里</font></a>。</p><p>　　<strong>环形数组</strong>意味着数组的末端将会与开头相连呈环状，给定一个长度为 <spanclass="math inline">\(n\)</span>的<strong>环形整数数组</strong> <spanclass="math inline">\(a[0..n-1]\)</span>，返回<spanclass="math inline">\(a[]\)</span>的非空子数组／子段／子序列的最大可能和 。例如<span class="math inline">\(a[]=\{5,-3,5\}\)</span>，则其环状最大子段和为<spanclass="math inline">\(5+5=10\)</span>。</p><p>　　对于这个题型，有三种方法可以解决。希望同学们尽量看懂下面的三种解法的思路。</p><h2 id="方法一用ｄｐ硬干时间on空间on">1.1 方法一：用ｄｐ硬干（时间<spanclass="math inline">\(O(n)\)</span>，空间<spanclass="math inline">\(O(n)\)</span>）</h2><p>　　总体思路：尽可能用“不限宽区间的最大和值”的思路来解决本题型中的“环状”的问题。因为环状可能会涉及到取余，而且对应的题是用vector来存储原始数据，所以建议最好把原始数组<spanclass="math inline">\(a[]\)</span>从下标０开始存储。在环形情况中，答案可能包括以下两种情况：</p><p>　　１）构成最大子数组和的子数组为 <spanclass="math inline">\(a[le:ri]\)</span>，包括 <spanclass="math inline">\(a[le:ri]\)</span> 共 <spanclass="math inline">\(ri−le+1\)</span> 个元素，其中 <spanclass="math inline">\(0≤le≤ri≤n-1\)</span>。　　２）构成最大子数组和的子数组为 <spanclass="math inline">\(a[0:le]\)</span> 和 <spanclass="math inline">\(a[ri:n-1]\)</span>，其中 <spanclass="math inline">\(0≤le&lt;ri≤n-1\)</span>。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic/img/%EF%BC%88%E4%BA%94%EF%BC%89%E7%8E%AF%E7%8A%B6%E7%9A%84%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%981.png" alt="image-20241230102930185" style="zoom: 80%;" /></p><p>　　对于情况１），可以用以前学过的“（一）不限宽的区间的“最大的和值”问题的解法来做，此处不再赘述。</p><p>　　对于情况２），其最大和值应分为左右两部分，如上图所示，<spanclass="math inline">\(nums[0:le]\)</span>和 <spanclass="math inline">\(nums[ri:n]\)</span>为实际<strong>被选</strong>子段，且有<spanclass="math inline">\(le+1&lt;ri\)</span>，否则就无法同时存在两段数据而蜕变成了情况１）。我们可以在<spanclass="math inline">\([2:n-1]\)</span>范围内枚举 <spanclass="math inline">\(ri\)</span>，故左子段<strong>“备选”</strong>的数据区间就是<spanclass="math inline">\([0..ri-2]\)</span>（因为左右两个子段之间至少要间隔１个数据不能选），而左子段的实际<strong>被选</strong>区间是<spanclass="math inline">\(a[0:le]\)</span>。此时我们很容易算出右子段<strong>“被选”</strong>数据段区间元素之和为<spanclass="math inline">\(sum(a[ri:n])\)</span>(可用“后缀和”的思想，或者用“前缀和相减”也行)，然后算出左子段<spanclass="math inline">\(a[0:ri−2]\)</span>的最大前缀和，将它和右子段的那个“和值”相加后考虑更新答案。</p><p>　　 <span class="math inline">\(leftMax[i]\)</span> 表示<spanclass="math inline">\(a[0:i]\)</span>的最大前缀和。注意，该最大前缀和的选择，不一定会选择到<spanclass="math inline">\(a[i]\)</span>。这就是“<strong>备选</strong>”和“<strong>被选</strong>”的差别。例如<spanclass="math inline">\(a[0:10]\)</span>这段数据的最大前缀和可能只是<spanclass="math inline">\(a[0:6]\)</span>，最后四个数因为是负数而不能选。又例如<spanclass="math inline">\(a[]=\{2,5,-2,4,-4,-2\}\)</span>，则有<spanclass="math inline">\(leftMax[]=\{2,7,7,9,9,9\}\)</span>，在计算<spanclass="math inline">\(leftMax[5]＝2+5-2+4=9\)</span>时，<spanclass="math inline">\(a[0..5]\)</span>都是<strong>备选</strong>元素，但只有<spanclass="math inline">\(a[0..3]\)</span>是<strong>被选</strong>元素。递推方程如下：<span class="math display">\[leftMax[le]=max(leftMax[le−1],\quad sum(nums[0:le])\qquad(le\in[0..n-1])\]</span></p><h2 id="方法二取反-时间on空间o1">1.2 方法二：取反 （时间<spanclass="math inline">\(O(n)\)</span>，空间<spanclass="math inline">\(O(1)\)</span>）</h2><p>　　对于上面1.1节中提到的情况２），我们不一定非要去求绿色区域的和值。我们可以改为求白色区域的最小和值，然后用总和去减它，剩下的自然就是绿色区域的和值了。此时这个白色区域肯定是一个连续块，不会断成首尾两截。</p><p>　　注意：</p><p>　　a）“取反”只适合于解决上面的情况２），并不能解决情况１）。所以，代码中仍然需要处理情况１）。</p><p>　　b）取反只适合于当<spanclass="math inline">\(n&gt;1\)</span>的情况，当<spanclass="math inline">\(a[]\)</span>只有一个元素时，只能取这个数，而其反集为空。而我们目前的做法都没有考虑空集的问题。</p><p>　　c）取反的时候要注意“其反集为全集”的情况。如<spanclass="math inline">\(\{-3,-2,-4\}\)</span>这种情况，其子段的最小和为<spanclass="math inline">\(-3-2-4=-9\)</span>，即所有数据都要选。此时若再用总和去减，则其结果为<spanclass="math inline">\(-9-(-9)=0\)</span>。这意味着不选就是最大。当根据我们的题意，必须要选至少一个数，不符合题意。所以取反求最小子段和的时候，若求出来的是全集，则也会失效，应剔除而不于考虑。</p><h2 id="方法三单调队列数组长度翻倍时间o2n空间o2n">1.3方法三：单调队列＋数组长度翻倍（<spanclass="math inline">\(时间O(2n),空间O(2n)\)</span>）</h2><p>　　我们可以将数组<spanclass="math inline">\(a[0:n-1]\)</span>延长一倍为<spanclass="math inline">\(a[0:2*n-1]\)</span>，即对于延长的区域内的元素，令<span class="math inline">\(a[i]=a[i−n]\quad(i \geqn)\)</span>。然后，对于1.1节中提到的第２）种情况，则左子段和右子段不会再分离，可以组成连续的一段<spanclass="math inline">\(a[ri:n+le]\)</span>。如下图所示：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic/img/%EF%BC%88%E4%BA%94%EF%BC%89%E7%8E%AF%E7%8A%B6%E7%9A%84%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%982.png"alt="image-20241231091109644" /><figcaption aria-hidden="true">image-20241231091109644</figcaption></figure><p>　　至此，我们就把一个“环状”的问题转变成了一个“链状”的问题。这和以前做过的“<ahref="https://www.luogu.com.cn/problem/P1880">P1880　合并石子</a>”的原理相似。剩下的就是按照本站之前讲过的（三）来处理了，有如下递推方程：<span class="math display">\[dpmax[i]=s[i]-\textcolor[RGB]{255,0,0}{min(\ s[i-m],\quads[i-m+1]\quad,\  ......\ ,\quad  s[i-2],\quad s[i-1]\ \quad\ ) }\tag{1}\]</span> 　　红色区域的处理需要用到单调队列来解决，在第<spanclass="math inline">\(i\)</span>轮求出<spanclass="math inline">\(s[i-m:i-1]\)</span>这个滑窗内的最小元素值，从而求出<spanclass="math inline">\(dpmax[i]\)</span>。具体做法若不清楚，请见<a href="/2025/01/01/%EF%BC%88%E4%B8%89%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/#jump1"><font color="red">这里</font></a>。</p><h1 id="二实战练习">二、实战练习</h1><h2 id="leetcode918-环状子数组的最大和">2.1 LeetCode918环状子数组的最大和</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<ahref="https://leetcode.cn/problems/maximum-sum-circular-subarray/description/">LeetCode918环状子数组的最大和</a></p><h3 id="ac代码">2.1.2 AC代码</h3><p>　　按照上面的理论讲解来实现三种代码，分别如下：</p><h4 id="方法１dp硬干">2.1.2.1 方法１：dp硬干</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 版本1： dp硬干 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//  提交内容如下</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubarraySumCircular</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">// leftMax[5]=12 表示nums[0..5]之间选择子段，子段的最大和值为12</span><br><span class="hljs-comment">// sum[5]=10 表示nums[0..5]的总和为10 </span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftMax</span><span class="hljs-params">(n)</span>, <span class="hljs-title">sum</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-comment">// 对坐标为 0 处的元素单独处理，避免考虑子数组为空的情况</span><br>leftMax[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>sum[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>sum[i] = sum[i<span class="hljs-number">-1</span>] + nums[i];<br>leftMax[i] = <span class="hljs-built_in">max</span>(leftMax[i - <span class="hljs-number">1</span>], sum[i]);<br>&#125;<br><br><span class="hljs-comment">// 处理情况2： </span><br><span class="hljs-comment">// 从右到左枚举后缀，固定后缀，选择最大前缀</span><br><span class="hljs-type">int</span> ans=sum[n<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ri = <span class="hljs-number">2</span>; ri &lt; n; ri++) &#123;<br><span class="hljs-comment">// sum[n-1]- sum[ri-1]是a[ri:n-1]的和，即后缀和</span><br><span class="hljs-comment">// 当前以ri为右子段的左边界，则左子段的右边界应为ri-2，两个子段之间必须要空至少一个元素不选 </span><br>ans = <span class="hljs-built_in">max</span>(ans, (sum[n<span class="hljs-number">-1</span>]- sum[ri<span class="hljs-number">-1</span>]) + leftMax[ri - <span class="hljs-number">2</span>]);   <br>&#125;<br><br><span class="hljs-comment">// 处理情况1： </span><br><span class="hljs-type">int</span> ms=nums[<span class="hljs-number">0</span>];ans= <span class="hljs-built_in">max</span>(ans, ms);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++) &#123;<br>ms= <span class="hljs-built_in">max</span>(ms,<span class="hljs-number">0</span>) + nums[i];<br>ans= <span class="hljs-built_in">max</span>(ans, ms);<br>&#125;<br><br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br><span class="hljs-comment">//提交内容如上</span><br>vector&lt;<span class="hljs-type">int</span>&gt; nums= &#123;<span class="hljs-number">-3</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-3</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br>Solution s1;<br>cout &lt;&lt;s1.<span class="hljs-built_in">maxSubarraySumCircular</span>(nums);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法２取反">2.1.2.2 方法２：取反</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 版本2： 取反，求最小 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//  提交内容如下</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubarraySumCircular</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">// 处理情况1： </span><br><span class="hljs-type">int</span> ms=nums[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> preSum=nums[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> ans=nums[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++) &#123;<br>ms= <span class="hljs-built_in">max</span>(ms,<span class="hljs-number">0</span>) + nums[i];<br>ans= <span class="hljs-built_in">max</span>(ans, ms);<br><br>preSum+= nums[i];<br>&#125;<br><br><span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ans;  <span class="hljs-comment">//若只有1个元素，则不适合情况2 </span><br><span class="hljs-comment">// 处理情况2： </span><br><span class="hljs-comment">// 对坐标为 0 处的元素单独处理，避免考虑子数组为空的情况</span><br><span class="hljs-type">int</span> minSum = nums[<span class="hljs-number">0</span>];<br>ans= <span class="hljs-built_in">max</span>(ans, preSum-minSum);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++) &#123;<br>minSum= <span class="hljs-built_in">min</span>(minSum,<span class="hljs-number">0</span>) + nums[i];<br><span class="hljs-keyword">if</span> (preSum != minSum) <br>ans= <span class="hljs-built_in">max</span>(ans, preSum-minSum);<br>&#125;<br><br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br><span class="hljs-comment">//提交内容如上</span><br>vector&lt;<span class="hljs-type">int</span>&gt; nums= &#123;<span class="hljs-number">-3</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-3</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br>Solution s1;<br>cout &lt;&lt;s1.<span class="hljs-built_in">maxSubarraySumCircular</span>(nums);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单调队列翻倍数组">2.1.2.3 单调队列＋翻倍数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 版本3： 单调队列，翻倍延长数组 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">将a[1..n]变成a[1..2*n]，延长一倍后，求a[1..2*n]中窗口宽度&lt;=n的最大和值。</span><br><span class="hljs-comment">需要用单调队列求sum[]中滑窗宽度&lt;=n内元素的最小值，第i轮的新元素是sum[i-1] </span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//  提交内容如下</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubarraySumCircular</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        deque&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q; <span class="hljs-comment">// &lt;pos, value&gt;</span><br>        <span class="hljs-type">int</span> pre = nums[<span class="hljs-number">0</span>], res = nums[<span class="hljs-number">0</span>];<br>        q.<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">0</span>, pre&#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">2</span> * n; i++) &#123;<br>            <span class="hljs-comment">// 根据之前学过的单调队列求最大和的模板，此处求&lt;=n的元素的最小值，pre=sum[i-1]是新元素 </span><br>            <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; pre &lt;= q.<span class="hljs-built_in">back</span>().second ) &#123;<br>                q.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            q.<span class="hljs-built_in">push_back</span>(&#123;i<span class="hljs-number">-1</span>, pre&#125;);<br><br>            <span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; (i<span class="hljs-number">-1</span>) - q.<span class="hljs-built_in">front</span>().first + <span class="hljs-number">1</span> &gt; n) &#123;<br>                q.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>            <span class="hljs-comment">// 计算出sum[i]，在下一轮时pre就是sum[i-1]了 </span><br>            pre += nums[i % n];<br>            <span class="hljs-comment">// 在第i轮，计算出dpmax[i]= sum[i] - min( s[i-m], sum[i-m+1], ...... , sum[i-2], sum[i-1] )</span><br>            res = <span class="hljs-built_in">max</span>(res, pre - q.<span class="hljs-built_in">front</span>().second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//提交内容如上</span><br>vector&lt;<span class="hljs-type">int</span>&gt; nums= &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-2</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br>Solution s1;<br>cout &lt;&lt;s1.<span class="hljs-built_in">maxSubarraySumCircular</span>(nums);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线性结构编程技巧 </category>
          
          <category> 最大子段和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（四）宽度大于等于m的区间的“最大的和值”问题</title>
      <link href="/2024/12/27/%EF%BC%88%E5%9B%9B%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"/>
      <url>/2024/12/27/%EF%BC%88%E5%9B%9B%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>　　本帖是“最大子段和”系列问题的第4帖，主要研究宽度大于等于m的区间的“最大的和值”这个问题。</p><h1 id="一.-理论教学">一. 理论教学</h1><p>　　之前我们练习过“区间宽度<span class="math inline">\(\leqm\)</span>”的情况，用单调队列来解决了问题。已经记不太清楚的同学请看<a href="/2025/01/01/%EF%BC%88%E4%B8%89%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"><font color="red">这里</font></a>。看到当前这个题型，第一反应就是“能不能用之前解决<spanclass="math inline">\(\leq m\)</span>的公式推导过程来解决本题型呢？”</p><p>　　可以试试看！</p><p>　　假设<span class="math inline">\(m=3\)</span>，原始数组为<spanclass="math inline">\(a[1..n]\)</span>，对应的前缀和数组为<spanclass="math inline">\(s[1..n]\)</span>，<spanclass="math inline">\(dpmax[i]\)</span>表示"<strong>在选定<spanclass="math inline">\(a[i]\)</span>的前提下，子段内所有数的最大和值</strong>"，且满足子段宽度<spanclass="math inline">\(\geq m\)</span>，而写法"<spanclass="math inline">\(a[3..5]\)</span>"表示"<spanclass="math inline">\(a[3]+a[4]+a[5]\)</span>"，则有 $$ <spanclass="math display">\[\begin{align}dpmax[1]&amp;=max(\ a[1..1]\ )\qquad(区间宽度均不够3，无解)\tag{1}  \\\\dpmax[2]&amp;=max(\ a[1..2], a[2..2]\ )\qquad(区间宽度仍均不够3，无解)\tag{1}  \\\\dpmax[3]&amp;=max(\ \ a[1..3]　\ \ )\qquad(只有[1..3]这个区间满足:宽度\geq 3)\\&amp;=max(\ s[3]-s[0]\ ) \\&amp;=s3-min(\ s[0]\ ) \tag{3}\\\\dpmax[4]&amp;=max(\ \ a[1..4],\ \ \qquad\quad  a[2..4]\quad ) \qquad(有[1..4]和[2..4]这２个区间满足：宽度\geq 3)\\&amp;=max(\ s[4]-s[0],\ \quad s[4]-s[1]\ ) \\&amp;=s[4]-min(\ s[0],\qquad\ s[1]\qquad\ )\tag{4}\\\\dpmax[5]&amp;=max(\ \ a[1..5],\ \ \qquad\quad  a[2..5],\ \ \qquad \quada[3..5]\ \ )  \\&amp;=max(\ s[5]-s[0],\ \quad s[5]-s[1],\ \quad s[5]-s[2]\ ) \\&amp;=s[5]-min(\ s[0],\quad \qquad s[1],\ \qquad\qquad s[2]\quad\  )\tag{5}\\\\dpmax[6]&amp;=max(\ \ a[1..6],\ \ \qquad\quad  a[2..6],\ \ \qquad \quada[3..6]\ \ ,\ \ \quad \quad a[4..6]\ \ )  \\&amp;=max(\ s[6]-s[0],\ \quad s[6]-s[1],\ \quad s[6]-s[2]\ ,\ \quads[6]-s[3]\ ) \\&amp;=s[6]-min(\ s[0],\quad \qquad s[1],\ \qquad\qquad s[2],\\qquad\qquad s[3]\quad) \tag{6}\\\\\end{align}\]</span> <span class="math display">\[则有一般性公式推导（注：从$\ i-m+1\ $到$\ i\$，一共有$m$个数；从$1$到$i-m+1$，或者从$0$到$i-m$，都是有$i-m+1$个数）如下：\]</span> <span class="math display">\[\begin{align}dpmax[i]&amp;=max(\ \ a[1..i],\ \ \qquad\quad  a[2..i],\quad\ \ ......\,\ \qquad a[i-m..i],\ \qquad\ \  a[i-m+1..i]\ )  \\&amp;=max(\ s[i]-s[0],\ \quad s[i]-s[1],\quad ......\ ,\quads[i]-s[i-m-1],\quad s[i]-s[i-m]\ \ ) \\&amp;=s[i]-\textcolor[RGB]{255,0,0}{min(\ s[0],\qquads[1]\qquad,\  ......\ ,\qquad \quad s[i-m-1],\qquad s[i-m]\ \qquad\ )}\qquad(i \in [m..n])\tag{6}\\\\\end{align}\]</span> $$ 　　从上面的公式（６）可以看出：</p><p>１）我们把一个求最大值的问题，变成了一个求最小值的问题。</p><p>２）原本是求<spanclass="math inline">\(a[]\)</span>的“和值”，现在改成了求<spanclass="math inline">\(s[]\)</span>的最值。</p><p>３）在第<span class="math inline">\(i\)</span>轮，<spanclass="math inline">\(min\)</span>操作的操作数的个数随着<spanclass="math inline">\(i\)</span>的增大而增大，也就是说，本题型并不是固定滑窗求最值，却和“（一）不限宽度的区间的“最大的和值”问题”中的单调队列处理方法比较类似。所以不需出队（因为没有滑窗宽度限制），甚至也可以不用单调队列而直接用变量<spanclass="math inline">\(mmin\)</span>就可搞定。</p><h1 id="二.实战练习">二.实战练习</h1><h2 id="p1404-平均数">2.1 P1404 平均数</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P1404">P1404平均数</a></p><h3 id="分析">2.1.2 分析</h3><p>　　原题的题意是“给一个长度为 <spanclass="math inline">\(n\)</span>的数列，我们需要找出该数列的一个子串，使得子串的平均数最大化，并且子串长度<span class="math inline">\(\geq m\)</span>”，要求输出最大的平均数。</p><p>　　我们可以初步分析一下：</p><p>　　１）要找一个子串，也就是说，要找一个子序列，或者说子段。</p><p>　　２）要想使得子段均值最大，也就意味着并不是子段越宽越好或者越窄越好。假设当前所选子段的均值为５，而新加入的数值为<spanclass="math inline">\(8&gt;5\)</span>，则势必会拉高均值，这是有益的；但如果新加入的数值为<spanclass="math inline">\(2&lt;5\)</span>，则势必会拉低均值，是有害的。但有害的数据并不意味着就不能选，万一在２后面的下一个数是１００呢？所以，这并不是一个简单的贪心策略能搞定的，多半会和暴力枚举所涉及的算法有关。目前已经学过的暴力枚举的算法，除了简单模拟之外，有<spanclass="math inline">\(dfs\)</span>、<spanclass="math inline">\(dp\)</span>和二分答案。<spanclass="math inline">\(dfs\)</span>复杂度太高，基本上放弃。</p><p>　　３）要求子段长度<span class="math inline">\(\geqm\)</span>，这个条件如何利用呢？这个感觉和题型H：“借助单调队列来求子段宽度<spanclass="math inline">\(\geqm\)</span>的最大的和值”很相似啊。但题型H是求和，而当前题型是求平均数，而且还要求最大的平均数。这里需要一个外力点拨。我们可以把原始数组元素都减去一个假定的均值<spanclass="math inline">\(avg\)</span>，然后对数组再来做题型H，这样就解决了“子段长度<spanclass="math inline">\(\geq m\)</span>”的问题。若求出的最大和值<spanclass="math inline">\(&gt;0\)</span>，说明<spanclass="math inline">\(avg\)</span>太小了；若最大的和值<spanclass="math inline">\(&lt;0\)</span>，说明<spanclass="math inline">\(avg\)</span>太大了。这听上去是不是很像“二分答案？的确是的。至此，已经完全分析清楚了。</p><p>　　例如：对于<spanclass="math inline">\(a[10]=\{2,5,7,9,6,1,6,7,4,1\},m=3\)</span>，假设<spanclass="math inline">\(avg=5\)</span>，则<spanclass="math inline">\(a_1^*[10]=\{-3,0,2,4,1,-4,1,2,-1,-4\}\)</span>，对<spanclass="math inline">\(a_1^*[]\)</span>求子段宽度<spanclass="math inline">\(\geq 3\)</span>的最大子段和为<spanclass="math inline">\(2+4+1=7\)</span>，这意味着什么呢？这说明这三个数对应的<spanclass="math inline">\(7,9,6\)</span>原数的真实均值是大于当前的<spanclass="math inline">\(avg=5\)</span>的，换句话说，当前的<spanclass="math inline">\(avg\)</span>太小了，可以再大一点。</p><p>　　二分答案的代码模板就不多说了，若不清楚请复习本站帖"二分查找和二分答案.md"，点击<a href="/2024/03/06/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/#jump1"><font color="red">这里</font></a>。注意对check(x)函数的把握。</p><p>　　需要注意的是，本题并不是标准的二分答案，因为题目要求输出的是二分后的结果砍掉末尾后的精确值，而不是四舍五入后的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++">输入样例１：<br><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span><br>正确输出：<br><span class="hljs-number">5000</span><br>错误输出：<br><span class="hljs-number">4999</span><br><br>输入样例２：<br><span class="hljs-number">10</span> <span class="hljs-number">10</span><br><span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">10</span> <span class="hljs-number">3</span> <span class="hljs-number">8</span> <span class="hljs-number">5</span> <span class="hljs-number">9</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><br>正确输出：<br><span class="hljs-number">5200</span><br>错误输出：<br><span class="hljs-number">5199</span>    <br></code></pre></td></tr></table></figure><p>　　鉴于上面的问题，所以需要把输出改为打印<spanclass="math inline">\(\ ri\ \)</span>端值就可以了。</p><h3 id="ac代码">2.1.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> jd=<span class="hljs-number">1e-7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> a[maxn],sum[maxn],le,ri,mid;<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)  sum[i]=sum[i<span class="hljs-number">-1</span>]+a[i]-x;<br><span class="hljs-type">double</span> maxsum=<span class="hljs-number">-1e9</span>, mmin=<span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m; i&lt;=n; i++) &#123;<br>mmin= <span class="hljs-built_in">min</span>(mmin, sum[i-m]);<br>maxsum=<span class="hljs-built_in">max</span>(maxsum,sum[i]-mmin);<br>&#125;<br><span class="hljs-keyword">return</span> (maxsum&gt;=<span class="hljs-number">0</span>);  <span class="hljs-comment">// 若平均化后的子段和&gt;0，则说明该x太小 </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;a[i]);<br>ri=<span class="hljs-built_in">max</span>(ri,a[i]);<br>&#125;<br>le=<span class="hljs-number">0</span>-jd;ri=ri+jd;<br><span class="hljs-keyword">while</span>( le+jd &lt; ri ) &#123;<br>mid =(ri+le) / <span class="hljs-number">2</span>;   <br><span class="hljs-keyword">if</span>( <span class="hljs-built_in">check</span>(mid) )<br>le=mid;    <span class="hljs-comment">// 既然mid太小，就砍掉左半段 </span><br><span class="hljs-keyword">else</span><br>ri=mid;<br>&#125;<br><span class="hljs-comment">//printf(&quot;le=%lf, ri=%lf\n&quot;, le, ri);</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">int</span>(ri*<span class="hljs-number">1000</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">10 10</span><br><span class="hljs-comment">6 4 2 10 3 8 5 9 4 1</span><br><span class="hljs-comment">5200</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2 2</span><br><span class="hljs-comment">5 5</span><br><span class="hljs-comment">5000</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">3 3</span><br><span class="hljs-comment">5 5 5</span><br><span class="hljs-comment">5000</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线性结构编程技巧 </category>
          
          <category> 最大子段和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（一）不限宽度的区间的“最大的和值”问题</title>
      <link href="/2024/12/24/%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E5%BA%A6%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"/>
      <url>/2024/12/24/%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E5%BA%A6%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>　　本帖是“最大子段和”系列问题的第1帖，主要研究不限宽度的区间的“最大的和值”和“最大的积值”这两个问题。</p><h1 id="一不限宽度的区间子段的最大的和值"><spanid="jump2">一、不限宽度的区间（子段）的"最大的<font color="red">和</font>值"</span></h1><h2 id="原题链接">1.1 原题链接</h2><p>　　<a href="https://www.luogu.com.cn/problem/P1115">P1115最大子段和</a>　／　<ahref="https://leetcode.cn/problems/maximum-subarray/description/">53最大子数组和</a></p><h2 id="分析">1.2 分析</h2><p>　　如果我们用 <span class="math inline">\(dp[i]\)</span> 表示前 i个元素中选择的子段内所有数的最大和值，<spanclass="math inline">\(a[]\)</span>表示题目上对应的数组，那么所求目标即为<spanclass="math inline">\(dp[n]\)</span>。但我们会发现，要根据<spanclass="math inline">\(dp[i-1]\)</span>等来递推出<spanclass="math inline">\(dp[i]\)</span>是很困难的，因为我们不确定<spanclass="math inline">\(a[i-1]\)</span>在<spanclass="math inline">\(dp[i-1]\)</span>的方案中是否被选中。如果<spanclass="math inline">\(a[i-1]\)</span>曾被选中，那现在去计算<spanclass="math inline">\(dp[i]\)</span>就比较简单了，对于<spanclass="math inline">\(a[i]\)</span>无非有“选<spanclass="math inline">\(a[i]\)</span>”或“不选<spanclass="math inline">\(a[i]\)</span>”这两种方案，所以有<spanclass="math inline">\(dp[i]=max(dp[i-1]+a[i],\ \dp[i-1])\)</span>。但如果<spanclass="math inline">\(a[i-1]\)</span>不曾被选中，那根据本题对“子段”的“下标连续性”的要求，就很难去推导了。</p><p>　　此路不通。不通的原因不是因为不该用<spanclass="math inline">\(dp\)</span>，而是因为<spanclass="math inline">\(dp[i]\)</span>的定义不对，因为违背了<spanclass="math inline">\(dp\)</span>的定义并不满足「最优子结构」(即“问题的最优解包含子问题的最优解”。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解)。<strong>而在当前<spanclass="math inline">\(dp[]\)</span>的这种定义下，当前位置的最优解未必是由前一个位置的最优解转移得到的</strong>。</p><p>　　正确的定义应该是用 <span class="math inline">\(dp[i]\)</span>表示"<strong>在选定<span class="math inline">\(a[i]\)</span>的前提下，前i个元素中选择的子段内所有数的最大和值</strong>"。之所以正确，是因为在这种定义下，强制要求选定<spanclass="math inline">\(a[i]\)</span>后，剔除掉了上面段落中所提到的“如果<spanclass="math inline">\(a[i-1]\)</span>不曾被选中”的情况，使得<spanclass="math inline">\(dp\)</span>的定义满足了“最优子结构”的要求。只不过在这样的定义下，所求目标不再是<spanclass="math inline">\(dp[n]\)</span>，而变成了<spanclass="math inline">\(max(dp[1..n])\)</span>。</p><p>　　这个题型，<spanclass="math inline">\(O(n)\)</span>的做法有两种。</p><p>　　１）<span class="math inline">\(dp[i]=max(\ dp[i-1],\ \ 0)+a[i]\)\qquad(i \in[1..n])\)</span></p><p>　　２）<span class="math inline">\(dp[i]=sum[i]-min(\ sum[1..i-1]\)\qquad(\ i \in[1..n]\ )\)</span></p><p>　　第１种方法，在本站《前缀和　二维前缀和》有非常详细的讲述，请点击<a href="/2024/01/03/%E5%89%8D%E7%BC%80%E5%92%8C%20%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/#jump1"><font color="red">这里</font></a>直达讲述位置，内含视频教学和AC代码，此处不再提。下面重点讲解第２种方法的得来。　</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic/img/%E4%B8%8D%E9%99%90%E5%AE%BD%E5%BA%A6%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%981.png" alt="image-20241227150534177" style="zoom:150%;" /></p><p>　　在上图中，我们以<spanclass="math inline">\(i=3\)</span>为例来进行讲解。我们知道<spanclass="math inline">\(dp[i]\)</span>的含义是“在选定<spanclass="math inline">\(a[i]\)</span>的前提下，前<spanclass="math inline">\(i\)</span>个元素中选择的子段内所有数的最大和值”，且用<spanclass="math inline">\(a[1..3]\)</span>表示<spanclass="math inline">\(a[1]+a[2]+a[3]\)</span>的值，则我们可以把<spanclass="math inline">\(dp[1]、dp[2]、dp[3]、dp[4]\)</span>的定义演绎成下面的公式：<span class="math display">\[\begin{align}dp[1]&amp;=max(\ a[1..1]\ ) \tag{1} \\dp[2]&amp;=max(\ a[1..2],\ \ a[2..2]\ ) \tag{2} \\dp[3]&amp;=max(\ a[1..3],\ \ a[2..3],\ \ a[3..3]\ ) \tag{3} \\dp[4]&amp;=max(\ a[1..4],\ \ a[2..4],\ \ a[3..4],\ \ a[4..4]\ ) \tag{4}\\\end{align}\]</span> 　　由（4）推出更加普遍的公式如下： <spanclass="math display">\[dp[i]=max(\ a[1..i],\ \ a[2..i],\ \ ......,\ \ a[i-1..i],\ \ a[i..i]\ )\tag{5}\]</span> 　　假设用<span class="math inline">\(sum[i]\)</span>表示<spanclass="math inline">\(a[1..i]\)</span>，即<spanclass="math inline">\(sum[i]=a[1]+a[2]+...+a[i]\)</span>。用前缀和思想，可以把（５）式进一步演变如下：<span class="math display">\[\begin{align}dp[i]&amp;=max(\\qquad\textcolor[RGB]{50,200,0}{a[1..i]},\qquad\qquad\quad\textcolor[RGB]{0,150,255}{a[2..i]},\ \ \ \quad\quad  ......,\ \\qquad\textcolor[RGB]{255,0,0}{a[i-1..i]},\ \\qquad\qquad\quad\textcolor[RGB]{255,225,0}{a[i..i]}\qquad\qquad)  \tag{}\\&amp;=max(\ \textcolor[RGB]{50,200,0}{sum[i]-sum[0]},\ \\textcolor[RGB]{0,150,255}{sum[i]-sum[1]},\ \ ......\ \ ,\ \\textcolor[RGB]{255,0,0}{sum[i]-sum[i-2]},\ \\textcolor[RGB]{255,225,0}{sum[i]-sum[i-1]}\ ) \tag{}\\&amp;=sum[i]-min(\ sum[0],\ sum[1],\ sum[2],\ ......\ ,\ sum[i-1]\ )\tag{6}\end{align}\]</span>　　从公式（６）中可以看到，我们需要在对应的前缀和数组sum[]中去求多个前缀和的最小值。在本题中因为没有限制子段的区间宽度，所以公式（６）比较简单。但如果要求区间的宽度受限制（<spanclass="math inline">\(==m、\leq m、\geqm\)</span>）等，公式（６）会变得稍微复杂一点，就需要用到单调队列来解决了。要实现方法２中的公式（６），可以有两种版本。</p><p>版本１）：用单变量<spanclass="math inline">\(mmin\)</span>来保存<spanclass="math inline">\(sum[1..i-1]\)</span>中各和值的最小值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> mmin=INT_MAX;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123;<br>    mmin=<span class="hljs-built_in">min</span>(mmin, sum[i<span class="hljs-number">-1</span>]); <br>    dp[i]=sum[i]-mmin;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　为了给后续帖展示复杂区间宽度限制，此处也给同学们展示做法２的过程。</p><p><span id="jump1">版本２）</span>：用单调队列来处理<spanclass="math inline">\(sum[1..i-1]\)</span>中各和值的最小值。需要注意的是，此处是求滑窗区间<spanclass="math inline">\(sum[0..i-1]\)</span>的最小值，基础数组是<spanclass="math inline">\(sum[]\)</span>；而且在第<spanclass="math inline">\(i\)</span>轮处理的是数据是<spanclass="math inline">\(sum[i-1]\)</span>，进队的下标应该是<spanclass="math inline">\(i-1\)</span>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 使用单调队列求sum[0..i-1]区间中的最小值，基础数组是sum[]哦！在第i轮处理的是sum[i-1]！</span><br><span class="hljs-keyword">while</span> (h&lt;=t &amp;&amp; sum[i<span class="hljs-number">-1</span>]&lt;=sum[dq[t]] ) t--;<br>dq[++t]=i<span class="hljs-number">-1</span>;<br><span class="hljs-comment">// 因为不限滑窗宽度，根本就没有滑窗，所以不用考虑队头元素这端被挤出滑窗而出队的情况了</span><br>mmin=sum[dq[h]];  <span class="hljs-comment">//使用“滑窗”内的最小值，即min(sum[0],sum[1],sum[2],sum[3],......,sum[i-1])</span><br></code></pre></td></tr></table></figure><h2 id="ac代码">1.3 AC代码</h2><p>　　用方法１（贪心策略）的代码就不在这里展示了，此处展示的是方法２的两个版本代码。</p><h3 id="不用单调队列">1.3.1 不用单调队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法2，版本1，不用单调队列</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">方法2：dp[i]= sum[i] - min(sum[0],sum[1],sum[2],......,sum[i-1])</span><br><span class="hljs-comment">    版本1： 用 单变量mmin来保存 sum[1..i-1] 中各和值的最小值。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> dp[<span class="hljs-number">200001</span>];   <br><span class="hljs-type">int</span> sum[<span class="hljs-number">200001</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> i,n,a,mmin=INT_MAX, ans=INT_MIN;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a);<br>sum[i]=sum[i<span class="hljs-number">-1</span>]+a;<br>mmin=<span class="hljs-built_in">min</span>(mmin, sum[i<span class="hljs-number">-1</span>]);<br>dp[i]=sum[i]-mmin;<br>ans= <span class="hljs-built_in">max</span>(ans, dpmax[i]);  <span class="hljs-comment">// 可以不定义dpmax[]：ans= max(ans, sum[i]-mmin); </span><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">//// 如果数据全为负数，也应该得到-20，而不是-100000</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">-200 -20 -150 -100 -120</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="用单调队列">1.3.2 用单调队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法2，版本2，用单调队列 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">方法2：dp[i]= sum[i] - min(sum[0],sum[1],sum[2],......,sum[i-1])</span><br><span class="hljs-comment">    版本2： 用 单调队列来保存 sum[1..i-1] 中各和值的最小值。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> dq[<span class="hljs-number">200001</span>];   <br><span class="hljs-type">int</span> sum[<span class="hljs-number">200001</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> i,n,a,mmin=INT_MAX, ans=INT_MIN;<br>cin&gt;&gt;n;<br><span class="hljs-type">int</span> h=<span class="hljs-number">1</span>, t=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a);<br>sum[i]=sum[i<span class="hljs-number">-1</span>]+a;<br><span class="hljs-comment">// 使用单调队列求sum[0..i-1]中的区间最小值，基础数组是sum[]哦！在第i轮处理的是sum[i-1]！ </span><br><span class="hljs-keyword">while</span> (h&lt;=t &amp;&amp; sum[i<span class="hljs-number">-1</span>]&lt;=sum[dq[t]] ) t--;<br>dq[++t]=i<span class="hljs-number">-1</span>;<br><span class="hljs-comment">// 因为不限滑窗宽度，根本就没有滑窗，所以不用考虑队头元素这端被挤出滑窗而出队的情况了 </span><br>mmin=sum[dq[h]];  <span class="hljs-comment">// 使用单调队列方法的成果，即sum[dq[h]]，</span><br>ans= <span class="hljs-built_in">max</span>(ans, sum[i]-mmin);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">//// 如果数据全为负数，也应该得到-20，而不是-100000</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">-200 -20 -150 -100 -120</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1id="二不限宽度的区间子段的最大的积值">二、不限宽度的区间（子段）的“最大的<font color="red">积</font>值”</h1><h2 id="原题链接-1">2.1 原题链接</h2><p>　　<ahref="https://leetcode.cn/problems/maximum-product-subarray/description/">１５２　乘积最大子数组（leetcode）</a></p><h2 id="分析-1">2.2 分析</h2><p>　　如果我们用 <span class="math inline">\(dpmax[i]\)</span> 表示以第i 个元素结尾的子段内所有数的最大乘积值，<spanclass="math inline">\(a[]\)</span>表示题目上对应的数组 <spanclass="math inline">\(nums[]\)</span>，那么根据“<ahref="https://www.luogu.com.cn/problem/P1115">P1115最大子段和</a>”的经验，我们很容易推导出这样的状态转移方程： <spanclass="math display">\[dpmax[i]=max(\ a[i],\quad dpmax[i-1]*a[i]\ )\qquad(i \in[1..n])  \tag{1}\]</span> 　　它表示以第 i 个元素结尾的乘积最大子数组的乘积，可以考虑<span class="math inline">\(a[i]\)</span> 加入前面的 <spanclass="math inline">\(dpmax[i-1]\)</span>对应的一段，或者单独成为一段，且在两种情况下取最大值。最后把 <spanclass="math inline">\(max(dpmax[1..n])\)</span>作为答案。</p><p>　　可是在这里，这样做是错误的（需要孩子们认真仔细地在草稿纸上枚举多个样例，就必然能发现这一点）。为什么呢？</p><p>　　因为这里的定义并不满足「最优子结构」(即“问题的最优解包含子问题的最优解”。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解)。具体地讲，如果<span class="math inline">\(a[]=\{5,\ 6,\ −3,\ 4,\−3\}\)</span>，那么此时<spanclass="math inline">\(dpmax[]\)</span>对应的序列是 <spanclass="math inline">\(\{\ 5,\ 30,\ −3,\ 4,\ −3\\}\)</span>，按照前面的算法我们得到的答案为 30（即<spanclass="math inline">\(5\times6\)</span>），而实际上答案应该是全体数字的乘积。我们来想一想问题出在哪里呢？问题出在最后一个−3 所对应的<span class="math inline">\(dpmax[5]\)</span>的值既不是−3，也不是 <span class="math inline">\(4×(−3)\)</span>，而是 <spanclass="math inline">\(5×6×(−3)×4×(−3)\)</span>。所以我们得到了一个结论：<strong>在这种定义下，当前位置的最优解未必是由前一个或前几个位置的最优解转移得到</strong>。</p><p>　　我们可以根据正负性进行分类讨论。</p><p>　　１）如果<span class="math inline">\(a[i]&lt;0\)</span>，那么我们希望<spanclass="math inline">\(dpmax[i-1]&lt;0\)</span>，这样就可以负负得正，并且我们希望<spanclass="math inline">\(dpmax[i-1]\)</span>尽可能"负得更多"(即尽可能小)。</p><p>　　２）如果<spanclass="math inline">\(a[i]&gt;0\)</span>，我们更希望<spanclass="math inline">\(dpmax[i-1]&gt;0\)</span>，并且希望<spanclass="math inline">\(dpmax[i-1]\)</span>尽可能地大。</p><p>　　于是这里我们可以再维护一个 <spanclass="math inline">\(dpmin[i]\)</span>，它表示以第 i个元素结尾的乘积最小子数组的乘积，那么我们可以得到这样的动态规划转移方程：<span class="math display">\[\begin{align}dpmax[i]&amp;=max(dpmax[i-1]*a[i],\quad dpmin[i-1]*a[i],\quad a[i])\qquad(i \in[2..n]) \tag{2}\\dpmin[i]&amp;=min(dpmax[i-1]*a[i],\quad dpmin[i-1]*a[i],\quad a[i])\qquad(i \in[2..n])\tag{3}\end{align}\]</span> 　　特例值很好分析，<spanclass="math inline">\(dpmax[1]=dpmin[1]=a[1];\)</span></p><p>　　仔细分析公式（２）和（３），可以发现，<spanclass="math inline">\(dpmax[]\)</span>和<spanclass="math inline">\(dpmin[]\)</span>不必开数组，只需要用两个变量<spanclass="math inline">\(dpmax\)</span>和<spanclass="math inline">\(dpmin\)</span>就能搞定了。</p><h2 id="ac代码-1">2.3 AC代码</h2><h3 id="数组版本">2.3.1 数组版本</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 版本2： dp数组版本 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//  提交内容如下 </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector &lt;<span class="hljs-type">long</span>&gt; <span class="hljs-built_in">maxF</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>()), <span class="hljs-built_in">minF</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            maxF[i] = <span class="hljs-built_in">max</span>(maxF[i - <span class="hljs-number">1</span>] * nums[i], <span class="hljs-built_in">max</span>((<span class="hljs-type">long</span>)nums[i], minF[i - <span class="hljs-number">1</span>] * nums[i]));<br>            minF[i] = <span class="hljs-built_in">min</span>(minF[i - <span class="hljs-number">1</span>] * nums[i], <span class="hljs-built_in">min</span>((<span class="hljs-type">long</span>)nums[i], maxF[i - <span class="hljs-number">1</span>] * nums[i]));<br>            <span class="hljs-keyword">if</span>(minF[i]&lt;INT_MIN) &#123;<br>                minF[i]=nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-built_in">max_element</span>(maxF.<span class="hljs-built_in">begin</span>(), maxF.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//提交内容如上</span><br> <br>vector&lt;<span class="hljs-type">int</span>&gt; nums=&#123;<span class="hljs-number">-4</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">-2</span>&#125;; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br>Solution s1;<br>cout &lt;&lt;s1.<span class="hljs-built_in">maxProduct</span>(nums);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">a[i]:-4     -3     -2</span><br><span class="hljs-comment">dpmax[i]    -4     12      6</span><br><span class="hljs-comment">dpmin[i]-4     -3     -24</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">ans=max(-4,12,6) = 12</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="变量版本">2.3.2 变量版本</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 版本1： dp变量版本 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//  提交内容如下 </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> dpmax, dpmin, dpmax11, dpmin11, ans;<br>        dpmax11=dpmin11=ans=nums[<span class="hljs-number">0</span>];<br><span class="hljs-comment">//        printf(&quot;%d %d %d\n&quot;, dpmax11, dpmin11, ans);</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            dpmax = <span class="hljs-built_in">max</span>(dpmax11*nums[i], <span class="hljs-built_in">max</span>((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)nums[i], dpmin11*nums[i]));<br>            dpmin = <span class="hljs-built_in">min</span>(dpmax11*nums[i], <span class="hljs-built_in">min</span>((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)nums[i], dpmin11*nums[i]));<br>            ans=<span class="hljs-built_in">max</span>(dpmax,<span class="hljs-built_in">max</span>(dpmin,ans));<br><span class="hljs-comment">//            printf(&quot;%d %d %d\n&quot;, dpmax, dpmin, ans);</span><br>            dpmax11=dpmax;<br>            dpmin11=dpmin;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//提交内容如上</span><br> <br>vector&lt;<span class="hljs-type">int</span>&gt; nums=&#123;<span class="hljs-number">-4</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">-2</span>&#125;; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br>Solution s1;<br>cout &lt;&lt;s1.<span class="hljs-built_in">maxProduct</span>(nums);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">a[i]:-4     -3     -2</span><br><span class="hljs-comment">dpmax[i]    -4     12      6</span><br><span class="hljs-comment">dpmin[i]-4     -3     -24</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">ans=max(-4,12,6) = 12</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线性结构编程技巧 </category>
          
          <category> 最大子段和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口求最值（单调队列入门）</title>
      <link href="/2024/12/15/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E6%9C%80%E5%80%BC%EF%BC%88%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%85%A5%E9%97%A8%EF%BC%89/"/>
      <url>/2024/12/15/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E6%9C%80%E5%80%BC%EF%BC%88%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%85%A5%E9%97%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="一-理论教学">一、 理论教学</h1><h2 id="基本概念">1.1 基本概念</h2><p>　　队列：变异后的一种线性表结构，只能在队尾插入元素（不允许在队尾删除元素），在队头位置读取或删除元素（不允许在队头插入元素）。在学习本帖之前要求学生已经掌握队列的含义、手捏队列及STL中的queue。</p><p>　　双端队列：在“队列”的基础上增强功能，允许在队头和队尾都能插入和删除元素。在STL中有专门的结构deque来实现，相对于queue，deque增加的操作如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">deque&lt;<span class="hljs-type">int</span>&gt; dq;<br>dq.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>); dq.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>); dq.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>dq.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 在队头位置插入５</span><br>dq.<span class="hljs-built_in">pop_back</span>();    <span class="hljs-comment">// 删除尾部的３０</span><br><span class="hljs-type">int</span> f=dq.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// f = 5;</span><br><span class="hljs-type">int</span> e=dq.<span class="hljs-built_in">back</span>();  <span class="hljs-comment">// e = 20;</span><br>dq.<span class="hljs-built_in">pop_front</span>();   <span class="hljs-comment">// 把５出队</span><br>f=dq.<span class="hljs-built_in">front</span>();     <span class="hljs-comment">// f = 10;</span><br></code></pre></td></tr></table></figure><p>　　单调队列：队列内元素值具有单调性（单调非递减／单调非递增）的双端队列。在双端队列操作的过程中，根据值的大小去想办法维护好各元素值的单调性，这就是单调队列了。所以单调队列并不是一个新结构，它是以双端队列为基本载体的。单调队列经常用来优化一些典型算法的时间复杂度。本帖是单调队列优化的入门贴，以最简单的“滑动窗口最值优化”模型为例。</p><h2 id="题型介绍">1.2 题型介绍</h2><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic/img/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E6%9C%80%E5%80%BC-%E9%A2%98%E5%9E%8B%E4%BB%8B%E7%BB%8D.png" style="zoom:80%;" /></p><h2 id="教学视频链接">1.3 教学视频链接</h2><p><ahref="https://www.bilibili.com/video/BV1H5411j7o6/?spm_id_from=333.1387.search.video_card.click">【模板】单调队列滑动窗口最值</a></p><h2 id="朴素算法">1.4 朴素算法</h2><p>　　如果没学过单调队列，拿到这种题后只能采用暴力的方法，复杂度是<spanclass="math inline">\(O(n^2)\)</span>。</p><p>　　假设dp[i]表示在data[]中以ｉ结尾的窗口中的最小值。则有伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i-k+<span class="hljs-number">1</span>; j&lt;=i; j++) <span class="hljs-comment">// 内层循环最糟糕的复杂度也达到了O(n)</span><br>        dp[i]= <span class="hljs-built_in">min</span>(data[j])<br></code></pre></td></tr></table></figure><p>　　注意，<strong>当考虑当前元素为ｉ号元素时，窗口的右边界是ｉ，左边界为ｉ－ｋ＋１，这样的区间［ｉ－ｋ＋１，ｉ］内就一共有ｋ个元素</strong>。例如ｋ＝３，ｉ＝１０时，下标区间为［８，１０］内就有a[8]、a[9]、a[10]这３个元素了。</p><h2 id="采用单调队列进行优化">1.5 采用单调队列进行优化</h2><p>　　我们可以采用单调队列来优化上面１.４节中伪代码的内层循环，使之复杂度降为<spanclass="math inline">\(O(1)\)</span>。</p><p>　　单调队列在进行“滑动窗口求最值／求和值”的使用套路如下：</p><p>　　１）判断队头元素是否需要出队</p><p>　　２）使用当前的队头元素（该值代表了当前元素为ｉ号元素时的data[]窗口内各元素体现出来的最优值）</p><p>　　３）判断队尾元素是否需要出队</p><p>　　４）队尾插入新元素的下标（队尾入队）</p><p>　　下面我们以上图中的样例数据（ｋ＝３）讲解使用单调队列求最小值（最大值雷同，同学们自行去举一反三）时的处理过程：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic/img/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E6%B1%82%E6%9C%80%E5%80%BC1.png" alt="image-20241221155531191" style="zoom:67%;" /></p><p>　　上面的这个算法图示过程有一个问题没有解决，那就是“当处理第ｉ个元素时，如何判断当前的队头元素在data数组中的原下标是否已经被移出了红窗口的左端？”　例如，在处理a[7]=6时，如何判断当前的队头元素－３（即４号元素）已经出了红窗口的左端？尤其是当data[]中可能存在重复值的情况下。所以，单靠值来判断是肯定不准确的。</p><p>　　仔细观察队列内所有元素的由来和使用，我们可以发现，队列里的所有元素值都直接来自于原始数组data，所以我们完全可以在队列中不直接存储元素值，而改为存储元素在data[]中的下标值。这样并不妨碍我们获得队头或队尾元素的值（需要多套一层，获取值需要从q[h]变成data[q[h]]即可）。当这样改进之后，对于上一段中提到的问题，我们可以通过i-q[h]+1&gt;k（“右端－左端＋１”即为区间长度）来判断了。</p><h2 id="注意事项">1.6 注意事项</h2><p>　　１）在理解单调队列的优化时，不要把队列的长度和窗口的宽度混为一谈。窗口宽度是针对data[]进行限制的。完全可能出现“窗口宽度是１０，而队列当前只有２个元素”的情况。</p><p>　　２）每次当ｉ右移一步，红窗右端增加１个元素，所以在队头位置最多只超宽１个元素，所以最多只需要在队头出队１次，此处应是一个ｉｆ判断，不需要循环。另一方面，根据队尾元素值来判断是否需要在队尾出队和进队，所以在队尾位置应该用ｗｈｉｌｅ来控制出队，可能一次性出队多个数据。在做“出队”或者“访问队头元素”时一定要注意在“队列存在元素”的条件满足情况下。</p><p>　　３）关于队列的实现，可以手捏队列，也可以用deque来实现，要求同学们两种方法都要会！对应代码应准备方法１和方法２两个版本。</p><p>　　４）虽然代码在ｆｏｒ里面会套ｗｈｉｌｅ，但每个元素都进队和出队１次，所以时间复杂度是<spanclass="math inline">\(O(n)\)</span>。</p><p>　　５）在本例中是求最小值，所以“如果新元素更优”可以理解为“如果新元素更小”，即有<spanclass="math inline">\(while(a[i]&lt;=a[q[t]])\)</span>。如果是让求最大值呢？同学们可以自行想一下，然后根据上图的数据，画出对应的框图。另外，这个式子为何需要有“＝”号呢？那是因为，假设当前元素和队尾元素的值都是６，则队尾那个６的所属下标应被出队丢弃，这是因为新６的下标更靠右，即更年轻。虽然新６和旧６都在红窗口内，当随着红窗的右移，新６在红窗内的时间更长，更不易被移出红框。</p><p>　　６）求滑动窗口内元素的最小值，越小则越优，故队列里各值（是下标值）对应元素值应是升序，即“越来越差”；反之，若求滑动窗口内元素的最大值，越大则越优，故队列里各值（是下标值）对应元素值应是降序，也是“越来越差”。</p><p>　　７）在上面的９张图中，虽然图２和图３的红窗内元素＜ｍ个，但此时队列中的各个数据及顺序仍然是正确的。也就是说，当区间长度＜ｍ时，队头元素及后续的元素都是正确的。本方法对区间宽度＜＝ｍ时同样适用。</p><p>　　８）因为队列里的数据都是来自于当前元素（不管当前元素＞、＝或＜队尾元素），所以队列内的所有元素都肯定来自于红窗内的所有元素，队列里不存在红窗外的任何元素。</p><h2 id="代码模板">1.7 代码模板</h2><p>　　１.　ｄｅｑｕｅ实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 该模板在队列ｑ中存储的是元素值和其下标值，也可以只存下标值（同学们自己写）。</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123; <span class="hljs-comment">// 对于每个元素</span><br><span class="hljs-keyword">while</span>( !q.<span class="hljs-built_in">empty</span>() &amp;&amp; q.<span class="hljs-built_in">back</span>().val&lt;=a[i] )<br>q.<span class="hljs-built_in">pop_back</span>();<br>q.<span class="hljs-built_in">push_back</span>( (node)&#123;a[i],i&#125; ); <span class="hljs-comment">//　可只存i</span><br><span class="hljs-keyword">if</span>( i-q.<span class="hljs-built_in">front</span>().pos+<span class="hljs-number">1</span> &gt; k ) <span class="hljs-comment">// 右端－左端＋１，是红窗实际宽度。此处不需要写while，最多超宽了１个元素</span><br>q.<span class="hljs-built_in">pop_front</span>();<br><span class="hljs-keyword">if</span>(i&gt;=k)　<span class="hljs-comment">//　此if条件应根据实际情况而定，不局限在“i&gt;=k”</span><br>cout &lt;&lt;q.<span class="hljs-built_in">front</span>().val &lt;&lt;endl;　<span class="hljs-comment">//　使用当前红窗内的最优值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>　　２.　手捏队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 手写队列时，ｈ和ｔ的精准含义可自行确定。需要提醒的时，数组模拟队列时，需留一个空位，即长度为１０的数组最多只存９个元素，以方便写码。</span><br>h=<span class="hljs-number">1</span>; <span class="hljs-comment">// h&lt;=t表示队内有元素，反之h&gt;t，即１&gt;0，表示队列空</span><br>t=<span class="hljs-number">0</span>; <span class="hljs-comment">// 队尾元素在队列中的下标位置，＝０表示初态，队内０个元素 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">while</span> ( h &lt;= t  &amp;&amp;  a[q[t]] &gt;= a[i] ) <br>t--;<br>q[++t] = i;<br><span class="hljs-keyword">if</span> ( i-q[h]+<span class="hljs-number">1</span> &gt; k ) <br>++h;<br><span class="hljs-keyword">if</span> ( i &gt;= k )<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[q[h]]);<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="二实战练习">二、实战练习</h1><h2 id="p2032-扫描">2.1 P2032　扫描</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<ahref="https://www.luogu.com.cn/problem/P2032">P2032　扫描</a></p><h3 id="分析">2.1.2 分析</h3><p>　　这个题是单调队列优化滑动窗口求最值的最简单的题了，比P1886还要简单一些，适合做入门后测试模板代码的第一个爽题。直接套模板即可。滑窗宽度固定在ｋ。</p><h3 id="代码">2.1.3 代码</h3><p>　　１）ｄｅｑｕｅ版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">单调队列模板的第一个题，deque实现 </span><br><span class="hljs-comment">求线性数据中，固定长度（k个）的窗口[i-k+1, i]内的最值问题 </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1000005</span>;<br><span class="hljs-type">int</span> n,k;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br><span class="hljs-type">int</span> val,pos;<br>&#125; a[N];  <span class="hljs-comment">// 其实可以不设置数组，因为ｑｍａｘ队列里已经存了数值，能提取出队头／尾对应的原始数据值</span><br>deque&lt;node&gt; qmax;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt;n &gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>cin&gt;&gt;a[i].val, a[i].pos=i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-comment">// 如果新来的元素比当前单调队列qmax中队尾元素qmax.back().val还要更优（本例是求最大值，即更大），</span><br><span class="hljs-comment">// 则需要从右往左依次把所有大于当前元素a[i]的队列元素全部出队。</span><br><span class="hljs-comment">// 这些年龄又大而且又没有本事的红窗内旧元素，肯定是比不过年轻有为的新来者的</span><br><span class="hljs-comment">// 既然这些红窗内旧元素永远没有获得最优值的可能，此时就马上剔除掉。</span><br><span class="hljs-comment">// 注意出队的前提条件中，必须有一条是：“假设队内有元素” </span><br><span class="hljs-keyword">while</span>( !qmax.<span class="hljs-built_in">empty</span>() &amp;&amp; qmax.<span class="hljs-built_in">back</span>().val&lt;=a[i].val )<br>qmax.<span class="hljs-built_in">pop_back</span>();<br><br><span class="hljs-comment">// 新元素进队尾（我虽然比左边的元素稍劣，但是我更年轻一点，未来我左边的牛人被踢走后，我就有可能是红窗内的最优值！）</span><br>qmax.<span class="hljs-built_in">push_back</span>(a[i]); <br>  <br><span class="hljs-comment">// 如果队列的左端在data中的位置qmax.front().pos出了红窗左边界，则需要出队1次 </span><br><span class="hljs-keyword">if</span>( i-qmax.<span class="hljs-built_in">front</span>().pos+<span class="hljs-number">1</span> &gt; k)<br>qmax.<span class="hljs-built_in">pop_front</span>();<br><span class="hljs-comment">// 存储或者表示答案，当前红窗内所有元素的最优值（即当前的最大值）存于当前的队头元素中！</span><br><span class="hljs-comment">// 窗口宽度不够k时是不需要输出的 </span><br><span class="hljs-keyword">if</span>(i&gt;=k)<br>cout &lt;&lt;qmax.<span class="hljs-built_in">front</span>().val &lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　２）手写队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">单调队列模板的第一个题，deque实现 </span><br><span class="hljs-comment">求线性数据中，固定长度（k个）的窗口[i-k+1, i]内的最值问题 </span><br><span class="hljs-comment">手写单调队列版本</span><br><span class="hljs-comment">*/</span> <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1000005</span>;<br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> qmax[N], h=<span class="hljs-number">1</span>,t=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt;n &gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>cin&gt;&gt;a[i];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">while</span>( h&lt;=t &amp;&amp; a[qmax[t]]&lt;=a[i] )<br>t--;<br>qmax[++t]= i; <span class="hljs-comment">// 注意这里需要先加t，再填值 </span><br><span class="hljs-keyword">if</span>( i-qmax[h]+<span class="hljs-number">1</span> &gt; k)<br>h++;<br><span class="hljs-keyword">if</span>(i&gt;=k)<br>cout &lt;&lt;a[qmax[h]] &lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p1886-滑动窗口-模板单调队列">2.2 P1886 滑动窗口/【模板】单调队列</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P1886">P1886 滑动窗口/【模板】单调队列</a></p><h3 id="分析-1">2.2.2 分析</h3><p>　　这个题需要求滑窗内的最大值和最小值，滑窗宽度固定为ｍ，两者互不影响，互不关联，可作为训练最大值或最小值的样板题。</p><h3 id="ac代码">2.2.3 AC代码</h3><p>　　１）deque版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法1：单调队列，deque实现 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">这个题要完成两件事，同时找出每次宽度为k的窗口右滑后窗口内所有元素的最大值和最小值</span><br><span class="hljs-comment">两件事情可以一起做，也可以分开做，互不影响</span><br><span class="hljs-comment">注意，本题的手写队列的方式也需要掌握，即方法二也需要掌握! </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sd</span> &#123;<br><span class="hljs-type">int</span> pos,val; <span class="hljs-comment">//存储编号和大小</span><br>&#125;;<br>deque&lt;sd&gt; qmax;<br>deque&lt;sd&gt; qmin;<br><span class="hljs-type">int</span> add[<span class="hljs-number">1000005</span>][<span class="hljs-number">2</span>]; <span class="hljs-comment">//用以存储答案的----见代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n,m,k,cnt=<span class="hljs-number">0</span>;<br>cin&gt;&gt;n&gt;&gt;k;<br>sd rr;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);  <span class="hljs-comment">//输入</span><br>rr.pos=i;<br>rr.val=x;  <span class="hljs-comment">//赋值</span><br><span class="hljs-keyword">while</span>( !qmax.<span class="hljs-built_in">empty</span>() &amp;&amp; x&gt;=qmax.<span class="hljs-built_in">back</span>().val )<br>qmax.<span class="hljs-built_in">pop_back</span>();  <span class="hljs-comment">//单调队列的操作，以保证单调</span><br><span class="hljs-keyword">while</span>( !qmin.<span class="hljs-built_in">empty</span>() &amp;&amp; x&lt;=qmin.<span class="hljs-built_in">back</span>().val)<br>qmin.<span class="hljs-built_in">pop_back</span>();<br>qmax.<span class="hljs-built_in">push_back</span>(rr); <span class="hljs-comment">//压入队尾</span><br>qmin.<span class="hljs-built_in">push_back</span>(rr); <span class="hljs-comment">//同上</span><br><span class="hljs-keyword">if</span>( i-k &gt;= qmax.<span class="hljs-built_in">front</span>().pos )  <span class="hljs-comment">//若队头元素在原始数组中已不在窗口宽度k内，则踢掉 </span><br>qmax.<span class="hljs-built_in">pop_front</span>();<br><span class="hljs-keyword">if</span>( i-k &gt;= qmin.<span class="hljs-built_in">front</span>().pos)   <span class="hljs-comment">//若队头元素在原始数组中已不在窗口宽度k内，则踢掉</span><br>qmin.<span class="hljs-built_in">pop_front</span>(); <br><br><span class="hljs-comment">// 当i&gt;=k之后才开始存储答案到数组中。当i&lt;k时不需要存。例如8个数，宽度3，答案是6个数</span><br><span class="hljs-keyword">if</span>(i&gt;=k) &#123;<br>add[++cnt][<span class="hljs-number">0</span>]=qmax.<span class="hljs-built_in">front</span>().val; <span class="hljs-comment">// 从1号位开始存储 </span><br>add[cnt][<span class="hljs-number">1</span>]=qmin.<span class="hljs-built_in">front</span>().val;<br>&#125; <span class="hljs-comment">//存答案</span><br>&#125;<br><span class="hljs-comment">// 打印每次窗口右滑1次后窗口内元素的最小值 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=cnt; i++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, add[i][<span class="hljs-number">1</span>]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-comment">// 打印每次窗口右滑1次后窗口内元素的最小值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=cnt; i++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, add[i][<span class="hljs-number">0</span>]);  <span class="hljs-comment">//输出</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　２）手捏队列</p><p>　　这个题要注意的是求滑窗最大值和最小值的这两个系列操作不要相互影响，而且需要存储数据而不是即时打印。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/// 方法2；单调队列模板题，手写数组实现单调队列</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e6</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> h1,t1,h2,t2; <span class="hljs-comment">// h1和t1表示最小值的队列，h2和t2表示最大值的队列</span><br><span class="hljs-type">int</span> q1[maxn], q2[maxn];     <span class="hljs-comment">// q1存最小值，q2存最大值。队列，存储元素在a[]中的下标值，队头元素值为a[q[h]]，队尾元素值为a[q[t]]</span><br><span class="hljs-type">int</span> i,n,a[maxn],k;<br><span class="hljs-type">int</span> maxx[maxn], minn[maxn], len;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>h1=<span class="hljs-number">1</span>, h2=<span class="hljs-number">1</span>;<br>t1=<span class="hljs-number">0</span>, h2=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">while</span> ( h1 &lt;= t1  &amp;&amp;  a[i] &lt;= a[q1[t1]] ) t1--;  <span class="hljs-comment">// 处理滑窗最小值队列 </span><br>q1[++t1] = i;<br><span class="hljs-keyword">if</span> ( i - q1[h1] + <span class="hljs-number">1</span> &gt; k ) ++h1;<br><br><span class="hljs-keyword">while</span> ( h2 &lt;= t2  &amp;&amp;  a[i] &gt;= a[q2[t2]] ) t2--;<br>q2[++t2] = i;<br><span class="hljs-keyword">if</span> ( i - q2[h2] + <span class="hljs-number">1</span> &gt; k ) ++h2;<br><br><span class="hljs-keyword">if</span> ( i &gt;= k ) <br>minn[++len]=a[q1[h1]], maxx[len]=a[q2[h2]];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=len; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, minn[i]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=len; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, maxx[i]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">10 3</span><br><span class="hljs-comment"> 10  30  -10  -30  50   30  30  60  50  65</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="p1440-求m区间内的最小值">2.3 P1440 求m区间内的最小值</h2><h3 id="原题链接-2">2.3.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P1440">P1440求m区间内的最小值</a></p><h3 id="分析-2">2.3.2 分析</h3><p>　　先要准确理解题意。本题在录入第i个数时，要去求［ｉ－ｍ，ｉ－１］这个固定区间宽度内所有数据的最小值，区间不是[i-m+1,i] 。即：假设m=3，录入第9个数时，应该打印第6、7、8这三个数的最小值！</p><p>　　对于本题的输入样例１，ｎ＝６，ｍ＝２，数据为｛７，８，１，４，３，２｝：</p><p>　　１）录入第１个数７，根据题意，前面无数，输出０；</p><p>　　２）录入第２个数８，８前面有１个数据７，不够ｍ（＝２）个，则有多少个算多少个，故最小值为７；</p><p>　　３）录入第３个数１，１前面２个数｛７，８｝的最小值为７；</p><p>　　４）录入第４个数４，４前面２个数｛８，１｝的最小值为１；</p><p>　　５）录入第５个数４，３前面２个数｛１，４｝的最小值为１；</p><p>　　６）录入第６个数２，２前面２个数｛４，３｝的最小值为３；</p><p>　　本题的数据规模较大，达到了２ｅ６。能不存储就尽量不存储了。本题只需要存储上一个数和当前数，所以不需要设置a[]。</p><p>　　本题和上面几个题之间最大的区别就是：在录入当前数时，处理的区间并不是［ｉ－ｍ＋１，ｉ］（ｍ个数据），而是［ｉ－ｍ，ｉ－１］。所以循环内是拿第ｉ－１个数来作为队尾的新进元素进行考虑和处理，该比较的比较，该出队尾的出队尾，该进队尾的进队尾，都以第ｉ－１个数为对象来处理！至于第ｉ个数？先晾着，不管。需要注意的是，循环从２号元素开始，１号需要单搞。</p><h3 id="ac代码-1">2.3.3 AC代码</h3><p>　　１）deque版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">单调队列来解决，deque版本，错位，求最小值 </span><br><span class="hljs-comment">注意，本题在录入第i个数时，要去求 [i-m, i-1] 这个区间窗口内数据的最小值，区间不是[i-m+1, i] ！ </span><br><span class="hljs-comment">即，假设m=3，录入第9个数时，应该打印第6、7、8这三个数的最小值 ！</span><br><span class="hljs-comment">*/</span> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> pos, val;<br>&#125;;<br>deque&lt;node&gt; dq;<br><span class="hljs-type">int</span> ans[<span class="hljs-number">2000001</span>], n, m;<br><span class="hljs-type">int</span> num, prenum;　<span class="hljs-comment">//当用deque存储node时已存取元素值，故可不存储原始数组。当此时需要用到a[i-1]，故用prenum来迭代num，维护好当前数和上一个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>ans[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;     <span class="hljs-comment">// 第1个数之前是没有数的，根据题意，故肯定为0 </span><br>prenum = num; <span class="hljs-comment">// 借助prenum，就不需要存储a[]了，节约内存空间 </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123; <span class="hljs-comment">// 针对第1个数的情况已经处理 </span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num); <br><span class="hljs-comment">// 存储第i个数据num时，却在计算窗口[i-m, i-1]的最小值，第i-1个数存于prenum </span><br><span class="hljs-comment">// 下面的代码跟num一点关系都没有哦！～完全是在处理上一个数prenum </span><br><span class="hljs-keyword">while</span> (dq.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span> &amp;&amp; prenum &lt;= dq.<span class="hljs-built_in">back</span>().val )<br>dq.<span class="hljs-built_in">pop_back</span>();<br>dq.<span class="hljs-built_in">push_back</span>( node&#123;i<span class="hljs-number">-1</span>, prenum&#125; );  <br><span class="hljs-keyword">if</span> (dq.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span> &amp;&amp; (i<span class="hljs-number">-1</span>) - dq.<span class="hljs-built_in">front</span>().pos + <span class="hljs-number">1</span> &gt; m )  <span class="hljs-comment">// 区间长度表示为：右端 - 左端 + 1 </span><br>dq.<span class="hljs-built_in">pop_front</span>();<br>ans[i] = dq.<span class="hljs-built_in">front</span>().val;  <span class="hljs-comment">// 使用当前滑窗内所有元素的最优值 </span><br>prenum= num;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans[i]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　２）手捏单调队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法2：手捏单调队列 ，求所有固定区间宽度内元素的最小值 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">单调队列来解决，deque版本，错位，求最小值 </span><br><span class="hljs-comment">注意，本题在录入第i个数时，要去求 [i-m, i-1] 这个区间窗口内数据的最小值，区间不是[i-m+1, i] ！ </span><br><span class="hljs-comment">即，假设m=3，录入第9个数时，应该打印第6、7、8这三个数的最小值 ！</span><br><span class="hljs-comment">*/</span> <br><span class="hljs-type">int</span> q[<span class="hljs-number">2000001</span>], h=<span class="hljs-number">1</span>, t=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> a[<span class="hljs-number">2000001</span>]; <span class="hljs-comment">// 必须要设置a[]了，只为了提取到a[q[h]]和a[q[t]]</span><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;a[<span class="hljs-number">1</span>]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>);     <span class="hljs-comment">// 第1个数之前是没有数的，根据题意，故肯定为0 </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123; <span class="hljs-comment">// 针对第1个数的情况已经处理 </span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]); <br><span class="hljs-comment">// 存储a[i]时，却在计算窗口[i-m, i-1]的最小值</span><br><span class="hljs-comment">// 下面的代码跟i和a[i]一点关系都没有哦！～完全是在处理上一个数a[i-1]，用到的也是i-1 </span><br><span class="hljs-keyword">while</span> ( h&lt;=t &amp;&amp; a[i<span class="hljs-number">-1</span>] &lt;= a[q[t]] ) <br>t--;<br>q[++t] = i<span class="hljs-number">-1</span>;   <br><span class="hljs-keyword">if</span> ( h &lt;= t &amp;&amp; (i<span class="hljs-number">-1</span>) - q[h] + <span class="hljs-number">1</span> &gt; m )  <span class="hljs-comment">// 区间长度表示为：右端 - 左端 + 1 </span><br>h++;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a[q[h]]);  <span class="hljs-comment">// 使用当前滑窗内所有元素的最优值 </span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="u162964-烽火传递">2.4 U162964 烽火传递</h2><h3 id="原题链接-3">2.4.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/U162964">U162964烽火传递</a></p><h3 id="分析-3">2.4.2 分析</h3><p>　　简要题意：ｎ个正整数，要求在连续的ｍ个数中至少要选择一个数。求所有选中的数的最小和值。</p><p>　　这个题要求学生最好是学过动态规划ｄｐ。难度介于黄绿之间。</p><p>　　拿到这个题，标准动作应该是先在草稿纸上写一些其他的样例，并写出对应的答案，看能否从中推出一些心得或规律，而不是就这么眼睁睁地干盯着空想。假设ｍ＝３（连续３个数中必须要选至少１个）：</p><p>　　１）<font color="red">１</font>　　４　　８　　　　　　　　　　　　答案：１；</p><p>　　２）１　　<font color="red">４</font>　　８　　８　　　　　　　　　答案：４；</p><p>　　３）１　　１　　<font color="red">４</font>　　８　　８　　　　　　答案：４；</p><p>　　４）５　　<font color="red">３</font>　　９　　<font color="red">３</font>　　５　　　　　　答案：３＋３＝６；</p><p>　　５）５　　３　　<font color="red">１</font>　　<font color="red">２</font>　　４　　５　　　答案：１＋２＝３；</p><p>　　６）１　　３　　<font color="red">１０</font>　４０　３０　<font color="red">５</font>　　　答案：１０＋５＝１５；</p><p>　　对于解题方案，第一反应并不会想到单调队列，而是想到和递推或者ｄｐ有关。这题肯定不是暴力（暴力去DFS的话，不光是要面对每个数的“选”和“不选”，还需要处理两个被选数之间的间隔，极为麻烦）；也没法贪心，不知道怎么贪；也不能去排序，因为顺序会改变题解；本题要求的也不是一个区间内的和值，所以也和“前缀和”无关。只有ｄｐ这种递推才有可能破题。</p><p>　　但如果假设ｄｐ［ｉ］为“前ｉ个数中所选数的最小和值”是不妥的。因为这样划分并没体现出ｄｐ的“无后效性”原则（即“ｄｐ［ｉ－１］的选择方案可能会影响到ｄｐ［ｉ］的选择方案”）。所以正确的做法是：定义ｄｐ［ｉ］为“<strong>选定第ｉ个数后，前ｉ个数内所有所选数的最小和值</strong>”。下面按照ｄｐ的套路来开始分析。</p><p>　　１）状态数组：</p><p>　　　　ｄｐ［ｉ］：选定第ｉ个数后，前ｉ个数内所有所选数的最小和值。</p><p>　　２）所求目标：</p><p>　　既然连续ｍ个数中必然选择一个，那么根据状态数组的定义，在倒数的ｍ个ｄｐ值中必然有一个是本题答案，即最小的那个。所求目标的公式如下：<span class="math display">\[min(\ dp[i]\ )\qquad(\ i \in [n-m+1,\ \ n]\ )\]</span> 　　３）状态转移方程：</p><p>　　从上面的４个样例可以看到，若当前数被选，则其左侧的ｍ个数ａ［ｉ－ｍ．．ｉ－１］中必然要有一个数被选定（该区间内无需选多个，纯属浪费，徒增和值）。可求这区间内所有的ｄｐ［］值，选最小的那个来和当前数ａ［ｉ］相加而得到ｄｐ［ｉ］。故有：<span class="math display">\[dp[i]=a[i]\ +\ min(\ dp[j]\ )\qquad (\ j \in[i-m,\ i-1]\ ,\ i \in[\m+1,\ n\ ]\ )\tag{1}\]</span> 　　４）循环边界和循环顺序</p><p>　　ｉ从ｍ＋１到ｎ，只能正序；ｊ从ｉ－ｍ到ｉ－１，正逆均可。</p><p>　　５）初始化和特例</p><p>　　　　<spanclass="math inline">\(dp[1..m]\)</span>这个范围内的值，因为必须要选<spanclass="math inline">\(a[i]\)</span>，且其左侧宽度已不够ｍ，不会再选其他数而只有自己，故最小和值就是自己。即有：<span class="math display">\[dp[i]=a[i] \qquad (i \in \ [\ 1,\ m\ ]\ )\tag{2}\]</span>　　从上面的分析我们可以看到，当处理第ｉ个ｄｐ值时，需要求一个固定宽度（宽度为ｍ）的下标区间内的所有ｄｐ值的最小值。这，不正就是之前单调队列可以搞定的事情吗？准确地说，是P1440题所对应的内容，因为区间并不包含当前的<spanclass="math inline">\(dp[i]\)</span>，而是<spanclass="math inline">\([i-m,i-1]\)</span>。所以我们只需要对<spanclass="math inline">\(dp[i](i \in[m+1,\n])\)</span>用P1440的方法来求就行了。</p><p>　　至于<span class="math inline">\(dp[i](i \in[1,\m])\)</span>，因为根据ｄｐ的定义，必须要选定当前数<spanclass="math inline">\(a[i]\)</span>，所以<spanclass="math inline">\(a[1..m]\)</span>左侧区间的数肯定就不够ｍ个了，甚至ｄｐ［１］左侧有０个数据（在全部数都为正数的前提下，空区间的最小值自然就是０）。</p><p>　　<spanclass="math inline">\(a[1]\)</span>左侧无数，区间为空，ｉ－１＝０进队尾（也是队头），故有<spanclass="math inline">\(q[h]=q[1]=0\)</span>；所以<spanclass="math inline">\(dp[1]=dp[q[h]]+a[1]=dp[0]+a[1]=a[1]\)</span>。</p><p>　　<spanclass="math inline">\(a[2..m]\)</span>依次进队尾，并在队列中形成增序序列，而因为左侧区间宽度一直＜ｍ个，所以队头这端不会出队，q[h]一直是1，而<spanclass="math inline">\(dp[q[h]]=dp[0]=0\)</span>，在执行“<spanclass="math inline">\(dp[i]=dp[q[h]]+a[i];\)</span>”时，蜕变为“<spanclass="math inline">\(dp[i]=a[i];\)</span>”了。这和公式（２）正好不谋而合。所以根据对上面单调队列的分析，可以将两个阶段整合成一个阶段，把公式（１）和（２）合并成如下的公式（３）：<span class="math display">\[dp[i]=a[i]\ +\ dp[\ q[h]\ ]\qquad (\ i \in[\ 1,\ n\ ]\ )\tag{3}\]</span></p><h3 id="ac代码-2">2.4.3 AC代码</h3><p>１）手捏单调队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法1： 手捏单调队列 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,m,w[N],dp[N],q[N];<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br>m=<span class="hljs-built_in">min</span>(n,m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) cin&gt;&gt;w[i];<br><span class="hljs-type">int</span> ans=<span class="hljs-number">2e9</span>;<br><span class="hljs-type">int</span> h=<span class="hljs-number">1</span>,t=<span class="hljs-number">0</span>;                          <span class="hljs-comment">//清空队列</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;           <br>    <span class="hljs-comment">// 在第i轮搞定，用单调队列来求dp[i-m..i-1]区间内所有元素的最小值 </span><br><span class="hljs-keyword">while</span>(h&lt;=t &amp;&amp; dp[i<span class="hljs-number">-1</span>] &lt;= dp[q[t]]) <br>t--;  <br>q[++t]=i<span class="hljs-number">-1</span>;                       <span class="hljs-comment">//队尾入队(存储下标 方便判断队头出队)</span><br><span class="hljs-keyword">if</span>( (i<span class="hljs-number">-1</span>)-q[h]+<span class="hljs-number">1</span> &gt; m) <br>h++;        <span class="hljs-comment">//队头出队(队头元素滑出窗口)</span><br>dp[i]=dp[q[h]]+w[i];              <span class="hljs-comment">//使用i-1对应的最优值q[h]，实现dp的转移方程 </span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) ans=<span class="hljs-built_in">min</span>(ans, dp[i]);  <br>cout&lt;&lt;ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>２）使用deque</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法2，用deque实现单调队列 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,m,w[N],dp[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) cin&gt;&gt;w[i];<br><span class="hljs-type">int</span> ans=<span class="hljs-number">2e9</span>;<br>deque&lt;<span class="hljs-type">int</span>&gt; q;           <span class="hljs-comment">//清空队列</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123; <span class="hljs-comment">//枚举序列</span><br><span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()&amp;&amp;dp[q.<span class="hljs-built_in">back</span>()]&gt;=dp[i<span class="hljs-number">-1</span>]) q.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//队尾出队(队列不空且新元素更优)</span><br>q.<span class="hljs-built_in">push_back</span>(i<span class="hljs-number">-1</span>);                                 <span class="hljs-comment">//队尾入队(存储下标 方便判断队头出队)</span><br><span class="hljs-keyword">if</span>((i<span class="hljs-number">-1</span>)-q.<span class="hljs-built_in">front</span>()+<span class="hljs-number">1</span> &gt; m) q.<span class="hljs-built_in">pop_front</span>();                  <span class="hljs-comment">//队头出队(队头元素滑出窗口)</span><br>dp[i]=dp[q.<span class="hljs-built_in">front</span>()]+w[i];<br><span class="hljs-keyword">if</span>(i&gt;n-m) ans=<span class="hljs-built_in">min</span>(ans,dp[i]);<br>&#125;<br>cout&lt;&lt;ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线性结构编程技巧 </category>
          
          <category> 单调队列优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dp中的状态转移训练</title>
      <link href="/2024/07/31/dp%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E8%AE%AD%E7%BB%83/"/>
      <url>/2024/07/31/dp%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E8%AE%AD%E7%BB%83/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="模型说明">1.1 模型说明</h2><p>　　dp中关于状态的描述和定义，是在做dp题时一个比较重要的环节。对于大部分dp题来说，其状态的描述和定义都比较简单，可能会引起初学者的忽视。这里用一个帖子来加强大家对这个环节的领悟能力。</p><p>　　“状态定义和转移”，一个比较经典的题型就是“股票买卖系列”的题。本帖主要剖析这个题型，同学们可自行感悟。</p><p>　　股票买卖系列是动态规划的经典题目，Leetcode上有六道关于股票买卖相关的问题。</p><p>　　<strong>给定一个大小为n的数组prices代表连续n天某支股票的股价，prices[i]即第i天的股价，且必须在买进后才能卖出。每天只能做一次操作（买或者卖，第二天才能卖或买），也就是<spanclass="math inline">\(冷却期_{买 \Rightarrow 卖}=1；冷却期_{卖\Rightarrow买}=1\)</span>。再给定一些限制条件，问最大收益。</strong></p><p>　　一般有如下几种限制条件，对于LeetCode和Acwing网站上的六道题：</p><ol type="1"><li><p>买卖一次：　　　　　　　　　　<ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121.买卖股票的最佳时机</a>／<ahref="https://www.acwing.com/problem/content/1056/">1054.股票买卖</a></p></li><li><p>不限买卖次数： 　　　　　　<ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122.买卖股票的最佳时机 II</a>/<ahref="https://www.acwing.com/problem/content/1057/">1055.买卖股票II</a></p></li><li><p>买卖两次：　　　　　　　　　　<ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">123.买卖股票的最佳时机 III</a>/<ahref="https://www.acwing.com/problem/content/1058/">1056.买卖股票III</a></p></li><li><p>买卖ｋ次：　　　　　　　　　　<ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">188.买卖股票的最佳时机 IV</a>/<ahref="https://www.acwing.com/problem/content/1059/">1057.买卖股票IV</a></p></li><li><p>带有冷却的股票买卖问题：　　　<ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">309.买卖股票的最佳时机含冷冻期</a>/</p></li><li><p>带有交易费用的股票买卖问题：　<ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">714.买卖股票的最佳时机含手续费</a>/<ahref="https://www.acwing.com/problem/content/1061/">1059.买卖股票VI</a></p></li></ol><p>　　上述的题目，都有一点没说清楚。那就是<strong>“每次买卖，都只能买一手股票，不能多买多卖。而题目中提供的价格，也是一手股票在当天的价格”</strong>。如果考试遇到这类问题，怎么办？我们稳扎稳打，只用一种通用方法解决所用问题，以不变应万变。</p><p>　　这 6道股票买卖问题是有共性的，我们通过对第四题（限制最大交易次数为k）的分析一道一道解决。因为第四题是一个最泛化的形式，其他的问题都是这个形式的简化。</p><p>　　第一题是只进行一次交易，相当于 k =1；第二题是不限交易次数，相当于 k = INF（正无穷）；第三题是只进行 2次交易，相当于 k =2；剩下两道也是不限次数，但是加了交易“冷冻期”和“手续费”的额外条件，其实就是第二题的变种，都很容易处理。</p><h2 id="如何描述和定义所有状态">1.2 如何描述和定义所有状态</h2><p>　　在动态规划中，状态表示题目所描述的模型，在某一个时刻瞬间所具备的一种静态的综合信息的汇总。状态往往会对应着一个具体的数值。所以我们才会使用dp数组来存储这个数值。要想准确地界定出这种唯一的状态，就需要把状态描述的所有维度都进行准确的定义，不能出现含混不清、模棱两可的情况。如果出现含混不清，说明你对状态描述的维数太少。比如，你想描述出立体空间里的某一个点的准确位置，如果你只想出来了“长x”和“宽y”但缺乏“高z”的话，是无法准确定位出这个点的。</p><p>　　在“股票买卖模型”中，“天”是每一次交易的耗时单位，所以“天”肯定是该模型中状态的一个维度。但是当具体到某一“天”时，我们仍然无法准确地去做决策。因为我们不知道自己的交易次数用完了没有（若已用完k次的话则不能再买），也不知道自己有没有钱买股票（题型禁止买空）或有没有股票可卖成钱（题型禁止卖空）。所以状态还应该包括“已交易次数k”和“是否持有股票”这两个维度。具体需要细说一下：</p><ul><li>关于交易次数k的认定——因为有买必然就有卖，所以我们可以指定一种操作的发生来表示交易的发生，下文都以“买股票”来作为一次交易的发生。</li><li>关于“是否持有股票”——因为要求每次交易只能买或卖<strong>一手</strong>股票，不允许多买多卖，也不允许零买零卖，所以只有‘持有一手股票’和‘没有股票’这两种情况，不需要考虑‘持有0.6手或者3手等股票’。</li></ul><p>　　上述的三个维度可以准确地描述出一个状态，所以<strong>本题型的dp数组应该是三维的，分别为“第i天末、已交易k次、是否持有一手股票（用1 表示持有一手股票，0表示没有持有股票）”</strong>，用该三维数组就能表述出本题型中的所有状态。比如说dp[3][2][1] 的含义就是：今天是第三天末，已经做了2次交易，我现在手上持有着一手股票，我最多能获得多少收益值。再比如dp[2][3][0] 的含义：今天是第二天末至今已经进行了 3次交易，我现在手上没有持有股票，最多能获得多少收益值。很容易理解，对吧？</p><p>　　此时，我们可以对这三个维度相关数值的组合做一个仔细研究，确定出初值和特例来。</p><ol type="1"><li><p>dp[0][k][0] = 0 (k=[0..K]) （初值式1） 解释：因为 i 是从 1开始的，所以 i = 0 意味着还没有开始，这时候的利润当然是 0，不管 k等于几，即不管现在已经交易买卖过多少次</p></li><li><p>dp[0][k][1] = -INF (k=[0..K]) （初值式2）解释：还没开始的时候，是不可能持有一手股票的，不管k等于几。用 -INF表示这种不可能 。</p></li><li><p>dp[i][0][0] = 0 (i=[1..n]) （初值式3） 解释：k = 0意味着根本还没做过任何的买卖交易。在没有股票的前提下，利润当然是0（连续躺平多天什么都不干，没有股票是合理的，利润必然是0） 。</p></li><li><p>dp[i][0][1] = -INF (i=[1..n]) （初值式4）</p><p>解释：在没做任何交易的情况下，是不可能持有一手股票的，用 -INF表示这种情况不合理，无解。</p></li></ol><p>　　上面的第1点和第2点处理了dp[0][..][..]的所有情况；第3点和第4点处理了dp[1..n][0][..]的所有情况。现在只剩dp[1..n][1..K][..]的所有情况尚未处理，等待填写了。上述4点对应的代码（1）大致如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 重要！代码（1） 初始化dp数组和对特例赋值。下面的代码并没有化简，纯粹是为了对应上面的4个点</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;=K; k++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>; t&lt;=<span class="hljs-number">1</span>; t++)&#123;<br>            <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span> &amp;&amp; t==<span class="hljs-number">0</span>)       <span class="hljs-comment">// 初始化1  dp[0][k][0] = 0       (k=[0..K])</span><br>                dp[i][k][t]= <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span> &amp;&amp; t==<span class="hljs-number">1</span>)  <span class="hljs-comment">// 初始化2  dp[0][k][1] = -INF    (k=[0..K])</span><br>                dp[i][k][t]= -INF;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k==<span class="hljs-number">0</span> &amp;&amp; t==<span class="hljs-number">0</span>)  <span class="hljs-comment">// 初始化3  dp[i][0][0] = 0       (i=[1..n]) </span><br>                dp[i][k][t]= <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span>                    <span class="hljs-comment">// 初始化4  dp[i][0][1] = -INF    (i=[1..n])</span><br>                dp[i][k][t]= -INF;            <br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="所求目标">1.3 所求目标</h2><p>　　我们想求的最终答案是dp[n][K][0]，即最后一天末（第n天末），已经做了 K次交易，手里没有一手股票，最多能获得多少利润。读者可能问为什么不是dp[n][K][1]？因为 [1] 代表手上持有一手股票，[0]表示手上的这一手股票已经卖出去了，很显然后者得到的利润一定大于前者（除非股票价格允许是负数）。既然本题要求最大的现金值，那么手里持有了一手股票则明显没有达到现金的最大化。</p><h2 id="状态转移">1.4 状态转移</h2><p>　　所谓的“状态转移”是指我在当前状态下，采取某种决策，从而转移成为另一个不同的状态。对于本题型的每个状态来说，原则上有三种决策可以选择：买入、卖出、无操作（我们用buy, sell, rest表示这三种选择）。但实际上所有状态之间肯定不是能够自由转移的（例如不可能从第1天的某个状态忽然就变成了第4天的任何状态），并且每个状态面临的三种决策也并非肯定真实有效（例如因为不准买空卖空，必须要先有“买”才能有“卖”，所以只持有现金时不能再卖股票，持有了一手股票时不能再买股票）。而且别忘了，我们还有交易次数k的限制，如果已经做过k次交易了就不能再去买股票了。这么多的状态和相互之间的关系，该怎么表达才比较清楚呢？我们可以采用“<strong>状态机模型</strong>”来帮助我们理解状态转移的过程，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240809142607044.png" alt="image-20240809142607044" style="zoom:67%;" /></p><p>　　上图就是一个简单的状态机模型图。两个正方形表达的是两种状态，0表示“只持有现金”，1表示“持有一手股票”。箭头表示状态之间的转移动作。每个箭头，都表示从某一天到下一天的状态转移的可选项。在状态为0时只有两种转移动作的选择（“不操作”和“买股票”）；在状态为1时也只有两种转移动作的选择（“不操作”和“卖股票”）。换一个角度来看，要想得到状态0，只有两个绿色箭头这样的操作；要想得到状态1，只有两个红色箭头这样的操作。想要得到状态0或者1，我们只需要在这两种同色转移（也是决策）中去取最优决策值即可，这就是后续我们的状态转移方程的书写依据。</p><ol type="1"><li>状态为0（只持有现金）的转移方程如下：</li></ol><p><span class="math display">\[\begin{align}\textcolor{red}{dp[i][k][0]}&amp;=max(\\textcolor{yellow}{dp[i-1][k][0]}, \quad\textcolor{orange}{dp[i-1][k][1]+price[i]}\ ) \tag{1}\\\textcolor{red}{第i天只持有现金}&amp;=max(\\textcolor{yellow}{第i天不操作}\ \quad,\quad\textcolor{orange}{第i天卖光股票}\ )\tag{} \\\end{align}\]</span></p><p>　　说明：<font color="red">在第i天末只持有现金</font>，可能是因为<font color="yellow">在第i-1天末就只持有现金，且在第i天什么都不操作（价值无变化，在第i天末仍然为前一天的值）</font>；也有可能是因为<font color="orange">在第i-1天末持有了一手股票，且在第i天卖光了股票（价值有变化，卖票后必然会增加现金收入）</font>。具体该为哪一个值呢？题目求最大收益，所以就看哪个值更大咯！橙色公式中需要注意，<strong>交易以“买”为准，“第i天卖掉股票”不算是1次交易，因为已经在第i-1天买股票的同时就计入交易次数了，1次买卖才算1次交易，不能算作2次交易！</strong></p><ol start="2" type="1"><li>状态为1（持有一手股票（可能也持有多余的现金））的转移方程如下：</li></ol><p><span class="math display">\[\begin{align}\textcolor{red}{dp[i][k][1]}&amp;=max(\\textcolor{yellow}{dp[i-1][k][1]}, \quad\textcolor{orange}{dp[i-1][k-1][0]-price[i]}\ ) \tag{2}\\\textcolor{red}{第i天只持有股票}&amp;=max(\\textcolor{yellow}{第i天不操作}\ \quad,\quad\textcolor{orange}{第i天全买股票}\ )\tag{} \\\end{align}\]</span></p><p>　　说明：<font color="red">在第i天末持有一手股票</font>，可能是因为<font color="yellow">在第i-1天末就持有了一手股票，且在第i天什么都不操作（价值无变化，在第i天末仍然为前一天的值）</font>；也有可能是因为<font color="orange">在第i-1天末时只持有现金，已交易k-1次，且在第i天全买成股票（价值有变化，买票后必然会减少现金收入）</font>。具体该为哪一个值呢？题目求最大收益，所以就看哪个值更大咯！橙色公式中需要注意，<strong>交易以“买”为准，“第i天卖掉股票”不算是1次交易，因为已经在第i-1天买股票的同时就计入交易次数了，1次买卖才算1次交易，不能算作2次交易！</strong></p><p>　　上面的公式（1）和公式（2）联合起来，组成了本贴最强大而通用的dp的转移方程。这看上去很像<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1312">1312：【例3.4】昆虫繁殖</a>这种双递推啊！两个递推方程，交叉地推~~如果对这种双递推感到不适应，可以先练“昆虫繁殖”这个题。</p><h2 id="秒杀题目">1.5 秒杀题目</h2><p>　　充分理解了1.2节～1.4节的内容之后，对于帖子最开始处的6种题型，我们按照从简单到难的顺序依次来怕破解。</p><h3 id="k1">1.5.1 k==1</h3><p>　　k==1，也就是要求整个过程最多允许交易1次买卖。</p><p>　　根据公式（1）和1.2节初值分析的第3点内容，有如下2个状态转移方程：<span class="math display">\[\begin{align}\textcolor{red}{dp[i][1][0]}&amp;=\textcolor{red}{max(\dp[i-1][1][0],\quad dp[i-1][1][1]+price[i]\ )} \tag{3} \\\textcolor{yellow}{dp[i][1][1]}&amp;=max(\ dp[i-1][1][1],\quaddp[i-1][1-1][0]-price[i]\ ) \tag{} \\&amp;=max(\ dp[i-1][1][1],\quad dp[i-1][0][0]-price[i]\ ) \tag{} \\&amp;=max(\ dp[i-1][1][1],\quad \textcolor{red}{0}-price[i]\)\quad\Longleftarrow\quad(根据1.2节初值分析第3点) \tag{} \\&amp;=\textcolor{yellow}{max(\ dp[i-1][1][1],\quad -price[i]\ )} \tag{4}\\&amp;(i \geq 1) \tag{}\end{align}\]</span>　　我们仔细观察上面红色和黄色这两个状态转移方程结果，可以惊奇地发现，2个公式中的第二维全是1，没有0，这说明第2维k已无存在的意义，可以精简掉，把三维数组dp[i][k][t]变成二维数组dp[i][t]。精简后的状态转移方程如下：<span class="math display">\[\begin{align}\textcolor{red}{dp[i][0]}&amp;=\textcolor{red}{max(\dp[i-1][0],\quad dp[i-1][1]+price[i]\ )} \tag{5} \\\textcolor{yellow}{dp[i][1]}&amp;=\textcolor{yellow}{max(\dp[i-1][1],\quad -price[i]\ )} \tag{6} \\ &amp;(i \geq 1) \tag{}\end{align}\]</span>　　我们把通用的初始化代码（1）结合“k==1”的情况调整一下，整合公式（5）和（6），得到如下的代码（2）：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 代码（2）</span><br><span class="hljs-comment">//// 空间复杂度为O(2*n)，时间复杂度O(n)</span><br><span class="hljs-type">int</span> dp[maxn][<span class="hljs-number">2</span>];<br>......<br><span class="hljs-comment">///// 初始化dp数组和对特例赋值</span><br><span class="hljs-comment">//  dp[0][0]=0, dp[0][1]=-INF, dp[1..n][0]= 0, dp[1..n][1]= -INF </span><br><span class="hljs-comment">//  整合一下，就是 ====&gt;  dp[0..n][0]=0, dp[0..n][1]= -INF （重要，是代码（3）初始化的理论基础）</span><br><span class="hljs-comment">// 下面的代码主要是为了吻合代码（1）。只要背下来了代码（1），就能推出下面的代码，其效果和上一行代码等效</span><br><span class="hljs-comment">// 建议同学们背下来代码（1），再根据6种题型来做初始化赋值的演变，这样以不变应万变    </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++)<br><span class="hljs-comment">//    for(int k=0; k&lt;=K; k++)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>; t&lt;=<span class="hljs-number">1</span>; t++)&#123;<br>            <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span> &amp;&amp; t==<span class="hljs-number">0</span>)       <span class="hljs-comment">// 初始化1  原来是 dp[0][k][0] = 0       (k=[0..K])</span><br>                dp[i][t]= <span class="hljs-number">0</span>;        <br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span> &amp;&amp; t==<span class="hljs-number">1</span>)  <span class="hljs-comment">// 初始化2  原来是 dp[0][k][1] = -INF    (k=[0..K])</span><br>                dp[i][t]= -INF;     <br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t==<span class="hljs-number">0</span>)          <span class="hljs-comment">// 初始化3  原来是 if (k==0 &amp;&amp; t==0) dp[i][0][0] = 0  </span><br>                dp[i][t]= <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span>                    <span class="hljs-comment">// 初始化4  原来是 if(t==1) dp[i][1] = -INF    (i=[1..n])</span><br>                dp[i][t]= -INF;            <br>        &#125;    <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;  <br>dp[i][<span class="hljs-number">0</span>]= <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + price[i] );<br>dp[i][<span class="hljs-number">1</span>]= <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], -price[i] );<br>&#125;<br></code></pre></td></tr></table></figure></p><p>　　代码（2）已经是最精简的代码了吗？其实不是！仔细分析可以看到，两个赋值等式右边的数组第一维全都是i-1。我们完全可以利用<spanclass="math inline">\(变量_新=f(变量_旧)\)</span>的方式来理解（回想一下“如何在不使用数组的前提下利用循环来递推斐波拉契数列？”问题的实现）。最精简的终极代码（3）如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 代码（3）这个代码够精简，够牛逼吧？如果没有前面的铺垫，这个代码是很难理解的！</span><br><span class="hljs-comment">//// 空间复杂度为O(1)，时间复杂度O(n)</span><br><span class="hljs-type">int</span> dp0= <span class="hljs-number">0</span>;     <span class="hljs-comment">// 理论基础见代码（2）第7行</span><br><span class="hljs-type">int</span> dp1= -INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;   <br>dp0= <span class="hljs-built_in">max</span>(dp0, dp1 + price[i] );<br>dp1= <span class="hljs-built_in">max</span>(dp1, -price[i] );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="kinf">1.5.2 k==INF</h3><p>　　如何理解k==INF在本题型中的含义呢？</p><p>　　k==INF　&lt;===&gt;　不限制交易次数　&lt;===&gt;　在思考递推方程时不必考虑k　&lt;===&gt;　可以去掉dp中k这个维度</p><p>　　所以，我们可以把公式（1）和（2）去掉k这个维度，整合成如下： <spanclass="math display">\[\begin{align}dp[i][0]&amp;=max(\ dp[i-1][0],\quad dp[i-1][1]+price[i]\ )\tag{7} \\dp[i][1]&amp;=max(\ dp[i-1][1],\quad dp[i-1][0]-price[i]\ ) \tag{8} \\&amp;(i \geq 1) \tag{}\end{align}\]</span>把通用的初始化代码（1）结合“不考虑k”进行整改，然后和公式（7）和（8），得到如下代码（4）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 代码（4）</span><br><span class="hljs-comment">//// 空间复杂度为O(2*n)，时间复杂度O(n)</span><br><span class="hljs-type">int</span> dp[maxn][<span class="hljs-number">2</span>];<br>......<br><span class="hljs-comment">///// 初始化dp数组和对特例赋值</span><br><span class="hljs-comment">//   和1.5.1节类似，都需要砍掉k这个维度，所以下面处理和代码（2）一样 ，省略</span><br><span class="hljs-comment">//  ...初始化赋值同代码（2）...</span><br>    <br><span class="hljs-comment">// 开始递推</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;  <br>dp[i][<span class="hljs-number">0</span>]= <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + price[i] );<br>dp[i][<span class="hljs-number">1</span>]= <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]-price[i] );<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，上面的代码（4）是可以简化的。简化掉第1维之后，代码（5）如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 代码（5）</span><br><span class="hljs-comment">//// 空间复杂度为O(1)，时间复杂度O(n)</span><br><span class="hljs-type">int</span> dp0= <span class="hljs-number">0</span>;     <span class="hljs-comment">// 理论基础见代码（2）第7行</span><br><span class="hljs-type">int</span> dp1= -INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>    <span class="hljs-type">int</span> dp0_old= dp0;<br>dp0= <span class="hljs-built_in">max</span>(dp0, dp1 + price[i] );<br>dp1= <span class="hljs-built_in">max</span>(dp1, dp0_old - price[i] ); <span class="hljs-comment">// dp0此时已经是新值了，根据代码（4）中for内容，我们需要的是旧值，只能定义一个dp0_old来临时存一下旧值了</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="k任意正整数">1.5.3 k==任意正整数</h3><p>　　一次交易由“买股票”和“卖股票”这两个环节构成，而且在卖出股票时是不允许当天马上就买股票的（根据题意），也就是说，1次完整的交易无论如何都会占据2天的选择。所以说，10天内不可能交易超过5次，n天内不可能交易超过n/2次。k是最大允许的交易次数，如果这个值超过n/2，也就意味着在n天实际上是不限交易次数了。所以当<spanclass="math inline">\(k \geqn/2\)</span>时，请用1.5.2节的方法来求解问题即可。本节主要讨论<spanclass="math inline">\(k&lt;=n/2\)</span>的情况。“k==2”属于“k==任意正整数”的一种情况。只要搞定了任意正整数，也就搞定了k==2。</p><p>　　因为<span class="math inline">\(k \in[2..n/2]\)</span>，更具有一般性，我们需要把公式（1）和（2）用代码直接实现出来。仔细观察这两个公式，因为两个公式右侧的dp值第1维都是i-1，所以我们需要从小到大来循环i；至于k的循环顺序，因为在填写第i面数据时，第i-1面的全部数据都已知，所以实际上k的循环顺序是“增序降序均可”。但如果对dp采用滚动数组的方式，压缩掉第1维的话，k就必须只能降序循环了（原理同01背包的滚动数组实现法）。大致代码如下代码（6）所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">////代码（6） k==任意整数</span><br><span class="hljs-type">int</span> dp[maxn][maxK][<span class="hljs-number">2</span>];<br><span class="hljs-comment">//初始化dp，直接照搬代码（1）到此处</span><br>......<br><br><span class="hljs-comment">// 开始递推</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=K;k&gt;=<span class="hljs-number">1</span>; k--)&#123;  <span class="hljs-comment">// 标准数组下增序降序都均可，滚动数组下k只能降序填写       </span><br><span class="hljs-comment">//  for(int k=1;k&lt;=K; k++) </span><br>        dp[i][k][<span class="hljs-number">0</span>]= <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>]   + price[i] );<br>        dp[i][k][<span class="hljs-number">1</span>]= <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][k<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - price[i] );        <br>    &#125;<br><br></code></pre></td></tr></table></figure><h3id="k_inf-且-冷却期_卖-rightarrow-买_2天冷却期_买-rightarrow-卖1天">1.5.4k_==INF　且　<span class="math inline">\(冷却期_{卖 \Rightarrow买}_==2\)</span>天，<span class="math inline">\(冷却期_{买 \Rightarrow卖}==1\)</span>天</h3><p>　　k==INF并不难搞，之前1.5.2节已经对这种情况做过处理了，仅需要直接无视掉第二维，让dp数组只含两维即可。本题型的难点是“冷却期==2天”。这里需要先科普一下“冷却期”的概念。</p><ul><li>冷却期==0：卖掉股票之后，当天马上就可以再买股票，即<spanclass="math inline">\(冷却期_{卖 \Rightarrow 买}=0\)</span>；</li><li>冷却期==1：当天卖掉股票之后，第2天（明天）才能再买股票，即<spanclass="math inline">\(冷却期_{卖 \Rightarrow 买}=1\)</span>；</li><li><strong>冷却期==2：当天卖掉股票之后，第3天（后天）才能再买股票，即<spanclass="math inline">\(冷却期_{卖 \Rightarrow买}=2\)</span>，这是本节讨论的对象</strong>；</li></ul><p>　　本题属于最后这种。在本题中，“卖出”操作的冷却期，即“卖出后再买入所需的最少时间间隔”，比较特殊地定为了2天。至于“买入”操作的冷却期，和1.5.1～3一样，仍然是1天，即<spanclass="math inline">\(冷却期_{买\Rightarrow卖}=1\)</span>。下面分别讨论两种状态的转移：</p><p>　　1.第i天末如果只持有现金（状态为dp[i][0]），该如何做才能达成这样的状态呢？有如下两种可能的转移来源：</p><p>　　1）第一种情况是：在第i天当天卖掉了手里的那1手股票，在第i天末时的现金价值为dp[i-1][1]+price[i]（在第i天卖出1手股票必然惠造成现金增多了price[i]）；</p><p>　　2）第二种情况是：在第i-1天末就已经只持有现金，且在第i天什么都没做，现金价值为dp[i-1][0]。</p><p>　　最终决策是在情况1）和情况2）种选择最大的那种，来作为最优决策。转移方程如下：<span class="math display">\[dp[i][0]=max(\ dp[i-1][0],\quad dp[i-1][1]+price[i]\ ) \tag{9}\]</span>　　2.第i天末如果要持有1手股票（状态为dp[i][1]），如何得来的呢？有如下两种可能的转移来源：</p><p>　　1）第一种情况是：在第i天当天购买了1手股票（根据“冷却期”的概念描述，要想能在第i天买入股票，需要第i-2天末一定是持有现金状态，且第i-1天没有买入），所以在第i天末时的现金价值为dp[i-2][0]-price[i]（在第i天买入1手股票必然惠造成现金减少了price[i]）；</p><p>　　2）第二种情况是：在第i-1天末就已经持有了一手股票，且在第i天什么都没做，现金价值为dp[i-1][1]。</p><p>　　最终决策是在情况1）和情况2）种选择最大的那种，来作为最优决策。转移方程如下：<span class="math display">\[dp[i][1]=max(\ dp[i-1][1],\quad dp[i-2][0]-price[i]\ ) \tag{10}\]</span>　　<strong>综合公式（9）和（10），就是1.5.4节这种情况的两个状态转移方程。它给我们指出了当<spanclass="math inline">\(冷却期_{卖 \Rightarrow 买}\)</span>和<spanclass="math inline">\(冷却期_{买 \Rightarrow卖}\)</span>分别为不同的其他值时该如何分析处理。</strong>因为都是砍掉k这个维度，所以在针对公式（9）和（10）进行编码时，“初始化dp数组”的代码和代码（2）中“初始化dp数组”的代码完全一致即可。具体代码这里就不展示了，没什么难度。</p><p>　　仔细的同学可以看到，在公式（9）和（10）中实际上只涉及到了[i-1]和[i-2]，当n的规模很大，担心MLE的同学可以定义一个变量dppre0来存储和管理不断变化的dp[i-2][0]值，并对公式（9）和（10）做滚动化压缩处理。dp[i][]为当前值（分别对应代码中赋值号左侧的dp0和dp1），dp[i-1][]为旧值（分别对应代码中赋值号右侧的dp0和dp1）,dp[i-2][0]为更旧的值（对应dppre2）。具体代码如下代码（7）所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">////代码（7） 冷却期=2天，滚动实现dp迭代</span><br><span class="hljs-type">int</span> dp0=<span class="hljs-number">0</span>, dp1= -price[<span class="hljs-number">1</span>], dppre2=<span class="hljs-number">0</span>; <span class="hljs-comment">// 第1天末只有现金时价值为0，买了股票后则价值为-value[1]，第0天只有现金0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123;<br>    <span class="hljs-type">int</span> tmp= dp0;               <span class="hljs-comment">// 把“旧值”暂存，避免执行下一行时被覆盖掉，等更替结束后，将其变成“更旧的值”</span><br>    dp0= <span class="hljs-built_in">max</span>(dp0, dp1 + price[i]);    <span class="hljs-comment">// 新值 &lt;===== f(旧值)，或者说，根据旧值计算出新值</span><br>    dp1= <span class="hljs-built_in">max</span>(dp1, dppre2 - price[i]); <span class="hljs-comment">// 这里需要的是更旧的值，即dppre2，</span><br>    dppre2= tmp;                <span class="hljs-comment">// 在做下一轮之前，先把&#x27;旧的dp0&#x27;变成 &#x27;更旧的dp0&#x27; </span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果冷却期是3天的话，那具体代码如下代码（8）所示，同学们可以了解一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">////代码（8） 冷却期=3天，滚动实现dp迭代</span><br><span class="hljs-type">int</span> dp0=<span class="hljs-number">0</span>, dp1= -INF; <span class="hljs-comment">// 理论基础见代码（2）和（5）中的初始化</span><br><span class="hljs-type">int</span> dppre3=<span class="hljs-number">0</span>;         <span class="hljs-comment">// dp[0..n][0] = 0 ，这里的dppre3、dppre2表示的都是dp[i-XXX][0]的值</span><br><span class="hljs-type">int</span> dppre2=<span class="hljs-number">0</span>; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>    <span class="hljs-type">int</span> tmp= dp0;               <span class="hljs-comment">// 把“旧值”暂存，避免执行下一行时被覆盖掉，等更替结束后，将其变成“更旧的值”</span><br>    dp0= <span class="hljs-built_in">max</span>(dp0, dp1 + price[i]);    <span class="hljs-comment">// 新值 &lt;===== f(旧值)，或者说，根据旧值计算出新值</span><br>    dp1= <span class="hljs-built_in">max</span>(dp1, dppre3 - price[i]); <span class="hljs-comment">// 这里需要的是更旧的值，即dppre3，</span><br>    dppre3= dppre2;             <span class="hljs-comment">// 在做下一轮之前，把&#x27;更旧的dp0&#x27;变成 &#x27;更更旧的dp0&#x27; </span><br>    dppre2= tmp;                <span class="hljs-comment">// 在做下一轮之前，把&#x27;旧的dp0&#x27;变成 &#x27;更旧的dp0&#x27; </span><br>&#125;<br></code></pre></td></tr></table></figure><p>　　对于更大的冷却期值，只需要按照代码（8）中第9、10行的模式继续写就行了。不过一般来说，股票交易也不可能有很大的冷却期，所以这一点基本上可以不去理会了。</p><h3 id="ｋinf-且-有交易手续费">1.5.5 ｋ==INF 且　有交易手续费</h3><p>　　每做一次交易要支付手续费，只要把手续费从利润中减去即可。这里要区分这个手续费是在买的过程中或是卖的过程中支付的。如果把买和卖合起来算一次交易，那么在二者任一过程中进行处理都行。需要注意的是，手续费始终属于支出的部分，不管在上下哪个式子里，都是要减掉的。</p><ol type="1"><li>如果是在 "买" 的环节中支付手续费，则改写方程如下：</li></ol><p><span class="math display">\[\begin{align}       dp[i][0] &amp;= max(\ dp[i-1][0], \quad dp[i-1][1] +prices[i]\ ) \\        dp[i][1] &amp;= max(\ dp[i-1][1], \quad dp[i-1][0] - prices[i] -fee\ ) \\\end{align}     \]</span></p><ol start="2" type="1"><li>如果是在 "卖" 的环节中支付手续费，则改写方程如下：</li></ol><p><span class="math display">\[\begin{align}       dp[i][0] &amp;= max(\ dp[i-1][0], \quad dp[i-1][1] +prices[i]- fee\ ) \\        dp[i][1] &amp;= max(\ dp[i-1][1], \quad dp[i-1][0] - prices[i] \) \\\end{align}\]</span></p><p>至于初始化的处理，和上述其他几种情况类似，这里不再赘述。</p><h1 id="二实战练习">二、实战练习</h1><h2 id="acwing1054交易1次">2.1 Acwing1054（交易1次）</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<ahref="https://www.acwing.com/problem/content/1056/">1054.股票买卖</a></p><h3 id="ac代码">2.1.2 AC代码</h3><h4 id="标准三维dp未简化i和k">2.1.2.1 标准三维dp，未简化i和k</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// /// 方法1： 标准DP，三维，未简化i和k</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">股票买卖线性DP的第1个题，</span><br><span class="hljs-comment">“只能进行一次买卖交易，&#x27;买入&#x27;为新的一次交易开始”</span><br><span class="hljs-comment">Acwing1054～1059</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> K = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> dp[maxn][K+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]; <span class="hljs-comment">// 注意，第二维是K+1，交易次数从1开始编号，若定义为[K]，下标无法从1开始。</span><br><span class="hljs-type">int</span> n, pri[maxn];<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>cin &gt;&gt;n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) cin &gt;&gt;pri[i];<br><br><span class="hljs-comment">// 初始化dp的0值，i的范围是[0..n]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++)<br>dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -INF;<br><span class="hljs-comment">// 初始化dp的-INF值，k的范围是[0..K]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;=K; k++)<br>dp[<span class="hljs-number">0</span>][k][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, dp[<span class="hljs-number">0</span>][k][<span class="hljs-number">1</span>] = -INF;<br><br><span class="hljs-comment">// 模板套上去，注意i和k都是从1开始</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=K; k++)&#123;<br>dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>] + pri[i] );                     <br>dp[i][k][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][k<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - pri[i] );<br>&#125;<br><br>cout &lt;&lt;dp[n][K][<span class="hljs-number">0</span>];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                                                                               <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="简化版本不定义dp数组">2.1.2.2 简化版本，不定义dp数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// /// 方法2： 简化DP，无需定义数组。 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">股票买卖线性DP的第一个题，</span><br><span class="hljs-comment">“只能进行一次买卖交易，&#x27;买入&#x27;为新的一次交易开始”</span><br><span class="hljs-comment">  其实没必要写成简化模式，记住通杀模板不是更香么？还能根据通杀模板推导出简化模式 </span><br><span class="hljs-comment">Acwing1054～1059</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> dp0, dp1;<br><span class="hljs-type">int</span> n, pri[maxn];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>cin &gt;&gt;n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) cin &gt;&gt;pri[i];<br><br><span class="hljs-comment">// 初始化dp0 和 dp1</span><br>dp0 = <span class="hljs-number">0</span>, dp1 = -INF;<br><span class="hljs-comment">// 模板套上去，注意i和k都是从1开始</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>dp0 = <span class="hljs-built_in">max</span>(dp0, dp1 + pri[i] );<br><span class="hljs-comment">//dp1 = max(dp1, dp0 - pri[i] );    </span><br><span class="hljs-comment">// 注意，这里不能这么搞，否则答案为7，无法AC，因为这里准确的说是需要dp[i-1][k-1][0]，而并非dp[i-1][k][0]</span><br>dp1 = <span class="hljs-built_in">max</span>(dp1,  - pri[i] );<br>&#125;<br>cout &lt;&lt;dp0;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="acwing1055交易无限次">2.2 Acwing1055（交易无限次）</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　<ahref="https://www.acwing.com/problem/content/1057/">1055股票买卖II</a></p><h3 id="ac代码-1">2.2.2 AC代码</h3><h4 id="二维dp数组简化了k">2.2.2.1 二维dp数组，简化了k</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// /// 方法1： 标准DP，三维简化为二维，未简化i</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">股票买卖线性DP的第2个题，</span><br><span class="hljs-comment">“能进行无限次买卖交易，&#x27;买入&#x27;为新的一次交易开始”</span><br><span class="hljs-comment">Acwing1054～1059</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> K = INF;<br><span class="hljs-type">int</span> dp[maxn][<span class="hljs-number">2</span>]; <span class="hljs-comment">//  k为正无穷，那么对交易次数的限制就已经丧失了实用意义。所以第二维省略，只剩第一维和第三维 </span><br><span class="hljs-type">int</span> n, pri[maxn];<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>cin &gt;&gt;n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) cin &gt;&gt;pri[i];<br><br><span class="hljs-comment">// 初始化dp的0值，i的范围是[0..n]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++)<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, dp[i][<span class="hljs-number">1</span>] = -INF;<br><br><span class="hljs-comment">// 模板套上去，注意i和k都是从1开始</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + pri[i] );<br>dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - pri[i] );<br>&#125;<br>cout &lt;&lt;dp[n][<span class="hljs-number">0</span>];<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="无需定义dp数组">2.2.2.2 无需定义dp数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/// /// 方法2： 简化DP，无需定义数组。 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">股票买卖线性DP的第2个题，</span><br><span class="hljs-comment">“能进行无限次买卖交易，&#x27;买入&#x27;为新的一次交易开始”</span><br><span class="hljs-comment">    其实没必要写成简化模式，记住通杀模板不是更香么？还能根据通杀模板推导出简化模式 </span><br><span class="hljs-comment">Acwing1054～1059</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> K = INF;<br><span class="hljs-type">int</span> dp0, dp1; <span class="hljs-comment">//  k为正无穷，那么对交易次数的限制就已经丧失了实用意义。所以第二维省略，只剩第一维和第三维 </span><br><span class="hljs-type">int</span> n, pri[maxn];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>cin &gt;&gt;n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) cin &gt;&gt;pri[i];<br><br><span class="hljs-comment">// 初始化dp0 和 dp1</span><br>dp0 = <span class="hljs-number">0</span>, dp1 = -INF;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>dp0 = <span class="hljs-built_in">max</span>(dp0, dp1 + pri[i] );<br>dp1 = <span class="hljs-built_in">max</span>(dp1, dp0- pri[i] );   <span class="hljs-comment">// 此处dp0不能省了，因为要反复迭代dp0了 </span><br>&#125;<br>cout &lt;&lt;dp0;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间dp(环)模型</title>
      <link href="/2024/07/31/%E5%8C%BA%E9%97%B4dp(%E7%8E%AF)%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/07/31/%E5%8C%BA%E9%97%B4dp(%E7%8E%AF)%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="模型说明">1.1 模型说明</h2><p>　　现在有N个数据依次排成<strong>一个圈</strong>，<strong>不允许移动</strong>（即有序），<strong>首尾连接</strong>。现在要对这N个数据进行合并，要求只能合并相邻的两个数据，合并后的数据可以参与下一次合并。现在给定每次数据合并产生的代价，求将所有数据合并成一个数所产生的最小代价/最大代价。这个模型和“区间dp(环)模型”的唯一区别就是“本模型的数据是一个环，首尾元素是相邻的，可以合并”。</p><p>　　<a href="https://www.luogu.com.cn/problem/P1880">P1880 [NOI1995]石子合并</a>是区间dp（环）的标准模板题型。理论上来说，也可以要求每次只能选择相邻的三堆数据。</p><h2 id="分析">1.2 分析</h2><p>　　环路数据合并，可以有两种方法来实现，下面分别进行讲述。</p><h3 id="方法1-割环为链拓展各个数组时间on3空间o4n2重点掌握">2.1.1 方法1割环为链，拓展各个数组（时间<spanclass="math inline">\(O(n^3)\)</span>，空间<spanclass="math inline">\(O(4n^2)\)</span>，重点掌握）</h3><p>　　由环转链，是解决环形区间dp较常用的一种方法。对于n个点，n条边构成的环路来说，每次对当前环路任意位置上相邻的两个点进行合并时，都会消除1个点和1条边，直到最后剩下1个点为止。也就是说，任何合并方案都需要对n个点、n条边的环路做n-1次合并即可。这样看来，必然会存在1条边是用不上的，多余的。换句话说，就算把多余的这1条边删掉，断环为链，也不影响这套合并方案的实施。但问题是我们并不知道哪一条边是多余的。既然如此，就干脆把该环路所有能够产生的链都去枚举处理一遍，然后比较得出最优解即可。那应该如何去“把所有的链都枚举一遍”呢？有一个简单的做法就是：<strong>对于由1-2-3-4-5组成的环路，我们可以将数据延展为：123451234</strong> 。也就是将长度为 n 的环变成了长度为 2n−1的链。那么最优解就在 12345、 23451、 34512、 45123和 51234中。以求最小值为例，那么就有<span class="math inline">\(dp(1,5)_环=min(\dp(1,5)_链,\quad  dp(2,6)_链,\quad dp(3,7)_链,\quad dp(4,8)_链,\quaddp(5,9)_链\ )\)</span>。</p><p>　　将数据拓展翻1倍之后，各个数组的维度长度都需要翻1倍。另外在初始化赋值时，更要小心处理。原始数组需要翻1倍，dp二维数组需要延展1倍，初始化时的对角线也需要延展。另外，关于两个区间进行合并的成本开销，即区间内所有数据之和，在链模型中是采用前缀和的方法来快捷算出的；在割环为链之后，其实这个方法仍然是可行的，但前缀和数组同样需要拓展一倍长度。</p><p>　　本方法虽然空间复杂度稍微较大，但后期可以采用平行四边形优化法，对时间复杂度进行优化，以适应更大的数据量处理。建议同学们重点掌握。</p><h3 id="方法2-利用取余来实现环不拓展数组时间on3空间on2">2.1.2 方法2利用取余来实现环，不拓展数组（时间<spanclass="math inline">\(O(n^3)\)</span>，空间<spanclass="math inline">\(O(n^2)\)</span>）</h3><p>　　在不拓展数组的情况下，如果区间右端点超过了数组的上限，则自动调整到下标0的位置上。对于方法2，因为涉及到取余，强烈建议所有数组都从下标0开始编号和存储数据，以便于代码书写。</p><p>　　需要提醒同学们注意的是，本来对区间（链）dp的填写有“for le, forri”和“for len, forle”这两种写法。在区间（环）的情况下如果不拓展数据，那么<spanclass="math inline">\(le \leq ri\)</span>的这个条件不再肯定成立，<spanclass="math inline">\(k+1\)</span>也不一定肯定会大于k，这会对dp数组的填写顺序造成较大的困扰，增添代码实现难度。所以，<strong>强烈建议如果要采用方法2来做，请最好是用“forlen, forle”的写法</strong>。虽然也会涉及到取余，但写起来相对容易一些。下面是参考的局部代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法2强烈建议用len和le来做循环变量，</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> le=<span class="hljs-number">0</span>; le&lt;n; le++ ) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ri=<span class="hljs-number">0</span>; le &lt;= n<span class="hljs-number">-1</span>; ++le) &#123;<br>        <span class="hljs-type">int</span> ri = le + len - <span class="hljs-number">1</span>;     <span class="hljs-comment">//先暂时不管越界，毕竟没在[]里</span><br>        <span class="hljs-comment">// 老老实实算区间和，用前缀和数组更难处理</span><br>        <span class="hljs-type">int</span> cost=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=le; k&lt;=ri; k++)  <span class="hljs-comment">// k在[]里，可能为ri，需要取余，否则k越界</span><br>            cost += data[k%n];     <span class="hljs-comment">// 因为下标从0开始存储基本数据，无法用前缀和，否则i-1为负数了</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=le; k &lt;= ri<span class="hljs-number">-1</span>; ++k) &#123; <span class="hljs-comment">//决策c</span><br>            <span class="hljs-comment">// 最大值和最小值都列举给同学们看看，注意 k、k+1 和 ri 都有可能数组越界，需要绕回来，取余%</span><br>            dpmin[le][ri%n] = <span class="hljs-built_in">min</span>(dpmin[le][ri%n], dpmin[le][k%n] + dpmin[(k+<span class="hljs-number">1</span>)%n][ri%n] + cost);<br>            dpmax[le][ri%n] = <span class="hljs-built_in">max</span>(dpmax[le][ri%n], dpmax[le][k%n] + dpmax[(k+<span class="hljs-number">1</span>)%n][ri%n] + cost);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　方法2的空间复杂度较小，但代码理解起来稍微困难，取余容易出错，且后期使用平行四边形优化法更为困难，所以建议会写即可。</p><h1 id="二实战训练">二、实战训练</h1><h2 id="p1880-石子合并">2.1 P1880 石子合并</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P1880">P1880 [NOI1995]石子合并</a></p><h3 id="分析-1">2.1.2 分析</h3><p>　　这是一个区间（环）dp的裸题，<spanclass="math inline">\(n\leq1e2\)</span>，不管是采用方法1或者方法2，<spanclass="math inline">\(n^3=1e6 \leq1e7\)</span>，不采用任何优化也能直接AC。cost数组就是区间内的数据之和。</p><h3 id="ac代码">2.1.3 AC代码</h3><h4 id="割环为链不优化">2.1.3.1 割环为链，不优化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法1：区间（环）dp，数组翻倍处理，割环为链，无任何优化 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 102</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NN 2*N</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">区间dp，数据首尾链接成环，求最小值和最大值。</span><br><span class="hljs-comment">需要割环为链，设置2倍的数组空间， </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-type">int</span> data[NN];<br><span class="hljs-type">int</span> dpmin[NN][NN];<br><span class="hljs-type">int</span> dpmax[NN][NN];<br><span class="hljs-type">int</span> sum[NN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i, le, ri, k, n, nn;<br><span class="hljs-built_in">memset</span>(dpmin, INF, <span class="hljs-built_in">sizeof</span>(dpmin));  <span class="hljs-comment">//初值设定为极大值</span><br><span class="hljs-built_in">memset</span>(dpmax, -INF  , <span class="hljs-built_in">sizeof</span>(dpmax));   <span class="hljs-comment">//初值设定为-INF</span><br>cin &gt;&gt;n;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data[i]);<br>data[i+n] = data[i];<br>&#125;<br>nn = <span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=nn;++i)&#123;<br>dpmin[i][i] = <span class="hljs-number">0</span>;<br>dpmax[i][i] = <span class="hljs-number">0</span>;<br>sum[i] = sum[i<span class="hljs-number">-1</span>] + data[i]; <br>&#125;<br><span class="hljs-keyword">for</span>( le=nn; le&gt;=<span class="hljs-number">1</span>; --le ) <br><span class="hljs-keyword">for</span>( ri=le+<span class="hljs-number">1</span>; ri &lt;= nn; ++ri)&#123;<br><span class="hljs-type">int</span> cost= sum[ri] - sum[le<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span>( k=le; k &lt;= ri<span class="hljs-number">-1</span>; ++k)&#123; <span class="hljs-comment">//决策：从哪一个转移过来</span><br>dpmin[le][ri] = <span class="hljs-built_in">min</span>(dpmin[le][ri], dpmin[le][k] + dpmin[k+<span class="hljs-number">1</span>][ri] + cost);<br>    dpmax[le][ri] = <span class="hljs-built_in">max</span>(dpmax[le][ri], dpmax[le][k] + dpmax[k+<span class="hljs-number">1</span>][ri] + cost);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 注意，答案并不存于dpmin[1][nn]。要求左右之间一定是宽度为n的区间</span><br><span class="hljs-comment">// 例如dpmin[1][n], 或者dpmin[2][n+1]、 dpmin[3][n+2]……dpmin[n][2*n-1]等中的最小值 </span><br><span class="hljs-type">int</span> mymin = INF;<br><span class="hljs-type">int</span> mymax = -INF;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; ++i)&#123;<br>       mymin = <span class="hljs-built_in">min</span> ( mymin , dpmin[i][i+n<span class="hljs-number">-1</span>] ) ;<br>   mymax = <span class="hljs-built_in">max</span> ( mymax , dpmax[i][i+n<span class="hljs-number">-1</span>] ) ;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, mymin);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, mymax);<br><br><span class="hljs-comment">//    for(int j=0; j&lt;= nn; j++)</span><br><span class="hljs-comment">//        printf(&quot;%8d&quot;, j);</span><br><span class="hljs-comment">//    printf(&quot;\n&quot;);</span><br><span class="hljs-comment">//for(int i=0; i&lt;=nn; i++)&#123; </span><br><span class="hljs-comment">//   for(int j=0; j&lt;= nn; j++)</span><br><span class="hljs-comment">//       if (dpmax[i][j] &lt; -10000)</span><br><span class="hljs-comment">//           printf(&quot;    -INF&quot;);</span><br><span class="hljs-comment">//        else</span><br><span class="hljs-comment">//           printf(&quot;%8d&quot;, dpmax[i][j]);</span><br><span class="hljs-comment">//    printf(&quot;\n&quot;);</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="不延展数组循环取余硬干">2.1.3.2 不延展数组，循环取余硬干</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法2：区间环dp + 不延长数组</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 102</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">区间dp，数据首尾链接成环，求最小值和最大值。</span><br><span class="hljs-comment">需要割环为链，设置2倍的数组空间， </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-type">int</span> data[N];<br><span class="hljs-type">int</span> dpmin[N][N];<br><span class="hljs-type">int</span> dpmax[N][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i, le, ri, k, n;<br><span class="hljs-built_in">memset</span>(dpmin, INF, <span class="hljs-built_in">sizeof</span>(dpmin));  <span class="hljs-comment">//初值设定为   INF</span><br><span class="hljs-built_in">memset</span>(dpmax, -INF  , <span class="hljs-built_in">sizeof</span>(dpmax));   <span class="hljs-comment">//初值设定为  -INF</span><br>cin &gt;&gt;n;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data[i]);<br>dpmin[i][i] = <span class="hljs-number">0</span>;<br>dpmax[i][i] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 假设n=10，下标分别为0..9 </span><br><span class="hljs-comment">// len=2  0..1  1..2  ...   8..9   9..0 </span><br><span class="hljs-comment">// len=4  0..3  1..4  ...   8..1   9..2 </span><br><span class="hljs-comment">// len=10 0..9  1..0  ...   8..7   9..8  </span><br><span class="hljs-comment">// 可以用len和le来循环 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> le=<span class="hljs-number">0</span>; le&lt;n; le++ )&#123; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ri=<span class="hljs-number">0</span>; le &lt;= n<span class="hljs-number">-1</span>; ++le)&#123;<br><span class="hljs-type">int</span> ri = le + len - <span class="hljs-number">1</span>;     <span class="hljs-comment">// 先暂时不管越界，毕竟没在[]里</span><br><span class="hljs-comment">// 老老实实算区间和，用前缀和数组更难处理 </span><br><span class="hljs-type">int</span> cost=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=le; k&lt;=ri; k++)  <span class="hljs-comment">// k在[]里，可能为ri，需要取余，否则k越界</span><br>    cost += data[k%n];     <span class="hljs-comment">// 因为下标从0开始存储基本数据，无法用前缀和，否则i-1为负数了</span><br>    <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=le; k &lt;= ri<span class="hljs-number">-1</span>; ++k)&#123; <span class="hljs-comment">//决策</span><br><span class="hljs-comment">// 最大值和最小值都列举给同学们看看，注意 k、k+1 和 ri 都有可能数组越界，需要绕回来，取余%</span><br>dpmin[le][ri%n] = <span class="hljs-built_in">min</span>(dpmin[le][ri%n], dpmin[le][k%n] + dpmin[(k+<span class="hljs-number">1</span>)%n][ri%n] + cost);<br>    dpmax[le][ri%n] = <span class="hljs-built_in">max</span>(dpmax[le][ri%n], dpmax[le][k%n] + dpmax[(k+<span class="hljs-number">1</span>)%n][ri%n] + cost);<br>    &#125;<br><span class="hljs-comment">//    printf(&quot;(%d,%d)-%2d-%2d &quot;, le, ri%n, dpmin[le][ri%n], dpmax[le][ri%n] );</span><br>&#125;<br><span class="hljs-comment">//printf(&quot;\n&quot;);</span><br>&#125;<br><span class="hljs-comment">// 注意，答案并不存于dpmin[1][nn]。要求左右之间一定是宽度为n的区间</span><br><span class="hljs-comment">// 例如dpmin[1][n], 或者dpmin[2][n+1]、 dpmin[3][n+2]……dpmin[n][2*n-1]等中的最小值 </span><br><span class="hljs-type">int</span> mymin = INF;<br><span class="hljs-type">int</span> mymax = -INF;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; ++i)&#123;<br>       mymin = <span class="hljs-built_in">min</span> ( mymin , dpmin[i][(i+n<span class="hljs-number">-1</span>)%n] ) ;    <span class="hljs-comment">// 注意要取余 </span><br>   mymax = <span class="hljs-built_in">max</span> ( mymax , dpmax[i][(i+n<span class="hljs-number">-1</span>)%n] ) ;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, mymin);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, mymax);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p1063-能量项链">2.2 P1063 能量项链</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P1063">P1063 [NOIP2006提高组] 能量项链</a></p><h3 id="分析-2">2.2.2 分析</h3><p>　　N个能量珠串成一串，相邻的珠子可以进行合并，旧珠消失，产生新珠，释放能量，求如何选择合并，使得释放的总能量最大。这是个比较明显的区间（环）DP问题。本来没什么难度，但题目中加了一个要素，就是“每个珠子有头标记和尾标记”，合并后的释放能量为<spanclass="math inline">\(m*r*n\)</span>。这个值得我们仔细研究一下，也就是cost[le][ri]=？</p><p>　　现在假设有两个相邻的能量珠（不管是原始的，或者是合并后产生的），珠1是第[le..c]个珠子合并后产生的能量珠，其头标记为m（必然是第le个珠子的头标记值），尾标记为r（必然是第c个珠子的尾标记值，同时根据“珠子相邻衔接”的基本定义，该值也是第c+1个珠子的头标记值）；珠2是第[c+1..ri]个珠子合并后产生的能量珠，其头标记为r（只可能是r，同学们可以想想为什么？然后在纸上画一画看看），尾标记为n（必然是第ri个珠子的尾标记）。那么两个珠子进行合并释放的能量就是：<span class="math display">\[\begin{align}&amp;\quad\ 第[le..c]个珠子合并后的珠子\ 与\第[c+1..ri]个珠子合并后的珠子\ 进行合并产生的能量\\&amp;=m \times r\times n\\ &amp;=第\ le\ 个珠子的头标记值m\ ×\ 第\ c\ 个珠子的尾标记值r\×\ 第\ ri\ 个珠子的尾标记值n\end{align}\]</span>　　剩下的可能的坑点就是结构体数据的录入和数组拓展部分结构体数据的复制了。需要的是同学们的仔细，在纸上画结构体数组的样例结果，然后小心调试。</p><h3 id="ac代码-1">2.2.3 AC代码</h3><p>　　本题以“断环为链”的方法来实现，其他方法请同学们自行研究。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100      </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NN 2*N+5</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">这个题，2个区间合并时，涉及到了3个数，比较麻烦，还是设定每个区间有ll和rr两个数，</span><br><span class="hljs-comment">这样比较容易控制区间编号，不至于造成混乱。 </span><br><span class="hljs-comment">    注意割环为链之后，长度从n变成了2n-1，所有数组都需要延展长度，并且第二层循环left</span><br><span class="hljs-comment">需要以右端不越界为截止点。 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> ll, rr;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> data[NN];<br><span class="hljs-type">int</span> dp[NN][NN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i, len, left, rt, k, n;<br>cin &gt;&gt;n;<br><span class="hljs-comment">//     0     1    2    3       4  |   5    6    7      8</span><br><span class="hljs-comment">//           2    3    5      10  |   2    3    5</span><br><span class="hljs-comment">//    /0   2/3   3/5  5/10   10/2 |  2/3  3/5  5/10  10/ </span><br><span class="hljs-comment">// 处理基本的data数据 </span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data[<span class="hljs-number">1</span>].ll);  <span class="hljs-comment">// 第一个数据单独处理，以便首尾衔接 </span><br>    data[n].rr= data[<span class="hljs-number">1</span>].ll; <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data[i].ll);<br>        data[i<span class="hljs-number">-1</span>].rr = data[i].ll;<br>    &#125;<br>    <span class="hljs-comment">// 处理延展部分的data数据 </span><br>    <span class="hljs-keyword">for</span>(i=n+<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>; i++)&#123;<br>        data[i].ll = data[i-n].ll;<br>        data[i].rr = data[i-n].rr;<br>    &#125;<br>    <span class="hljs-comment">// 初始化和特例处理 </span><br>    <span class="hljs-built_in">memset</span>(dp, -INF, <span class="hljs-built_in">sizeof</span>(dp)); <span class="hljs-comment">// 本例中无负数，初始化为0在本例中也是可以的 </span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>; i++)&#123;<br>        dp[i][i] = <span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-keyword">for</span>(len = <span class="hljs-number">2</span>; len&lt;=n; len++)<br><span class="hljs-comment">// 截止位置的条件是 区间右端下标不能超过2*n-1 </span><br><span class="hljs-keyword">for</span>(left=<span class="hljs-number">1</span>; left+len<span class="hljs-number">-1</span>&lt;=<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>; left++)&#123;<br>rt = left+len<span class="hljs-number">-1</span>;<br><span class="hljs-comment">// k的取值范围不变 </span><br><span class="hljs-keyword">for</span>(k=left; k&lt;=rt<span class="hljs-number">-1</span>; k++)<br><span class="hljs-comment">// 用data[k].rr 去乘，才能衔接得上 </span><br>dp[left][rt] = <span class="hljs-built_in">max</span> (dp[left][rt] , dp[left][k] + dp[k+<span class="hljs-number">1</span>][rt] + data[left].ll*data[k].rr*data[rt].rr );<br>&#125;<br><br><span class="hljs-comment">// 注意跨度值，跨度为n的区间，如果左端是i的话，那么右端应该是i+n-1 </span><br><span class="hljs-type">int</span> ans= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>ans = <span class="hljs-built_in">max</span>(ans, dp[i][i+n<span class="hljs-number">-1</span>]);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 区间dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间dp(链)模型</title>
      <link href="/2024/07/31/%E5%8C%BA%E9%97%B4dp(%E9%93%BE)%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/07/31/%E5%8C%BA%E9%97%B4dp(%E9%93%BE)%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="模型说明">1.1 模型说明</h2><p>　　现在有N个数据依次排成一条线，不允许移动（即有序），首尾不连接。现在要对这N个数据进行合并，要求只能合并相邻的两个数据，合并后的数据可以参与下一次合并。现在给定每次数据合并产生的代价，求将所有数据合并成一个数所产生的最小代价/最大代价。</p><p>　　<strong><ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1274">1274：【例9.18】合并石子</a></strong>是区间dp的标准模板题型。理论上来说，也可以要求每次只能选择相邻的三堆数据。</p><h2 id="分析">1.2 分析</h2><p>　　如果N个数据是无序的，允许任意选择数据来合并的话，整个过程就变成了<ahref="https://www.luogu.com.cn/problem/P1090">P1090 [NOIP2004 提高组]合并果子 / [USACO06NOV] Fence RepairG</a>这种二叉或者K叉哈夫曼树问题，用贪心的思想来解决问题即可。但当前题型要求不能任意选择数据，每次合并只能选择<strong>相邻</strong>的两个数据进行合并。“合并相邻数据”，这是区间dp的一个很典型的特征。下面介绍区间dp的做法（以求最小值为例）。</p><ol type="1"><li><p>状态数组定义</p><p>　　dp[le][ri]表示将编号从le到ri的这个区间内所有数据进行合并所需的最小代价。</p></li><li><p>所求目标</p><p>　　dp[1][n]表示将编号从1到n的这个区间内所有数据进行合并所需的最小代价。</p></li><li><p>状态转移方程</p><p>　　对于这种稍微复杂点的问题，同学们最好是举个例子来分析，拿出你的草稿纸和笔！</p><p>根据状态数据的基本定义，我们可以得到如下： <spanclass="math display">\[dp[1][5]=min\begin{cases} dp\textcolor{red}{[1][1]}+dp[2][5] +\quad合并[1..1]和[2..5]所需代价\\ dp[1][2]+dp[3][5]  +\quad合并[1..1]和[2..5]所需代价\\ dp[1][3]+dp[4][5]  +\quad合并[1..1]和[2..5]所需代价\\ dp[1][4]+dp\textcolor{red}{[5][5]}  +\quad合并[1..1]和[2..5]所需代价\\ \end{cases} \tag{1}\]</span></p><p>　　我们把公式1进一步浓缩一下，得到如下的公式2： <spanclass="math display">\[dp[1][5]=min(dp[1][c]+dp[c+1][5]+\quad合并[1..c]和[c+1..5所需代价])\\(le \leq c \leq \textcolor{red}{ri-1}) \tag{2}\]</span> 　　再把公式2做一般性推广，得到公式3如下： <spanclass="math display">\[dp[le][ri]=min(dp[le][c]+dp[c+1][ri]+\quad合并[le..c]和[c+1..\ri]所需代价)\\(1 \leq le \leq ri\leq n,\quad le \leq c \leq \textcolor{red}{ri-1})\tag{3}\]</span>　　这就是区间dp的公式之一。这个公式有一个假设前提，那就是“假设对区间内的数据进行合并时，是“求和”的模式（注意，也可以求最大值/最小值等，到时候就不是两个dp[][]值相加，而是求max或者min了）”。具体的状态转移方程需要同学们根据实际情况灵活分析和处理，不要死记硬背公式3！</p><p>　　公式3是对多个数据进行比较求最小，在代码实现的时候可以采用<strong>累比</strong>的模式来实现，大致如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> le ... )  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ri ... ) <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c ...)<br>            dp[le][ri] = <span class="hljs-built_in">min</span>(dp[le][ri], dp[][]+dp[][] + 合并所需代价)　<br></code></pre></td></tr></table></figure></li><li><p>循环顺序和边界值</p><p>　　从公式3来进行分析，要求dp[le][ri]的值，就要求dp[le][c]和dp[c+1][ri]的值已知（即已填过），这样才能根据已知数据填写未知元素。根据dp[le][c]以及方程的要求"<spanclass="math inline">\(c \leqri-1\)</span>"可以看出，要求dp[le][ri]，就<strong>必须要知道当前网格<font color="red">左侧</font>的数据</strong>；根据dp[c+1][ri]以及方程的要求"<spanclass="math inline">\(le \leqc\)</span>"可以看出，要求dp[le][ri]，就<strong>必须要知道当前网格<font color="red">下方</font>的数据</strong>。综上所述，要根据当前网格左方和下方的数据来填写当前网格的数据。所以，我们的循环顺序应该是“从下往上，从左往右”或者“从左往右，从下往上”。鉴于绝大部分程序员都采用“逐行填写”的习惯，所以这里<strong>本帖推荐“从下往上，从左往右”的循环顺序</strong>。</p><p>　　关于循环边界，这里首先要注意一个事情，那就是公式3中有一个<spanclass="math inline">\(le\leqri\)</span>，也就是说，不允许出现dp[4][3]或者dp[8][2]这种情况。归纳一下三个循环变量的顺序和边界如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> le=n; le&gt;=<span class="hljs-number">1</span>; le--)       <span class="hljs-comment">// 从下往上</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ri=le; ri&lt;=n; ri++)  <span class="hljs-comment">// 从左往右</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=le; c&lt;= ri<span class="hljs-number">-1</span>; c++) <span class="hljs-comment">// 可增可减，公式1中的4排数据，从上往下min或者从下往上min，都不影响求最终的min值</span><br>            dp[le][ri] = <span class="hljs-built_in">min</span>(dp[le][ri], dp[][]+dp[][] + 合并所需代价)　<br></code></pre></td></tr></table></figure><p>　　从上面的代码可以看到，<strong>整个算法的时间复杂度是<spanclass="math inline">\(O(n^3)\)</span>的，不能处理<spanclass="math inline">\(n \geq200\)</span>的情况</strong>。</p><p>　　其实，除了上面这种最直接地枚举区间左右两端之外，还有第2种枚举方式，时间复杂度相同。对于[1,5]，它是由5个数据经过合并得到的，而它的子问题 [1 ,2] , [2 ,4]等，都是由长度为2~4的区间合并而成。要计算由 n 个数合并而成的区间 [a ,a+n−1]处理的最值dp时，我们要做的是先计算好由长度为 2 至 n−1 的区间[a ,a+c−1]。因为 c 一定小于 n，所以我们可以将区间的长度len作为第一维。只要知道len及left，就能够算出rt的位置。因为长区间都是由短区间的值计算而来，所以，如果短区间的值先计算出来，那么长区间的值的计算自然毫无障碍。大致代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 先计算短区间，然后计算长区间 ，最短长度是2（最少是2个数的合并）</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len= <span class="hljs-number">2</span>; len&lt;=n; len++)<br>    <span class="hljs-comment">// 枚举左端le值，增序降序都能AC</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> le=<span class="hljs-number">1</span>; le+len<span class="hljs-number">-1</span>&lt;=n; le++)&#123; <br>        <span class="hljs-comment">// 先处理区间[10..13]，或者先处理区间[1..4]都无所谓，相互不影响，正序逆序均可</span><br>        <span class="hljs-comment">//for(int le=n-len+1; le&gt;=1; le--)&#123;  // 正反序均可</span><br>        <span class="hljs-type">int</span> ri = le + len - <span class="hljs-number">1</span>;            <span class="hljs-comment">// 根据le和len来计算出ri</span><br>        <span class="hljs-comment">// 上面的双重for顺序无法适用于平行四边形优化</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=le; c&lt;=ri<span class="hljs-number">-1</span>; c++)<br>            dp[le][ri] = <span class="hljs-built_in">min</span>(dp[le][ri] , dp[le][c]+dp[c+<span class="hljs-number">1</span>][ri]+合并所需代价);<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>初始化和特例</p><p>整个dp数组的左下三角部分是不会被填写的，应该是“无解”，因为区间右端必须要大于等于区间左端。整个数组可以初始化为无解。</p><p>既然是要填写dp数组的右上部分，那特例肯定就不像以前那样在第0行或者在dp[0][0]了。同学们可以想一下，整个数组在三重循环时最先填写的是什么位置上的数据？它需要什么特例呢？可以稍微想一下就会知道，在数组的右下位置需要最先填写。主对角线位置是特例，因为dp[i][i]表示从自己到自己这个区间的合并收益，而从自己到自己是不需要合并的，合并收益为0。所以有如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">memset</span>(dp, -INF, <span class="hljs-built_in">sizeof</span>(dp));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++) dp[i][i]= <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li></ol><h1 id="二实战训练">二、实战训练</h1><h2 id="合并石子">2.1 1274 合并石子</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1274">1274：【例9.18】合并石子</a></p><h3 id="分析-1">2.1.2 分析</h3><p>　　裸的区间dp入门题，n个数据是有序的，任何区间进行合并的代价就是区间数据之和，对两个合并对象进行求和之后再加上该合并操作的额外代价即可。n=100，用裸模板的话，时间复杂度为1e6,可AC本题。本题也可以采用平行四边形优化，后面再说。</p><h3 id="ac代码">2.1.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法1：区间dp，链，朴素做法，没有用四边形优化。  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 101</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">区间动态规划， 链，求最小值，最朴素的版本，没有用四边形优化。 </span><br><span class="hljs-comment">本题中两个区间合并，是求和值，故用 &quot; + &quot; 来处理两个子区间的dp值 </span><br><span class="hljs-comment">本题用前缀和数组sum[] </span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> data[N], n;<br><span class="hljs-type">int</span> sum[N]; <br><span class="hljs-type">int</span> dp[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>cin &gt;&gt;n;<br><span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data[i]);<br>sum[i] = sum[i<span class="hljs-number">-1</span>] + data[i];    <span class="hljs-comment">// 用前缀和数组sum[]来快速记录 </span><br>dp[i][i] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> left=n; left&gt;=<span class="hljs-number">1</span>; left--)<br>    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> rt=left+<span class="hljs-number">1</span>; rt&lt;=n; rt++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=left; k&lt;=rt<span class="hljs-number">-1</span>; k++)      <span class="hljs-comment">// 普通做法 </span><br>                dp[left][rt] = <span class="hljs-built_in">min</span>(dp[left][rt] , dp[left][k] + dp[k+<span class="hljs-number">1</span>][rt] + sum[rt] - sum[left<span class="hljs-number">-1</span>] ) ;<br><br>cout &lt;&lt; dp[<span class="hljs-number">1</span>][n] &lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 区间dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间分段dp（“萝卜填坑”）模型</title>
      <link href="/2024/07/21/%E5%8C%BA%E9%97%B4%E5%88%86%E6%AE%B5dp%EF%BC%88%E2%80%9C%E8%90%9D%E5%8D%9C%E5%A1%AB%E5%9D%91%E2%80%9D%EF%BC%89%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/07/21/%E5%8C%BA%E9%97%B4%E5%88%86%E6%AE%B5dp%EF%BC%88%E2%80%9C%E8%90%9D%E5%8D%9C%E5%A1%AB%E5%9D%91%E2%80%9D%EF%BC%89%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="模型说明">1.1 模型说明</h2><p>　　现在有K个数据依次排成一条线，不允许移动。给定这一条线上任意两个位置之间（形成了一个区间）的收益值<spanclass="math inline">\(value[\ le\ ][\ ri\]\)</span>，现在需要将这K个数据的线分割成<span class="math inline">\(P(1\leq P \leqK)\)</span>段，求分割后的收益最大值/最小值（为了讲解方便，在第一章中我们统一用“最大值”）。</p><p>　　这种题型看上去有点像是区间DP，不过和正规的区间DP在dp数组定义、求解思路等方面都有一些差别。因为这种题型还是涉及到了“在区间中进行决策”，所以我们把它归于“区间DP”这个大类中来了。</p><h2 id="分析">1.2 分析</h2><p>　　因为我们需要将K个数据分割成N段，所以我们完全可以把这N段设置为N个阶段，这种划分满足“局部最优”和“无后效性”这两大特点，所以这种题型可以用dp这种大模型来搞定。</p><ol type="1"><li>状态数组定义</li></ol><p>　　我们用状态数组dp来存放最大收益值。既然如此，我们的dp数组的维度就要能够准确地描述出一个唯一的状态，或者说是一种划分。划分不仅和“数据”有关，也和划分的“段”有关。所以有如下的二维数组定义：</p><p>　　dp[p][k]：<strong>把前k个数据划分成p段后得到的最大收益值；</strong></p><ol start="2" type="1"><li><p>所求目标</p><p>dp[P][K]：把K个数据划分成P段后得到的最大收益值；</p></li><li><p>状态转移方程</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240721150540525.png" alt="image-20240721150540525" style="zoom:80%;" /><span class="math display">\[dp[p][k]= dp[p-1][c]\ \ \ + value[c+1][k] \tag{1}\]</span><font color="red"><strong>把前k个数据划分成p段的收益值　=　把前c个数据划分成p-1段的收益值　+　在从[c+1..k]这1段数据中获得的收益值（假设是求和值）</strong></font></p><p>上面的公式，只是一次划分或者一次“决策”。根据定义，还需要所有决策值比较，获得最大值。所以状态转移方程如下：<span class="math display">\[\begin{align}dp[p][k]=max(dp[p-1][c]+value[c+1][k]) \tag{2} \\(1 \leq p \leq P,\quad p \leq k \leq K,\quad p-1 \leq c \leq k-1 )\tag{}\end{align}\]</span></p><p>　　上面的公式（2）只是一个数学简式，并不是一个真正的C++代码。如果要转成代码，需要考虑max函数和循环的特点。伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[p][k]= -INF;  <span class="hljs-comment">// 初值设为负无穷，为“无解”状态的初始值， 以方便max运算出正确的结果</span><br><span class="hljs-keyword">for</span> (p)          <span class="hljs-comment">// 省略了部分代码</span><br>    <span class="hljs-keyword">for</span>(k)<br>        <span class="hljs-keyword">for</span>(c)<br>            dp[p][k]= <span class="hljs-built_in">max</span>(dp[p][k], dp[p<span class="hljs-number">-1</span>][c]+value[c+<span class="hljs-number">1</span>][k]);<br></code></pre></td></tr></table></figure><p>　　这里我们假设了整个划分方案的收益值是每个分段收益值之和，所以方程中出现了“dp<font color="red"><strong>+</strong></font>value”。这是一个假设，并不绝对。同学们不必死背公式，一定要理解着来推。</p></li><li><p>循环顺序和循环边界</p></li></ol><p>　　在公式（2）的状态转移方程中有3个变量，分别为p、k、c。第p行依赖于第p-1行，而c&lt;k。这里我们需要分析一下变量k和变量c的取值范围。</p><p>1）k：因为这种题型基本上都要求每段至少要有1个数据，所以要把k个数据划分成p段，必然要求<spanclass="math inline">\(k \geqp\)</span>，所以<strong>k的循环取值范围是[p..K]</strong>；对于状态[p][0..p-1]，一律视为“无解”的状态，赋予他们“无解”该有的初值即可。</p><p>2）c：<strong>决策点c值的循环取值范围是[p-1..k-1]</strong>，其详细推导过程如下，请展开阅读。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">假设现在有8个数据，需要分成3段。如果要求每段至少要有1个数据的话，划分结果只能是如下几种：<br>    1)　&#123;[1..1]、  [2..2（第3段的决策点c值）]、  [3..8]&#125;<br>    2)　&#123;[1..1]、  [2..3（第3段的决策点c值）]、  [4..8]&#125;<br>    3)　&#123;[1..2]、  [3..3（第3段的决策点c值）]、  [4..8]&#125;<br>          ......// 太多了，这里不全列出来了，<br>    *)　&#123;[1..4]、  [5..7（第3段的决策点c值）]、  [8..8]&#125;<br>    *)　&#123;[1..6]、  [7..7（第3段的决策点c值）]、  [8..8]&#125;<br>对于第2段的右端点（即划分第3段的决策点c值），只可能是2、3、4、5、6、7。<br>我们把上面的结果推广一下，如果有k个数据需要划分成p段，那么决策点c值的取值范围是[p-1..k-1]。记住这个结论。<br></code></pre></td></tr></table></figure><p>　　所以循环顺序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// P 个阶段，每个阶段划分出一段，必须增序</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p=<span class="hljs-number">1</span>; p&lt;=P; p++)             <span class="hljs-comment">// [1..P]</span><br>    <span class="hljs-comment">// 增序、降序均可，数据来源于上一行</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=p; k&lt;=K; k++)          <span class="hljs-comment">// [p..K]或者[K..p]</span><br>        <span class="hljs-comment">// 必须增序，从左往右填</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=p<span class="hljs-number">-1</span>; c&lt;=k<span class="hljs-number">-1</span>; c++)  <span class="hljs-comment">// [p-1..k-1]</span><br></code></pre></td></tr></table></figure><p>　　可以看出，这是一个时间复杂度为<spanclass="math inline">\(O(P*K^2)\)</span>的算法。</p><ol start="5" type="1"><li>初始化和特例</li></ol><p>　　整个dp[0..P][0..K]数组并不会全部被填写。循环没有遍历到的网格，必然就是不可能出现的状态（例如dp[10][3]，把3个数据划分成10段，这没法搞，直接“无解”），所以整个dp数组需要初始化成“无解”状态对应的值。</p><p>　　对于特例，</p><p>　　dp[0][0]表示把前0个数据划分成0段后得到的最大收益值；这里没有提供任何数据，要求0段（即不划分），很简单，什么都不做即为合理的做法，收益值为0.</p><p>　　dp[0][1]表示把前1个数据划分成0段后得到的最大收益值；把1个数据划分为0段，描述不合理，无法实现，无解，收益值为“无解”对应的取值INF。</p><p>　　从上面两条可以看出，特例只有<strong>dp[0][0]=0</strong>,而dp[0][1..K]则和其他行的数据一样，不是特例，应初始化为"无解"。</p><p>　　个别题可能会把dp[i][i]归于特殊情况，需要酌情考虑给予恰当的值。</p><h1 id="二实战训练">二、实战训练</h1><h2 id="p1281">2.1 1278/P1281</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1278">1278：【例9.22】复制书稿(book)</a>/<ahref="https://www.luogu.com.cn/problem/P1281">P1281 书的复制</a></p><h3 id="分析-1">2.1.2 分析</h3><p>　　要求把K本书分给P个人，每个人分到的书必须是连续的，这实际上就是一个“线性有序条件下的分段”的问题。每个分段内所需时间为该分段内每一本书所需时间之和，而整个划分方案的收益值为该方案中所有分段内部所需时间的最大值。现在要求整个方案的最小所耗时间。看上去有点像个min(max(sum()))的架构，挺吓人的，哈哈～</p><ol type="1"><li><p>状态数组定义</p><p>　　dp[p][k]：把前k本书划分给p段（每个人1段）后得到的最小时间值；</p></li><li><p>所求目标</p><p>　　dp[P][K]：把前K本书划分给P段（每个人1段）后得到的最小时间值；</p></li><li><p>状态转移方程</p><p>　　我们再来看这张图，</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240721150540525.png" alt="image-20240721150540525" style="zoom:80%;" /></p><p>　　根据题意，dp[p][k]和dp[p-1][c]及value[c+1][k]之间并不是“求和”的关系，而是“取最大值”的关系。也就是说，dp[p][k]=<font color="red">max</font>(dp[p-1][c],value[c+1][k])。1个方案的值等于每个人所需时间的最大值。注意，这只是一个方案的值，并不是我们要求的“最优方案”。那最优方案该怎么求呢？题目说了，值最小的就是最优。所以：<span class="math display">\[dp[p][k]=min(\ max(dp[p-1][c],\ \ value[c+1][k])\ ) \tag{3}\]</span> 　　<spanclass="math inline">\(value[c+1][k]\)</span>原本表示的是把第[c+1..k]个数设为1个段而得到的收益值，在本题中其实就是第[c+1..k]本书所需时间之和。我们现在已知每本书所需的时间，而本题又需要频繁求任意两本书位置区间之和，所以最好的办法就是新建一个前缀和数组，采用sum[k]-sum[c]来表示出value[c+1][k]。所以状态转移方程进一步转化为：<span class="math display">\[\begin{align}dp[p][k]=min(\ max(dp[p-1][c],\ \ sum[k]-sum[c])\ ) \tag{4}\\(1 \leq p \leq P,\quad p \leq k \leq K,\quad p-1 \leq c \leq k-1 )\tag{}\end{align}\]</span></p><p>　　上面的公式（4）只是一个数学简式，并不是一个真正的C++代码。如果要转成代码，需要考虑max函数和循环的特点。伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[p][k]= INF;   <span class="hljs-comment">// 初值设为负无穷，为“无解”状态的初始值， 以方便min运算出正确的结果</span><br><span class="hljs-keyword">for</span> (p)          <span class="hljs-comment">// 省略了部分代码</span><br>    <span class="hljs-keyword">for</span>(k)<br>        <span class="hljs-keyword">for</span>(c)<br>            dp[p][k]= <span class="hljs-built_in">min</span>( dp[p][k],   <span class="hljs-built_in">max</span>( dp[p<span class="hljs-number">-1</span>][c], sum[k]-sum[c]) );<br></code></pre></td></tr></table></figure></li><li><p>循环顺序和边界</p><p>　　和1.2节分析结果相同，照做即可。</p></li><li><p>初始化和特例</p><p>　　公式（4）里面有max，有min，当初始化dp数组为“无解”时，到底应该初始化为“INF”或者“-INF”呢？在公式（4）中我们需要先计算max，再来计算min。但是在做max运算时，所比较的对象中并没有dp[p][k]自身，而是把两个确切的值（dp[p-1][c]和sum[k]-sum[c]）做比较，这跟“赋初值”毫无关系，只是一个干扰项。<strong>真正实现累比的是min操作（因为min操作的其中一个比较对象是dp[p][k]它自己）。所以dp[p][k]的初值应该定义成针对min操作合适的初值对象，即INF</strong>。</p><p>　　关于特例，有dp[0][0]=0。而dp[0][1..K]，因为无法把前k本书划分给0个人，人都没有，怎么划分？所以其最小时间值为“无解”状态。这也是根据1.2节中的第5点分析而来。所以初始化和特例的处理应该是如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;  <span class="hljs-comment">// 在第0行只应对dp[0][0]做特殊处理</span><br></code></pre></td></tr></table></figure></li><li><p>输出方案</p><p>　　根据本题对dp数组的定义，dp[P][K]表示把前K本书划分给P个人后得到的最小时间值。在最优方案中，dp[P][K]又表示每个人所获页数的最大值（根据题目上对任一方案值的定义）。所以我们只需要按序分配书，并且让每个人的页数不超过dp[P][K]即可。可用递归函数来实现，不难。</p></li><li><p>优化</p><p>这个题是可以做平行四边形优化的，具体后面再说。</p></li></ol><h3 id="ac代码">2.1.3 AC代码</h3><h4 id="标准dp数组无优化输出方案">2.1.3.1标准dp数组，无优化，输出方案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法1. 可AC1278和P1281， 标准dp数组，无优化，输出方案</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 501</span><br><span class="hljs-type">int</span> K, P;<br><span class="hljs-type">int</span> page[N];         <span class="hljs-comment">// 存储每本书的页数</span><br><span class="hljs-type">int</span> dp[N][N];        <span class="hljs-comment">// dp[p][k]表示前 k 本书分给前 p 个人抄写的最短复制时间</span><br><span class="hljs-type">int</span> sum[N];          <span class="hljs-comment">// 用前缀和数组sum[]来方便处理，sum[p]表示前p本书的总页数</span><br><span class="hljs-comment">//打印输出把前k本书分给前p个人抄写的划分方案</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> c, s;<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 1278题允许P为0，P1281要求p至少为1。加本行才可以过1278题，否则只能过P1281 </span><br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-number">1</span>) &#123;         <span class="hljs-comment">// 如果只有1个人，把所有前k本书都给他吧</span><br>        cout &lt;&lt;<span class="hljs-number">1</span> &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt;k &lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    c = k;<br>    s = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 从第k本书开始，在dp[P][K]范围内往左一直分配，尽量多分配书给第p个人</span><br>    <span class="hljs-keyword">while</span>( s + page[c] &lt;= dp[P][K] ) &#123;<br>        s = s + page[c];<br>        c--;<br>    &#125;<br>    <span class="hljs-comment">// [c+1, k]之间的书已经分配给第p个人了，</span><br>    <span class="hljs-comment">// 下面接着分配[1, c]的书给剩下的p-1个人</span><br>    <span class="hljs-built_in">print</span>( p<span class="hljs-number">-1</span>, c );<br>    <span class="hljs-comment">// 为了体现正序，所以这里应该先追溯递归，然后再cout本次函数的分配方案</span><br>    cout &lt;&lt;c+<span class="hljs-number">1</span>  &lt;&lt;<span class="hljs-string">&quot; &quot;</span>  &lt;&lt;k  &lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> k, p;<br>    cin &gt;&gt;K &gt;&gt;P;           <span class="hljs-comment">// K本书，P个人</span><br>    <span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=K; k++) &#123;  <span class="hljs-comment">// K本书</span><br>        cin &gt;&gt;page[k];<br>        sum[k] = sum[k<span class="hljs-number">-1</span>] + page[k];<br>    &#125;<br>    <span class="hljs-comment">// 先要算出dp[P][K]，这样print函数才能用得上</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=<span class="hljs-number">1</span>; p&lt;=P; p++)      <span class="hljs-comment">// p个人</span><br><span class="hljs-comment">//      for(k=K; k&gt;=p; k--)  // k本书 增序降序均可 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=p; k&lt;=K; k++)  <span class="hljs-comment">// k本书</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=p<span class="hljs-number">-1</span>; c&lt;=k<span class="hljs-number">-1</span>; c++) <span class="hljs-comment">//</span><br>                dp[p][k] = <span class="hljs-built_in">min</span> (dp[p][k] , <span class="hljs-built_in">max</span>( dp[p<span class="hljs-number">-1</span>][c], sum[k]-sum[c] ));<br><br>    <span class="hljs-comment">// 这个题不光是要最短时间dp[P][K]，也要分配方案</span><br>    <span class="hljs-built_in">print</span>(P, K);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>样例对应的dp数组如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240722151409997.png" alt="image-20240722151409997" style="zoom:50%;" /></p><h4 id="滚动dp数组无优化输出方案">2.1.3.2滚动dp数组，无优化，输出方案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法2. 可AC1278和P1281，滚动dp数组，无优化，输出方案</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 501</span><br><span class="hljs-type">int</span> K, P;<br><span class="hljs-type">int</span> page[N];         <span class="hljs-comment">// 存储每本书的页数</span><br><span class="hljs-type">int</span> dp[N];           <span class="hljs-comment">// dp[k]表示前 k 本书分给前 p 个人抄写的最短复制时间</span><br><span class="hljs-type">int</span> sum[N];          <span class="hljs-comment">// 用前缀和数组sum[]来方便处理，sum[p]表示前p本书的总页数</span><br><span class="hljs-comment">//打印输出把前k本书分给前p个人抄写的划分方案</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> c, s;<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 1278题允许P为0，P1281要求p至少为1。加本行才可以过1278题，否则只能过P1281 </span><br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-number">1</span>) &#123;         <span class="hljs-comment">// 如果只有1个人，把所有前k本书都给他吧</span><br>        cout &lt;&lt;<span class="hljs-number">1</span> &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt;k &lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    c = k;<br>    s = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 从第k本书开始，在dp[K]范围内往左一直分配，尽量多分配书给第p个人</span><br>    <span class="hljs-keyword">while</span>( s + page[c] &lt;= dp[K] ) &#123;<br>        s = s + page[c];<br>        c--;<br>    &#125;<br>    <span class="hljs-comment">// [c+1, k]之间的书已经分配给第p个人了，</span><br>    <span class="hljs-comment">// 下面接着分配[1, c]的书给剩下的p-1个人</span><br>    <span class="hljs-built_in">print</span>( p<span class="hljs-number">-1</span>, c );<br>    <span class="hljs-comment">// 为了体现正序，所以这里应该先追溯递归，然后再cout本次函数的分配方案</span><br>    cout &lt;&lt;c+<span class="hljs-number">1</span>  &lt;&lt;<span class="hljs-string">&quot; &quot;</span>  &lt;&lt;k  &lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> k, p;<br>    cin &gt;&gt;K &gt;&gt;P;               <span class="hljs-comment">// K本书，P个人</span><br>    <span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=K; k++) &#123;  <span class="hljs-comment">// K本书</span><br>        cin &gt;&gt;page[k];<br>        sum[k] = sum[k<span class="hljs-number">-1</span>] + page[k];<br>    &#125;<br>    <span class="hljs-comment">// 先要算出dp[K]，这样print函数才能用得上</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=<span class="hljs-number">1</span>; p&lt;=P; p++)      <span class="hljs-comment">// p个人</span><br>        <span class="hljs-keyword">for</span>(k=K; k&gt;=p; k--)      <span class="hljs-comment">// k本书 滚动数组只能降序 </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=p<span class="hljs-number">-1</span>; c&lt;=k<span class="hljs-number">-1</span>; c++) <span class="hljs-comment">//</span><br>                dp[k] = <span class="hljs-built_in">min</span> (dp[k] , <span class="hljs-built_in">max</span>( dp[c], sum[k]-sum[c] ));<br><br>    <span class="hljs-comment">// 这个题不光是要最短时间dp[K]，也要分配方案</span><br>    <span class="hljs-built_in">print</span>(P, K);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p4677">2.2 1197/P4677</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1197">1197：山区建小学</a>/<ahref="https://www.luogu.com.cn/problem/P4677">P4677 山区建小学</a></p><h3 id="分析-2">2.2.2 分析</h3><p>　　题目比较难懂，先把测试样例的结果搞明白，往往有助于理解题意。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724103511313.png"alt="image-20240724103511313" /><figcaption aria-hidden="true">image-20240724103511313</figcaption></figure><p>　　把2个学校分别设置在2号村庄和7号村庄的话，各个村庄到附近学校的距离之和达到最小，为18。</p><h4 id="动态规划多步分析">2.2.2.1 动态规划多步分析</h4><p>　　理解了基本题意之后，我们来观察这张图，感觉这个题像是在“k个村庄中选择p个小学”的选择策略问题，而且每个小学会涵盖一个区间范围。所有K个小学被分割成了P个区间范围。每个区间范围内的村庄都去对应的小学上学。区间之间互不影响。下面我们用动态规划的分析思路来进行整理和细化。</p><ol type="1"><li>状态数组定义</li></ol><p>dp[p][k]:把前k个村庄分成p段，每1段内建立1个小学后,每段内每个村庄到各自段内小学的最短路程之总和</p><ol start="2" type="1"><li>所求目标</li></ol><p>dp[P][K]:把K个村庄分成P段，每1段内建立1个小学后,每段内每个村庄到各自段内小学的最短路程之总和</p><ol start="3" type="1"><li>状态转移方程</li></ol><p>　　这个内容比较复杂，下面需要用较多的篇幅来讲述。</p><p>　　首先我们要意识到这是一个“把K个数据分为P段”策略问题，可以用dp来求最优解。</p><p>　　我们现在要计算dp[p][k]，也就是要填表格中第p行第k列的值。我们现在能利用的，就是已经填过值的数据，也就是表格中dp[p][k]所处位置以左或以上的数据，也就是例如dp[p-1][k]、dp[p-1][k-1]、dp[p-2][k]、dp[p-3][k-1]、dp[p-2][k-2]、...等这些数据。</p><p>　　为了方便说明，我们下面暂时以dp[3][6]为例，即在前6个村庄中选3个位置来作为学校，求所有村庄到附近小学的最短路径之和。很多时候，当我们在推导状态转移方程时，可以假设一些具体的数据，便于快速找到方法，再推广到普通的情况。</p><p>　　<strong>1）传统dp做法，让dp[p][k]去和dp[p][k-1]、dp[p-1][k-1]或者dp[p-1][k]等产生关联（不可行）</strong></p><p>　　如下图所示，先算出这6个点“ABCDEF”到其中2个点“B”和“D”的最短距离之和，即dp[2][6]。其中B和D是假定的学校位置，具有随机性。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723141319295.png" alt="image-20240723141319295" style="zoom:67%;" /></p><p>　　然后再在剩下的4个点中新增第3个学校F，调整参与求和的距离，使得总和最小。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723141456308.png" alt="image-20240723141456308" style="zoom:67%;" /></p><p>　　可以看出，在把F点设置为学校之后，上面两个图在计算距离之和这方面，参与计算求和的多个距离值存在较大的不同。这样划分，使得上一个步骤计算出来的各种距离值化为乌有，不可再用，很多距离值都需要重新计算，会使得程序更难理解和处理，复杂度暴涨，放弃！而且这样设计，并没有体现出“把K个数据分为P段”当中的“段”的思想。</p><p>　　2）<strong>改进做法（可行，但需调整）</strong></p><p>　　当村庄和学校的位置都确定时，每个村庄都会到附近最近的学校去上学，这实际上已经形成了以多个学校为中心的片区。每个片区可以看成一个段。段与段之间的村庄不产生相互的联系。这实际上更像是“线性结构上分段”的类型。　　</p><p>　　如果要计算dp[3][6]，可以先算出前5个点“ABCDE”到其中2个点“B”和“D”的最短距离之和，即dp[2][5]（注意，“B”和“D”仍然是随便假定的学校位置）。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723141808078.png" alt="image-20240723141808078" style="zoom:67%;" /></p><p>　　然后再在剩下的6-5=1个点中新增第3个学校“F”，<strong>并且要求前5个村庄不得到新增点的学校来上课（体现出了“段”的思想，不同段内的数据相互不产生任何联系）</strong>。这样可以保持之前已有的数据关系和数据值不变（可以使得划分具有“无后效性”和“局部最优”的特点，满足动态规划的基本要求），得到“在前6个点中设置3个学校的距离之和”的<strong>一个（注意，并不是唯一的）</strong>计算公式。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723142122884.png" alt="image-20240723142122884" style="zoom:67%;" /></p><p>　　当然，这个公式肯定是存在一定问题的。从上面的图中可以看出，E点如果要去学校D，明显会比去学校F更远。也就是说，这种划分，虽然能很方便地利用之前dp数组的数据，但其结果却是不对的，还需要进一步修正。</p><p>　　上面这个结果的错误之处，在于这种划分不对。我们不应该划分成“ABCDE+F”的组合，这样会使得E点的孩子去学校D上学而不去更近的学校F。那除了“ABCDE+F”这种划分之外，还可以有其他的划分方法，即“空+ABCDEF”，“A+BCDEF”，“AB+CDEF”，“ABC+DEF”，“ABCD+EF”这五种。</p><p>　　<font color="red">正确的划分方法，肯定就在这六种划分方式中。我们可以遍历一遍，找出其中的最小值。哪个组合的距离之和最小，那对应的划分方法自然就是正确答案。</font></p><ul><li><del>空+ABCDEF—— dp[3][6] = dp[2][0] +“ABCDEF中选一个点作为学校后其他5个点到该点的距离之和的最小值”</del>(无法在0个村庄中选2个学校，dp[2][0]必然无解，本策略无效，不必参与min比较)</li><li><del>A+BCDEF　—— dp[3][6] = dp[2][1] + “BCDEF中选一个点作为学校后其他4个点到该点的距离之和的最小值”</del>(无法在1个村庄中选2个学校，dp[2][1]必然无解，本策略无效，不必参与min比较)</li><li>AB+CDEF　—— dp[3][6] = dp[2][2] + “CDEF中选一个点作为学校后其他3个点到该点的距离之和的最小值”</li><li>ABC+DEF　—— dp[3][6] = dp[2][3] + “DEF中选一个点作为学校后其他2个点到该点的距离之和的最小值”</li><li>ABCD+EF　—— dp[3][6] = dp[2][4] + “EF中选一个点作为学校后其他1个点到该点的距离之和的最小值”</li><li>ABCDE+F　—— dp[3][6] = dp[2][5] + “F中选一个点F作为学校后的距离的最小值（其实就是0了，自己到自己的距离）”</li></ul><p>　　从上面的6个式子可以看出，有一种信息需要频繁求取，而我们还没有对应的数据结构来表示它。那就是“在一段连续的村庄（假设为从第i个村庄到第j个村庄）中选一个点作为学校后，该段内其他所有点到该点的距离之和的最小值”。该如何表示这个信息呢？其实只需要把i和j表示出来即可。该信息表示的是最小值，所以不应该在数据结构中指定学校的位置。所以该结构只需要2个信息即可，就是i和j，我们可以<strong>用一个二维数据Cost[i][j]来表示从第i个村庄到第j个村庄这一个区间中选1个点作为学校后，该区间内其他点到该学校点的距离之和的最小值</strong>。</p><p>　　关于Cost[][]的值，怎么计算出来呢？这是本题比其他同类型题复杂的地方。题面上并没有直接给出Cost[][]的值，需要我们去计算出来。具体分析和计算过程，因为内容较多，为了避免冲淡主题，把这部分内容单独做成2.2.2.2小节，请同学们注意学习。下面的分析假设该数组C的值已经获得。</p><p>　　根据上面红色文字的叙述，我们可以总结出下面的公式来。 <spanclass="math display">\[\begin{align}dp[3][6]=min(\ &amp;dp[2][\textcolor{red}2]+Cost[3][6],\tag{}\\ &amp;dp[2][\textcolor{red}3]+Cost[4][6],\tag{}\\&amp;dp[2][\textcolor{red}4]+Cost[5][6], \tag{}\\&amp;dp[2][\textcolor{red}5]+Cost[6][6]\ \ ) \tag{1}\end{align}\]</span></p><p>　　把公式（1）翻译成代码，那就是如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 公式1对应的代码如下：</span><br>dp[<span class="hljs-number">3</span>][<span class="hljs-number">6</span>]= INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=<span class="hljs-number">3</span><span class="hljs-number">-1</span>; c&lt;=<span class="hljs-number">6</span><span class="hljs-number">-1</span>; c++)  <span class="hljs-comment">// c表示公式（1）中的红色数字，代表了不同的分割策略</span><br>    dp[<span class="hljs-number">3</span>][<span class="hljs-number">6</span>]= <span class="hljs-built_in">min</span>( dp[<span class="hljs-number">3</span>][<span class="hljs-number">6</span>],  dp[<span class="hljs-number">3</span><span class="hljs-number">-1</span>][c] + Cost[c+<span class="hljs-number">1</span>][<span class="hljs-number">6</span>] );<br></code></pre></td></tr></table></figure><p>　　所以状态转移方程就是： <span class="math display">\[dp[p][k]=min(dp[p][k],\ dp[p-1][c]\ + \ Cost[c+1][k]\ ) \\(1 \leq p \leq P;\quad p \leq k \leq K;\quad p-1 \leq c\leq k-1)\]</span></p><ol start="4" type="1"><li><p>循环顺序和边界</p><p>p:dp[p][k]的求解，需要且只需要用到上一行的数据，所以p只能增序，[1..P]；</p><p>k:既然是只用到上一行的数据，所以k可以增序，也可以降序。在本题中，如果村庄数k少于学校数p，是不合理的，无解，所以只需要填写<spanclass="math inline">\(k \geqp\)</span>的情况。所以循环顺序和边界为[p..K]，或者[K..p];</p><p>c:策略c在dp的第二维，对于状态[p-1][c]来说，第二维的数字c不能小于第一维的数字p-1（否则该状态无解，不应参与比较，即使参与了也是白比），所以c的范围是[p-1,k-1]。增序降序均可。先比哪个策略，后比哪个策略，这个顺序并不重要，最终都要比完所有的策略。</p></li><li><p>初始化和特例</p></li></ol><p>　　因为状态可能存在无解，所以dp数组初始化为无解，在本题中对应的就是INF。</p><p>　　根据1.2节第5点的分析，dp[0][0]=0。而对于dp[0][1..K]，在k个村庄中设置0个学校，把k个数据划分为0段，描述不合理，无解。</p><h4 id="推导cost数组">2.2.2.2 推导Cost数组</h4><p>　　Cost数组是状态转移方程中非常重要的一个数据结构。Cost[le][ri]来表示从第le个村庄到第ri个村庄这一个区间中选1个点作为学校后，该区间内其他点到该学校点的距离之和的最小值。该如何找规律来计算呢？老规矩，草稿纸上画样例，先看看样例具有什么样的规律。下面以6个村庄中找1个学校为例来分析。</p><p>1）以1号点为学校，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724114648838.png" alt="image-20240724114648838" style="zoom:50%;" /></p><p>2）以2号点为学校，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724114610444.png" alt="image-20240724114610444" style="zoom:50%;" /></p><p>3）以3号点为学校，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724113906535.png" alt="image-20240724113906535" style="zoom:50%;" /></p><p>4）以4号点为学校，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724114049227.png" alt="image-20240724114049227" style="zoom:50%;" /></p><p>5）以5号点为学校，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724114250586.png" alt="image-20240724114250586" style="zoom:50%;" /></p><p>6）以6号点为学校，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724114501124.png" alt="image-20240724114501124" style="zoom:50%;" /></p><p>　　把上面6种方案的距离值进行对比，可以发现，不管红黄绿蓝紫的路径值为多少，必然会有：</p><p>　　5红4黄3绿2蓝1紫(以1号为学校) &gt;= 1红4黄3绿2蓝1紫(以2号为学校)&gt;= <strong>1红2黄3绿2蓝1紫(以3号为学校)==1红2黄3绿2蓝1紫(以4号为学校)</strong> &lt;= 1红2黄3绿4蓝1紫(以5号为学校)&lt;= 1红2黄3绿4蓝5紫(以6号为学校)</p><p>　　也就是说，在这串村庄组成的线性结构中，<strong>取区间中点位置的点作为村庄，总距离之和是最小的，不管各个点之间的线性距离是多少。</strong>当这些点为奇数个时，直接取中点作为学校；当这些点为偶数个时，取中间两个点都能得到最小值。</p><p>　　搞清楚了这一点，我们就能确定任意一个指定区间[le,ri]中学校的位置为(le+ri)/2。</p><p>　　下一步要做什么呢？下一步就是计算该区间内所有点到该学校点的距离之和了。这里有一个小问题需要解决，在确定好学校点之后，如何以最快捷方便的办法计算出该区间内所有点到学校点的距离之和呢？题目上只告知了每相邻2个点之间的距离值。其实方法很简单，因为所有点都正好在一个线形上，任意两点之间的距离值，就变成了两点之间所有相邻点距离值之和，这实际上是个“区间和”的问题，所以用前缀和数组就能搞定了。</p><p>　　相关的局部代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=K; i++)  <span class="hljs-comment">// 村庄从1开始编号，sum[1]=0 </span><br>   cin &gt;&gt;sum[i], sum[i]+= sum[i<span class="hljs-number">-1</span>];<br><span class="hljs-comment">// cost[i][j]：第i~j个村庄之间建立1所小学，这几个村庄到这个小学的最小距离之和。 </span><br>   <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> le=<span class="hljs-number">1</span>; le&lt;=K; le++)<br>   <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> ri=le; ri&lt;=K; ri++)&#123;<br>       <span class="hljs-type">int</span> mid = (le+ri) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// 把这所小学定在第mid个村庄，使得第i~j个村庄到这个小学距离之和最小  </span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=le; k&lt;=ri; k++)<br>       cost[le][ri] += <span class="hljs-built_in">abs</span>(sum[mid] - sum[k]); <span class="hljs-comment">// 算出这个距离之和，然后填表cost </span><br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="ac代码-1">2.2.3 AC代码</h3><p>　　在不考虑平行四边形优化的前提下，本题的朴素代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//dp，标准状态数组，无优化</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 法1： 朴素做法，标准状态数组dp[][]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1001</span><br><span class="hljs-type">int</span> K, P;<br><span class="hljs-type">int</span> sum[N];     <span class="hljs-comment">// 距离的前缀和数组， </span><br><span class="hljs-type">int</span> cost[N][N]; <span class="hljs-comment">// cost[10][20]=400表示从第[10..20]个小学内设置一个学校后，这11个村庄到这所小学的最短距离之和 </span><br><span class="hljs-type">int</span> dp[N][N];   <span class="hljs-comment">//前 k个村庄放 p 个小学时的“村校最小距离和”（即: 所有小学到附近村庄的最小距离之和）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i, j, p, k, le, rt;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); <br><span class="hljs-comment">// K村庄数     P小学数 </span><br>    cin &gt;&gt;K &gt;&gt;P;<br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">2</span>; i&lt;=K; i++)  <span class="hljs-comment">// 村庄从1开始编号，sum[1]=0 </span><br>    cin &gt;&gt;sum[i], sum[i]+= sum[i<span class="hljs-number">-1</span>];<br>    <br>    <span class="hljs-comment">// 根据上面的数组(任意两村之间的距离)，填数组cost[][]的右上部分，对角线上全0 </span><br><span class="hljs-comment">// cost[i][j]：第i~j个村庄之间建立1所小学，这几个村庄到这个小学的最小距离之和。 </span><br>    <span class="hljs-keyword">for</span>( le=<span class="hljs-number">1</span>; le&lt;=K; le++)<br>    <span class="hljs-keyword">for</span>( rt=le; rt&lt;=K; rt++)&#123;<br>        <span class="hljs-type">int</span> mid = (le+rt) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// 把这所小学定在第mid个村庄，使得第i~j个村庄到这个小学距离之和最小  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=le; k&lt;=rt; k++)<br>        cost[le][rt] += <span class="hljs-built_in">abs</span>(sum[mid] - sum[k]); <span class="hljs-comment">// 算出这个距离之和，然后填表cost </span><br>   &#125;<br>    <br><span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp)); <br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <br>    <span class="hljs-keyword">for</span>( p=<span class="hljs-number">1</span>; p&lt;=P; p++)       <span class="hljs-comment">// p个小学   1&lt;=p&lt;=P</span><br>    <span class="hljs-keyword">for</span>( k=p; k&lt;=K; k++)   <span class="hljs-comment">// k个村庄 , p&lt;=k&lt;=K    </span><br><span class="hljs-comment">//    for( k=K; k&gt;=p; k--)   // 标准数组，k增序降序都可以  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=k<span class="hljs-number">-1</span>; c&gt;=p<span class="hljs-number">-1</span>; c--)  <span class="hljs-comment">// c个分隔点（策略），p-1&lt;= c &lt;=k-1, 增序降序都可以！ </span><br>            dp[p][k] = <span class="hljs-built_in">min</span>(dp[p][k],  dp[p<span class="hljs-number">-1</span>][c] + cost[c+<span class="hljs-number">1</span>][k]);<br><br>    cout &lt;&lt;dp[P][K]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 区间dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三种分组背包的处理</title>
      <link href="/2024/07/02/%E4%B8%89%E7%A7%8D%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E7%9A%84%E5%A4%84%E7%90%86/"/>
      <url>/2024/07/02/%E4%B8%89%E7%A7%8D%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E7%9A%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="分组背包的题型和分类">1.1 分组背包的题型和分类</h2><p>　　一个背包的总约束量为YS1，有n个物品，约束量分别为<spanclass="math inline">\(ys1[1]、ys1[2]、...、ys1[n]\)</span>,收益量分别为<spanclass="math inline">\(value[1]、value[2]、...、value[n]\)</span>,这n个物品被划分为了若干组，在选择物品时每个组遵循一个共同的<font color="red">规则要求</font>，求解在这种规则要求下选出来的物品的约束量之和不超过YS1的情况下，其物品组合的<strong>最大收益值</strong>。</p><p>　　上述的<font color="red">规则要求</font>，可分为以下三类，分别对应着三种类型的分组背包题型：</p><ol type="1"><li>每组物品选的物品个数<font color="red">&lt;=</font>1个：每组内的物品之间相互冲突，最多只能选一个，允许不选；</li><li>每组物品选的物品个数<font color="red">==</font>1个：每组内的物品之间相互冲突，只能选一个，不能多，也不能少；</li><li>每组物品选的物品个数<font color="red">&gt;=</font>1个：每组内的物品之间不冲突，至少选一个，可以多选，但不允许不选；</li></ol><p>　　需要指出的是，分组背包支持多维费用，求解时也并不一定是“&lt;=YS1”情况下的最大收益值，也支持其他情况，求解方式大同小异。同学们可以自己去思考拓展。</p><h2 id="题型1每组物品选的物品个数1个">1.2题型1：每组物品选的物品个数<font color="red">&lt;=</font>1个</h2><p>　　这种题型在普及组中出现得较多，是最基础的分组背包题型。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240716100733859.png"alt="image-20240716100733859" /><figcaption aria-hidden="true">image-20240716100733859</figcaption></figure><p>　　我们来分析一下上面的样例数据，看看怎么破解这种题型。YS1=10，6个物品，一共被分为了3组。我们需要针对每一组内的物品来做考虑，但是录入的时候，物品编号是全局的编号值，并非组内的序号，这会给我们遍历每一组内的所有物品带来不便。所以我们需要用idx[][]数组来转换一下全局编号和组内序号之间的关系。这个数组的填写过程可以在录入所有物品的同时就完成。idx[2][0]=2表示第2组一共有2个物品；idx[2][2]=4表示第2组的第2个物品的编号是4号。在这种结构下，我们可以使用如下的代码来遍历访问第g组所有物品的ys1[]值和value[]值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)&#123;<br>cout &lt;&lt; ys1[ idx[g][k] ] &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt;value[ idx[g][k] ] &lt;&lt;endl; <span class="hljs-comment">// 注意idx[g][k]返回的是i值，即物品的全局编号值i</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240716111815053.png" alt="image-20240716111815053" style="zoom:80%;" /></p><p>　　我们用dp[][]数组来表示物品组合的最大收益值，<strong>但因为有分组的约束，所以这里第一维不能是全局编号i了，而应该是组号g</strong>。第二维仍然是约束总量j。所以<strong>dp[g][j]表示“前g组中所选物品在不超过总约束量为j的前提下，物品组合的最大收益值”</strong>。根据这个定义，本题的所求目标就是dp[maxg][YS1]了（假设一共有maxg组物品）。</p><p>　　既然是分组背包，那我们就只能一组一组地来做选择，所以在填写dp[][]数组时，第一层循环应该是for(intg=1; g&lt;=maxg;g++)了。处理完一组的所有物品之后，再去处理下一组的所有物品。这里遇到一个问题：请问第二层循环应该是什么呢？是forj呢，或者是for组内物品k？其实两种方法都是可以的，但要小心在初始化或者if语句或者循环边界上的一些微小的差别。</p><h3 id="先for-组内物品k再for-j重点掌握">1.2.1 先for 组内物品k，再forj（重点掌握）</h3><p>　　第一层是forg，针对每一组进行循环，在所有题型中都一样，这里就不专门去写了，我们重点分析第二层和第三层。第二层循环是for组内物品k，即针对第g组的所有物品去做第三层循环的操作（只能是forj了，即遍历填写dp[g][0..YS1]），即如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（1），组内最多选1件，先for 组内物品k 再 for j，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br><span class="hljs-comment">// 开始循环填写</span><br>......<span class="hljs-comment">// k=1 针对该组的第1个物品，j的循环范围为[YS1..ys1[ idx[g][1]] ]</span><br>dp[g][<span class="hljs-number">50</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">50</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] );  <span class="hljs-comment">// j=50，如果50&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">51</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">51</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] );  <span class="hljs-comment">// j=51，如果51&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">52</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">52</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] );  <span class="hljs-comment">// j=52，如果52&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">53</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">53</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">53</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] );  <span class="hljs-comment">// j=53，如果53&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>...<br>......<span class="hljs-comment">// k=2 针对该组的第2个物品，j的循环范围为[YS1..ys1[ idx[g][2]] ]</span><br>dp[g][<span class="hljs-number">50</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">50</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] );  <span class="hljs-comment">// j=50，如果50&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">51</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">51</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] );  <span class="hljs-comment">// j=51，如果51&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">52</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">52</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] );  <span class="hljs-comment">// j=51，如果51&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">53</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">53</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">53</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] );  <span class="hljs-comment">// j=53，如果53&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>...<br>......<span class="hljs-comment">// k=3 针对该组的第3个物品，j的循环范围为[YS1..ys1[ idx[g][3]] ]</span><br>dp[g][<span class="hljs-number">50</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">50</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] );  <span class="hljs-comment">// j=50，如果50&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">51</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">51</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] );  <span class="hljs-comment">// j=51，如果51&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">52</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">52</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] );  <span class="hljs-comment">// j=52，如果52&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">53</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">53</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">53</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] );  <span class="hljs-comment">// j=53，如果53&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>...<br><br></code></pre></td></tr></table></figure><p>　　上面的代码（1）整合之后的等效代码（2）如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（2），等效于代码（1），组内最多选1件，先for 组内物品k 再 for j，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br><span class="hljs-comment">// 开始循环填写</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[idx[g][k]]] + value[idx[g][k]] );<br></code></pre></td></tr></table></figure><p>　　上面的代码（2）是针对“第g组为‘组内最多选择1件物品’”的情况。如果所有组的物品都是“组内最多选择1件物品”的话，则在代码（2）的外面套一个对所有组的循环即可，得到如下的代码（3）.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（3），所有组都只能组内最多选1件，先for 组内物品k 再 for j，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=maxg; g++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>    dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>    dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[idx[g][k]]] + value[idx[g][k]] );<br>&#125;<br></code></pre></td></tr></table></figure><p>　　如果对dp[][]采用滚动数组，看上去好像可以把代码（3）进一步演变为如下代码（4）所示，但实际上这个代码是错误的!</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（4），错误代码！错误代码！所有组都只能组内最多选1件，先for 组内物品k 再 for j，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=maxg; g++)<br>    <span class="hljs-comment">// 不需要再“照抄上一行数据”了，下面的写法已经隐含地包括了对“不选任何物品”这个选择的max比较了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 必须只能倒序！</span><br>    dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dp[j-ys1[idx[g][k]]] + value[idx[g][k]] );<br></code></pre></td></tr></table></figure><p>　　错误的原因就在于在代码（4）的第5、6行执行时，可能会把一些dp[]值进行更改为新值（选择了当前组的某个物品价值更大），这会使得对该组后续的其他物品进行选择考虑时，本应该做dp[g][j]=max( dp[g][j], dp[g-1][j-ys1[idx[g][k]]] + value[idx[g][k]]);，但因为dp[j]被改过，所以它表达的实际上已经是dp[g][j]的值，而不是dp[g-1][j]的值了，如果此时再去选，会造成该组同时选择2个或多个物品。举个例子：</p><p>　　假如第1组现在有2个物品，成本分别是2斤、3斤，收益对应分别为1元和3元。如果我们按照代码（4）来做的话，当第1个物品处理结束后，dp[0..YS1]值会是{0,0,1,1,1,1,1,1,...}。在这种情况下，去处理第二个物品时，dp[0..YS1]会是{0,0,1,3,3,4,4,4,4,....}。这是错误的。实际上dp[0..YS1]的正确答案应该是{0,0,1,3,3,3,3,....}。之所以出现这种情况，是因为代码（4）在处理第二个物品时，做了dp[5]=max(dp[5],dp[2]+3)=max(1,1+3)=4，而实际上应该是dp[5]=max(dp[5],dp[2]+3)=max(1,0+3)=3。这里的dp[2]错误地取成了1（表示已选了第1个物品），本应该是0。</p><p>　　找到问题之后，解决方法如下代码（５）所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（５），正确代码！所有组都只能组内最多选1件，先for 组内物品k 再 for j，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=maxg; g++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--) <br>        dptmp[j]=dp[j];     <span class="hljs-comment">// 用dptmp[0..YS1]来存dp[g-1][0..YS1] </span><br>    <span class="hljs-comment">// 不需要再“照抄上一行数据”了，下面的写法已经隐含地包括了对“不选任何物品”这个选择的max比较了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 必须只能倒序！</span><br>            <span class="hljs-comment">// dptmp[]表示的是dp[g-1][] !!</span><br>    dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dptmp[j-ys1[idx[g][k]]] + value[idx[g][k]] );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="先for-j再for-组内物品k">1.2.2 先for j，再for 组内物品k</h3><p>　　第二层循环是forj，即针对所有的总约束量j去做第三层循环的操作（只能是for组内物品k了，即遍历该组的每个物品），即如下代码（6）所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（6），所有组都只能组内最多选1件，先for j 再 for 组内物品k，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br>......<span class="hljs-comment">// j=50</span><br>dp[g][<span class="hljs-number">50</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] ); <span class="hljs-comment">// k=1，如果50&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">50</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] ); <span class="hljs-comment">// k=2，如果50&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">50</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] ); <span class="hljs-comment">// k=3，如果50&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>...<br>......<span class="hljs-comment">// j=51</span><br>dp[g][<span class="hljs-number">51</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] ); <span class="hljs-comment">// k=1，如果51&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">51</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] ); <span class="hljs-comment">// k=2，如果51&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">51</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] ); <span class="hljs-comment">// k=3，如果51&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>...<br>......<span class="hljs-comment">// j=52</span><br>dp[g][<span class="hljs-number">52</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] ); <span class="hljs-comment">// k=1，如果52&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">52</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] ); <span class="hljs-comment">// k=2，如果52&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">52</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] ); <span class="hljs-comment">// k=3，如果52&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>...<br></code></pre></td></tr></table></figure><p>　　仔细把代码（1）和上面的代码（6）进行比对，你会发现其实他们是等效的，只是语句的顺序不太一样而已。把上面的代码（6）整合，得到等效的代码（7）如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（7），等效于代码（6），所有组都只能组内最多选1件，先for j 再 for 组内物品k，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] )  <span class="hljs-comment">// 因为在第4行还没有k，无法写出j&gt;=ys1[ idx[g][k] ]，所以只能在这里写！</span><br>            dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br></code></pre></td></tr></table></figure><p>　　注意，代码（7）中的第2、3行代码，其实是可以整合到下面的循环中去的，得到等效的代码（8）如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（8），等效于代码（7），所有组都只能组内最多选1件，先for j 再 for 组内物品k，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>    dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];     <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] )  <span class="hljs-comment">// 因为在第4行还没有k，无法写出j&gt;=ys1[ idx[g][k] ]，所以只能在这里写！</span><br>            dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br>&#125;<br></code></pre></td></tr></table></figure><p>　　如果对dp[][]采用滚动数组，则可以把代码（8）进一步演变为如下代码（9）所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（9），等效于代码（8），所有组都只能组内最多选1件，先for j 再 for 组内物品k，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>    <span class="hljs-comment">// 不需要再“照抄上一行数据”了，下面的写法已经隐含地包括了对“不选任何物品”这个选择的max比较了</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] )  <span class="hljs-comment">// 因为在第2行还没有k，无法写出j&gt;=ys1[ idx[g][k] ]，所以只能在这里写！</span><br>            dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dp[j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br>&#125;<br></code></pre></td></tr></table></figure><p>　　上面的代码（9）是针对“第g组为‘组内最多选择1件物品’”的情况。如果所有组的物品都是“组内最多选择1件物品”的话，则在代码（9）的外面套一个对所有组的循环即可，得到如下的代码（10）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（10），所有组都只能组内最多选1件，先for j 再 for 组内物品k，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=maxg; g++)   <span class="hljs-comment">// 对每一组进行</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>            <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] ) <br>                dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dp[j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br>    &#125;<br></code></pre></td></tr></table></figure><p>　　我们现在可以来比较这两种方法，会发现各种版本的代码都各有千秋，不存在哪个版本绝对精简。希望同学们尽量都能推导，要懂得灵活处理，理解原理，没必要死记硬背，很容易背错。滚动数组看起来虽然方便，但理解困难，容易出错。标准数组理解起来方便一些，但涉及初值赋予，多占空间。鉴于分组背包的复杂性和易错，建议基础薄弱的同学们最好是首先考虑标准状态数组。</p><h2 id="题型2每组物品选的物品个数-1个">1.3题型2：每组物品选的物品个数<font color="red">= =</font>1个</h2><p>题型2和题型1的区别在于：每一组必须要选择一个物品。这种区别会带来一些变化如下：</p><ol type="1"><li><p>因为每一组要求必须要选择一个物品，在“总成本量&lt;=j”的这个限制条件下，有可能无法选择任何一个物品，即无解。例如假设第g组所有物品的成本量都超过了100，则dp[g][0..99]都肯定是无解的，无法选出，只能无解。</p></li><li><p>既然要求每组不能不选物品，那么就不能再用dp[g][j]=dp[g-1][j]了，因为这行代码表示“本组不选任何物品”。因为可能存在本组无解的情况，所以dp[g][j]的初值应该对应着“无解”。如果在计算的过程中发现有解，则应该替换覆盖原来的初值。</p></li></ol><p>　　对于“无解”的处理，在<a href="/2024/05/27/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98/">《背包问题的初始化问题》</a>中的1.3节中专门讨论过各种题型对“无解”这个状态的理解。同学们可以回看一下。</p><p>　　<strong>分组背包模型中，对“无解”的处理，总结出来如下三点：</strong></p><p>　　1.<strong>首先应该看当前题型是否可能存在“无解”的状态（在分组背包中，只有"当前组必须要选1个或者至少选1个"的题型才存在“无解（如果选不出来就意味着无解）”的状态）。如果可能存在，那么</strong></p><p>　　　　1）<strong>如果dp表示最大值，则初始化时dp[1..gcnt][<font color="red">0</font>..YS1]=-INF；</strong></p><p>　　　　2）<strong>如果dp表示方案数，则初始化时dp[1..gcnt][<font color="red">1</font>..YS1]=0,dp[0][0]=1；</strong></p><p>　　　　3）<strong>如果dp表示最小值，则初始化时dp[1..gcnt][<font color="red">0</font>..YS1]=INF。</strong></p><p>　　2.<strong>不管当前题型是否存在无解的情况，dp[<font color="red">0</font>][0..YS1]都应该要设置为全0（若表示方案数，dp[0][0]=1,dp[0][1..YS1]=0）！因为在任何情况下，如果连组都没有（g==0，表示“尚未开始选择”），那肯定收益值是0，方案数是1（“什么都不做”）。从另外一个角度来看，如果第0行全是-INF或者INF的话，就没法更新dp数组下面的每行数据（因为每组题型的dp[g][]都依赖于dp[g-1][]）了。</strong></p><p>　　3.这里需要小心容易被同学们忽略的地方，那就是“对第0列的处理”。虽然第0行属于特例，需要单独处理，但是第0列并不是特例！当dp数组表示最大值或者最小值，并且在题型2或者题型3中时，dp[g][0]=0表示对第g组的选择是合理合法的，但如果dp[g][0]=无解，这表示对第g组的选择已经无法按规定要求正确进行。在这种情况下，去处理第g+1行的数据，一旦需要使用到dp[g][0]则必然会出现问题！从公式上来看，右侧的式子一旦是无解的状态，则由它来推导出左侧的状态值，这显然是不合理的！有部分同学把dp[1..gcnt][0]设置为了全0，似乎也能AC某些题，这纯粹是因为测试数据太弱的缘故，在考试时肯定会出问题。总结起来，记住一点，<strong>对dp数组的第0列不要做特殊处理。初始化第g行所有数据时，一定要把dp[g][0]的初始化包含在内</strong>。</p><p>　　在1.2节中的“先for 组内物品k，再for j”和“先for j，再for组内物品k”这两个不同的策略，同样适用于1.3节这种题型。同学们可以选择自己熟悉的策略来重点掌握（<strong>建议掌握“先for组内物品k，再for j”这种策略的做法，适用范围更广</strong>）。</p><h3 id="先for-组内物品k后for-j重点掌握">1.3.1 先for 组内物品k，后forj（重点掌握）</h3><p>1.标准状态数组下的做法</p><p>　　在代码（2）的基础之上演变得到如下的代码（11）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（11），组内必须选1件，先for 组内物品k 再 for j，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>dp[g][j]= -INF;    <span class="hljs-comment">// 默认针对每个j，当前组都暂时无解，值为-INF。当然，也可以用memset或者直接设置为全局数组以自动清0，这样就可以不用写这个for循环了</span><br><span class="hljs-comment">// 开始循环填写dp</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[idx[g][k]]] + value[idx[g][k]] );<br><span class="hljs-comment">// 填完整个dp数组之后，如果某个dp[g][j]的值仍然是-INF，说明这个状态是无解的。</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>滚动状态数组下的做法</li></ol><p>　　在代码（5）的基础之上演变得到如下的代码（12）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（12），组内必须选1件，先for 组内物品k 再 for j，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123; <br>    dptmp[j]=dp[j];   <span class="hljs-comment">// 用dptmp[0..YS1]来存dp[g-1][0..YS1]</span><br>    dp[j]= -INF;      <span class="hljs-comment">// dp[j]现在要去存放dp[g][j]了，以“无解”（收益值为-INF）来作为该状态([g][j])的初始值</span><br>&#125;<br><span class="hljs-comment">// 不再“照抄上一行数据”，每个dp[0..YS1]的初值设为了-INF，在第一次执行dp[j]=max(dp[j], ...)时，等效于执行了“dp[j]=max(-INF, ...)”，意味着本组的所有策略中没有包含“本组什么物品都不选”。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 必须只能倒序，表示每个物品不能多选！</span><br>         <span class="hljs-comment">// dptmp[]表示的是dp[g-1][] !!</span><br>    dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dptmp[j-ys1[idx[g][k]]] + value[idx[g][k]] );<br></code></pre></td></tr></table></figure><h3 id="先for-j后for-组内物品k">1.3.2 先for j，后for 组内物品k</h3><ol type="1"><li>标准状态数组下的做法</li></ol><p>　　在代码（8）的基础之上演变得到如下的代码（13）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（13），组内必须选1件，先for j 再 for 组内物品k，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>    dp[g][j]= -INF;     <span class="hljs-comment">// 以“无解”（收益值为-INF）来作为该状态的初始值。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] )  <span class="hljs-comment">// 因为在第2行还没有k，无法写出j&gt;=ys1[ idx[g][k] ]，所以只能在这里写！</span><br>            dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>滚动状态数组下的做法</li></ol><p>　　在代码（9）的基础之上演变得到如下的代码（14）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（14），组内必须选1件，先for j 再 for 组内物品k，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>    dp[j]=-INF;<span class="hljs-comment">// 以“无解”（收益值为-INF）来作为[g][j]状态的初始值。即使dp全数组在for g之前已全都置为了-INF，本行代码也必须要写！</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] )  <br>            dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dp[j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题型3每组物品选的物品个数-1个">1.4题型3：每组物品选的物品个数<font color="red">&gt; =</font>1个</h2><p>　　题型3仍然存在题型2中面临的“可能存在无解”的情况。所以，题型2中关于dp[g][0..YS1]初值的设定，对于题型3仍然适用。为了降低初学难度，我们还是以“<strong>在&lt;=YS1的前提下求最大收益值</strong>”为例，来讲解“每组物品选的物品个数&gt;=1个”这种要求的应对策略。</p><p>　　dp[g][j] 表示选前 g 组物品（每组至少选1个）并且限制量不超过j的最大收益值。所求目标为dp[gcnt][YS1]。有两种情况可以转到当前状态[g][j]：</p><ol type="1"><li>在“<strong>第g组还没选择任何物品</strong>”的前提下，第一次选择了第g组的编号为x的物品，则会有:</li></ol><p><span class="math display">\[dp[g][j]= max(\ dp[g][j], \quad dp[g-1][j-ys1[x] ] + value[x]\ );\tag{1}\]</span></p><ol start="2" type="1"><li>在“<strong>已经选择了第g组的某个或者某些物品</strong>”的前提下，现在选择编号为x的物品，则会有:<span class="math display">\[dp[g][j]= max(\ dp[g][j], \quad dp[g][j-ys1[x] ] + value[x]\ );\tag{2}\]</span>既然这两种情况都可能发生，那么最终策略就看哪种方案的值最大，就选哪种方案了。所以最终的状态转移方程是：<span class="math display">\[dp[g][j]= max(\ dp[g][j], \quad dp[g-1][j-ys1[x] ] + value[x]\ , \quaddp[g][j-ys1[x] ] + value[x]\ ); \tag{3}\]</span></li></ol><p>　　公式（3）在转成代码的时候，需要小心！对于编号为x的物品，情况1和情况2是不可能同时存在的。所以公式（3）中的<span class="math inline">\(dp[g-1][j-ys1[x] ] + value[x]\)</span> 和<span class="math inline">\(dp[g][j-ys1[x] ] +value[x]\)</span>这两个策略不可能都执行，在写代码的时候建议采用A=max(max(A,B),C)的方式来写。而且，第1次执行公式（1）时，公式右侧的dp[g][j]存放的应该是该状态的初值“无解”，即-INF。而后续执行该公式时，右侧的dp[g][j]纯粹只是为了实现“多个数据之间的<strong>累计比较</strong>”的效果而已。</p><h3 id="先for-组内物品k再for-j掌握">1.4.1 先for 组内物品k，再forj（掌握）</h3><p>　　下面我们看一个例子，用“先for 组内物品k，后forj”的思路来进一步来加深对公式（３）的理解。</p><p>　　1)处理第1组的1号物品</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723170245209.png"alt="image-20240723170245209" /><figcaption aria-hidden="true">image-20240723170245209</figcaption></figure><p>　　可以看到，第一次填写dp[g][j]时，等式右边的dp[g][j]为“无解”的状态，值为-INF，以方便max运算。</p><p>　　2）处理第1组的4号物品</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723170855857.png"alt="image-20240723170855857" /><figcaption aria-hidden="true">image-20240723170855857</figcaption></figure><p>　　3)处理第2组的2号物品</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723171222171.png"alt="image-20240723171222171" /><figcaption aria-hidden="true">image-20240723171222171</figcaption></figure><p>　　后续对剩余2个物品的处理与上雷同，就不再画图展示了。</p><p>　　需要注意的是，这里j的循环顺序一定是倒序，即从YS1到ys1[i]。这是因为对于每个物品来说，最多只能被选择一次，不能被连续选择2次。这和“一个组内允许选择多个物品”，是不相关的。如下图所示。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723172427927.png"alt="image-20240723172427927" /><figcaption aria-hidden="true">image-20240723172427927</figcaption></figure><p>　　题型3的代码模板如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g &lt;= gcnt; g++ )            <span class="hljs-comment">// 历所有组数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++ ) &#123;   <span class="hljs-comment">// 遍历每组的物品</span><br>        <span class="hljs-type">int</span> i=idx[g][k];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j&gt;=ys1[i]; j--) <span class="hljs-comment">// 此处必须只能倒序，因为有dp[g][...] </span><br><span class="hljs-comment">//      for(int j = ys1[i]; j&lt;=YS1; j++) // 错误！ 每个物品只能被选1次！ 右侧公式里有dp[g][...] ！见帖子说明</span><br>            <span class="hljs-comment">//dp[g][j] = max ( dp[g][j] , max(dp[g-1][j-ys1[i]]+value[i] , dp[g][j-ys1[i]]+value[i]) ); // 和下一行等效，可AC</span><br>            dp[g][j] = <span class="hljs-built_in">max</span> ( <span class="hljs-built_in">max</span>(dp[g][j] , dp[g<span class="hljs-number">-1</span>][j-ys1[i]]+value[i] ), dp[g][j-ys1[i]]+value[i] );<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="先for-j再for-组内物品k-1">1.4.2 先for j，再for 组内物品k</h3><p>　　从公式（3）中可以看到一个我们需要注意的东西，那就是dp[g][j]的值，依赖于dp[g][j-...]的值。换句话说，当前格子的填写，依赖于同行左侧某个格子的填写。这是之前题型1和题型2所没有的情况（这两种题型都是依赖于上一行的值，已确定）。在这种情况下，就需要我们必须要从左往右填写每一排数据，否则左侧格子的值肯定是-INF或者0这种初始值，这样会导致dp[g][j-...]失去对max的参与，无法发挥作用（这一项的作用就是“在已选本组某物品的情况，再选择本组的其他物品”。一旦失效，意味着dp[g][j]无法存放多个物品的累加和）。但是，如果从左往右填写，会带来另外一个问题，那就是“同一个物品，被选择了2次或者无限次”（这是完全背包的典型特征）。</p><p>　　鉴于上面的情况，<strong>请同学们对本题型放弃“先for j，后for组内物品k”的做法</strong>。</p><h1 id="二实战练习">二、实战练习</h1><h2 id="每组最多选1个物品">2.1 1272（每组最多选1个物品）</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1272">1272：【例9.16】分组背包</a></p><h3 id="ac代码">2.1.2 AC代码</h3><p>1.先for j，再for 组内物品k，标准dp数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法2，每组最多选1个，先for j，再for 组内物品k，标准dp数组  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    参考帖子代码（8） </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxYS1 201</span><br><span class="hljs-type">int</span> dp[<span class="hljs-number">11</span>][maxYS1];    <span class="hljs-comment">// dp应该是物品组g和背包容量YS1的函数，所以定义为dp[g][YS1] </span><br><span class="hljs-type">int</span> YS1, n, gcnt;<br><span class="hljs-type">int</span> tot[maxYS1], ys1[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>], value[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>]; <span class="hljs-comment">// ys1[2][4]：第2组的第4个物品的ys1值，value同理 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 录入背包总重量YS1， 物品件数n个，种类gcnt种 </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;YS1, &amp;n, &amp;gcnt);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> W, C, g;         <span class="hljs-comment">//group组 </span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;W, &amp;C, &amp;g);  <span class="hljs-comment">// 重量W，价值C，组号g </span><br>        tot[g]++;                     <span class="hljs-comment">// 第g组的物品个数增加1个 </span><br>        ys1[g][tot[g]] = W;             <span class="hljs-comment">// 第g组的最新个的重量值为W </span><br>        value[g][tot[g]] = C;           <span class="hljs-comment">// 第g组的最新个的价值值为C </span><br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]= <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 每组最多选1个，所以按组来划分阶段。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g = <span class="hljs-number">1</span>; g &lt;= gcnt; g++) <br><span class="hljs-comment">//      for(int j = YS1; j &gt;= 0; j--)   // 标准dp数组，正序逆序都可以 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= YS1; j++)&#123; <br>dp[g][j] = dp[g<span class="hljs-number">-1</span>][j];       <span class="hljs-comment">// 允许本组一个都不选，所以先假定一个都没选  </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= tot[g]; k++) <br>                <span class="hljs-keyword">if</span> ( j &gt;= ys1[g][k] )<br>                    dp[g][j] = <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j - ys1[g][k]] + value[g][k] );<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[gcnt][YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>先for j，再for 组内物品k，滚动dp数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"> <span class="hljs-comment">//// 方法1；每组最多选1个，先for j，再for 组内物品k，滚动dp数组 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    参考帖子代码（10） </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxYS1 201</span><br><span class="hljs-type">int</span> dp[maxYS1];<br><span class="hljs-type">int</span> YS1, n, gcnt;<br><span class="hljs-type">int</span> tot[maxYS1], ys1[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>], value[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <br><span class="hljs-comment">// 录入背包总重量YS1， 物品件数n个，种类gcnt种 </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;YS1, &amp;n, &amp;gcnt);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123; <br>        <span class="hljs-type">int</span> W, C, g;       <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;W, &amp;C, &amp;g);  <span class="hljs-comment">// 重量W，价值C，组号g </span><br>        tot[g]++;                     <span class="hljs-comment">// 第g组的物品个数增加1个 </span><br>        ys1[g][tot[g]] = W;             <span class="hljs-comment">// 第g组的最新个的重量值为W </span><br>        value[g][tot[g]] = C;           <span class="hljs-comment">// 第g组的最新个的价值值为C </span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 每一组物品 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g = <span class="hljs-number">1</span>; g &lt;= gcnt; g++)<br>      <span class="hljs-comment">// dp[g][j]需要用到dp[g-1][...]，且每个物品最多只被选1次，所以若用滚动数组的话，这里必须倒序  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= <span class="hljs-number">0</span>; j--)  <span class="hljs-comment">// 这里没法写j&gt;=ys1[k]了；k在内层。 </span><br><span class="hljs-comment">// 第g组的第k个不同的物品 </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= tot[g]; k++) <br>                <span class="hljs-keyword">if</span> ( j &gt;= ys1[g][k] )<br>                    dp[j] = <span class="hljs-built_in">max</span>( dp[j],  dp[j - ys1[g][k]] + value[g][k] );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>先for 组内物品k，再for j，标准dp数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法3，每组最多选1个，先for 组内物品k，再for j，标准dp数组</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    参考帖子代码（3）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxYS1 201</span><br><span class="hljs-type">int</span> dp[<span class="hljs-number">11</span>][maxYS1];    <span class="hljs-comment">// dp应该是物品组g和背包容量YS1的函数，所以定义为dp[g][YS1]</span><br><span class="hljs-type">int</span> YS1, n, gcnt;<br><span class="hljs-type">int</span> tot[maxYS1], ys1[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>], value[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>]; <span class="hljs-comment">// ys1[2][4]：第2组的第4个物品的ys1值，value同理</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 录入背包总重量YS1， 物品件数n个，种类gcnt种</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;YS1, &amp;n, &amp;gcnt);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> W, C, g;         <span class="hljs-comment">//group组</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;W, &amp;C, &amp;g);  <span class="hljs-comment">// 重量W，价值C，组号g</span><br>        tot[g]++;                     <span class="hljs-comment">// 第g组的物品个数增加1个</span><br>        ys1[g][tot[g]] = W;             <span class="hljs-comment">// 第g组的最新个的重量值为W</span><br>        value[g][tot[g]] = C;           <span class="hljs-comment">// 第g组的最新个的价值值为C</span><br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 每组最多选1个，所以按组来划分阶段。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>            dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=tot[g]; k++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[g][k]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>                dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[g][k]] + value[g][k] );<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4d&quot;</span>, dp[g][j]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <br>    <br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[gcnt][YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>先for 组内物品k，再for j，滚动dp数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法4；每组最多选1个，先for 组内物品k，再for j，滚动dp数组</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    参考帖子代码（5）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxYS1 201</span><br><span class="hljs-type">int</span> dp[maxYS1], dptmp[maxYS1];<br><span class="hljs-type">int</span> YS1, n, gcnt;<br><span class="hljs-type">int</span> tot[maxYS1], ys1[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>], value[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 录入背包总重量YS1， 物品件数n个，种类k种</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;YS1, &amp;n, &amp;gcnt);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> W, C, g;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;W, &amp;C, &amp;g);  <span class="hljs-comment">// 重量W，价值C，组号g</span><br>        tot[g]++;                     <span class="hljs-comment">// 第g组的物品个数增加1个</span><br>        ys1[g][tot[g]] = W;             <span class="hljs-comment">// 第g组的最新个的重量值为W</span><br>        value[g][tot[g]] = C;           <span class="hljs-comment">// 第g组的最新个的价值值为C</span><br>    &#125;<br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++) &#123;<br>        <span class="hljs-comment">// 用dptmp[0..YS1]来存dp[g-1][0..YS1] </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>            dptmp[j]= dp[j];<br>        <span class="hljs-comment">// 不需要再“照抄上一行数据”了，下面的写法已经隐含地包括了对“不选任何物品”这个选择的max比较了</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=tot[g]; k++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[g][k]; j--)  <span class="hljs-comment">// 必须只能倒序！</span><br>                <span class="hljs-comment">// dptmp[]表示的是dp[g-1][] </span><br>                dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dptmp[j-ys1[g][k]] + value[g][k] );<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　<a href="https://www.luogu.com.cn/problem/P1757">P1757通天之分组背包</a>和本题几乎完全一样，只是录入稍有差异。可作为复习巩固之用。</p><h2 id="p5322每组最多选1个物品">2.2 P5322（每组最多选1个物品）</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P5322">P5322 [BJOI2019]排兵布阵</a></p><p>　　简明题意如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++">   简明题意<br>       你有m个士兵，可以把它们随意分配到 n 个城堡里，在每个城堡中，你需要挑战城堡内的所有<br>   对手，如果在第 i 个城堡的一次挑战中你的士兵个数 &gt; 对手士兵个数 * <span class="hljs-number">2</span>，该场你就获得了i 分；<br>如果挑战失败，该场你获得<span class="hljs-number">0</span>分。已知对手们在每个城堡的士兵人数，求你能获得的总得分的最大值。<br>样例分析：<br>输入： <br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">10</span>  （除我之外还有<span class="hljs-number">2</span>个玩家，<span class="hljs-number">3</span>个城堡，我有<span class="hljs-number">10</span>个士兵） <br><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span>   （第<span class="hljs-number">1</span>个玩家对三个城堡的出兵数量分别为 <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span>） <br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>   （第<span class="hljs-number">1</span>个玩家对三个城堡的出兵数量分别为 <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>）<br>输出：<br><span class="hljs-number">8</span>分<br>解释：我的对三个城堡的出兵数量分别为 <span class="hljs-number">1</span>人   <span class="hljs-number">5</span>人   <span class="hljs-number">1</span>人 <br>这样的话，和第一个玩家PK，赢第<span class="hljs-number">2</span>个城堡得<span class="hljs-number">2</span>分 <br>  和第二个玩家PK，赢第<span class="hljs-number">1</span>个城堡得<span class="hljs-number">1</span>分、赢第<span class="hljs-number">2</span>个城堡得<span class="hljs-number">2</span>分、 赢第<span class="hljs-number">3</span>个城堡得<span class="hljs-number">3</span>分<br>所以一共得<span class="hljs-number">2</span>+<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3</span>=<span class="hljs-number">8</span>分<br>这是得最高分的策略了 <br></code></pre></td></tr></table></figure><h3 id="分析">2.2.2 分析</h3><p>　　首先我们需要搞清楚一个事情，这个题为什么是分组背包而不是贪心？我们可以来看看如下的反例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">  如果要尽量贪心，那么就应该尽可能获得编号值较大的城堡内的挑战胜利，在该城堡内也尽可能获得较多的胜利场次；<br>  反例（1）输入： <br>2 5 21  （除我之外还有2个对手玩家，3个城堡，我有21个士兵） <br>1 1 1 1 10   （第1个对手对三个城堡的出兵数量分别为 1 1 1 1 10） <br>0 0 0 0 0    （第2个对手对三个城堡的出兵数量分别为 0 0 0 0 0）<br>  错误的贪心策略：在编号最大的第5个城堡安排2×10+1=21个士兵（用光），获得2场胜利，得到2×5=10分；<br>  正确的策略：在1～4号城堡分别安排3个士兵，共12个士兵，获得1～4号城堡的8场胜利，共得2+4+6+8=20分；还剩9个士兵安排在5号城堡，获得一场胜利，得5分。所有共计25分。<br><br>  从这个例子可以看出，虽然想尽可能获得编号值较大的城堡里的挑战胜利，但是否真能如愿，完全取决于该城堡里的各玩家的士兵人数情况。而士兵人数情况是存在很大的不确定性的。有可能很轻松就拿下该城堡内所有场次的胜利，也有可能非常困难，得不偿失。在这种情况下，如果一味地想着去贪这种胜利，绝对是错误的策略。<br><br>  既然如此，那是不是在本题中就完全用不上一点点贪心呢？那也不是。<br>  当你已经在某个城堡里打败了所有的对手，那就没有必要再往这个城堡里安排更多的士兵了，而应该把剩余的士兵安排去征服其他的城堡。<br></code></pre></td></tr></table></figure><p>　　根据上面所述的贪心规则，我们完全可以针对每个城堡内敌方的士兵情况，计算出要获得每场胜利所需的最少士兵人数，作为我们的决策。例如在反例（1）中，我们如果想在第1个城堡打败对手2，只需要派1人入驻即可；但如果我们需要打败对手1，则需要派遣3个士兵入驻（这3个士兵同时也能打败对手2）。</p><p>　　对于城堡1，摆在我们面前的结果其实就3种：躺平放弃；打败对手2；打败对手1和对手2。<strong>这三种策略分别对应着“不派遣士兵；派遣1个士兵；派遣3个士兵”这3种策略，带来的收益则分别是“在城堡1内2场挑战两场全输共得0分；在城堡1内2场挑战一胜一负共得1分；在城堡1内2场挑战两场全胜共得2分；”</strong>分析到这里，可能有些同学已经领悟过来了，这不就是分组背包中的题型1（每组最多选1个）吗？</p><p>　　假设第i个城堡有 5个对手，分别在该城堡里入驻了ys1[1..5]={10,20,5,3,5}个士兵，那么除了“不派遣”这个策略之外，我们面临的其他派遣策略就是{21,41,11,7,11}这一共5个策略。如果我们现在选择“战胜第k=1个对手，即派遣21个士兵”这个策略，那么在第i个城堡里可以赢几场呢？这需要我们拿着21去和{21,41,11,7,11}数组中的每个数去比较，累计而得。这挺麻烦的。一个简单的优化就是：我们可以事先对ys1[]进行递增排序，得到ys1[1..5]={3,5,5,10,20}。在这种情况下，如果我们选择“战胜对手1（派遣7人）”，则可以胜1场，获得1×i=i分；如果我们选择“战胜对手4（派遣21人）”，则可以胜4场（战胜对手1、2、3、4），获得4×i=4i分；如果我们选择“战胜对手k（派遣2*ys1[k]+1人）”，则可以胜k场，获得k×i分。经过排序之后，我们可以很方便地获得一个组内的“获胜场次”值k，从而优化代码。</p><p>　　可能有些同学已经看到了ys1[1..5]={3,5,5,10,20}中有两个5。当我们选择第1个5时，k=2，我们认为我们战胜了对手1和对手2，但实际上我们也战胜了对手3。那获胜场次这样计算是否有误呢？仔细思考，其实不影响答案。因为在dp[g][j]=max(dp[g][j],dp[g][j-(2*5+1)]+1*g, dp[g][j-(2*5+1)]+2*g,...)的运算中，dp[g][j-(2*5+1)]+1*g &lt;dp[g][j-(2*5+1)]+2*g，所以dp[g][j-(2*5+1)]+1*g是不会对dp[g][j]的运算结果产生任何影响的。</p><h3 id="ac代码-1">2.2.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-comment">//#define MAX(A,B) ((A)&gt;(B)?(A):(B))       // 自己打MAX比调用max的确要快一丁点 </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">设 dp[j]表示玩家(在第g个城堡)放j个士兵可以获得的最大分数。a[g][k]表示在第g个</span><br><span class="hljs-comment">    城堡时s个玩家中出兵数量第k大的玩家的出兵数量（这样设计有利于算出得分。一共有gcnt个城堡，</span><br><span class="hljs-comment">    相当于就是gcnt个分组。对于每一个城堡，s个玩家有s个出兵</span><br><span class="hljs-comment">数。在和这s个玩家中的任一个进行两两对决时，我只需要出对方数量的两倍多1即可，也</span><br><span class="hljs-comment">就是说，我面对这个玩家，我的策略是a[g][k] * 2 + 1。一共有s个玩家，也就是说，我有</span><br><span class="hljs-comment">s个策略数量可供我选择。这就是我在这一个城堡（分组）内可供选择的策略的成本。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">与之对应，这些策略的收益是得分。战胜当前玩家，我能获得第g个城堡的g分；同时，</span><br><span class="hljs-comment">因为还有k-1个玩家的出兵数少于当前玩家（因为当前玩家的出兵数是第k小），所以我的</span><br><span class="hljs-comment">这个出兵数还能超过这k-1个玩家出兵数的2倍，故我这个策略能使我在第g个城堡的对抗中</span><br><span class="hljs-comment">面对其他玩家，再得(k-1)*g分，所以我这个策略实际有k*g分的收益。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">归纳地说，gcnt个分组，每组内s个决策，每个决策的成本是a[g][k]*2+1人，收益是k*g分 </span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">dp转移方程即为： </span><br><span class="hljs-comment">dp[j] = max( dp[j - a[g][k]*2 - 1] + k * g,   dp[j]);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> s , gcnt, YS1, ans;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">20002</span>];     <span class="hljs-comment">// 滚动dp[]，玩家(在第i个城堡)放j个士兵可以获得的最大分数</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>];   <span class="hljs-comment">// 第i个城堡时s个玩家中出兵数量第k大的玩家的出兵数量</span><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;s, &amp;gcnt, &amp;YS1);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=s; ++k)         <span class="hljs-comment">// s个玩家 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; ++g)  <span class="hljs-comment">// gcnt个城堡 </span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[g][k]);  <span class="hljs-comment">// 反过来存储，以便于等会对每个城堡，按照玩家来进行增序排序 </span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; ++g)<br><span class="hljs-built_in">sort</span>(a[g]+<span class="hljs-number">1</span>, a[g]+<span class="hljs-number">1</span>+s);     <span class="hljs-comment">// 对每个城堡，让s个玩家的出兵数做递增排序，以便于后续统计得分 </span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; ++g)      <span class="hljs-comment">// 枚举分组：gcnt个城堡，就相当于是gcnt个分组 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; --j) <span class="hljs-comment">// 枚举背包容量：倒序枚举派出的兵数 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=s; ++k) <span class="hljs-comment">// 枚举组内策略：对每个城堡，我可以选择s个玩家出兵数的2倍以上，即对这个分组我有s个策略可以选择 </span><br><span class="hljs-keyword">if</span>( j &gt; a[g][k]*<span class="hljs-number">2</span> ) <span class="hljs-comment">// </span><br><span class="hljs-comment">// 每个决策的成本是a[g][k]*2+1，收益是k*g，详情解释见上面的说明 </span><br>dp[j] = <span class="hljs-built_in">max</span>(dp[j-a[g][k]*<span class="hljs-number">2</span><span class="hljs-number">-1</span>]+k*g, dp[j]);<br><span class="hljs-comment">//for(int g=1;g&lt;=gcnt;g++)</span><br><span class="hljs-comment">//for(int j=YS1;j&gt;=0;j--)&#123;</span><br><span class="hljs-comment">//dp[g][j]=dp[g-1][j];//要在枚举 k 的循环外继承。</span><br><span class="hljs-comment">//for(int k=1;k&lt;=s;k++)</span><br><span class="hljs-comment">//if(j&gt;=a[g][k]*2+1)dp[i][j]=max(dp[i][j],dp[i-1][j-a[i][k]*2-1]+k*i);</span><br><span class="hljs-comment">//&#125;</span><br>    <span class="hljs-comment">// 给我的YS1个士兵，我可以不全部放完。反正求出最大值即可。就算放多了，也不会影响得分。 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=YS1; ++i) <br>ans=<span class="hljs-built_in">max</span>(ans, dp[i]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="p2409每组只能选1个物品不能多不能少">2.3P2409（每组只能选1个物品，不能多、不能少）</h2><h3 id="原题链接-2">2.3.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P2409">P2409Y的积木</a></p><h3 id="分析-1">2.3.2 分析</h3><p>　　这个题要求方案数，dp[g][j] = t表示前g个盒子各抽1个积木凑成==j斤积木的组合方案个数是4种。既然表示的是方案数，所以在转移方程中应该是“累加”，而不应该是“累比”。因为是“恰好等于j”，并且还要求每组必须要选，所以对状态[g][j]可能存在无解的情况，所以所有方案数的初始dp值建议设置为0，表示“暂时认为没有任何方案”，即“无解”。</p><p>　　特例情况是“前0个盒子中各抽1个积木，凑成恰好0斤重量，其组合的方案数为1种（dp[0][0]=1;），即'什么积木都不放'（因为是在0个盒子中选，所以不必遵守‘每个盒子都必须选1个’的规定了，因为连盒子都没有）。”</p><p>　　所求目标：一言难尽，看代码。</p><p>　　关于状态转移方程，因为本题的dp数组存放的是方案数，而不是最大值，所以状态转移方程中并没有max或者min，而是用‘+’。现在不能直接套用1.3节中的代码模板，那该怎么做呢？我们可以用一个实际样例来分析看看。有时候把数字具体化，推导起来会更方便，更容易看到一些关系。样例推导过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//    分组背包，每组必须要放1个物品，不能多，不能少</span><br><span class="hljs-comment">//    dp[3][6] = 4 表示前3个盒子各抽1个积木凑成6斤积木的组合方案个数是4种.</span><br><br>    对于第g组的处理：<br>    <span class="hljs-number">1.</span> 如果先<span class="hljs-keyword">for</span> j，再<span class="hljs-keyword">for</span> k（即针对每个状态[g][j]，去考虑它由哪些数值累加而成）<br>        假设第g组(盒)的物品(积木)的重量分别依次是 <span class="hljs-number">10</span>、 <span class="hljs-number">50</span>、 <span class="hljs-number">100</span>和 <span class="hljs-number">580</span>。那么：<br>        <span class="hljs-number">1</span>）对于[g][<span class="hljs-number">300</span>]    <br>            <span class="hljs-comment">// 重量为580的那个积木无法装入，不考虑它</span><br>            dp[g][<span class="hljs-number">300</span>] = dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">290</span>] +  dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">250</span>] + dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">200</span>] <span class="hljs-comment">// 如果不懂这行的由来，请看本站关于背包方案数的专帖后再回来学本帖。 </span><br>            上面的累加式子演变成代码的话，如下所示：<br>            dp[g][<span class="hljs-number">300</span>] = <span class="hljs-number">0</span>;              <span class="hljs-comment">// 初始化[g][300]为&quot;无解&quot;状态</span><br>            dp[g][<span class="hljs-number">300</span>] += dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">290</span>];  <span class="hljs-comment">// 开始累加, 300&gt;=290</span><br>            dp[g][<span class="hljs-number">300</span>] += dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">250</span>];  <span class="hljs-comment">//   300 &gt;=250</span><br>            dp[g][<span class="hljs-number">300</span>] += dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">200</span>];  <span class="hljs-comment">// 300&gt;=200 </span><br>            <span class="hljs-comment">// ......直到本组内所有j&gt;=ys1[]的积木都考虑完，则结束累加的循环</span><br><br>        <span class="hljs-number">2</span>）对于[g][<span class="hljs-number">5</span>]<br>            <span class="hljs-comment">//因为本组内的4个物品的ys1[]值都&gt;5，所以本组内的所有积木都不考虑装入</span><br>            dp[g][<span class="hljs-number">5</span>] = 空气 + 空气（哈哈）<br>            演变成代码就是    <br>            dp[g][<span class="hljs-number">5</span>] = <span class="hljs-number">0</span>;                <span class="hljs-comment">// 初始化[g][5]为&quot;无解&quot;状态 </span><br>            <span class="hljs-comment">// 累加循环一次都不做，直接略过</span><br><br>        对上面的<span class="hljs-number">1</span>）和<span class="hljs-number">2</span>）进行总结后，得到代码模板如下：<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--) <span class="hljs-comment">// YS1是通过计算而得</span><br>            dp[g][j]= <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化状态[g][j]的方案数为0（即“无解”），而不是来源于dp[g-1][j] ！！ </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=ys1[g][<span class="hljs-number">0</span>]; k++)   <span class="hljs-comment">//组内枚举每个物品，ys1[g][0]表示该组内物品的个数</span><br>                <span class="hljs-keyword">if</span> ( j &gt;= ys1[g][k] ) <span class="hljs-comment">//先判断能不能放</span><br>                    <span class="hljs-comment">// 和以往的背包问题中求最大值最小值不同，本题背包问题是求累加和！</span><br>                    <span class="hljs-comment">// 第一次累加时，dp[g][j]原值为0，表示所有方案数都来自于dp[g-1][ j-ys1[g][...] ] </span><br>                    dp[g][j] = dp[g][j] + dp[g<span class="hljs-number">-1</span>][ j-ys1[g][k] ];<br><br>    <span class="hljs-number">2.</span> 如果先<span class="hljs-keyword">for</span> k，再<span class="hljs-keyword">for</span> j（即针对组内的每<span class="hljs-number">1</span>个物品，去填写或者修正dp数组第g排的所有元素）<br>    对于第g组的第k个物品（假设重量为<span class="hljs-number">580</span>），它不可能装入容量为<span class="hljs-number">300</span>斤或者<span class="hljs-number">5</span>斤的背包中，只可能装入容量&gt;=<span class="hljs-number">580</span>的背包中。所以在填写或者修正dp[g][YS1.<span class="hljs-number">.1</span>]时，不需要<span class="hljs-keyword">for</span>\(<span class="hljs-type">int</span> j=YS1, j&gt;=<span class="hljs-number">1</span>; j--)，只需要<span class="hljs-keyword">for</span>\(<span class="hljs-type">int</span> j=YS1, j&gt;=ys1[idx[g][k]]; j--)即可。假设YS1=<span class="hljs-number">1000</span>， 对于本组内重量为<span class="hljs-number">580</span>的物品，只需要处理dp[g][<span class="hljs-number">1000.</span><span class="hljs-number">.580</span>]即可。而对于dp[g][<span class="hljs-number">1.</span><span class="hljs-number">.579</span>]的这些元素值，仍保留原来的数值即可（不管是为初值<span class="hljs-number">0</span>（无解）或者其他数值，这样处理都是合理的）<br>        代码模板如下：<br>        <span class="hljs-comment">///// 参考本帖代码（11），组内必须选1件，先for K 再 for j，标准dp数组，求方案数，初始化为“无解 ” </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>        dp[g][j]= <span class="hljs-number">0</span>;    <span class="hljs-comment">// 默认[g][j]状态暂时无解，方案数为0。当然，也可以用memset或者直接设置为全局数组以自动清0，这样就可以不用写这个for循环了</span><br>        <span class="hljs-comment">// 开始循环累加</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=ys1[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[g][k]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>        dp[g][j]=  dp[g][j] + dp[g<span class="hljs-number">-1</span>][ j-ys1[g][k] ];<br><br></code></pre></td></tr></table></figure><p>　　本题有个小坑点，那就是关于方案数爆int和longlong的问题。同学们一定要小心，一般来说，方案数都是一个很大的数字。所以一旦题目中涉及到要求方案数，一定要注意爆int或者爆longlong的问题。本题如果不特别处理，最后一个subtask会爆longlong。处理方法也很简单，就是不让dp[g][j]的值超过k。为什么可以这样做呢？因为本题要输出dp最后一排各个元素中非零元素的下标（若dp[g][j]==5，则要输出5个j值），如果某一个dp[g][j]的值&gt;k了，的确没必要再去保存精确数值了，对输出的结果无任何影响。</p><h3 id="ac代码-2">2.3.3 AC代码</h3><h4 id="先for-组内物品k后for-j">2.3.3.1 先for 组内物品k，后for j</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 方法1： 分组背包，每组必须要放1个物品，标准状态数组，先for 组内物品k 再forj，恰好等于，方案数 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// ys1[3][5]=12, 表示第3组的第5个积木的约束1属性值（重量）是12</span><br><span class="hljs-comment">// ys1[3][0]=13, 表示第3组内一共有13个物品，存储本组物品个数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxg=<span class="hljs-number">101</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxYS1=<span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> ys1[maxg][<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> dp[maxg][maxYS1]; <span class="hljs-comment">// dp[3][6] = 4 表示前3个盒子各抽1个积木凑成6斤积木的组合方案个数是4种. </span><br><span class="hljs-type">int</span> K, gcnt, YS1;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;gcnt, &amp;K);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++) &#123;<br>        <span class="hljs-comment">// 第i组的物品个数存于ys1[i][0]</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;ys1[g][<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> maxa = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=ys1[g][<span class="hljs-number">0</span>]; j++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;ys1[g][j]);<br>            maxa = <span class="hljs-built_in">max</span>(maxa, ys1[g][j]);<br>        &#125;<br>        <span class="hljs-comment">// 本题中的YS1没有直接被告知，找出每组内的最大值，加起来</span><br>        <span class="hljs-comment">// 每个盒子抽取1个积木，加起来的总重量肯定不会超过YS1=每组中积木的最大重量之和</span><br>        YS1 += maxa;<br>    &#125;<br>    <span class="hljs-comment">// 前0个盒子各抽1个积木凑成&lt;=0斤积木的组合方案个数是1种（=不抽）.</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++)&#123; <span class="hljs-comment">//控制组数</span><br>        <span class="hljs-comment">///// 参考本帖代码（11），组内必须选1件，先for K 再 for j，标准dp数组，求方案数，初始化为“无解 ” </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>        dp[g][j]= <span class="hljs-number">0</span>;    <span class="hljs-comment">// 默认[g][j]状态暂时无解，方案数为0。当然，也可以用memset或者直接设置为全局数组以自动清0，这样就可以不用写这个for循环了</span><br>        <span class="hljs-comment">// 开始循环填写dp</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=ys1[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[g][k]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>        dp[g][j]=  dp[g][j] + dp[g<span class="hljs-number">-1</span>][ j-ys1[g][k] ], dp[g][j] = <span class="hljs-built_in">min</span>(dp[g][j], K);<br>    &#125;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=YS1; i++)&#123;<br>        <span class="hljs-comment">// 打印dp[gcnt][i]个i（在没数到K个之前）</span><br>        <span class="hljs-keyword">while</span>( dp[gcnt][i])&#123;<br>            cout &lt;&lt;i &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            dp[gcnt][i]--;<br><br>            j++;<br>            <span class="hljs-keyword">if</span> (j==K) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法对应的滚动数组模式的代码，请参看本帖的代码（12），此处略过。</p><h4 id="先for-j-再for-组内物品k">2.3.3.2 先for j 再for 组内物品k</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 方法2： 分组背包，每组必须要放1个物品，标准状态数组，先for j 再for 组内物品k，恰好等于，方案数 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// ys1[3][5]=12, 表示第3组的第5个积木的约束1属性值（重量）是12</span><br><span class="hljs-comment">// ys1[3][0]=13, 表示第3组内一共有13个物品，存储本组物品个数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxg=<span class="hljs-number">101</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxYS1=<span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> ys1[maxg][<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> dp[maxg][maxYS1];  <span class="hljs-comment">// dp[3][6] = 4 表示前3个盒子各抽1个积木凑成6斤积木的组合方案个数是4种.</span><br><span class="hljs-type">int</span> k, gcnt, YS1;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;gcnt, &amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++) &#123;<br>        <span class="hljs-comment">// 第i组的物品个数存于ys1[i][0]</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;ys1[g][<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> maxa = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=ys1[g][<span class="hljs-number">0</span>]; j++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;ys1[g][j]);<br>            maxa = <span class="hljs-built_in">max</span>(maxa, ys1[g][j]);<br>        &#125;<br>        <span class="hljs-comment">// 本题中的YS1没有直接被告知，找出每组内的最大值，加起来</span><br>        <span class="hljs-comment">// 每个盒子抽取1个积木，加起来的总重量肯定不会超过YS1=每组中积木的最大重量之和</span><br>        YS1 += maxa;<br>    &#125;<br>    <span class="hljs-comment">// 前0个盒子各抽1个积木凑成&lt;=0斤积木的组合方案个数是1种（=不抽）.</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++)    <span class="hljs-comment">// 控制组数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--) <span class="hljs-comment">// YS1是通过计算而得</span><br>            dp[g][j]= <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化状态[g][j]的方案数为0（即“无解”），而不是来源于dp[g-1][j] ！！ </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=ys1[g][<span class="hljs-number">0</span>]; k++) <span class="hljs-comment">//组内枚举每个物品k</span><br>                <span class="hljs-keyword">if</span> ( ys1[g][k] &lt;= j )       <span class="hljs-comment">//先判断能不能放</span><br>                    <span class="hljs-comment">// 和以往的背包问题中求最大值最小值不同，本题背包问题是求累加和！</span><br>                    dp[g][j] = dp[g][j] + dp[g<span class="hljs-number">-1</span>][ j-ys1[g][k] ], dp[g][j] = <span class="hljs-built_in">min</span>(dp[g][j], k);;<br><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=YS1; i++)&#123;<br>        <span class="hljs-comment">// 打印dp[gcnt][i]个i（在没数到K个之前）</span><br>        <span class="hljs-keyword">while</span>( dp[gcnt][i])&#123;<br>            cout &lt;&lt;i &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            dp[gcnt][i]--;<br><br>            j++;<br>            <span class="hljs-keyword">if</span> (j==K) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法对应的滚动数组模式的代码，请参看本帖的代码（14），此处略过。</p><h2 id="hdu3033每组至少选择1个物品">2.4HDU3033（每组至少选择1个物品）</h2><h3 id="原题链接-3">2.4.1 原题链接</h3><p>　　<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3033">HDU3033I love sneakers!</a></p><p>题意：</p><p>　　一个人去买运动鞋，他手里拥有的钱为<spanclass="math inline">\(YS1(1 \leq YS1 \leq 10000)\)</span>，运动鞋有<span class="math inline">\(gcnt(1 \leq gcnt \leq10)\)</span>种品牌，每种品牌都可能有多双运动鞋，并且对于每种品牌，他都至少要买一双。</p><p>　　输入的数据包含多组测试样例，直到输入的数据文件结束为止。对于每组测试样例，依次输入<spanclass="math inline">\(n(1 \leq n\leq100)\)</span>双运动鞋，YS1值和gcnt值。后面跟着n行数据，每行数据依次为第<spanclass="math inline">\(\ i\ (1 \leq i \leqn)\)</span>双运动鞋所属的品牌号<span class="math inline">\(g[i](1 \leqg[i]\leq gcnt)\)</span>，价格<span class="math inline">\(ys1[i](0 \leqys1[i]\leq 10^5)\)</span>，价值<span class="math inline">\(value[i](0\leq value[i]\leq10^5)\)</span>。输出能获得的最大价值，如果本测试样例无解，输出"Impossible"。</p><h3 id="分析-2">2.4.2 分析</h3><p>　　1)根据“输入的数据包含多组测试样例，直到输入的数据文件结束为止”，可以得到，代码主框架肯定如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>( <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n, &amp;YS1, &amp;gcnt) != EOF ) &#123;<br>        ........<br>&#125;<br></code></pre></td></tr></table></figure><p>　　2)本题是“组内至少要选择1件物品+求最大收益值”的类型，可能存在无解。所以dp数组应初始化为“无解”，即dp[g][j]=-INF。对于本题来说，因为所有收益值都是正数，所以也可以初始化为0，不影响max函数的运行结果。若初始化为-INF，则需要小心第0行应该是全0。</p><p>　　3）关于“测试样例无解”，该怎么理解呢？如果给你10元钱，让你去买飞机坦克大炮，你能买得回来吗？肯定不行。换句话说，每组都有一个最廉价的物品，如果手里的钱不够买所有组内最廉价的物品，那就是无解了。所以我们可以找出每组内最低的价格，累加得到一个购买所有组物品的的最低价。如果给予的钱YS1少于这个最低价，则必然无法购买所有组的物品，即无解，输出“Impossible”。</p><p>　　4）本题要求支持多组样例。所以在每组样例录入前，一定要记得对各种数组进行复位或者重置。</p><h3 id="ac代码-3">2.4.3 AC代码</h3><p>根据分析，这种题型只能采用“先for 组内物品k，再for j”的思路来做。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 一共100双鞋子以内，1万元以内的成本，最多10个品牌 </span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">101</span>, maxYS1=<span class="hljs-number">10001</span>, maxg=<span class="hljs-number">11</span>;<br><span class="hljs-type">int</span> n, YS1, gcnt;<br><span class="hljs-type">int</span> ys1[maxn], value[maxn];<br><span class="hljs-type">int</span> minys1[maxg];  <span class="hljs-comment">// 每组内最小的物品约束量（每组内最便宜的鞋价） </span><br><span class="hljs-comment">// 分组背包专用的下标转换数组</span><br><span class="hljs-comment">// idx[3][5]=14 表示第3组第5个物品在所有物品列表中的下标是14 </span><br><span class="hljs-type">int</span> idx[maxg][maxn];<br><span class="hljs-comment">// dp[3][200]=480 表示前3组物品按照约束要求（每组至少必须买1个），</span><br><span class="hljs-comment">//       在200元约束范围内能获得的最大价值是480元 </span><br><span class="hljs-type">int</span> dp[maxg][maxYS1];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">while</span>( <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n, &amp;YS1, &amp;gcnt) != EOF ) &#123;<br><span class="hljs-comment">// 因为会有多组案例，所以一定要把历史数据清空干净！ </span><br><span class="hljs-built_in">memset</span>(minys1, INF, <span class="hljs-built_in">sizeof</span>(minys1));  <span class="hljs-comment">// 最小值数组要初始化为最大值 </span><br><span class="hljs-built_in">memset</span>(idx, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(idx));<br><span class="hljs-comment">// 如果嫌弃下面这两行有点罗嗦的话，也可以直接让整个dp数组全0，毕竟所有收益值都是整数，0值已经足够小 </span><br><span class="hljs-built_in">memset</span>(dp, -INF, <span class="hljs-built_in">sizeof</span>(dp));         <br><span class="hljs-built_in">memset</span>(dp[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp[<span class="hljs-number">0</span>]));     <span class="hljs-comment">// dp[0][0..YS1]必须要全0 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-comment">// 录入每双鞋所属的品牌编号，需耗成本和价值 </span><br><span class="hljs-type">int</span> g; <br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;g, &amp;ys1[i], &amp;value[i] );<br>++idx[g][<span class="hljs-number">0</span>];<br>idx[g][ idx[g][<span class="hljs-number">0</span>] ] = i;       <span class="hljs-comment">// 第g组第idx[g][0]个鞋子在所有物品中的下标序号是 i </span><br>minys1[g] = <span class="hljs-built_in">min</span> ( minys1[g], ys1[i]);  <span class="hljs-comment">// 记录第g组最小的需耗成本，这个数据不必初始化为最大 </span><br>&#125;<br><span class="hljs-comment">// x表示要每个品牌买一双鞋最起码一共需要多少钱 </span><br><span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=gcnt; i++) <br>x += minys1[i];<br><br><span class="hljs-comment">// 所带的钱不够每个品牌买1双</span><br><span class="hljs-keyword">if</span> ( YS1 &lt; x ) <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Impossible\n&quot;</span>);<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g &lt;= gcnt; g++ )            <span class="hljs-comment">// 历所有组数 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++ )&#123;    <span class="hljs-comment">// 遍历每组的物品 </span><br><span class="hljs-type">int</span> i=idx[g][k];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j&gt;=ys1[i]; j--) <span class="hljs-comment">// 倒序遍历约束量YS1 </span><br><span class="hljs-comment">//                  for(int j = ys1[i]; j&lt;=YS1; j++) // 错误！ 每个物品只能被选1次！ 右侧公式里有dp[g][...] ！见帖子说明 </span><br><span class="hljs-comment">//dp[g][j] = max ( dp[g][j] , max(dp[g-1][j-ys1[i]]+value[i] , dp[g][j-ys1[i]]+value[i]) ); // 和下一行等效，可AC </span><br>dp[g][j] = <span class="hljs-built_in">max</span> ( <span class="hljs-built_in">max</span>(dp[g][j] , dp[g<span class="hljs-number">-1</span>][j-ys1[i]]+value[i] ), dp[g][j-ys1[i]]+value[i] );<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dp[gcnt][YS1]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">// dp[3][200]=480 表示前3组物品在200元约束范围内能获得的最大价值是480元 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">(1)</span><br><span class="hljs-comment">5 15 3</span><br><span class="hljs-comment">1 4 5</span><br><span class="hljs-comment">2 5 10</span><br><span class="hljs-comment">3 4 100</span><br><span class="hljs-comment">1 5 70</span><br><span class="hljs-comment">2 7 50</span><br><span class="hljs-comment">ans:</span><br><span class="hljs-comment">180</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">(2)</span><br><span class="hljs-comment">3 5 3</span><br><span class="hljs-comment">1 2 5</span><br><span class="hljs-comment">2 2 1</span><br><span class="hljs-comment">3 2 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">3 5 3</span><br><span class="hljs-comment">1 0 5</span><br><span class="hljs-comment">2 0 1</span><br><span class="hljs-comment">3 0 2</span><br><span class="hljs-comment">ans:</span><br><span class="hljs-comment">Impossible</span><br><span class="hljs-comment">8</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">(3)</span><br><span class="hljs-comment">3 5 3</span><br><span class="hljs-comment">1 6 0</span><br><span class="hljs-comment">2 0 0</span><br><span class="hljs-comment">3 0 0</span><br><span class="hljs-comment">3 5 3</span><br><span class="hljs-comment">1 0 5</span><br><span class="hljs-comment">2 0 1</span><br><span class="hljs-comment">3 0 2</span><br><span class="hljs-comment">3 5 3</span><br><span class="hljs-comment">1 0 0</span><br><span class="hljs-comment">2 0 0</span><br><span class="hljs-comment">3 0 0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">ans：</span><br><span class="hljs-comment">Impossible</span><br><span class="hljs-comment">8</span><br><span class="hljs-comment">0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span> <br></code></pre></td></tr></table></figure><p>如果需要用滚动数组来做的话，则需要定义一个dptmp[]来存放上一组的结果。之前已经分析过，这里就不再赘述了。</p><h2 id="hdu3535混合分组背包的典型题">2.5HDU3535(混合分组背包的典型题)</h2><h3 id="原题链接-4">2.5.1 原题链接</h3><p>　　<a href="https://acm.hdu.edu.cn/showproblem.php?pid=3535">hdu3535AreYouBusy</a></p><p>　　题目中文意思和解读如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">问题描述<br>新学期快乐！<br>到了三年级之后，小A意识到她没有太多时间来解决问题，因为她还有其他事情要做，这使她几乎发疯了。<br>而且，老板告诉她，对于某些工作集合（是一个“分组”），她必须选择组内的至少一项工作；但是对于某些工作集合而言，她则最多只能选择组内的一项工作。这对老板来说毫无意义。对于其他的工作集合，她可以尽自己的意愿，不选或者选做其中的任意多项工作。我们只将她可以选择的东西定义为“工作”。每1个工作都需要时间，并给xiaoA带来一些幸福感（这意味着她总是愿意做这些工作）。因此，您可以选择其中的最佳组合来给她带来最大的幸福快乐点，同时也可以成为一个好的初中生。 （这意味着她应该听老板的建议）？<br><br>输入项<br>下面有几套测试用例，每套测试用例都以两个整数n和T（0 &lt;= n，T &lt;= 100）开头，有n组作业供您选择，由T分钟供她完成。然后后面是n个描述集，每个描述都以两个整数m和s（0 &lt;m &lt;= 100）开头，该集合中有m个作业，集合类型为s，（0代表应选择的集合至少要完成1项工作，对于最多应选择1项的集合要进行1项选择，可以自由选择的项要进行2项选择。），然后后面是m对整数ci，gi（0 &lt;= ci，gi &lt;= 100），表示第i个工作成本为ci分钟，可以通过完成它获得幸福感gi。每一项工作只能做一次。<br> 输出量<br>每个测试用例一行包含我们可以从所有工作中选择的最大幸福值。如果她不能完成老板想要的工作，则输出-1。<br> 样本输入<br>3 3     第1套用例内有3组作业，要求在3分钟内完成<br>2 1        第1组作业内有2个作业，分组类型为1（最多选择1个作业）<br>2 5           第1个作业成本2分钟，幸福值5<br>3 8           第2个作业成本3分钟，幸福值8<br>2 0        第2组作业内有2个作业，分组类型为0（至少要选择1个作业）<br>1 0           第1个作业成本1分钟，幸福值0<br>2 1           第2个作业成本2分钟，幸福值1<br>3 2        第3组作业内有3个作业，分组类型为2（随意选择）<br>4 3           第1个作业成本4分钟，幸福值3<br>2 1           第2个作业成本2分钟，幸福值1<br>1 1           第3个作业成本1分钟，幸福值1<br><br><br>3 4    第2套用例内有3组作业，要求在4分钟内完成<br>2 1        第1组作业内有2个作业，分组类型为1（最多选择1个作业）<br>2 5           第1个作业成本2分钟，幸福值5<br>3 7           第2个作业成本3分钟，幸福值7<br>2 0        第2组作业内有2个作业，分组类型为0（至少要选择1个作业）<br>1 1           第1个作业成本1分钟，幸福值1<br>2 8           第2个作业成本2分钟，幸福值8<br>3 2        第3组作业内有3个作业，分组类型为2（随意选择）<br>4 4           第1个作业成本4分钟，幸福值4<br>2 1           第2个作业成本2分钟，幸福值1<br>1 1           第3个作业成本1分钟，幸福值1<br><br><br>1 1   第3套用例内有1组作业，要求在1分钟内完成<br>1 0       第1组作业内有1个作业，分组类型为0（至少要选择1个作业）<br>2 1          第1个作业成本2分钟，幸福值1<br><br><br>5 3   第4套用例内有5组作业，要求在3分钟内完成 <br>2 0       第1组作业内有2个作业，分组类型为0（至少要选择1个作业）<br>1 0           第1个作业成本1分钟，幸福值0<br>2 1           第2个作业成本2分钟，幸福值1<br>2 0       第2组作业内有2个作业，分组类型为0（至少要选择1个作业）<br>2 2           第1个作业成本2分钟，幸福值2<br>1 1           第2个作业成本1分钟，幸福值1<br>2 0       第3组作业内有2个作业，分组类型为0（至少要选择1个作业）<br>3 2           第1个作业成本3分钟，幸福值2<br>2 1           第2个作业成本2分钟，幸福值1<br>2 1       第4组作业内有2个作业，分组类型为1（最多选择1个作业）<br>1 5           第1个作业成本1分钟，幸福值5<br>2 8           第2个作业成本2分钟，幸福值8<br>3 2       第5组作业内有3个作业，分组类型为2（任意选择作业）<br>3 8           第1个作业成本3分钟，幸福值8<br>4 9           第2个作业成本4分钟，幸福值9<br>5 10          第3个作业成本5分钟，幸福值10<br><br>样本输出<br><br>5<br>13<br>-1<br>-1<br></code></pre></td></tr></table></figure><h3 id="分析-3">2.5.2 分析</h3><p>　　这是一个分组背包的题，而且每一组的选择策略还不相同，属于混合分组背包，所以不能统一地对整个dp数组去做初始化，而应该根据当前组的选择策略来分别对当前行赋予不同的初始值。当然，第0行是肯定要清零的，而且，因为是多组测试数据，所以需要反复清零。</p><p>　　本题中有一种分组策略为“可以选择0个或者任意多个”。这种题型在第一章中没有讲到。其实做起来也很简单。它实际上是题型1和题型3的结合。因为允许本组选0个物品，所以本组不会存在‘无解’的情况。既然如此，初始化时直接沿用上一行数据，表示本组暂选0个。dp[g][0..YS1]=dp[g-1][0..YS1]。然后再采用题型3的策略，2个max组合起来即可。</p><p>　　本题中允许ys1[i]和value[i]的值为0。只要在填写dp时采用2个max组合起来填，就没问题。</p><p>　　如果把第0列初始化为0，会造成网页中第4个测试样例错误。本题容易出错的地方就是每一行的初始化问题。小心做好，不要“想当然”。</p><h3 id="ac代码-4">2.5.3 AC代码</h3><p>题目中有些分组要求至少要选择一个物品，为简单和统一，建议全都采用“先for组内物品k，再for j”的代码框架。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-type">int</span> gcnt, n, YS1, type;<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">101</span>],value[<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> g, j, i;<br>    <span class="hljs-keyword">while</span>( ~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;gcnt, &amp;YS1) ) &#123;  <span class="hljs-comment">// 多组数据</span><br><span class="hljs-built_in">memset</span>(dp[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp[<span class="hljs-number">0</span>]));  <span class="hljs-comment">// 做每组数据之前重置第0行为全0。中间的正常格子需要根据分组的类型来决定其初值</span><br><br>        <span class="hljs-keyword">for</span>(g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;type);<br>            <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;ys1[i], &amp;value[i]);<br>            <span class="hljs-keyword">if</span>(type == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 组内要至少选择一项工作</span><br>                <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)  <span class="hljs-comment">// 本组要求必须要选，所以可能存在无解，故初始化为无解对应的值-INF，如果选不出来则造成“无解”</span><br>                    dp[g][j] = -INF;   <span class="hljs-comment">// dp[g][0]的初值也必须是无解，其值不能为0！ </span><br><br>                <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>                    <span class="hljs-keyword">for</span>(j=YS1; j&gt;=ys1[i]; j--)<br>                        dp[g][j] = <span class="hljs-built_in">max</span>( dp[g][j], <span class="hljs-built_in">max</span>( dp[g][j-ys1[i]]+value[i], dp[g<span class="hljs-number">-1</span>][j-ys1[i]]+value[i] ) );<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( type == <span class="hljs-number">1</span> ) &#123; <span class="hljs-comment">// 组内最多选择一项工作，可以不选</span><br>                <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;=YS1; j++) <span class="hljs-comment">// 当前组初始化，因为本组允许不选，不存在无解，初始化为上一组的对应值，表示“本组什么都不选”这个策略</span><br>                    dp[g][j] = dp[g<span class="hljs-number">-1</span>][j];<br><br>                <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>                    <span class="hljs-keyword">for</span>(j=YS1; j&gt;=ys1[i]; j--) <span class="hljs-comment">// 倒序</span><br>                        dp[g][j] = <span class="hljs-built_in">max</span>( dp[g][j] , dp[g<span class="hljs-number">-1</span>][j-ys1[i]] + value[i] );<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( type == <span class="hljs-number">2</span> ) &#123;     <span class="hljs-comment">// 任意选择，可一个都不选，也可选多个不同工作</span><br>                <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>                    dp[g][j] = dp[g<span class="hljs-number">-1</span>][j];  <span class="hljs-comment">// 分析与type==1相同</span><br><br>                <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>                    <span class="hljs-keyword">for</span>(j=YS1; j&gt;=ys1[i]; j--)<br>                        dp[g][j] = <span class="hljs-built_in">max</span>( dp[g][j], <span class="hljs-built_in">max</span>( dp[g][j-ys1[i]]+value[i], dp[g<span class="hljs-number">-1</span>][j-ys1[i]]+value[i] )  );<br>            &#125;<br>        &#125;<br>        dp[gcnt][YS1] = <span class="hljs-built_in">max</span>(dp[gcnt][YS1], <span class="hljs-number">-1</span>); <span class="hljs-comment">//所有“无解”的状态，其值都是远远小于0的，现在做输出调整，输出-1</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[gcnt][YS1]);<br><span class="hljs-comment">//        // 调试专用，省略</span><br><span class="hljs-comment">//        for(int j = 0; j&lt;=YS1; j++)</span><br><span class="hljs-comment">//            printf(&quot;%4d&quot;, j);</span><br><span class="hljs-comment">//        printf(&quot;\n&quot;);</span><br><span class="hljs-comment">//        for(int g=0; g &lt;= gcnt; g++ ) &#123;</span><br><span class="hljs-comment">//            for(int j = 0; j&lt;=YS1; j++)</span><br><span class="hljs-comment">//                printf(&quot;%4d&quot;, max(-1,dp[g][j]));</span><br><span class="hljs-comment">//            printf(&quot;\n&quot;);</span><br><span class="hljs-comment">//        &#125;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">第一套测试样例</span><br><span class="hljs-comment">5 3</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">1 0</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">2 2</span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">1 5</span><br><span class="hljs-comment">2 8</span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">3 8</span><br><span class="hljs-comment">4 9</span><br><span class="hljs-comment">5 10</span><br><span class="hljs-comment">正确输出</span><br><span class="hljs-comment">-1</span><br><span class="hljs-comment">错误输出</span><br><span class="hljs-comment">8 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">第二套测试样例</span><br><span class="hljs-comment">输入：</span><br><span class="hljs-comment">3 3</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">2 5</span><br><span class="hljs-comment">3 8</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">1 0</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">4 3</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">3 4</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">2 5</span><br><span class="hljs-comment">3 7</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">1 3</span><br><span class="hljs-comment">1 8</span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">4 4</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment">1 0</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">5 3</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">1 0</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">2 2</span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">1 5</span><br><span class="hljs-comment">2 8</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">3 8</span><br><span class="hljs-comment">4 9</span><br><span class="hljs-comment">5 10</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">1 4</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">2 5</span><br><span class="hljs-comment">3 7</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">正确输出：</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">16</span><br><span class="hljs-comment">-1</span><br><span class="hljs-comment">-1</span><br><span class="hljs-comment">7</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 背包问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求背包问题的具体方案</title>
      <link href="/2024/06/24/%E6%B1%82%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%85%B7%E4%BD%93%E6%96%B9%E6%A1%88/"/>
      <url>/2024/06/24/%E6%B1%82%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%85%B7%E4%BD%93%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><p>　　背包问题的具体方案求解，这个问题是背包问题拓展的经典题型，适合于已经学过01普通背包、完全背包、多重背包等基础背包类型之后的同学在拓展阶段学习。</p><p>　　一般来说，背包问题求具体方案，往往是在这些背包模型的基础上，要求输出最终选择的物品的种类编号和个数（若是普通01背包，则只需要输出物品编号）。这里需要注意的一点是，对于最终的最优收益值，其实现的方案往往可能是不唯一的。为了在线判题的方便，往往题目上会要求“输出方案按照字典序来输出”。所谓的字典序，类似于字符串的大小比较顺序，即小的数字或者字符先输出。在C++中，String类型和Vector类型的对象都支持直接比较大小，且按照字典序来比较大小。</p><h2 id="普通01背包不超过ys1输出最优收益值的选择方案">1.1“普通01背包+不超过YS1”，输出最优收益值的选择方案</h2><h3 id="为什么要逆推路径">1.1.1 为什么要逆推路径？</h3><p>　　“普通01背包+不超过YS1”，这是最普通常见的背包入门题型，以1267为例。这种题型，一般做法都是定义dp[i][j]表示“前i个物品在不超过指定容量YS1时的最优收益值”，然后采用从第1行到第n行的顺序来填写dp[][]数组，如下代码所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 代码(1)</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)      <span class="hljs-comment">// 一般做法都是正序向下填写数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++) <span class="hljs-comment">// 因为是标准状态数组，所以逆序也可以（不管是01背包或者完全背包）</span><br>    dp[i][j]= <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i<span class="hljs-number">-1</span>][j-ys1[i]]+value[i] ); <br></code></pre></td></tr></table></figure><p>　　最后再从dp[n][YS1]往上倒推，从而确定出所选物品的编号值序列，如下面的代码所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 代码(2)</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n,j=YS1; i&gt;<span class="hljs-number">0</span>; i--)<br>    <span class="hljs-keyword">if</span> (dp[i][j] == dp[i<span class="hljs-number">-1</span>][j-ys1[i]]+value[i] )&#123;<span class="hljs-comment">// 这种转移，是因为选择了第i个物品而导致。（暂时这么认为）</span><br>        cout &lt;&lt; i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        j-=ys1[i];<br>    &#125;<br></code></pre></td></tr></table></figure><p>　　为什么要采用倒推的方式来找路径呢？或者说，为什么不能从[0][0]开始去往下找路径，直到[n][YS1]为止呢？因为对于每个物品，我们都有“选第i个物品”和“不选第i个物品”这两种选择。理论上来说，每个数组方格都有“往下”和“往右下”这两个分支情况。如果从[0][0..YS1]中每个方格为根节点，往下形成多棵二叉树。如果每个分支情况都要去判断的话，算法复杂度会达到<spanclass="math inline">\(O(2^n)\)</span>指数级别，此法不可取。如下图绿色所示。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240630142301495.png"alt="image-20240630142301495" /><figcaption aria-hidden="true">image-20240630142301495</figcaption></figure><p>　　稍微聪明一点的同学可能已经意识到，既然这是一颗二叉树结构，要寻找根节点到下面某个结点之间的路径，最简单的方式就是“逆推”。因为每个树节点只有唯一的一个父节点。所以可以用<spanclass="math inline">\(O(n)\)</span>的效率，从路径终点往根节点逆推出唯一的路径。<font color="yellow">if(dp[i][j] == dp[i-1][j-ys1[i]]+value[i])，则说明dp[i][j]是因为选择了第i个物品而从dp[i-1][j-ys1[i]]转移过来而得</font>。代码（2）就是这个意思，只不过是逆序输出了而已。想要反过来输出也不难。</p><p>　　看到这里，似乎具体方案已经讲解完了。然则非也！上段的黄色文字的叙述是存在一定问题的。每种状态因为选择或者不选择物品，往下有两种状态转移的可能（只能二选一，不能既选又不选）；反过来思考，每种状态可能因为上一行的两种情况之一而得来，<font color="pink">但有可能存在"dp[i-1][j]==dp[i-1][j-ys1[i]]+value[i]"的情况，也就是说，选第i种物品或者不选，都可能达到相同的dp[i][j]值。如上图中的红色箭头所示，0+6==dp[3][0]+value[4]==dp[3][4]==6==dp[4][4]。总结来说，即这并非一棵树结构，而是图结构！</font></p><p>　　在这种情况下，如果要输出具体方案，则可能存在多条路径。如上图中，如果要达到[4][4]的状态，可以“选4”、“选1-3”和“选1-2”这三种方案。尤其是第三个方案，如果从下往上逆推，只能倒推到[0][1]而非[0][0]，也就是说，“选1-3”的方案，存在一定的成本冗余。根据题目的定义，这是允许且合理的。</p><h3 id="为什么要字典序输出">1.1.2 为什么要字典序输出？</h3><p>　　1.1.1节中我们说过，路径可能存在多条。在最糟糕的情况下（“ys1[1..n]=a，求dp[n][2*a]”，任选其中2个物品，共有<spanclass="math inline">\(A_n^2=n(n+1)/2\)</span>种选法，即路径），路径数为平方级。因路径太多条，更多的输出情况是“输出字典序最小的物品编号序列”，如<ahref="https://www.acwing.com/problem/content/12/">12.背包问题求具体方案</a>。</p><p>　　这里有必要科普一下“字典序”。字典序的比较规则，和字符串的比较规则完全一致。例如：1-4小于2-3；1-4小于4；1-4小于1-4-5。</p><h3 id="方法一为每个状态存储路径可拓展性更强建议掌握">1.1.3方法一：为每个状态存储路径（可拓展性更强，建议掌握！）</h3><p>　　要想表示和输出路径，一个最简单好理解的做法，就是为每一个状态都存储路径，在状态转移时比较路径的字典序，从而得到新状态的路径值。在C++中，String、Vector、map都是按照字典序来进行大小比较的，所以我们可以把路径存为String或者Vector这种结构。</p><p>　　1) 标准状态数组下的代码如代码（3）所示。空间复杂度为<spanclass="math inline">\(O( N * YS1 * N)\)</span>，较高，慎用。在<ahref="https://www.acwing.com/problem/content/12/">12.背包问题求具体方案</a>中使用会MLE！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 代码（3），01背包，标准状态数组，存储路径</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">jc</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>&#125; dp[N][<span class="hljs-number">201</span>];<br>......<br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)            <span class="hljs-comment">// 针对每1个物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++) &#123; <span class="hljs-comment">// 枚举背包总空间j，正序逆序均可！！</span><br>            dp[i][j]= dp[i<span class="hljs-number">-1</span>][j];   <span class="hljs-comment">// value和path都复制</span><br>            <span class="hljs-keyword">if</span> (j&gt;=ys1[i]) &#123;<br>                <span class="hljs-comment">// 先捏造一个临时决策来存储选择第i个物品后的value和path</span><br>                jc tmp=dp[i<span class="hljs-number">-1</span>][j-ys1[i]];  <span class="hljs-comment">// value和path都复制</span><br>                tmp.value+=value[i];       <span class="hljs-comment">// value要增加</span><br>                tmp.path.<span class="hljs-built_in">push_back</span>(i);     <span class="hljs-comment">// path也要增加</span><br>                <span class="hljs-keyword">if</span> (dp[i][j].value &lt; tmp.value || \<br>                        <span class="hljs-comment">// 等值时，若选择i的路径字典序更小，则也需要更新为更小字典序的决策</span><br>                        dp[i][j].value ==tmp.value  &amp;&amp; dp[i][j].path &gt; tmp.path ) &#123;<br>                    dp[i][j] = tmp;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    cout &lt;&lt;dp[n][YS1].value &lt;&lt;endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;dp[n][YS1].path.<span class="hljs-built_in">size</span>(); i++)    <span class="hljs-comment">//// 关掉这段代码，即可AC 1267题</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, dp[n][YS1].path[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　2）滚动状态数组下的代码如代码（4）所示：空间复杂度为<spanclass="math inline">\(O( YS1 * N)\)</span>，Nice！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 代码（4），01背包，滚动状态数组，存储路径</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">jc</span> &#123;           <span class="hljs-comment">// 决策</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> value;  <span class="hljs-comment">// 该决策的收益值</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 决策的具体内容（每个公司选择多少台机器，path长度不超过M）</span><br>&#125; dp[maxYS1];         <span class="hljs-comment">// 滚动数组，空间复杂度达到了O( M * M )</span><br>......<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--) &#123;     <span class="hljs-comment">// 普通01背包，滚动数组需要倒序填写</span><br>            jc tmp;  <span class="hljs-comment">// 暂时捏造一个决策tmp，表示选择第i个物品后的各种值。</span><br>            tmp.value= dp[j-ys1[i]].value + value[i];<br>            tmp.path= dp[j-ys1[i]].path;<br>            tmp.path.<span class="hljs-built_in">push_back</span>(i);      <span class="hljs-comment">// 表示选择第i个物品</span><br>            <span class="hljs-keyword">if</span> (dp[j].value &lt; tmp.value || \<br>                dp[j].value ==tmp.value &amp;&amp; dp[j].path &gt; tmp.path ) <br>            &#123; <span class="hljs-comment">// 如果在等值情况下新方案的路径字典序更小 </span><br>                dp[j] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>　　上述的方法，都需要用到struct jc来定义新类型。那能否就在intdp[][]数组的基础上直接逆推来得到字典序最小的唯一路径呢？</p><h3 id="方法二不存储路径直接逆推出最小字典序的唯一路径">1.1.4方法二：不存储路径，直接逆推出最小字典序的唯一路径</h3><p>　　我们以两个样例来研究一下如何倒推。两张图中，红色虚线圆圈处为逆推时需要抉择分支的状态，绿色箭头为最优路径，红色箭头为其他路径。任何颜色的箭头，从左往右指，表示逆推时需要选择当前物品；往上往下指，表示逆推时不选择当前物品。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240702153952478.png" alt="image-20240702153952478" style="zoom:70%;" /></p><p>　　从上面的两张图可以看出，在逆推遇到圆圈处时，并没有准确的规律该向“左上方”？或者该向“正上方”？这是为什么呢？因为在圆圈处有两种选择的前提下，如果往左上方逆推，意味着选择第i个物品；而如果想正上方逆推，意味着不选择第i个物品。那这为什么无法确定规律呢？</p><p>　　道理其实很简单。因为我们是从4号到1号，倒序来考虑每个物品的。假如当前我们选择4号物品，但我们此时并不确定以后是否会选择1、2、3号物品。<strong>序列越靠前的号码越能决定序列的字典序大小，光确定了中段或者末段的值是无法估算该序列大小的</strong>。光凭序列中有个“4”，并不能肯定该序列就是最小字典序的。例如[1,4]&lt;[2,3]，或者[1]&lt;[1,4]。</p><p>　　上述问题的解决方法其实也很简单。我们只需要<strong>让逆推时先决策的是小编号的物品</strong>即可。我们只要选择了1号物品，那么1开头的序列的字典序是肯定小于2或者3开头的序列的字典序的。例如[1,5,6,7]&lt;[2,4]。</p><p>　　那如何让逆推时先决策的是小编号的物品呢？先决策小编号，意味着先决策第一行。换句话说，我们要从dp[1][YS1]开始，从上往下去“倒推”dp数组，直到倒推到dp[n+1][]为止。</p><p>　　要想实现这个，只有一种可能，即<strong>[1][YS1]就是dp数组的终态</strong>。也就是说，dp数组需要换定义了，<strong>dp[i][j]表示“在第i～n个物品之间选择，不超过成本量j的最大收益值”</strong>。</p><p>　　在这种情况下，我们<strong>在填写dp数组值时，应该从下往上填写</strong>。并且，递推的特例也需要调整为第n+1行，dp[n+1][0..YS1]=0。新的递推方程如下：<span class="math display">\[\begin{align}dp[i][j]=\begin{cases}dp[i+1][j] &amp;(j&lt;ys1[i]) \tag{1}\\max(\ dp[i+1][j],\quad dp[i+1][j-ys1[i]]\ ) &amp;(j \geq ys1[i])\end{cases}\end{align}\]</span>　　可以看出，该公式相比之前传统的01背包公式，只是第一维从<spanclass="math inline">\(i-1\)</span>变成了<spanclass="math inline">\(i+1\)</span>，第二维依旧是<spanclass="math inline">\(j-ys1[i]\)</span>。这意味着，我们在推导公式时，第一维只能从n到1，而第二维则依然是正序逆序均可！若为滚动数组，第二维的顺序要领则依然和以前一样。</p><p>　　在下面的这四张图中，每一排的测试数据都各自相同，一共有两排（组）数据。左侧第一列的两组数据是从1到n的填写顺序，终态（黄色方格）在右下方的位置，且从下往上逆推方案路径。右侧第二列的两张图样例数据分别和左侧同一排的样例数据相同，但采用的是从n到1的填写顺序，终态在右上角的位置，且从上往下逆推方案路径。这四张图中，绿色箭头表示字典序最小的终态路径，是我们想要的答案；而红色箭头也属于终态路径，但字典序偏大。每一个红色虚线圆圈处，代表在逆推时需要对路径分叉进行选择的地方，也是我们研究决策的关键位置。</p><p>　　要想正确地逆推出字典序最小的到达终态的路径，可以看出，左侧第一列的两张图，在不同的样例数据下，分叉的最优选择各自不同，无法看出规律。而右侧第二列的两张图，<strong>在每次往下分叉时，只要选择“尽可能向左”（代表“选择第i个物品”），放弃“竖直向下”的分支（代表“不选第i个物品”），就能达成最优路径</strong>。</p><p>其核心代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// dp[i][j]表示从第i～n个物品之间挑选出不超过指定成本量j的最大收益值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n;i &gt;= <span class="hljs-number">1</span>;i--) &#123;        <span class="hljs-comment">// 倒序填写，从n到1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= YS1;j++) &#123;  <span class="hljs-comment">// 因为是标准状态数组，所以正序逆序都可以</span><br>            dp[i][j] = dp[i+<span class="hljs-number">1</span>][j];      <span class="hljs-comment">// 注意i+1</span><br>            <span class="hljs-keyword">if</span> (j &gt;= ys1[i])<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i+<span class="hljs-number">1</span>][j-ys1[i]]+value[i]);  <span class="hljs-comment">// 注意i+1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j=YS1;i &lt;= n;i++) &#123; <span class="hljs-comment">// 从终态[1][YS1]往下逆推到[0][..]</span><br>    <span class="hljs-comment">// 要一直确保j-ys1[i]为有效的数组下标！这一点别忘了！</span><br>        <span class="hljs-keyword">if</span> (j-ys1[i] &gt;= <span class="hljs-number">0</span> &amp;&amp; dp[i][j] == dp[i+<span class="hljs-number">1</span>][j-ys1[i]]+value[i]) &#123; <span class="hljs-comment">//能选i则选i</span><br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            j -= ys1[i];<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>　　<imgsrc="C:\Users\wangx\AppData\Roaming\Typora\typora-user-images\image-20240702152231395.png"alt="image-20240702152231395" /></p><p>　　从上面的代码中可以看出，<strong>这种算法的时间复杂度和空间复杂度，都是<spanclass="math inline">\(O(n*YS1)\)</span></strong>。因为涉及到要从终态开始逆推，所以dp数组不允许被压缩成滚动数组。</p><h2 id="完全背包不超过ys1输出最优收益值的选择方案">1.2“完全背包+不超过YS1”，输出最优收益值的选择方案</h2><p>　　如果不要求输出方案，则代码模板如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)          <span class="hljs-comment">// 针对每1种物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++) &#123;  <span class="hljs-comment">// 枚举背包总空间j，只能正序</span><br>        dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[i]) &#123;<br>            <span class="hljs-comment">// dp[i-1][j] 表示“能装而不装”，照搬上一行，注意是i-1</span><br>            <span class="hljs-comment">// dp[i][j - ys1[i]] + value[i]是当前行左侧（注意是i），它可能已经装有若干个物品i</span><br>            <span class="hljs-keyword">if</span> (dp[i][j] &lt; dp[i][j - ys1[i]] + value[i] ) &#123; <span class="hljs-comment">// 注意，是[i][j-...]</span><br>                dp[i][j] = dp[i][j - ys1[i]] + value[i];<br>            &#125;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>　　现在要求输出方案，则应该改装dp[][]的定义。在推导时，总体思路不变。代码模板如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++) &#123;<br>        dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>        dp[i][j].path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 先假设第i种物品装0个，即不装</span><br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[i]) &#123;<br>            <span class="hljs-comment">// dp[i][j - ys1[i]] + value[i]是当前行左侧（注意是i），它可能已经装有若干个物品i</span><br>            jc tmp= dp[i][j-ys1[i]];<br>            tmp.value += value[i];   <span class="hljs-comment">// [i][j - ys1[i]]状态再选择1个i号物品</span><br>            tmp.path[i<span class="hljs-number">-1</span>]++;  <span class="hljs-comment">// 第i种物品对应的是path[i-1]（vector从0开始编号），将其加1，表示再选择1个i号物品</span><br>            <span class="hljs-keyword">if</span> (dp[i][j].value &lt; tmp.value || \<br>                    dp[i][j].value == tmp.value &amp;&amp; dp[i][j].path &gt; tmp.path) &#123;<br>                dp[i][j] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="视频参考教程">1.3 视频参考教程</h2><p>　　<ahref="https://www.bilibili.com/video/BV1454y1C7AR/?spm_id_from=333.999.0.0">E20背包DP求具体方案</a>，该视频内容仅供参考，同学们有时间的话可以看看，加深印象。</p><h1 id="二实战训练">二、实战训练</h1><h2 id="acwing-12.-背包问题求具体方案">2.1 Acwing 12.背包问题求具体方案</h2><h3 id="原题链接">2.1.1 原题链接</h3><h3 id="acwing-12.-背包问题求具体方案微信登录">　　　　<ahref="https://www.acwing.com/problem/content/12/">Acwing 12.背包问题求具体方案</a>（微信登录）</h3><p>　　本题要求输出最优方案的具体内容，和 P2066 有相似之处。</p><h3 id="ac代码">2.1.2 AC代码</h3><h4 id="方法一为每个状态存储路径path">2.1.2.1方法一，为每个状态存储路径path</h4><p>　　时间复杂度：<spanclass="math inline">\(O(n*YS1)=1e3*1e3=1e6\)</span></p><p>　　空间复杂度：<spanclass="math inline">\(O(n*YS1)=1e3*1e3=1e6\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法1：01普通背包 + 滚动状态数组 + 路径保存 + 字典序输出具体方案 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    本题的maxn和maxYS1都达到了1e3，如果选择P2066那种标准状态数组，空间复杂度会达到1e9，超过64MB=6.4e7</span><br><span class="hljs-comment">    采用滚动数组后，空间复杂度为 4e6 &lt; 6.4e7</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxYS1=<span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n, YS1;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">jc</span> &#123;           <span class="hljs-comment">// 决策</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> value;  <span class="hljs-comment">// 该决策的收益值</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 决策的具体内容，空间复杂度O(n)。若要极限压缩空间，可设为为Bit类型，用0/1的bit序列来表示决策内容 </span><br>&#125; dp[maxYS1];         <span class="hljs-comment">// 滚动数组，空间复杂度为O(n*YS1)</span><br><span class="hljs-type">int</span> ys1[maxn], value[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;YS1);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;ys1[i], &amp;value[i]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--) &#123;     <span class="hljs-comment">// 普通01背包，滚动数组需要倒序填写</span><br>            jc tmp;  <span class="hljs-comment">// 暂时捏造一个决策tmp，表示选择第i个物品后的各种值。</span><br>            tmp.value= dp[j-ys1[i]].value + value[i];<br>            tmp.path= dp[j-ys1[i]].path;<br>            tmp.path.<span class="hljs-built_in">push_back</span>(i);      <span class="hljs-comment">// 表示选择第i个物品</span><br>            <span class="hljs-keyword">if</span> (dp[j].value &lt; tmp.value || dp[j].value ==tmp.value &amp;&amp; dp[j].path &gt; tmp.path ) &#123; <span class="hljs-comment">// 如果在等值情况下新方案的路径字典序更小 </span><br>                dp[j] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;dp[YS1].path.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        cout&lt;&lt;dp[YS1].path[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">4 5</span><br><span class="hljs-comment">2 4</span><br><span class="hljs-comment">3 4</span><br><span class="hljs-comment">4 6</span><br><span class="hljs-comment">1 2</span><br><span class="hljs-comment">输出</span><br><span class="hljs-comment">1 4</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">4 4</span><br><span class="hljs-comment">2 4</span><br><span class="hljs-comment">1 2</span><br><span class="hljs-comment">3 4</span><br><span class="hljs-comment">4 6</span><br><span class="hljs-comment">正确输出</span><br><span class="hljs-comment">1 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="方法二标准状态数组定义不变逆序填写正序逆推">2.1.2.2方法二，标准状态数组定义不变，逆序填写，正序逆推</h4><p>　　时间复杂度：<spanclass="math inline">\(O(n*YS1)=1e3*1e3=1e6\)</span></p><p>　　空间复杂度：<spanclass="math inline">\(O(n*YS1)=1e3*1e3=1e6\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法2：01普通背包 + 标准状态数组 + 倒序填写、正序逆推 + 字典序输出具体方案 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxYS1=<span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n,YS1;<br><span class="hljs-type">int</span> dp[maxn][maxYS1];<br><span class="hljs-type">int</span> ys1[maxn],value[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; YS1;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)<br>        cin &gt;&gt; ys1[i] &gt;&gt; value[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n;i &gt;= <span class="hljs-number">1</span>;i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= YS1;j++) &#123;<br>            dp[i][j] = dp[i+<span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">if</span> (j &gt;= ys1[i])<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i+<span class="hljs-number">1</span>][j-ys1[i]]+value[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j=YS1;i &lt;= n;i++) &#123;<br>        <span class="hljs-keyword">if</span> (j-ys1[i] &gt;= <span class="hljs-number">0</span> &amp;&amp; dp[i][j] == dp[i+<span class="hljs-number">1</span>][j-ys1[i]]+value[i]) &#123;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            j -= ys1[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p2066-机器分配">2.2 P2066 机器分配</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P2066">P2066机器分配</a> / <ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1266">1266</a></p><h3 id="分析">2.2.2 分析</h3><p>　　这是一个区间dp的题。不仅如此，题目还要求输出方案，且要求字典序最小。区间dp的题，必然是个三重for循环，其最内层循环k中，处理第i个物品在不超过指定成本量j时选择k的决策。决策方案不再是“选i”或者“不选i”，所以2.1节中的方法2（逆序填写，正序逆推）不再适用于本题。本题只能采用2.1节中的方法1，为每个状态加入path成员，随时记录路径，以供比较或运算。</p><p>　　需要指出的是，官方题解的第一篇题解有点问题，不要看。符合下列测试数据的，才有可能是正确题解。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs text">样例1 <br>3 6<br>10 10 1 1 1 1<br>10 1 10 1 1 1<br>10 10 10 1 1 1<br>正确输出   // 可以不选6台，不一定要选满哦！～<br>30<br>1 1<br>2 1<br>3 1<br>错误输出<br>30<br>1 2<br>2 1<br>3 3<br><br>样例2<br>2 5<br>1 1 1 1 1<br>1 1 1 1 2<br>正确输出<br>2<br>1 0<br>2 5   // 0 5比1 1更小<br><br>样例3<br>2 5<br>1 1 1 1 1<br>1 1 1 1 1<br>正确输出<br>2<br>1 1<br>2 1 <br></code></pre></td></tr></table></figure><h3 id="ac代码-1">2.2.3 AC代码</h3><h4 id="重点掌握的版本">2.2.3.1 重点掌握的版本</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    本题要求输出最优方案的具体内容，和acwing12题有相似之处</span><br><span class="hljs-comment">这个是区间DP的题，1266和本题几乎完全相同,1266题上漏了“要求字典序最小”的要求。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">定义状态：</span><br><span class="hljs-comment">dp[i][j]为前i个公司，分配不超过j台机器的最大收益值 （根据题意，可以不分满j台！）</span><br><span class="hljs-comment">        // dp[2][5].value=150表示前2个公司，一共选择5台机器， 其最大收益值是150</span><br><span class="hljs-comment">        // dp[2][5].path=[4,1]表示公司1要选择4台机器，公司2要选择1台机器   4+1 &lt;= 5</span><br><span class="hljs-comment">状态转移：</span><br><span class="hljs-comment">    前2个公司选不超过3台机器的收益dp[2][3]</span><br><span class="hljs-comment">        = max(&#x27;公司1选不超过3台，公司2选0台&#x27;，&#x27;公司1选不超过2台，公司2选1台&#x27;，&#x27;公司1选不超过1台，公司2选2台&#x27;，&#x27;公司1选不超过0台，公司2选3台&#x27;)</span><br><span class="hljs-comment">        = max(          dp[1][3],                    dp[1][2]+data[2][1],         dp[1][1]+data[2][2],              dp[1][0]+data[2][3]  )</span><br><span class="hljs-comment">        整理后得：</span><br><span class="hljs-comment">            dp[2][3]=max(dp[1][3], dp[1][2]+data[2][1], dp[1][1]+data[2][2], dp[1][0]+data[2][3])</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        状态转移方程如下：</span><br><span class="hljs-comment">dp[i][j] = max( dp[i][j] , dp[i-1][j-k] + a[i][k] )</span><br><span class="hljs-comment">(i属于[1..maxn], j属于[1..YS1], k属于[1..j])</span><br><span class="hljs-comment">k：给公司i分配k个机器</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">dp[]初始值和特例：dp数组全0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxn 11     <span class="hljs-comment">// 最大公司数量 </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxYS1 16     <span class="hljs-comment">// 设备最大总台数 </span></span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> data[maxn][maxYS1];<br><span class="hljs-type">int</span> n,YS1;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">jc</span> &#123;           <span class="hljs-comment">// 决策</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> value;  <span class="hljs-comment">// 该决策的收益值</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 决策的具体内容（每个公司选择多少台机器，path长度不超过maxYS1）</span><br>&#125; dp[maxn][maxYS1];  <span class="hljs-comment">// 空间复杂度达到了O( maxn * maxYS1 * maxYS1 ) ，可能会MLE，可考虑用滚动数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;YS1);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=YS1; j++) <span class="hljs-comment">// j ：选择j台机器</span><br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;data[i][j]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++) &#123;<br>            <span class="hljs-comment">// 为编程方便，先让dp[3][7]=dp[2][7]，即第3个公司暂时什么都不选</span><br>            dp[i][j].path= dp[i<span class="hljs-number">-1</span>][j].path;   <span class="hljs-comment">// 先复制下前两个公司选择的台数，2个int</span><br>            dp[i][j].path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);       <span class="hljs-comment">// 第3个公司既然一台都不选，则台数为 0</span><br>            dp[i][j].value= dp[i<span class="hljs-number">-1</span>][j].value; <span class="hljs-comment">// 别忘了值也要复制好</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=j; k++) &#123; <span class="hljs-comment">// 选择0台已经在上面处理过了，此处至少1台，最多j台</span><br>                jc tmp;                       <span class="hljs-comment">// 假设第i个公司选择k台机器，此处捏造状态tmp，以便于if内的运算</span><br>                tmp.value= dp[i<span class="hljs-number">-1</span>][j-k].value + data[i][k];<br>                tmp.path=dp[i<span class="hljs-number">-1</span>][j-k].path;<br>                tmp.path.<span class="hljs-built_in">push_back</span>(k);        <span class="hljs-comment">//</span><br>                <span class="hljs-keyword">if</span> (dp[i][j].value &lt; tmp.value || \<br>                        <span class="hljs-comment">// 等值时，若当前决策tmp.path的字典序更小，则也需要更新为更小字典序的决策</span><br>                        dp[i][j].value ==tmp.value  &amp;&amp; dp[i][j].path &gt; tmp.path ) &#123;<br>                    dp[i][j] = tmp; <span class="hljs-comment">// 1 &lt;= k &lt;= 15</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dp[n][YS1].value);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,i,dp[n][YS1].path[i<span class="hljs-number">-1</span>]);  <span class="hljs-comment">// 别忘了vector是从0开始编号的</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">3 6</span><br><span class="hljs-comment">10 10 1 1 1 1</span><br><span class="hljs-comment">10 1 10 1 1 1</span><br><span class="hljs-comment">10 10 10 1 1 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">正确输出   // 可以不选6台，不一定要选满哦！～</span><br><span class="hljs-comment">30</span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">3 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">错误输出</span><br><span class="hljs-comment">30</span><br><span class="hljs-comment">1 2</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">3 3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="精简版本学习操作符重载的可以进来看看优秀的代码">2.2.3.2精简版本（学习操作符重载的可以进来看看！优秀的代码）</h4><p>　　上面的代码是可以精简的，精简后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 写法2： 结构体操作符重载，可以大量节省码量，适合高手，建议看懂，学好！  lyyi2003的代码 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxYS1 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxn 16</span><br><span class="hljs-type">int</span> data[maxYS1][maxn];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">jc</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-comment">// 用字符来表示每个位置，有安全隐患，虽然也能存10以上的编号，</span><br>    <span class="hljs-comment">// 但无法存超过127的编号。意味着YS1不能超过127</span><br>    string path;<br>    <span class="hljs-comment">// 算术操作符的重载</span><br>    jc <span class="hljs-keyword">operator</span> +(<span class="hljs-type">int</span> y)  <span class="hljs-keyword">return</span> &#123;value+y,path&#125;;<br>    jc <span class="hljs-keyword">operator</span> +(<span class="hljs-type">char</span> c) <span class="hljs-keyword">return</span> &#123;value  ,path+c&#125;;<br>    <span class="hljs-comment">// 比较操作符的重载</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(jc a) <span class="hljs-type">const</span><br>        <span class="hljs-keyword">return</span> value&lt;a.value||value==a.value&amp;&amp;path&gt;a.path;<br>&#125; dp[maxYS1][maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n,YS1,i,j,k;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;YS1);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>; j&lt;=YS1; j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;data[i][j]);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;=YS1; j++) &#123;<br>            <span class="hljs-comment">// 别忘了value要复制过去，path+‘0’的值也要复制过去</span><br>            dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]+<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>; k&lt;=j; k++)<br>                <span class="hljs-comment">// 此处隐含了&#x27;&lt;&#x27;操作符的操作，且有value和path的操作</span><br>                dp[i][j]=<span class="hljs-built_in">max</span>(dp[i][j],dp[i<span class="hljs-number">-1</span>][j-k]+data[i][k]+(<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;0&#x27;</span>+k));<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dp[n][YS1].value);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,i,dp[n][YS1].path[i<span class="hljs-number">-1</span>]<span class="hljs-number">-48</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section">2.3 1268</h2><h3 id="原题链接-2">2.2.1 原题链接</h3><p>　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1268">1268</a></p><h3 id="分析-1">2.2.2 分析</h3><p>　　这个题的题解，我们之前已经研究过了。在这里主要是说一下完全背包的最优方案的字典序输出。其实总体思路并没有变化，但这里最好是采用“为每个状态存储路径”的方法。</p><h3 id="非ac代码">2.2.3 非AC代码</h3><p>　　下面的代码，只要去掉输出方案的部分，就能AC掉1268题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法5， 非AC代码, 标准状态数组 + 2重for + 增序 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">jc</span>&#123;<br>    <span class="hljs-type">int</span> value;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>&#125;dp[<span class="hljs-number">35</span>][<span class="hljs-number">211</span>], tmp;<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">35</span>], value[<span class="hljs-number">35</span>];<br><span class="hljs-type">int</span> YS1, n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin &gt;&gt;YS1 &gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>cin &gt;&gt;ys1[i] &gt;&gt;value[i];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)       <span class="hljs-comment">// 针对每1种物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举背包总空间j，只能正序 </span><br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];   <br>dp[i][j].path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 先假设第i种物品装0个，即不装 </span><br><span class="hljs-keyword">if</span> (j&gt;=ys1[i])&#123;  <br>                <span class="hljs-comment">// dp[i][j - ys1[i]] + value[i]是当前行左侧（注意是i），它可能已经装有若干个物品i </span><br>                jc tmp= dp[i][j-ys1[i]];<br>                tmp.value += value[i];<br>                tmp.path[i<span class="hljs-number">-1</span>]++;  <span class="hljs-comment">// 第i种物品对应的是path[i-1]（vector从0开始编号），将其加1，表示再选择1个i号物品 </span><br>                <span class="hljs-keyword">if</span> (dp[i][j].value &lt; tmp.value || \<br>                dp[i][j].value == tmp.value &amp;&amp; dp[i][j].path &gt; tmp.path)&#123;<br>    dp[i][j] = tmp;<br>    &#125;<br>    &#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max=%d\n&quot;</span>, dp[n][YS1].value);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;dp[n][YS1].path.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        cout &lt;&lt; dp[n][YS1].path[i] &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">样例1 </span><br><span class="hljs-comment">10 4</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">3 3</span><br><span class="hljs-comment">4 5</span><br><span class="hljs-comment">4 9</span><br><span class="hljs-comment">正确输出</span><br><span class="hljs-comment">max=19</span><br><span class="hljs-comment">1 0 0 2</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 背包问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题的方案数求解</title>
      <link href="/2024/06/10/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0%E6%B1%82%E8%A7%A3/"/>
      <url>/2024/06/10/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0%E6%B1%82%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="视频参考教程">1.1 视频参考教程</h2><p>　　<ahref="https://www.bilibili.com/video/BV16K411A7iC/?spm_id_from=333.999.0.0&amp;vd_source=0e7cc4e4bbbb67e5c3c2a3e7d967f075">E19背包DP 求方案数</a>　　</p><h2 id="问题分类">1.2 问题分类</h2><p>　　对于一个给定了背包容量、物品费用、物品价值、物品间相互关系（分组、依赖、普通01、多重、完全等）的背包问题，关于方案总数的考法经常有以下几种：</p><ol type="1"><li><p>求解“所用成本量刚好等于==（或不超过&lt;=）某一指定成本量YS1”的方案总数；</p><p>例如：<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1273">1273：【例9.17】货币系统</a></p><p>先填出成本量等于<span class="math inline">\(j(0 \leq j \leqYS1)\)</span>的dp数组，如果题目要求的是“&lt;=”，则需要对</p></li><li><p>求解“符合题意的最优方案”的方案总数</p><p>例如：<ahref="https://www.acwing.com/problem/content/description/11/">11.背包问题求方案数</a></p><p>这里先不管了，先做例题，然后再来总结</p></li></ol><h1 id="二实战练习">二、实战练习</h1><h2 id="货币系统">2.1 1273 货币系统</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1273">1273：【例9.17】货币系统</a>　/　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1293">1293：买书</a></p><h3 id="理论铺垫">2.1.2 理论铺垫</h3><ol type="1"><li><p>加法原理</p><p>　　做一件事情，完成它有<strong>n类<font color="red">方式</font></strong>，第一类方式有<spanclass="math inline">\(M_1\)</span>种方法，第二类方式有<spanclass="math inline">\(M_2\)</span>种方法，……，第n类方式有<spanclass="math inline">\(M_n\)</span>种方法，那么完成这件事情共有<spanclass="math inline">\(N=M_1+M_2+……+M_n\)</span>种方法。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240621154650672.png" style="zoom:80%;"/></p></li><li><p>乘法原理</p><p>　　做一件事情，完成它需要分成<strong>n个<font color="red">步骤(或阶段)</font></strong>，做第一步有<spanclass="math inline">\(M_1\)</span>种不同的方法，做第二步有<spanclass="math inline">\(M_2\)</span>种不同的方法，……，做第n步有<spanclass="math inline">\(M_n\)</span>种不同的方法。那么完成这件事共有 <spanclass="math inline">\(N=M_1×M_2×M_3×…×M_n\)</span> 种不同的方法。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240621160613616.png" style="zoom:80%;"/></p></li><li><p>两者的组合</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240621161256460.png" style="zoom:80%" /></p></li></ol><h3 id="分析">2.1.3 分析</h3><p>　　首先，根据题意可以看出，对于每一种面值的硬币，都可以选择无限个，这很像是一个完全背包模型的题。第一反应要往这方面去思考。</p><p>　　其次，既然要求组成面值为YS1（即题上的ｍ），肯定是要求“恰好等于==”，而不是“小于等于&lt;=”。用状态数组dp来表示方案数，其初值应该是０（假设一个方案都没有），且需要注意，方案数一般来说都很大，要考虑用longlong 而不是int。</p><p>　　第三，我们令dp[i][j]表示“前i种货币组成面值为ｊ的方案总数”。这样的话，我们只需要求出dp[n][YS1]即可。下面开始推导状态转移方程，即研究dp[i][j]和dp[i-...][j-...]之间的关系：</p><p>　　可以把“前i种货币的处理”分为“前i-1<strong>种</strong>货币的处理”（第一阶段）和“第i<strong>种</strong>货币的处理”（第二阶段）这两个阶段。对于第二阶段，分为“选第i种货币若干个”或者“不选第i种货币”。</p><p>　　1)如果不选择第i种货币</p><p>　　　　则总金额j全部由第一阶段中的前i-1种货币组成，其方案数为dp[i-1][j]；第二阶段只有“不选择第i种货币”这1个方法。故根据乘法原理，有：$$ <span class="math display">\[\begin{align}dp[i][j]&amp;=dp[i-1][j]\times 1 \tag{} \\&amp;=dp[i-1][j]\tag{1} \\\end{align}\]</span> $$</p><p>　　2)如果选择了第i种硬币中的<span class="math inline">\(\ k\ \ (k =1、2、3、...、\lfloor j/ys1[i] \rfloor)\ \)</span>枚</p><p>　　　　则第二阶段一共使用了<spanclass="math inline">\(k*ys1[i]\)</span>的成本量，所以第一阶段必然是使用了<spanclass="math inline">\(j-k*ys1[i]\)</span>的成本量，故第一阶段的方案数为dp[i-1][j-k*ys1[i]]，而第二阶段只有“选择第i种货币k枚”这1种方法，故根据乘法原理，有<span class="math display">\[\begin{align}dp[i][j]&amp;=dp[i-1][j-ys1[i]*k] \times 1 \tag{} \\&amp;=dp[i-1][j-ys1[i]*k] \tag{2}\end{align}\]</span>　　　　但因为k值不确定，可以选1个、2个、3个...，所以总方案数应该是多个选择的方法数之和（加法原理）。所以这里需要在<spanclass="math inline">\(\textcolor{red}[\ 1,\ \ \lfloor j/ys1[i] \rfloor\\textcolor{red}]\)</span>范围内枚举k值，并累加求和。故情况2）下的公式变为如下：　　　　<span class="math display">\[\begin{align}dp[i][j]&amp;=\sum_{k=1}^{\lfloor j/ys1[i] \rfloor}dp[i-1][j-ys1[i]*k] \tag{3}\end{align}\]</span>　　　　<strong>公式（3）过于繁琐，时效差，放弃！</strong>问题根源在于在情况2）种去枚举k值造成。那还有没有其他更好的方案呢？当然有！</p><p>　　　　一种更好的方案是把在处理情况2）时不要把思考的着力点放在k值上。我们不管k等于多少，<strong>想要凑成“前i类，总成本量为j”，则除了“在‘前i-1类，总成本量j’的基础上选0个（即1个都不选）第i类物品”这种方案之外，另外的方案肯定是“在‘前i类，总成本量为j-ys1[i]’基础上再选择1个第i类物品”</strong>这种方法。根据<a href="/2024/05/11/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/#133-二重for-+-标准状态数组-+-正序（较优，掌握，是下一节的铺垫））">《完全背包问题》</a>的1.3.3节内容（简图如下所示，详情见链接），在填写标准状态数组时应该从左往右填（从而可以把三重for降成二重for，从而提高效率）。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240515101440755.png" /></p><p>　　　如上面右图所示，在考虑dp[2][5]时，一种方法是“在dp[1][5]的基础上，<strong>1个第2类物品都不选（该步骤只有这1种做法）</strong>”来得到dp[2][5]，第二种方法就是“在dp[<font color="red">2</font>][3]的基础上，<strong>再装入<font color="red">1个</font>2类物品（该步骤只有这1种做法）</strong>”，根据乘法原理和加法原理，有如下公式：$$ <span class="math display">\[\begin{align}dp[i][j]&amp;=dp[i-1][j] \times 1+dp[i][j-ys1[i]] \times 1 \tag{}\\        &amp;=dp[i-1][j] \textcolor{red}+dp[\textcolor{red} i][j-ys1[i]]\tag{4}\\        \tag{}\\&amp;(1 \leq i \leq n, \quad ys1[i] \leq j \leq YS1) \tag{}\end{align}\]</span> $$</p><p>　　上面的这个（4）式要求j&gt;=ys1[i]，不是完整的公式。当j&lt;ys1[i]时，自然只能选择公式（1）。所以完整的完全背包模型下的方案数的状态转移方程，如下公式（5）所示。注意，这里不是求max或者min了哦！<span class="math display">\[dp[i][j]=\begin{cases}dp[i-1][j] &amp; (0 \leq j &lt; ys1[i]) \\dp[i-1][j] \textcolor{red}+dp[\textcolor{red}i][j-ys1[i]] &amp; (ys1[i]\leq j \leq YS1)\\\tag{5}\end{cases}\]</span> 　　如果是滚动状态数组的话，则方程如下： <spanclass="math display">\[dp[j] = dp[j] \textcolor{red}+dp[\ j-ys1[i]\ ] \tag{6}\\(1 \leq i \leq n, \quad ys1[i] \leq j \leq YS1)\]</span>　　第四，关于初值和特例。因为dp[][]表示的是方案数，我们可以假设一般的dp[i][j]都是0。至于特例，不管现在提供多少种货币，凑成总面值为0的方案都是“一个都不选”<strong>这1种</strong>方案。所以，dp[1..n][0]=1（滚动数组下是dp[0]=1）。因为公司（5）中有i-1这样的东西，所以我们在填第1行时还需要用到dp[0][..]。如果一种货币都不使用，那凑成任何面值的方案都是“没法搞定”，即dp[0][]=0（滚动数组下是dp[]=0）。</p><h3 id="ac代码">2.1.4 AC代码</h3><ol type="1"><li><p>标准状态数组实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//方法1：二维标准状态数组，二重for，正序填 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 这个题，题上没有明说有多少种硬币，以及面值上限是多少</span><br><span class="hljs-comment">// 标准状态数组中，面值这一维的长度要设置成5000以上才能过，硬币种类设置成20种以内 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V 5005</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[<span class="hljs-number">20</span>][V];<br><span class="hljs-type">int</span> ys1[V], n, YS1;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;YS1);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;ys1[i]);<br>    <span class="hljs-comment">// 如果要求总面值之和是0，不管是前多少个硬币，方案都是“什么硬币都不加入”，这是 1 种方案哦！～</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1L</span>;<br>    <span class="hljs-comment">// 针对每种不同面值的硬币</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-comment">// 多重背包，因为此版本为了减少一层循环，采用了当前行左侧数据，所以此处只能增序填写 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>            <span class="hljs-comment">// if语句根据帖子公式（5）得来 </span><br>            <span class="hljs-keyword">if</span> (j&lt;ys1[i])<br>                dp[i][j]= dp[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">else</span> <br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j-ys1[i]]; <span class="hljs-comment">// 注意这里的第一维！！！</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, dp[n][YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>滚动数组实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//方法2：滚动状态数组，二重for，正序填 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V 5005 </span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[V];<br><span class="hljs-type">int</span> ys1[V], n, YS1; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;YS1);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;ys1[i]);<br><span class="hljs-comment">// 一个硬币都不加入，总面值是0，刚好吻合“要求面值之和是0”的情况，这也是 1 种方案哦！～   </span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 针对每种不同面值的硬币 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    <span class="hljs-comment">// 从该面值ys1[i] 到 总面值YS1，多重背包，所以是增序 </span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=ys1[i]; j&lt;=YS1; j++)<br>            <span class="hljs-comment">// 根据帖子公式（6）得来</span><br>  dp[j] = dp[j] + dp[j-ys1[i]];<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, dp[YS1]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure></li></ol><h2 id="数字组合">2.2 1291：数字组合</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1291">1291：数字组合</a></p><h3 id="分析-1">2.2.2 分析</h3><p>　　看本题之前，强烈建议先学完2.1节的内容。需要注意的是，这个题和2.1节的1273题不太一样。这个题可能题上没有表达清楚到位，本题每个数只能使用一次，而不能无限次使用！所以，本题就是个普通01背包的方案数求解，不是完全背包！</p><p>　　既然是01普通背包，那么在用标准状态数组求解时，填写顺序是正序逆序均可的。状态转移方程如下：<span class="math display">\[dp[i][j]=\begin{cases}dp[i-1][j] &amp; (0 \leq j &lt; ys1[i]) \\dp[i-1][j] \textcolor{red}+dp[\textcolor{red}{i-1}][j-ys1[i]] &amp;(ys1[i] \leq j \leq YS1)\\\tag{7}\end{cases}\]</span>　　公式（7）和公式（5）只有一个地方不一样，即标红的这个“i-1”，且正序逆序均可。</p><h3 id="ac代码-1">2.2.3 AC代码</h3><ol type="1"><li><p>标准状态数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法1：标准状态数组实现 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">dp[i][j] = 5 表示：前i个数之内选一部分，加起来的和是j，这样的组合方案个数有5个</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">有2种情况：</span><br><span class="hljs-comment">1. 当总数j &gt;= ys1[i]，即可以把第i个数加进去（能加，不代表就肯定要加）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">总方案数 = 不加第i个数的组合的方案数  +  加第i个数的组合的方案数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">其中，加第i个数的组合中，既然最后一个数铁定是第i个数，那么</span><br><span class="hljs-comment">“前i个数加起来是j”的组合数，应该和“前i-1个数加起来是j-ys1[i]”</span><br><span class="hljs-comment">的组合数相同 ，即dp[i-1][j-ys1[i]] 。完全背包则不会这样写。 </span><br><span class="hljs-comment">所以： </span><br><span class="hljs-comment">dp[i][j] = dp[i-1][j] +  dp[i-1][j-ys1[i]] </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2. 当总数j &lt; ys1[i]，即没办法把第i个数加进去（加进去就超过j了）</span><br><span class="hljs-comment">所以总方案数在此时 =  dp[i-1][j]</span><br><span class="hljs-comment">   即 “在不加入第i个数的情况下凑够j”的方案数 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[<span class="hljs-number">21</span>][<span class="hljs-number">1001</span>];<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">21</span>], n, YS1;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin &gt;&gt;n &gt;&gt;YS1;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;= n; ++i)<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;ys1[i]);       <br><span class="hljs-comment">// 前0个数，加起来的和是0，这样的方案，有1种 </span><br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i)<br><span class="hljs-comment">//for(int j=YS1; j&gt;=0; --j)  // 01背包，标准状态数组的前提下，正反顺序都可以AC </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; ++j)<br><span class="hljs-keyword">if</span> (j &gt;= ys1[i]) <br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i<span class="hljs-number">-1</span>][j-ys1[i]];   <br><span class="hljs-keyword">else</span><br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>cout &lt;&lt; dp[n][YS1];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>滚动状态数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//方法2：滚动状态数组，AC代码</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[<span class="hljs-number">1001</span>];<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">21</span>], n, YS1;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin &gt;&gt;n &gt;&gt;YS1;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;= n; ++i)<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;ys1[i]);<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; --j)   <span class="hljs-comment">// 01背包模型，在滚动数组前提下只能逆序填！ </span><br>dp[j] = dp[j] + dp[j-ys1[i]];<br>cout &lt;&lt; dp[YS1];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="背包问题求方案数">2.3 背包问题求方案数</h2><h3 id="原题链接-2">2.3.1 原题链接</h3><p>　　<ahref="https://www.acwing.com/problem/content/description/11/">11.背包问题求方案数</a>(微信登录)</p><h3 id="分析-2">2.3.2 分析</h3><p>　　根据题意，这是一个普通01背包模型。要求在背包容量范围内求获得最大价值的方案数，并将方案数对<spanclass="math inline">\(10^9+7\)</span>取余。这里需要在“普通01背包+指定成本量范围内+求最大收益值”题型模板下，结合“方案数求解”来做。换句话说，一边对收益值求max，一边对方案数求和。这里需要dp[][]存放最大收益值，并用cnt[][]存放对应的方案总数。最后求出max(dp[n][0..YS1])，并把对应获得最大收益值的位置上的cnt[n][0..YS1]进行求和，取余，即可。</p><p>　　2.3节做法与2.1、2.2节例题做法大不相同。上面2个小节例题的dp数组直接表示方案数，但本节例题的方案数是用cnt[][]来表示，并且是跟踪记录dp数组 的过程来求cnt的。本节例题里的dp数组表示的是最优收益值。</p><p>　　之所以有这样的不同是因为，在前两节例题中，每种货币的成本量等于收益值，由于任意转移过程中最大收益值就等于此时的成本量，因此我们无需专门的数组来保存最大收益值，所以我们可以省去一个数组。而当物品成本量不等于收益值时，装满并不意味着就取得了最大价值，此时我们需要一个数组来专门记录这个最大价值，因为状态转移过程中需要用到。</p><h3 id="ac代码-2">2.3.3 AC代码</h3><ol type="1"><li><p>标准状态数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxYS1 = <span class="hljs-number">1005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> n, YS1; <br><span class="hljs-type">int</span> dp[maxn][maxYS1];       <span class="hljs-comment">//前i个物品，成本量恰好为j的最大收益值，对10^9+7取余的结果 ，放心用int 初始化为全0 </span><br><span class="hljs-type">int</span> cnt[maxn][maxYS1];      <span class="hljs-comment">//前i个物品，成本量恰好为j的方案数，初始化为全0 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt;n &gt;&gt;YS1;<br>    cnt[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;          <span class="hljs-comment">// 注意，第0列要等于1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>        <span class="hljs-type">int</span> ys1, value;<br>        cin &gt;&gt;ys1 &gt;&gt;value;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)&#123;<br>            <span class="hljs-comment">// 如果“装得下第i个物品” </span><br>        <span class="hljs-keyword">if</span> (j &gt;= ys1)&#123;<br>        <span class="hljs-comment">// 如果“不装入”的收益 &lt; “装入”的收益，则更新相关值</span><br>            <span class="hljs-keyword">if</span>( dp[i<span class="hljs-number">-1</span>][j] &lt; dp[i<span class="hljs-number">-1</span>][j-ys1] + value )&#123;<br>                <span class="hljs-comment">// 放弃以前的决策，采用“装入”的决策，更新最大收益值 </span><br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j-ys1] + value;<br>            <span class="hljs-comment">// 同步放弃以前的方案数，“装入第i个物品”只有1种方法，而“在前i-1个物品内装到价值为j-ys1”的方案数为cnt[i-1][j-ys1] </span><br>            cnt[i][j] = cnt[i<span class="hljs-number">-1</span>][j-ys1]*<span class="hljs-number">1</span>;   <span class="hljs-comment">//这个×1写在这里，让同学们更好理解。实际上可不写 </span><br>&#125;<br><span class="hljs-comment">//  如果“不装入”的收益 == “装入”的收益，则更新相关值，累加方案个数</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( dp[i<span class="hljs-number">-1</span>][j] == dp[i<span class="hljs-number">-1</span>][j-ys1] + value )&#123;<br>                <span class="hljs-comment">// 更新最大收益值为“不装入”或者“装入”（结果都一样） </span><br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br><span class="hljs-comment">// 不放弃以前决策的方案数，并加入新决策的方案数 </span><br>            cnt[i][j] = (cnt[i<span class="hljs-number">-1</span>][j] + cnt[i<span class="hljs-number">-1</span>][j-ys1]) % mod;<br>&#125;<br>            <span class="hljs-comment">// 如果“不装入”的收益 &gt; “装入”的收益，则不装</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 既然不装第i个物品，则最大收益值和方案数都延续，照抄即可 </span><br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>            cnt[i][j] = cnt[i<span class="hljs-number">-1</span>][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果“装不下第i个物品”</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// 则肯定只能不装了，延续，照抄 </span><br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>            cnt[i][j] = cnt[i<span class="hljs-number">-1</span>][j];<br>&#125;<br>        &#125; <br>    &#125;<br>    <span class="hljs-comment">// 求出最大收益值=max[n][0..YS1] </span><br>    <span class="hljs-type">int</span> maxval = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=YS1; i++) <br>        <span class="hljs-keyword">if</span> (maxval &lt; dp[n][i] )<br>        maxval = dp[n][i];<br>    <span class="hljs-comment">// 找出最大收益值位置上的方案数，累加，求余 </span><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=YS1; i++)<br>        <span class="hljs-keyword">if</span> ( dp[n][i] == maxval )<br>            ans = ( ans + cnt[n][i] ) % mod;<br>    cout &lt;&lt;ans &lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>滚动状态数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxYS1 = <span class="hljs-number">1005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> n, YS1; <br><span class="hljs-type">int</span> dp[maxYS1];       <span class="hljs-comment">//体积恰好为j的最大收益值，初始化为全0 </span><br><span class="hljs-type">int</span> cnt[maxYS1];      <span class="hljs-comment">//体积恰好为j的方案数，初始化为全0 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt;n &gt;&gt;YS1;<br>    cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;       <span class="hljs-comment">// 凑成总金额为0的方案数只有1个（“什么都不做”这1个） </span><br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>        <span class="hljs-type">int</span> ys1, value;<br>        cin &gt;&gt;ys1 &gt;&gt;value;<br>        <span class="hljs-comment">// 下面代码可看标准状态数组AC代码中的注释内容 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1; j--)&#123;   <span class="hljs-comment">// 01背包，逆序，到ys1为止</span><br>            <span class="hljs-keyword">if</span>( dp[j] &lt; dp[j-ys1] + value )&#123;<br>            dp[j] = dp[j-ys1] + value;<br>            cnt[j] = cnt[j-ys1];<br>&#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( dp[j] == dp[j-ys1] + value )<br>            cnt[j] = ( cnt[j] + cnt[j-ys1] ) % mod;<br>            <span class="hljs-keyword">else</span><br>            ;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> maxval = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">0</span>; i&lt;=YS1; i++) <br>        <span class="hljs-keyword">if</span> (maxval &lt; dp[i] )<br>        maxval = dp[i];<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">0</span>; i&lt;=YS1; i++)<br>        <span class="hljs-keyword">if</span> ( dp[i] == maxval )<br>            ans = ( ans + cnt[i] ) % mod;<br>    cout &lt;&lt;ans &lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="lcr-081.组合总和选学可暂时不做">2.4 LCR081.组合总和（选学，可暂时不做）</h2><h3 id="原题链接-3">2.4.1 原题链接</h3><p>　　<a href="https://leetcode.cn/problems/Ygoe9J/description/">LCR081.组合总和</a>（leetcode，微信登录）</p><h3 id="分析-3">2.4.2 分析</h3><p>　　本题和1273很相似，都是“完全背包问题+成本量恰好等于指定成本量”模型下求方案，但本题是要求方案内容，而不是方案数。</p><h3 id="ac代码-3">2.4 3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 输入一维动态数组candidates[]和目标整数target，输出一个二维动态数组 </span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">// 先对 candidates[]按增序来排序 </span><br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(),candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// 所有大于target的币值不可能凑成target的总数，直接删除它们 </span><br>        <span class="hljs-keyword">while</span>(candidates.<span class="hljs-built_in">size</span>() &amp;&amp; candidates.<span class="hljs-built_in">back</span>() &gt; target)  <br>            candidates.<span class="hljs-built_in">pop_back</span>();<br><br>        <span class="hljs-keyword">typedef</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; VI;  <span class="hljs-comment">// 定义二维动态数组类型名</span><br>        <span class="hljs-comment">// 一个方案就是一个一维动态数组，凑成一个指定值j有多个方案，则需要一个二维动态数组来存 </span><br>        <span class="hljs-comment">// 现在需要保存所有指定值的所有方案，则dp是一个三维动态数组 </span><br>        <span class="hljs-function">vector&lt;VI&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target+<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//  三维动态数组dp的第一维长度是target+1</span><br>        <br>        <span class="hljs-comment">// 对于每一种币值num </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num: candidates)&#123;<br>            <span class="hljs-comment">// 首先，num这种币值肯定可以凑成指定总额num，装入对应的方案中 </span><br>            dp[num].<span class="hljs-built_in">push_back</span>(&#123;&#123;num&#125;&#125;);<br>            <span class="hljs-comment">// 对于所有可能的货币总额 i </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = num;i&lt;=target;++i)&#123;<br>                <span class="hljs-comment">// 如果有方法能凑成i-num的金额，则可以对dp[i]进行扩容；否则不能扩容dp[i]</span><br>                <span class="hljs-keyword">if</span>(dp[i-num].<span class="hljs-built_in">size</span>())&#123;<br>                    <span class="hljs-comment">// dp是三维，dp[i-num]是二维，dp[i-num]内的元素vec就是一维动态数组，每个vec内所有int之和为i-num  </span><br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> vec : dp[i-num])&#123;<br>                        <span class="hljs-comment">// 对于每个vec，装入num这个int。emplace_back()比push_back()更高效 </span><br>                        <span class="hljs-comment">// 装入num之和，vec内所有int之和就是i了 </span><br>                        vec.<span class="hljs-built_in">emplace_back</span>(num);<br>                        <span class="hljs-comment">// 既然总和为i，当然可作为dp[i]的组成方案了，把这个一维数组加到dp[i]这个二维数组内 </span><br>                        dp[i].<span class="hljs-built_in">emplace_back</span>(vec);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="lcr-082.组合总和ii选学可暂时不做">2.5 LCR082.组合总和II（选学，可暂时不做）</h2><h3 id="原题链接-4">2.5.1 原题链接</h3><p>　　<a href="https://leetcode.cn/problems/4sjJUc/description/">LCR082.组合总和II</a></p><h3 id="分析-4">2.5.2 分析</h3><p>　　本题比2.4节的081题有区别。本题实际上是普通01背包。candidates数组中有重复数字，但每个数字都只能使用1次。</p>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 背包问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题的初始化问题</title>
      <link href="/2024/05/27/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98/"/>
      <url>/2024/05/27/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="什么时候必须要做数组初始化">1.1什么时候必须要做数组初始化？</h2><p>　　我们对变量的初始化操作并不陌生。一些变量在某个循环体内的公式中可能需要去读取，从而来改变其值，所以就需要先具有正确的初值。例如下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span> ;    <span class="hljs-comment">// 对sum必须要做初始化操作，否则结果错误！</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">10</span>; i++)<br>    sum= sum + i;<br></code></pre></td></tr></table></figure><p>　　<strong>因为第三行在给sum赋值之前，需要先读取sum的值（当i=1时，sum必须要先具备正确的初值）</strong>，才能确保整个循环过程中数据的正确。如果在给变量赋值之前不需要读取其值，则不需要对该变量进行初始化。如下列代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a,b,c;<br>cin &gt;&gt;a &gt;&gt;b;<br>c=a+b;<br></code></pre></td></tr></table></figure><p>　　在上面的这个代码中，因为第三行代码并不需要事先读取变量c的值，无论c之前是什么值，都会被直接覆盖掉。所以变量c是不需要做任何初始化操作的。当然，对于a和b也是一样的，不需要初始化。</p><p>　　上述的初始化前提，对于数组来说也是同样的。</p><p>　　我们需要对Fibonacci（斐波那契）数列a[]的a[1]和a[2]做初始化处理，但是对<spanclass="math inline">\(a[i] \ (3 \leq i \leqn)\)</span>不需要做初始化处理，<strong>因为他们都可以根据前两个值相加而得，不需要读取当前值，直接覆盖即可</strong>。</p><p>　　当以递推的方式填二维标准数组之前，我们只需要对特例的位置进行初始化即可，其他普通位置的值都来自于已求出的格子值，所以可以不必初始化。</p><p>　　当以递推的方式填一维滚动数组之前，因为滚动状态下的递推式为dp[j]=max(dp[j],XXXXX)，这种情况下需要先读取dp[j]的值，所以dp[j]的值必须要事先正确。例如求max之前应将dp[j]初始化为一个极小值，例如0（收益不可能为负数）；或者求min之前应将dp[j]初始化为一个极大值，例如INF。</p><h2 id="问题分类">1.2 问题分类</h2><p>　　不管是一维费用背包或是二维费用背包，不管是标准状态数组或是滚动状态数组，不管是普通01、完全背包或多重背包，对于状态数组初始化值方面的问题方案都是一样的。为了讲解方便，下面就统一用“一维费用背包+一维滚动状态数组”为例，先把问题抛出来让同学们熟悉一下。后面一一讲解每种题型的初始化应对之策。</p><h3 id="求收益值">1.2.1 求收益值</h3><ol type="1"><li><p><font color="red"><strong>至多 +求最大</strong></font><strong>收益值</strong></p><p>　　问题模型：现在有n个/种物品的成本值ys1[1..n]和收益值value[1..n]，求<strong>不超过（至多，&lt;=）</strong>背包总成本量YS1的物品组合的<strong>最大</strong>收益值。</p><p>　　注意：这种模型不可能求“最小”收益值。若要“不超过总成本量+最小收益值”，答案就是“全都不选”，没意思。</p></li><li><p><font color="red"><strong>至少 +求最小</strong></font><strong>收益值</strong></p><p>　　问题模型：现在有n个/种物品的成本值ys1[1..n]和收益值value[1..n]，求<strong>不少于（至少，&gt;=）</strong>背包总成本量YS1的物品组合的<strong>最小</strong>收益值。</p><p>　　注意：这种模型不可能求“最大”收益值。若要“不超过总成本量+最大收益值”，答案就是“全都选”，没意思。</p></li><li><p><font color="red"><strong>恰好等于</strong></font></p><p>　　问题模型：现在有n个/种物品的成本值ys1[1..n]和收益值value[1..n]，求<strong>恰好等于（不多也不少，=）</strong>背包总成本量YS1的物品组合的收益值。其中内含两种子题型如下：</p><ol type="a"><li><p>求总收益最大值</p></li><li><p>求总收益最小值</p></li></ol></li></ol><h3 id="求方案总数">1.2.2 求方案总数</h3><p>　　如果要求方案总数，如果在“至多”或者“至少”于总成本量的前提下，那方案总数就太多了，呈现指数级规模增长，基本上是不可求出的。<strong>所以如果要求方案总数，往往是在“总成本<font color="red">恰好等于</font>总成本量”的前提下</strong>，方案总数才相对较小，可以表达。但注意，就这种情况下，总数仍然是很大的，所以往往最好是定义longlong类型为佳！否则很有可能“见祖宗”……</p><p>　　问题模型：现在有n个/种物品的成本值ys1[1..n]和收益值value[1..n]，求物品总成本<strong>恰好等于</strong>背包总成本量YS1的物品组合的<strong>方案总数</strong>。</p><h2 id="如何理解和处理各种模型中的极大值inf极小值-inf">1.3如何理解和处理各种模型中的“极大值(INF)”、“极小值(-INF)”？</h2><p>　　在上述的题型中，当处理“恰好等于总成本量”时，不管是求收益值或者是求方案总数，都有可能存在一种情况，即“前i个物品无法实现恰好等于总成本量j”的这种情况。此时对于dp[i][j]就出现了三种可能的情况：</p><ol type="1"><li>dp[i][j]=a（a为某个普通的正值）：表示前i个物品中能实现恰好等于总成本量为j，最大/最小总收益值为a。</li><li>dp[i][j]=0：表示前i个物品中能实现恰好等于总成本量为j，最大/最小总收益值为0；实际上往往是dp[i][0]=0，因为只要对前i个物品一个都不选择的话，那么总成本量就恰好是0，而总收益值也自然是0。</li><li><strong>dp[i][j]=INF或-INF：表示“无解”，即前i个物品无论怎么选，都无法实现'恰好等于总成本量为j'。这种情况下，根本就没有符合要求的方案，所以收益值无从谈起，应标识为一个特殊的值，以便于区分识别。</strong></li></ol><p>　　在上面解决问题的过程中，需要用到INF或者-INF，所以本节来讨论如何理解和处理极大值或极小值。后期在图的算法中也会经常需要使用INF或-INF来处理“路径不可达”。下面讲述的技术同样适用于图的这些算法。</p><p>　　极大值是“正无穷”，通常用宏变量INF表示；极小值就是“负无穷”，通常用正无穷的取负方式来表示。所以只需要想清楚如何表达正无穷即可。</p><p>　　经常可能会在一些题解中看到类似于“intinf=1e9;”这样的代码。这种代码不够严谨，如果遇到一些存心卡数据的题，可能会出问题。同学们慎用之。</p><h3 id="关于int_max和long_long_max">1.3.1关于INT_MAX和LONG_LONG_MAX</h3><p>　　最常用的数据类型是int类型(<spanclass="math inline">\([-2.147483647*10^{\textcolor{red}{10}}\sim2.147483647*10^{\textcolor{red}{10}}]\)</span>)和long long类型(<spanclass="math inline">\([-9.223372*10^{\textcolor{red}{18}}\ \sim \9.223372*10^{\textcolor{red}{18}}]\)</span>)。这两种整数类型对“无穷大”的理解和表示方法基本上是相同的。另外，在C++中有<strong>INT_MAX</strong>和<strong>LONG_LONG_MAX</strong>这两个宏常量，分别表示int类型的最大值和longlong类型的最大值。同学们可以将其打印出来，看看类型的极限值是多大。但需要注意的是，这两个值是类型的极限，既然是极限，那么就一点都不能再增大了。也就是说，如果执行inta=INT_MAX+1；，必然会爆int而让变量a突变成一个极小值；longlong的情况类似。<strong>所以如果在算法中需要执行“INF+常数”，则一定不能将INF设为INT_MAX或者LONG_LONG_MAX。</strong></p><h3 id="极大值的选择策略以int类型为例">1.3.2极大值的选择策略（以int类型为例）</h3><ol type="1"><li><p><strong>选择INT_MAX（适用于“数组值不可能再做‘INF+常数’等增值操作，只纯粹做比较而用”的情况，加1就爆int）</strong></p></li><li><p><strong>选择0x7f7f7f7f（+21亿左右，<spanclass="math inline">\(\approx 2 \times10^{10}\)</span>，适用于“可做‘INF+常数’，但不会做‘INF+INF’操作”的情况，常数不能超过700万）</strong>，适用于int、longlong和double类型的极大值。</p></li><li><p><strong>选择0x3f3f3f3f（+10亿左右，<spanclass="math inline">\(\approx 1 \times10^{10}\)</span>，适用于可以做‘INF+INF’操作，且INF不会超过1e10的情况的情况）</strong>，适用于int、longlong类型的极大值，<font color="red"><strong>不适用于double类型</strong></font>。</p><p>上述的三种策略和适用情况，希望同学们谨记。</p></li></ol><h3 id="批量赋值的两种方式">1.3.3 批量赋值的两种方式</h3><p>　　选定了值之后，就要考虑给数组做批量赋值了。给数组做批量赋初值，常见的有以下两种方法（以int类型为例，而longlong类型的处理是一样的）：</p><ul><li><p>1）采用memset方法来把一个变量或者一个数组的全部元素都设置为无穷大INF</p><p>　　下面的这种做法，简单，码量少，效率一般，但有个缺点：一旦对数组使用memset，则OJ系统会认为该数组的所有元素都被使用过了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f        <span class="hljs-comment">// 可用于memset，也可用来直接给变量赋值，但long long需要8个7f</span></span><br><span class="hljs-comment">//#define INF 0x7f            // 这样写仅适合memset方法，第二个参数只需填一个字节的值即可，不适合直接赋值</span><br><span class="hljs-type">int</span> a, b[N];<br><span class="hljs-built_in">memset</span>(&amp;a, INF, <span class="hljs-built_in">sizeof</span>(a));   <span class="hljs-comment">// 注意，第一个参数是起始地址</span><br><span class="hljs-built_in">memset</span>(b, INF, <span class="hljs-built_in">sizeof</span>(b));    <span class="hljs-comment">// 注意，数组名称原本就是地址。OJ系统判定使用了N个元素</span><br></code></pre></td></tr></table></figure></li><li><p>2)采用多重for循环来给数组赋值（<font color="red"><strong>推荐！</strong></font>）</p><p>　　下面的这种做法，写循环麻烦些，<strong>时间效率和memset不相上下</strong>，但有个优点：可以根据实际需要来赋值，没有赋值的元素不会被OJ系统判为使用了的内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF  0x7f7f7f7f        <span class="hljs-comment">// 用来直接给int变量赋极大值，但long long需要8个7f</span></span><br><span class="hljs-comment">//#define INF 0x7f             // 不可这样写！！  </span><br><span class="hljs-type">int</span> b[N], n;<br>cin &gt;&gt;n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)        <span class="hljs-comment">// OJ系统判定使用了n个元素，而不是N个元素</span><br>    b[i]= INF;            <br></code></pre></td></tr></table></figure></li></ul><h2 id="至多-求最大收益值的初始化">1.4 “<font color="red"><strong>至多 +求最大</strong></font><strong>收益值</strong>”的初始化</h2><p>　　这个题型是比较普通的，之前我们做过的绝大部分背包问题，基本上都属于这一类，不超过背包总容量YS1的前提下，求最大收益值。在这种题型下，dp数组应该如何做初始化呢？</p><p>　　对于特例位置上的数据，肯定是需要做其初始化赋值的。除此之外，标准数组和滚动数组在数组普通位置上的处理略有不同，具体如下：</p><ol type="1"><li><p>对于标准数组而言，除了特例之外，任何普通位置上的数据均来自于已知位置上的数值，故可不必做普通位置上的数组初始化操作；</p></li><li><p>对于滚动数组而言，普通位置上的数值也需要做初始化，因为其递推方程规定了在修改前会先读取该位置的数据。因为收益值不可能为负数，所以普通位置上的收益值初始化为0，就已经可以做正常的max操作了。</p><p>这个题型的例子很多，之前很多背包问题都是这个模型，我们就不再举例练习了。</p></li></ol><h2 id="至少-求最小收益值的初始化">1.5 “<font color="red"><strong>至少 +求最小</strong></font><strong>收益值</strong>”的初始化</h2><p>　　这个题型在普及组中较为少见，但也有在出。要求物品总成本要超过总成本量YS1，求最小收益值。因为其递推方程中不再是max，而是min。这对我们的初始化操作有什么样的影响呢？</p><p>　　对于特例位置上的数据，肯定是需要做其初始化赋值的。这条法则对本帖中的任何题型都是适用的。这个毋庸置疑。同时，对于标准数组来说，任何普通位置上的数据均来自于已知位置上的数值，所以仍然不需要做初始化。</p><p>　　1.5节和1.4节唯一的区别就在于<strong>：当状态数组是滚动数组时，普通位置上的收益值应先初始化为INF，以便于min操作能正确执行。</strong></p><p>　　本小节的这种题型是有一个坑点的，那就是“既然是‘至少’，那就允许最终方案的成本总量超过YS1”。可能有些小朋友会觉得奇怪，总成本量增加了，<strong>怎么可能总价值反而还能减少？这当然是有可能的！</strong></p><p>　　我们来举个例子：3种物品，成本分别为{10斤,6斤,8斤，1斤}，假设每种物品要么不选，要么只能选1次，其价值为{1000元,2元,3元，1元}，YS1=10斤。如果要求“至少10斤以上，且希望总价值尽量小”，那答案肯定是选物品2和3，而不是选物品1。</p><p>　　通过举例，我们知道dp[][]数组求出来之后，<strong>dp[n][YS1]沿第一维和第二维这两个方向并不一定是数值递增的，所以最小值往往并不一定会在dp[n][YS1]这个位置上</strong>。那我们该如何去寻找这种题型的最优解，或者说dp[][]的最小值呢？难道我们要在dp[n][YS1..INF]这个超大范围内去找最小值吗？</p><p>　　答案当然是“不需要，<strong>只需要在dp[n][YS1..YS1+max(ys1[i])]这个范围内找最小数组值即可</strong>”。在上面的题中，我们只需要在dp[4][10..10+10]这个范围内来找最小值即可。为什么上限是YS1+max(ys1[i])呢？</p><p>　　我们既然要找最小值，那么，当备选方案已经满足了题意的要求（总成本量至少YS1=10斤以上）时，此时，备选方案是多个物品的组合，总成本量可能微超YS1，虽有超量，但也可能是最优解，所以是一个备选方案。<strong>这里的“超量”不可能超过一个完整的最大物品的成本量，应该要小于等于物品的单个最大成本量才对</strong>（举个例子，现在已知每种物品都不可能超过10斤，那么如果当前方案的成本量是35斤，超了35-YS1=35-10=25斤，即必然有至少2个或以上的物品是多余不应该选的，35斤这个方案绝非备选方案）。我们没有必要在一个合法的备选方案的基础上再去增加物品了，除非新增的这个物品的价值能够为负数，否则增加它后新方案的总价值必然会更大。换句话说，新方案不够小，绝非最优解，故绝非备选方案。</p><p>　　所以，对于这种题型，当我们填好整个dp数组的值之后，最优解就是min(dp[n][YS1..YS1+max(ys1[i])])。</p><p>　　既然讲到这里，就顺带着再说一下这个min(dp[n][YS1..YS1+max(ys1[i])])的求法。最常见的主要有两种求法，如下：</p><ol type="1"><li><p>把dp数组定义大一些，用来存放dp[n][YS1..YS1+max(ys1[i])]所有超量的值。填表时循环需要突破YS1（0..YS1+max(ys1[i])），填表也需要突破YS1。在填完数组之后单独写一个一重for，求出这个范围内各元素的最小值。这是常规的原始做法，也是最好理解的做法。</p></li><li><p>dp数组仍然定义为dp[n][YS1]这么大，超量范围内的dp值并不会被专门存放，而是在计算出来之后立刻与dp[n][YS1]这个值去做min操作。换句话说，dp[n][YS1]的含义已经发生了变化，它保存的就是dp[n][YS1..YS1+max(ys1[i])]整个超量范围内的最小值，也就是答案。这个方法在填写时，循环仍然需要突破YS1，但dp数组不需要突破YS1。咋一看不太好理解，需要先结合1）的方法先理解好原理，再来写2）的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (t= YS1; t&gt;=<span class="hljs-number">0</span>; --t) &#123;                <span class="hljs-comment">// 根据当前位置t，确定要填写的下标位置j的值。j的范围是[ys1[i]..YS1]</span><br>        <span class="hljs-type">int</span> j = <span class="hljs-built_in">min</span>( YS1, t + ys1[i] );  <span class="hljs-comment">// 确保要填写的下标不会越上界</span><br>        dp[j] = <span class="hljs-built_in">min</span> (dp[j] , dp[t] + value[i] );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　参考样例：[P2918 <ahref="https://www.luogu.com.cn/problem/P2918">USACO08NOV]Buying HayS</a></p></li></ol><h2 id="恰好等于求最大收益值的初始化">1.6“<font color="red"><strong>恰好等于+求最大</strong></font>收益值”的初始化</h2><p>　　因为本题型是要求“恰好等于”，所以有可能存在无解的情况。因为是求最大值，所以<strong>普通位置</strong>上的数组值不再初始化为0，而应是初始化为“无解”的对应值，即-INF（负无穷）。具体如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><span class="hljs-type">int</span> dp[N][C];<br><span class="hljs-built_in">memset</span>(dp, -INF, <span class="hljs-built_in">sizeof</span>(dp)); <span class="hljs-comment">// 也可用二重for来初始化</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt;= n ; i++)      <span class="hljs-comment">// 处理特例。第0列值为0</span><br>    dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 前i个物品，在“一个都不选”的情况下，总成本恰好为0，总收益值自然也是0</span><br></code></pre></td></tr></table></figure><p>　　01背包的状态转移方程为：<br /><span class="math display">\[dp(i,j)=\begin{cases}dp(i-1,j) &amp; (0 \leq j &lt;ys1[i]) \\max(\ dp(i-1,j), \quad dp(i-1,j-ys1[i])\ +value[i]\ ) &amp; (ys1[i] \leqj \leq YS1)\end{cases}\]</span>　　现在我们以一组实际数据来做1.6节的研究和学习。现有5个物品，成本分别是{5,4,7,2,6}，收益值分别是{12,3,10,3,6}。现在求成本量恰好等于12的最大收益值是多少？</p><p>　　我们来看看针对上面的数据，对应的dp数组应该怎么填：</p><ol start="0" type="1"><li><p>先把整个数组初始化为-INF（用‘X’表示），并给第0列赋值为0，做好填写前的准备工作。如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240609163951203.png" alt="image-20240609163951203" style="zoom:70%;" /></p></li><li><p>当i==1时，处理第1个物品的策略：</p><p>因为起初除dp[0][0]==0以外，第0行所有的其他值dp[0][1..YS1]均为-INF，那么</p><p>1）当j==ys1[1]=5时：</p><p><span class="math display">\[\begin{align}dp(i,j)=dp(1,5)&amp;=max(dp(1-1,5),\ \ dp(1-1,\ 5-ys1[1]\)+value[1]\ )\\&amp;=max(dp(0,5),\ \ dp(0,5-5)+v_1) \\&amp;=max(dp(0,5), \ \ dp(0,0)+12) \\&amp;=max(-INF\ , \ \ 0+12)\\&amp;=12\end{align}\]</span></p><p>2）当<span class="math inline">\(\ \ j \neq ys1[1] = 5\ \)</span>时： <span class="math display">\[\begin{align}j \neq ys1[1]&amp;=5 \quad \Longrightarrow j-5\neq0 \quad\Longrightarrow dp[0][j-5]=-INF \\\\dp(i,j)=dp(1,j)&amp;=max(dp(1-1,j), \quad dp(1-1,j-ys1[1])+value[1]) \\&amp;=max(dp(0,j),\quad dp(0,j-5)+12) \\&amp;=max(-INF, \quad -INF+12) \\&amp;=-INF+12  \\&amp;\approx -INF\end{align}\]</span>　　ps:实际不真正等于—INF，但从数学角度来说，“负无穷大+常数=负无穷大”</p><p>填完第1行之后如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240609165755878.png" style="zoom:70%;" /></p></li><li><p>当i==2时，处理第2个物品的三个策略如下：</p><p>a.只选物品1，成本5，收益12</p><p>b.只选物品2，成本4，收益3</p><p>c.物品1和物品2都选，成本5+4=9，收益12+3=15</p><p>其他情况下都不会“恰好等于”，收益值为-INF</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240609170636562.png" style="zoom:70%;" /></p><p>从图上可以看到，除了dp[1][0]和dp[1][5]之外，dp[1][0..12]的其他值都等于-INF，+4之后依旧等于-INF。</p></li><li><p>填完之后的dp数组如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240609174340545.png" style="zoom:70%;" /></p></li></ol><p>　　在上图中，dp[5][1]和dp[5][3]的值仍然为负数(不一定是-INF，但仍然&lt;0，是负数)，表示这些位置无解。</p><p>上述的计算过程，当dp数组从标准变成滚动状态数组之后，过程同样适用。此处就不再赘述了。</p><p>上述讲解的参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x7f7f7f7f</span>;<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span> ,<span class="hljs-number">2</span> ,<span class="hljs-number">6</span>&#125;;<br><span class="hljs-type">int</span> value[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">13</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i,j,n = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> YS1 = <span class="hljs-number">12</span>;<br>    <span class="hljs-built_in">memset</span>(dp, -INF, <span class="hljs-built_in">sizeof</span>(dp));<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        <span class="hljs-keyword">for</span>(j=YS1; j&gt;=ys1[i]; j--)      <span class="hljs-comment">//   j不够ys1[i]的话，dp[j]不会改变。</span><br>            dp[j] = <span class="hljs-built_in">max</span>( dp[j], dp[j-ys1[i]]+value[i] );<br><br><span class="hljs-comment">//    for(int c = 0; c&lt;=YS1; c++)</span><br><span class="hljs-comment">//        printf(&quot;%2d  &quot;, c);</span><br><span class="hljs-comment">//    printf(&quot;\n&quot;);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//    for(int c = 0; c&lt;=YS1; c++)</span><br><span class="hljs-comment">//        if(dp[c] &lt; 0)</span><br><span class="hljs-comment">//            printf(&quot; X  &quot;);</span><br><span class="hljs-comment">//        else</span><br><span class="hljs-comment">//            printf(&quot;%2d  &quot;, dp[c]);</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　参考样例：<ahref="https://www.luogu.com.cn/problem/CF189A">CF189A Cut Ribbon</a></p><h2 id="恰好等于求最小收益值的初始化">1.7“<font color="red"><strong>恰好等于+求最小</strong></font>收益值”的初始化</h2><p>　　分析过程参考1.6节的内容，这里只说结论了。<strong>对于求最小值的话，对应的“无解”初值应该是INF。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><span class="hljs-type">int</span> dp[N][C];<br><span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp)); <span class="hljs-comment">// 也可用二重for来初始化</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt;= n ; i++)      <span class="hljs-comment">// 处理特例。第0列值为0</span><br>    dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 前i个物品，在“一个都不选”的情况下，总成本恰好为0，总收益值自然也是0</span><br></code></pre></td></tr></table></figure><p>　　填完dp数组之后，如果最终 dp[j]或者dp[i][j] == INF，说明容量为 j的背包无法被前i个物品<strong>恰好</strong>装满；</p><p>　　参考样例：<a href="https://www.luogu.com.cn/problem/SP39">PIGBANK- Piggy-Bank</a></p><h2 id="恰好等于成本量j方案总数的初始化">1.8“<font color="red"><strong>恰好等于成本量j+方案总数</strong></font>”的初始化</h2><p>　　对于成本量j，如果前i个物品的选择组合，其成本量无法<strong>恰好等于</strong>j，那么就意味着<strong>"无解"，方案总数应该为0</strong>。但需要注意的是，dp[0]或者dp[i][0]=1。因为“什么都不选”这1种方案正好其成本量就恰好等于0。</p><p>　　关于方案总数的dp完整求法，本站另帖来讲。此处暂时不赘述。</p><h1 id="二.-实战练习">二. 实战练习</h1><h2 id="p2918-buying-hay-至少求最小收益值">2.1 P2918 Buying Hay（“至少+求最小收益值”）</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　[P2918 <ahref="https://www.luogu.com.cn/problem/P2918">USACO08NOV]BuyingHay</a></p><h3 id="ac代码">2.1.2 AC代码</h3><ol type="1"><li>标准状态数组+至少+求最小收益值+一维费用+完全背包（增序）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">AC代码，一维费用的完全背包求最小值，限制量要求要大于等于约束值，</span><br><span class="hljs-comment">    二重for，二维状态数组，增序，</span><br><span class="hljs-comment">其实这个情况下，既然已经是二维数组，增序或者降序并不重要了，</span><br><span class="hljs-comment">    但因为是完全背包，为了做2重for，所以用了增序 </span><br><span class="hljs-comment">    本题中，根据题意，max(ys1[i])=5000 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-type">int</span> n,YS1,ans=INF;<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">101</span>], value[<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">101</span>][<span class="hljs-number">50001</span>+<span class="hljs-number">5000</span>];  <span class="hljs-comment">// 注意数组要多定义出超量的这部分，避免RE </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;YS1);<br><br>    <span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">0</span>; i&lt;=n; i++)    <span class="hljs-comment">// 要从第0行开始初始化，不是第1行！ </span><br>    dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 求最小收益值，第0列初始化为0 </span><br><br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;ys1[i], &amp;value[i]);<br>    <br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    <span class="hljs-comment">// 注意循环结束为YS1+5000，因为你只购买YS1千克时花费的钱不一定是最少的，</span><br><span class="hljs-comment">// 5000是一坨草质量的最大值 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1+<span class="hljs-number">5000</span>; j++)&#123;     <span class="hljs-comment">// 增序以体现完全背包，注意起始和结束的边界！！ </span><br>        dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br><span class="hljs-keyword">if</span> ( j &gt;= ys1[i] )<br>dp[i][j] = <span class="hljs-built_in">min</span> ( dp[i][j], dp[i][j-ys1[i]] + value[i] );<br>    &#125;<br><br><span class="hljs-comment">//寻找哪一个既符合购买量，钱又最少</span><br>    <span class="hljs-keyword">for</span>( i=YS1; i&lt;=YS1+<span class="hljs-number">5000</span>; i++)<br>    ans = <span class="hljs-built_in">min</span>( ans, dp[n][i] ); <br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p><ol start="2" type="1"><li>滚动状态数组+至少+求最小收益值+一维费用+完全背包（增序）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">AC代码，一维费用的完全背包求最小值，限制量要求要大于等于约束值，</span><br><span class="hljs-comment">    二重for，一维状态数组，增序，</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-type">int</span> n,YS1,ans=INF;<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">101</span>], value[<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">50001</span>+<span class="hljs-number">5000</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;YS1);<br><br>    <span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>   dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <br><br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;ys1[i], &amp;value[i]);<br>    <br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    <span class="hljs-comment">// 注意循环结束为YS1+5000，因为你只购买YS1千克时花费的钱不一定是最少的，</span><br><span class="hljs-comment">// 5000时一坨草质量的最大值 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=ys1[i]; j&lt;=YS1+<span class="hljs-number">5000</span>; j++)     <span class="hljs-comment">// 增序以体现完全背包，注意起始和结束的边界！！ 循环次数突破了YS1次，数组下标也突破了YS1</span><br>dp[j] = <span class="hljs-built_in">min</span> ( dp[j], dp[j-ys1[i]] + value[i] );<br><br><span class="hljs-comment">//寻找哪一个既符合购买量，钱又最少</span><br>    <span class="hljs-keyword">for</span>( i=YS1; i&lt;=YS1+<span class="hljs-number">5000</span>; i++)<br>    ans = <span class="hljs-built_in">min</span>( ans, dp[i] ); <br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="u291791-潜水员至少求最小收益值">2.2 U291791潜水员（“至少+求最小收益值”）</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/U291791">U291791潜水员</a>/<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1271">1271：【例9.15】潜水员</a></p><h3 id="分析">2.2.2 分析</h3><p>　　这是一个二维费用的01背包问题，同时要求“至少+求最小收益值”。气缸容量是成本费用，气缸重量是收益。与2.1节的题相比，有两个地方不同：</p><p>1）二维费用，所以标准状态数组是3维，滚动数组是2维。如果采用拓展dp数组的方式，则需要把dp数组的这两维定义大一些，要有足够的超量。题目上说了每缸的氧气容量不会超过28升（原题内容有误，氧气容量可能超过21，但不会超过28升），氮气容量不会超过79升。这里有个巧合，那就是YS1正好也等于21，而YS2也恰好等于79。纯属巧合，干扰项。填完dp数组后，需要在超量的二维范围内求最小值，才是答案。</p><p>2）本题是普通01背包而非2.1节题中的完全背包。对于这个问题，如果是滚动数组，需要倒序填写。</p><h3 id="ac代码-1">2.2.3 AC代码</h3><ol type="1"><li><p>拓展dp数组的方法</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240610140047566.png" sytle="size:70%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法1： 拓展dp[][]数组，求dp[][]中一个方框范围内的最小值为答案</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x7f7f7f7f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXO2  28       <span class="hljs-comment">// 这个数字如果改成27或以下，则样例4无法通过</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN2  79</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">本方法扩展了原来的dp[YS1][YS2]，使其变为dp[YS1+MAXO2][YS2+MAXN2]这个</span><br><span class="hljs-comment">尺寸。因为本题要计算大于等于YS1且大于等于YS2的所有物品组合的最小重量，</span><br><span class="hljs-comment">所以不能只取dp[YS1][YS2]来作为答案。而应该遍历左上角为(YS1, YS2) ，</span><br><span class="hljs-comment">右下角为(YS1+MAXO2, YS2+MAXN2)的这个方框范围内的所有点中的最小值作为答案。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    之所以向右拓展80列，向下拓展28列，是因为新增每个物品的氧气最多</span><br><span class="hljs-comment">28（此处题有误，实际最多值不是21，而是28），新增每个物品的氮气最多79，</span><br><span class="hljs-comment">所以没必要去计算更右下区域范围内的值。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">本题的测试样例都默认了所有物品的(ys1[i], ys2[i])至少有一个是在</span><br><span class="hljs-comment">(YS1, YS2)这个方框内的。 并且本题的测试样例也默认所有物品的资源总和</span><br><span class="hljs-comment">肯定会超过YS1和YS2，即保证有解。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> YS1, YS2, n;<br><span class="hljs-type">int</span> ys1[N], ys2[N], value[N];<br><span class="hljs-type">int</span> dp[MAXO2*<span class="hljs-number">2</span>][MAXN2*<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> ans = inf;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;YS1, &amp;YS2);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;ys1[i], &amp;ys2[i], &amp;value[i]);<br><br><span class="hljs-built_in">memset</span>(dp, inf, <span class="hljs-built_in">sizeof</span>(dp));<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">// 注意，这里不能把0行或0列设置为0，dp[0][20]这表示氮气是要加的，气缸的组合重量不应该是0</span><br><br><span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>    <span class="hljs-comment">// 普通01背包，倒序填写</span><br>        <span class="hljs-comment">// 超量，注意边界！～ </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> o2=YS1+MAXO2; o2&gt;=ys1[i]; o2--) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n2=YS2+MAXN2; n2&gt;=ys2[i]; n2--) &#123;<br>dp[o2][n2] = <span class="hljs-built_in">min</span>(dp[o2][n2], dp[o2-ys1[i]][n2-ys2[i]] + value[i] );<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>( i=YS1; i&lt;=YS1+MAXO2; i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS2; j&lt;=YS2+MAXN2; j++)<br>ans = <span class="hljs-built_in">min</span>(ans, dp[i][j]);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>不拓展dp数组，算出来超量范围内的数组值之后马上和dp[n][YS1][YS2]进行min操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法2： 不拓展dp数组，将超过(YS1, YS2)右下部分的dp值计算出来与dp[YS1][YS2]进行比较并更新dp[YS1][YS2]</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x7f7f7f7f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXO2  28       <span class="hljs-comment">// 这个数字如果改成27或以下，则样例4无法通过</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN2  79</span><br><br><span class="hljs-type">int</span> YS1, YS2, n;<br><span class="hljs-type">int</span> i, o2, n2;<br><span class="hljs-type">int</span> ys1[N], ys2[N], value[N];<br><span class="hljs-type">int</span> dp[MAXO2][MAXN2];   <span class="hljs-comment">// 本方法不需要拓展</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;YS1, &amp;YS2);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;ys1[i], &amp;ys2[i], &amp;value[i]);<br><br>    <span class="hljs-comment">//因为结果是要求最小值，所以初始化dp要给数组的每个元素初始化为一个极大值</span><br>    <span class="hljs-built_in">memset</span>(dp, inf, <span class="hljs-built_in">sizeof</span>(dp));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-comment">// 根据o2和n2，来决定要填写的位置j和k，j、k不会超量</span><br>        <span class="hljs-keyword">for</span>(o2=YS1; o2&gt;=<span class="hljs-number">0</span>; o2--)<br>            <span class="hljs-keyword">for</span>(n2=YS2; n2&gt;=<span class="hljs-number">0</span>; n2--)&#123;<br>                <span class="hljs-comment">// j比o2多ys1[i]，所以j在赋值号左侧</span><br>                <span class="hljs-type">int</span> j = <span class="hljs-built_in">min</span>( YS1, o2 + ys1[i] );<br>                <span class="hljs-type">int</span> k = <span class="hljs-built_in">min</span>( YS2, n2 + ys2[i] );<br>                dp[j][k] = <span class="hljs-built_in">min</span> (dp[j][k] , dp[o2][n2] + value[i] ) ;<br>            &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[YS1][YS2]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="cf189a-cut-ribbon刚好装满背包求最大收益值">2.3 CF189A CutRibbon(“刚好装满背包+求最大收益值”)</h2><h3 id="原题链接-2">2.3.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/CF189A">CF189A CutRibbon</a></p><h3 id="分析-1">2.3.2 分析</h3><p>　　要准确理解题意！洛谷翻译得比较垃圾，“After the cutting eachribbon piece should have length a、b orc”的意思是“经过剪断之后，所有丝带的长度都应该是a、b或者c”。言下之意，没有丝毫浪费，没有任何其他的长度值哟！～换句话说，这是一个“长度之和刚好等于n”的“刚好装满背包”问题。</p><p>　　每段丝带即为一个物品，一共有3种长度，故有3种物品。每种长度的丝带允许有多条，所以是完全背包问题。要求最大数量值，所以每根丝带的数量1即为该物品的收益值。所以本题是一个“完全背包+刚好装满+求最大收益”的问题。</p><p>　　根据“完全背包”，填滚动dp数组时应该正序；根据“刚好装满+求最大”，dp数组初始化应该全为-INF。YS1就是丝带总长度；ys1[i]就是三种丝带的长度值；1为value[1..3]，可以不定义value数组而直接使用1。剩下的内容就很简单了。AC代码如下。</p><h3 id="ac代码-2">2.3.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 4010</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><br><span class="hljs-type">int</span> n, YS1;<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">4</span>];   <span class="hljs-comment">// 这里要写到4，不要阴沟里翻船了哈</span><br><span class="hljs-type">int</span> dp[N];    <span class="hljs-comment">// dp[j]=a表示长度为j的丝带可以刚好被切割成abc的最多总条数是a条，若为-INF表示无解</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>cin &gt;&gt; n;<br>cin &gt;&gt;ys1[<span class="hljs-number">1</span>] &gt;&gt; ys1[<span class="hljs-number">2</span>] &gt;&gt;ys1[<span class="hljs-number">3</span>];   <span class="hljs-comment">// 暴力收数，懒得写循环了，别问我为什么</span><br><br>YS1 = n;                           <span class="hljs-comment">// 丝带总长就是YS1了</span><br><span class="hljs-built_in">memset</span>(dp, -INF, <span class="hljs-built_in">sizeof</span>(dp));      <span class="hljs-comment">// -INF作为数组初值，先默认无解</span><br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;                         <span class="hljs-comment">// 特例。注意，先初值，再特例！   </span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">3</span>; i++)            <span class="hljs-comment">// 3种物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=ys1[i]; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 完全背包，正序</span><br>dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-ys1[i]] + <span class="hljs-number">1</span>);   <span class="hljs-comment">// 收益值为1，直接用。记得是求最大</span><br>&#125;<br><br>cout &lt;&lt;dp[YS1];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sp39-pigbank---piggy-bank恰好等于求最小收益值">2.4 SP39 PIGBANK- Piggy-Bank（“恰好等于+求最小收益值”）</h2><h3 id="原题链接-3">2.4.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/SP39">SP39 PIGBANK -Piggy-Bank</a></p><h3 id="分析-2">2.4.2 分析</h3><p>　　中文大致题意如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs text">在 ACM 能够开展之前，必须准备预算，并获得必要的财力支持。该活动的主要收入来自于 Irreversibly Bound Money (IBM)。思路很简单。任何时候，某位 ACM 会员有少量的钱时，他将所有的硬币投入到小猪储钱罐中。这个过程不可逆，因为只有把小猪储钱罐打碎才能取出硬币。在足够长的时间之后，小猪储钱罐中有了足够的现金，用于支付 ACM 活动所需的花费。<br>    但是，小猪储钱罐存在一个大的问题，即无法确定其中有多少钱。因此，我们可能在打碎小猪储钱罐之后，发现里面的钱不够。显然，我们希望避免这种不愉快的情况。唯一的可能是，称一下小猪储钱罐的重量，并尝试猜测里面的有多少硬币。假定我们能够精确判断小猪储钱罐的重量，并且我们也知道给定币种的所有硬币的重量。那么，我们可以保证小猪储钱罐中最少有多少钱。<br>    你的任务是找出最差的情形，即判断小猪储钱罐中的硬币最少有多少钱。我们需要你的帮助。<br>输入<br>输入包含 T 组测试数据。输入文件的第一行，给出了 T 的值。<br><br>对于每组测试数据，第一行包含 E 和 F 两个整数，它们表示空的小猪储钱罐的重量，以及装有硬币的小猪储钱罐的重量。两个重量的计量单位都是 g (克)。小猪储钱罐的重量不会超过 10 kg (千克)，即 1 &lt;= E &lt;= F &lt;= 10000 。每组测试数据的第二行，有一个整数 N (1 &lt;= N &lt;= 500)，提供了给定币种的不同硬币有多少种。接下来的 N 行，每行指定一种硬币类型，每行包含两个整数 P 和 W (1 &lt;= P &lt;= 50000，1 &lt;= W &lt;=10000)。P 是硬币的金额 (货币计量单位)；W 是它的重量，以 g (克) 为计量单位。<br><br>输出<br>对于每组测试数据，打印一行输出。每行必须包含句子 “The minimum amount of money in the piggy-bank is X.” 其中，X 表示对于给定总重量的硬币，所能得到的最少金额。如果无法恰好得到给定的重量，则打印一行 “This is impossible.” 。<br><br>示例输入<br><br>3<br><br>10 110<br>2<br>1 1<br>30 50<br><br>10 110<br>2<br>1 1<br>50 30<br><br>1 6<br>2<br>10 3<br>20 4<br><br>示例输出<br><br>The minimum amount of money in the piggy-bank is 60.<br>The minimum amount of money in the piggy-bank is 100.<br>This is impossible.<br><br></code></pre></td></tr></table></figure><p>　　题目说了一大堆废话，干扰项，考验同学们的阅读和分析能力。精简后的题意如下：现在给定钱币的总重量YS1，已知它是n种钱币的组合，并给定每种钱币的重量ys1[i]和其价值value[i]，求可能出现的最小总价值是多少。</p><p>　　这无疑肯定是一个“刚好装满+求最小价值”的裸题。钱币可重复，故是完全背包，需正序填写dp数组。是求最小价值，故dp初始化应全为INF，特例dp[0]=0。填完数组后，如果值还是INF，表示无解。</p><p>　　需要注意的是：本题很容易能够被改编成其他题型，例如“刚好装满+求最大价值”或者“刚好装满+求方案总数”。同学们可以想想该怎么做。</p><h3 id="ac代码-3">2.4.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> t, dp[N];<br><span class="hljs-type">int</span> ys1[N];<br><span class="hljs-type">int</span> value[N];<br><span class="hljs-type">int</span> n, empty, YS1;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt;t;<br>    <span class="hljs-keyword">while</span>( t-- ) &#123;<br>        cin &gt;&gt;empty &gt;&gt;YS1;<br>        YS1 = YS1 - empty;   <span class="hljs-comment">// 最大乘装量 = 最大毛重 - 空包重量</span><br>        cin &gt;&gt;n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>            cin &gt;&gt;value[i] &gt;&gt;ys1[i];<br>        <span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//这一步是特别重要的。</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = ys1[i]; j&lt;=YS1; j++)<br>                dp[j] = <span class="hljs-built_in">min</span>( dp[j], dp[j-ys1[i]] + value[i] );<br><br>        <span class="hljs-keyword">if</span> ( dp[YS1] == INF )<br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;This is impossible.\n&quot;</span> );<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The minimum amount of money in the piggy-bank is %d.\n&quot;</span>, dp[YS1] );<br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 背包问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多维费用背包问题</title>
      <link href="/2024/05/23/%E5%A4%9A%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2024/05/23/%E5%A4%9A%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学　　</h1><h2 id="模型引入">1.1 模型引入</h2><p>　　同学们还记得我们之前学过的普通01背包的模型及解法吧？如果不记得，请先复习回看，然后再看本帖。</p><p>　　之前的普通01背包模型中，背包总约束量YS1，每个物品的约束量ys1[]和收益value[]都给定，求在总约束量YS1之内的最大价值。这个题面有一个假设前提，那就是“只有一个背包”。那可不可以有两个或者多个不同类型的背包呢？当然可以有。下面就以二维为例，来讲解多维费用背包的解决方案。至于三维、四维等，解法思路是类似的。</p><p>　　二维费用背包的模型：</p><p>　　现在已知有两个属性的背包约束总量分别为YS1和YS2，每个物品在这两个属性上的约束量为ys1[]和ys2[]，该物品的收益值为value[]，求<strong>分别在这两个</strong>背包总容量限制<strong>之内</strong>的物品<strong>最大</strong>价值。(后续会有求最小值的模型，到时候再说。本帖都是求最大值的模型)</p><h2 id="视频教程">1.2 视频教程</h2><p>　　“E15 背包DP 二维费用背包”的<ahref="https://www.bilibili.com/video/BV1P54y1C7Ew/?spm_id_from=333.999.0.0&amp;vd_source=0e7cc4e4bbbb67e5c3c2a3e7d967f075">视频教程链接</a></p><h2 id="分析">1.3 分析</h2><p>　　<strong>对于二维费用背包</strong>（多维类似处理即可），只需要在遍历填写dp多维数组时，多加一个维度即可。当然，因为数组多了一个维度，所以总量更容易超过内存限度。往往在绝大多数情况下，只能使用滚动数组来处理多维费用背包的问题，否则会MLE。</p><h3 id="标准三维状态数组-普通01背包模型求最大值">1.3.1 标准三维状态数组+ 普通01背包模型+求最大值</h3><p>　　同学们应该还记得“标准二维状态数组+普通01背包模型+求最大值”的解法代码，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)            <span class="hljs-comment">// 针对每1个物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)   <span class="hljs-comment">// 枚举背包总空间j，正序逆序均可！！</span><br>        <span class="hljs-comment">// 如果背包空间够放第i个物品，</span><br>        <span class="hljs-keyword">if</span> ( ys1[i] &lt;= j )<br>            <span class="hljs-comment">// 需要判断放与不放，到底哪个更划算！</span><br>            dp[i][j]= <span class="hljs-built_in">max</span>( dp[i<span class="hljs-number">-1</span>][j-ys1[i]] + value[i],  dp[i<span class="hljs-number">-1</span>][j]);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 如果背包空间不够放第i个物品，然并卵，肯定就不放进去了哈！上下照抄不变</span><br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br></code></pre></td></tr></table></figure><p>　　现在多了一个费用维度之后，"标准三维状态数组 +普通01背包模型"的正确代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)            <span class="hljs-comment">// 针对每1个物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)   <span class="hljs-comment">// 枚举背包1总空间j，正序逆序均可！！</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;=YS2; k++)   <span class="hljs-comment">// 枚举背包2总空间k，正序逆序均可！！</span><br>        <span class="hljs-comment">// 如果两个背包的空间都够放第i个物品，</span><br>        <span class="hljs-keyword">if</span> ( ys1[i] &lt;= j &amp;&amp; ys2[i] &lt;= k )<br>            <span class="hljs-comment">// 需要判断放与不放，到底哪个更划算！</span><br>            dp[i][j][k]= <span class="hljs-built_in">max</span>( dp[i<span class="hljs-number">-1</span>][j-ys1[i]][k-ys2[i]] + value[i],  dp[i<span class="hljs-number">-1</span>][j][k]);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 如果背包空间不够放第i个物品，然并卵，肯定就不放进去了哈！上下照抄不变</span><br>            dp[i][j][k] = dp[i<span class="hljs-number">-1</span>][j][k];<br></code></pre></td></tr></table></figure><p>　　初学者最容易出现的问题，就是在复制粘贴的过程中，忘了修改，或者敲代码敲错了，把k敲成了j，或者反之等等。注意仔细检查，不要低级错误。</p><h3 id="滚动二维状态数组-普通01背包模型求最大值">1.3.2<font color="red">滚动</font>二维状态数组 + 普通01背包模型+求最大值</h3><p>　　“滚动一维状态数组+普通01背包模型+求最大值”的解法代码，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)  <span class="hljs-comment">// 针对每1个物品</span><br>    <span class="hljs-comment">// 这里j应该从右往左推，千万要注意！！注意是&gt;=ys1[i]截止，因为下标[j-ys1[i]]不可能为负数！</span><br>    <span class="hljs-comment">// 对于那些小于ys1[i]的j，在这里就不去处理（默认等于前值）了，也就是说，等效于dp[i][j] = dp[i-1][j]了！</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)<br>        <span class="hljs-comment">// 需要判断放与不放，到底哪个更划算！</span><br>        dp[j] = <span class="hljs-built_in">max</span>( dp[j - ys1[i]] + value[i],  dp[j]);<br></code></pre></td></tr></table></figure><p>　　现在多了一个费用维度之后，"滚动二维状态数组 +普通01背包模型+求最大值"的正确代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=YS2; k&gt;=ys2[i]; k--) &#123;  <span class="hljs-comment">// 注意各个细节不要写错了</span><br>        dp[j][k] = <span class="hljs-built_in">max</span>(dp[j][k], dp[j-ys1[i]][k-ys2[i]] + value[i]);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度分析">1.3.3 时间复杂度分析</h3><p>　　二维费用背包的时间复杂度都是<spanclass="math inline">\(O(n*YS1*YS2)\)</span>，如果采用滚动状态数组的话，其空间复杂度为<spanclass="math inline">\(O(YS1*YS2)\)</span>。</p><h1 id="二实战训练">二、实战训练</h1><p>　　注意：一本通上的1271题（“潜水员”）并不是裸的二维费用背包，还包含了其他技术点，初学者暂时不要去练，后续会安排机会来做该题。</p><h2 id="p1507-nasa的食物计划">2.1 P1507 NASA的食物计划</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P1507">P1507NASA的食物计划</a></p><h3 id="分析-1">2.1.2 分析</h3><p>　　这是一个裸的二维费用背包题目。<span class="math inline">\(n \leq50,\ YS1 \leq 400,\ YS2 \leq400\)</span>。整个题的数据规模都比较小，很适合用来练各种解法。同学们可以先练标准数组，再练滚动数组。</p><h3 id="ac代码">2.1.3 AC代码</h3><p>　　下面展示两种方法，同学们都需要看懂，尤其是第二种方法，背下来哦！</p><h4 id="标准状态数组下的解决方案">2.1.3.1 标准状态数组下的解决方案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法1：二维费用背包，标准状态数组，求最大值</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//// 给出n个物品，在总质量和总体积的限制下，求总价值的最大值</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 51</span><br><span class="hljs-type">int</span> YS1, YS2, n;<br><span class="hljs-type">int</span> ys1[N], ys2[N], value[N];<br><span class="hljs-type">int</span> dp[N][<span class="hljs-number">401</span>][<span class="hljs-number">401</span>];  <span class="hljs-comment">// 标准状态数组</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;YS1, &amp;YS2);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;ys1[i], &amp;ys2[i], &amp;value[i]);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)            <span class="hljs-comment">// 针对每1个物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)   <span class="hljs-comment">// 枚举背包1总空间j，正序逆序均可！！</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;=YS2; k++)   <span class="hljs-comment">// 枚举背包2总空间k，正序逆序均可！！</span><br>            <span class="hljs-comment">// 如果两个背包的空间都够放第i个物品，</span><br>            <span class="hljs-keyword">if</span> ( ys1[i] &lt;= j &amp;&amp; ys2[i] &lt;= k )<br>                <span class="hljs-comment">// 需要判断放与不放，到底哪个更划算！</span><br>                dp[i][j][k]= <span class="hljs-built_in">max</span>( dp[i<span class="hljs-number">-1</span>][j-ys1[i]][k-ys2[i]] + value[i],  dp[i<span class="hljs-number">-1</span>][j][k]);<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 如果背包空间不够放第i个物品，然并卵，肯定就不放进去了哈！上下照抄不变</span><br>                dp[i][j][k] = dp[i<span class="hljs-number">-1</span>][j][k];<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dp[n][YS1][YS2]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="滚动状态数组下的解决方案">2.1.3.2 滚动状态数组下的解决方案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法2：二维费用背包，滚动状态数组，求最大值</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">二维成本的01背包，滚动dp，</span><br><span class="hljs-comment">给出n个物品，在总质量和总体积的限制下，求总价值的最大值</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 51</span><br><span class="hljs-type">int</span> YS1, YS2, n;<br><span class="hljs-type">int</span> ys1[N], ys2[N], value[N];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">401</span>][<span class="hljs-number">401</span>];   <span class="hljs-comment">//注意，这里是滚动数组！！！不要一看到二维就误以为是标准数组</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;YS1, &amp;YS2);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;ys1[i], &amp;ys2[i], &amp;value[i]);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=YS2; k&gt;=ys2[i]; k--) &#123;<br>            dp[j][k] = <span class="hljs-built_in">max</span>(dp[j][k], dp[j-ys1[i]][k-ys2[i]] + value[i]);<br>        &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dp[YS1][YS2]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p1910-l-国的战斗之间谍">2.2 P1910 L 国的战斗之间谍</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P1910">P1910 L国的战斗之间谍</a></p><h3 id="分析-2">2.2.2 分析</h3><p>　　这个题也是一个几乎裸的二维费用背包题目，其解法代码和2.1节题几乎完全一致，可以作为复习和巩固。如果很熟了，可以不做本题。在本题中A是收益（价值），B和C都是成本。</p><p>　　求不超过背包总限制YS1（对应B）和YS2（对应C）的最大收益价值。<spanclass="math inline">\(n \leq 10^4,\ YS1 \leq 1*10^3,\ YS2 \leq1*10^3\)</span>。对于value[]没说其数值的取值范围，为了稳妥起见，最好是开longlong。牢记：“十年OI一场空，不开long long见祖宗！”</p><h3 id="ac代码-1">2.2.3 AC代码</h3><p>　　和2.1节中的P1833的代码几乎完全一样。此处略。</p><h2 id="p1855-榨取kkksc03">2.3 P1855 榨取kkksc03</h2><h3 id="原题链接-2">2.3.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P1855">P1855榨取kkksc03</a></p><h3 id="分析-3">2.3.2 分析</h3><p>　　这个题是一个二维费用背包题目，题面上明说了，在时间和金钱有限的情况下求达成愿望最多的个数。所以每个愿望所需的时间和金钱是成本，分别是ys1和ys2，而愿望个数是收益。那收益值是多少呢？很简单，纳入每个愿望后，达成1个愿望，所以收益值是1。所以本题不需要录入value[]哦！</p><p>　　本题数据规模较小，随便用标准状态数组或者滚动数组来做，都是可以的！</p><h3 id="ac代码-2">2.3.3 AC代码</h3><p>　　下面提供滚动数组的做法。标准数组的做法略，请参看2.1节内容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">二维成本的01背包，滚动dp，求最大值 </span><br><span class="hljs-comment">给出n个愿望，</span><br><span class="hljs-comment">在时间和金钱的限制下，求可以实现的愿望的总个数最大值 </span><br><span class="hljs-comment">成本是时间和金钱，收益是1，要求收益的最大值 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 101 </span><br><span class="hljs-type">int</span> YS1, YS2, n;<br><span class="hljs-type">int</span> ys1[N], ys2[N], value[N]; <br><span class="hljs-type">int</span> dp[<span class="hljs-number">201</span>][<span class="hljs-number">201</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;YS1, &amp;YS2);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;ys1[i], &amp;ys2[i]);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=YS2; k&gt;=ys2[i]; k--)&#123;<br>dp[j][k] = <span class="hljs-built_in">max</span>(dp[j][k], dp[j-ys1[i]][k-ys2[i]] + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dp[YS1][YS2]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 背包问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多重背包问题</title>
      <link href="/2024/05/17/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2024/05/17/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学　　</h1><h2 id="模型引入">1.1 模型引入</h2><p>　　总约束量为YS1，n<font color="red"><strong>种</strong></font>可待选择的物品需要装入，第i种物品有cnt[i]个，它们都有各自的重量和价值，你需要从中选择合适的组合来使得总约束量内的物品总价值最大（<strong>每种物品可以装[0..cnt[i]]个；不需要刚好装满，允许不"刚好"装满</strong>）</p><p>　　上面这段就是“多重背包”最常见的题面。</p><p>　　可以看到，多重背包是普通01背包和完全背包的进一步拓展和一般化，而01背包和完全背包是多重背包的特例情况。当cnt[i]=1时，蜕变为01背包模型；当cnt[i]=无穷大时，蜕变为完全背包模型。所以，只要搞定了多重背包模型，就肯定能搞定01背包和完全背包。</p><p>　　关于多重背包的解决方案，有如下三种：</p><ul><li>传统朴素做法　　　　　　复杂度: <span class="math inline">\(O(YS1 *\Sigma_{i=1}^{i=n} cnt[i])\)</span></li><li>二进制优化改进后　　　　复杂度: <span class="math inline">\(O(YS1 *\Sigma_{i=1}^{i=n} log_2cnt[i])\)</span>，CSP-S低分段难度</li><li>单调队列优化改进后　　　复杂度: <span class="math inline">\(O(YS1 *n)\)</span>，CSP-S高分段难度，可暂不学</li></ul><h2 id="视频教程">1.2 视频教程</h2><ul><li>“朴素做法+二进制优化”的<ahref="https://www.bilibili.com/video/BV1MA41177cg/?spm_id_from=333.999.0.0&amp;vd_source=0e7cc4e4bbbb67e5c3c2a3e7d967f075">视频教程链接</a></li><li>“单调队列优化”的<ahref="https://www.bilibili.com/video/BV1354y1C7SF/?spm_id_from=333.999.0.0&amp;vd_source=0e7cc4e4bbbb67e5c3c2a3e7d967f075">视频教程链接</a></li></ul><h2 id="朴素做法三重for-oys1-sigma_i1in-cnti">1.3 朴素做法（三重for，<span class="math inline">\(O(YS1 * \Sigma_{i=1}^{i=n}cnt[i])\)</span>）</h2><p>　　在“完全背包问题”的帖子中，当允许一种物品选择多个物品时，我们曾经推出状态转移方程为：</p><p><span class="math display">\[dp[i][j]=\begin{cases}    dp[i-1][j] &amp; (j&lt;ys1[i]) \\max(dp[i-1][j],\quaddp[i-1][j-ys1[i]]+value[i],\quad dp[i-1][j-2*ys1[i]]+2*value[i], \quaddp[i-1][j-3*ys1[i]]+3*value[i], \quad ......,dp[i-1]\textcolor[RGB]{0,225,0}[j-\textcolor[RGB]{225,0,0}\lfloorj/ys1[i]\textcolor[RGB]{225,0,0}\rfloor*ys1[i]\textcolor[RGB]{0,225,0}]+\textcolor[RGB]{225,0,0}\lfloorj/ys1[i]\textcolor[RGB]{225,0,0}\rfloor*value[i] \ &amp; (j\geq ys1[i]))\end{cases} \tag{1}\]</span></p><p>　　现在对公式（1）加入cnt[i]对状态转移方程的限制作用，得到公式（2）如下：<span class="math display">\[dp[i][j]=\begin{cases}    dp[i-1][j] &amp; (j&lt;ys1[i]) \\max(dp[i-1][j],\quaddp[i-1][j-ys1[i]]+value[i],\quad dp[i-1][j-2*ys1[i]]+2*value[i], \quaddp[i-1][j-3*ys1[i]]+3*value[i], \quad ......,dp[i-1]\textcolor[RGB]{0,225,0}[j-\textcolor[RGB]{225,0,0}k*ys1[i]\textcolor[RGB]{0,225,0}]+\textcolor[RGB]{225,0,0}k*value[i] \ &amp; (j\geq ys1[i]),\ 0 \leq k \leq cnt[i]且k*ys1[i] \leqj)\end{cases} \tag{2}\]</span>　　仔细比较公式（2）和（1），可以发现，仅仅只是在第三重for循环内对k多加了一个限制k&lt;=cnt[i]而已。还是很好理解的。</p><h3 id="多重背包朴素做法二维标准状态数组-三重for">1.3.1多重背包朴素做法：二维标准状态数组 + 三重for</h3><p>　　其关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//for(int i=1; i&lt;=n; i++)       // 针对每1种物品</span><br><span class="hljs-comment">//    for(int j=0; j&lt;=YS1; j++)   // 正序枚举背包总容量j，注意，j的取值范围是[0, YS1]</span><br><span class="hljs-comment">//        if (j &lt; ys1[i])</span><br><span class="hljs-comment">//            dp[i][j]= dp[i-1][j];</span><br><span class="hljs-comment">//        else &#123;</span><br><span class="hljs-comment">//            dp[i][j]= dp[i-1][j];</span><br><span class="hljs-comment">//            dp[i][j]= max(dp[i][j], dp[i-1][j-ys1[i]] + value[i]);</span><br><span class="hljs-comment">//            dp[i][j]= max(dp[i][j], dp[i-1][j-2*ys1[i]] + 2*value[i]);</span><br><span class="hljs-comment">//            dp[i][j]= max(dp[i][j], dp[i-1][j-3*ys1[i]] + 3*value[i]);</span><br><span class="hljs-comment">//            ......</span><br><span class="hljs-comment">//        &#125;  // end if</span><br><span class="hljs-comment">////      简化后的代码如下：</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)          <span class="hljs-comment">// 针对每1种物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++) &#123;  <span class="hljs-comment">// 枚举背包总容量j，注意，j的起点0, 不是ys1[i] ! </span><br>        dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];   <span class="hljs-comment">// 需要先照抄上一行数据，哪怕j &lt; ys1[i] ! </span><br>        <span class="hljs-keyword">if</span> ( j &gt;= ys1[i] )<br>            <span class="hljs-comment">// 放入物品i的个数k不仅要受到背包剩余容量的限制，还要受到物品 i 的总个数的限制</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k * ys1[i] &lt;= j &amp;&amp; k &lt;= cnt[i]; k++ )  <span class="hljs-comment">//其实0是空转，不影响结果，但为了好记，且和后续其他模型的代码统一，建议这里写0</span><br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i<span class="hljs-number">-1</span>][j-k*ys1[i]] + k*value[i] );<br>    &#125;<br></code></pre></td></tr></table></figure><p>　　第三重for循环内是两个条件式“与”起来，初学者很容易写漏一个，切记！请注意！</p><h3 id="多重背包朴素做法一维滚动状态数组-三重for">1.3.2多重背包朴素做法：一维滚动状态数组 + 三重for</h3><p>　　参照1.3.1节中简化后的代码，所以本节的关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 多重背包，朴素做法，一维状态数组+三重for</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)  <span class="hljs-comment">// 针对每1个物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)   <span class="hljs-comment">// 既然是朴素做法，这里只能从右往左枚举!! 滚动数组不需要枚举到0</span><br>        <span class="hljs-comment">// 本题和1268的方法2只有一个地方不一样，即下面的“&amp;&amp; k&lt;=cnt[i]”</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k*ys1[i]&lt;=j &amp;&amp; k&lt;=cnt[i]; k++) <span class="hljs-comment">//其实0是空转，不影响结果，但为了好记，且和后续其他模型的代码统一，建议这里写0</span><br>            dp[j] = <span class="hljs-built_in">max</span>( dp[j],  dp[j - k*ys1[i]] + k*value[i] ) ;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度分析">1.3.3 时间复杂度分析</h3><p>　　1.3.1节和1.3.2节的代码，在时间复杂度上是一致的，所以这里合在一起分析。</p><p>　　假设n=10种，YS1=1000，第i种物品的个数限制cnt[i]=i*10个，ys1[i]充分小（例如=1)，则第三重for循环的复杂度为<spanclass="math inline">\(O(cnt[i])\)</span>，则上面的代码等效于如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[<span class="hljs-number">1</span>]; j--)   <span class="hljs-comment">// O(YS1)=1000</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;=j &amp;&amp; k&lt;=cnt[<span class="hljs-number">1</span>]; k++)     <span class="hljs-comment">// O(cnt[1])=10</span><br>        dp[j] = <span class="hljs-built_in">max</span>( dp[j],  dp[j - k*ys1[<span class="hljs-number">1</span>]] + k*value[<span class="hljs-number">1</span>] ) ;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[<span class="hljs-number">2</span>]; j--)               <span class="hljs-comment">// O(YS1)=1000  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;=j &amp;&amp; k&lt;=cnt[<span class="hljs-number">2</span>]; k++)     <span class="hljs-comment">// O(cnt[2])=20</span><br>        dp[j] = <span class="hljs-built_in">max</span>( dp[j],  dp[j - k*ys1[<span class="hljs-number">2</span>]] + k*value[<span class="hljs-number">2</span>] ) ;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[<span class="hljs-number">3</span>]; j--)               <span class="hljs-comment">// O(YS1)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;=j &amp;&amp; k&lt;=cnt[<span class="hljs-number">3</span>]; k++)     <span class="hljs-comment">// O(cnt[3])=30</span><br>        dp[j] = <span class="hljs-built_in">max</span>( dp[j],  dp[j - k*ys1[<span class="hljs-number">3</span>]] + k*value[<span class="hljs-number">3</span>] ) ;<br>......<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[<span class="hljs-number">10</span>]; j--)               <span class="hljs-comment">// O(YS1)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;=j &amp;&amp; k&lt;=cnt[<span class="hljs-number">10</span>]; k++)     <span class="hljs-comment">// O(cnt[10])=100</span><br>        dp[j] = <span class="hljs-built_in">max</span>( dp[j],  dp[j - k*ys1[<span class="hljs-number">10</span>]] + k*value[<span class="hljs-number">10</span>] ) ;    <br></code></pre></td></tr></table></figure><p>　　所以三重for循环的累计执行次数如下： <span class="math display">\[\begin{align}&amp;\quad\ 1000*10+1000*20+1000*30+...+1000*100\\&amp;=1000*(10+20+30+...+100)\\&amp;=YS1*\Sigma_{i=1}^{i=n}cnt[i]\end{align} \tag{1}\]</span>　　上面这个式子，就是朴素做法的时间复杂度公式。如果物品种类数n是成百上千，而物品个数限制cnt[]也成千上万的话，那么<spanclass="math inline">\(\Sigma_{i=1}^{i=n}cnt[i]\)</span>的值会较大，再乘以YS1，极易超过1e7，容易TLE。</p><h2 id="二进制优化版本二重循环oys1-_i1in-log_2cnti">1.4二进制优化版本（二重循环，$O(YS1 * _{i=1}^{i=n} log_2cnt[i]) $）</h2><p>　　在朴素算法中，第三重“for k”循环的时间复杂度是<spanclass="math inline">\(O(cnt[i])\)</span>。对于第i种物品，如果cnt[i]较大，将会比较耗时。而二进制优化，则主要应用在第三重fork的实现上，将<spanclass="math inline">\(O(cnt[i])\)</span>的时间复杂度降为<spanclass="math inline">\(O(\ log_2\ cnt[i]\ )\)</span>，准确地说应该是<spanclass="math inline">\(O(\ log_2\ \lceil \ cnt[i]\ \rceil \)\)</span>。</p><h3 id="二进制拆分原理">1.4.1 二进制拆分原理</h3><p>　　[1..n]内的所有整数，都可以表示为固定不变的多个数的组合（加或不加）形式。下面用例子证明：　　　　假设cnt[i]=22，则1..22的这22个数可以用1,2,4,8,7这5个数的组合形式表示；　　 　　　　1）1--15之间所有的数可以由1,2,4,8从中选取来组成，</p><p>　　　　2）而对于16--22之间的数，可以先减去剩余的7，剩下1--15之间的数，就可以用1,2,4,8表示了。</p><p>　　每个数的拆分情况请看下面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 =0011   = 1+2<br>5 =0101   = 1+4<br>6 =0110   = 2+4<br>7 =0111   = 1+2+4<br>9 =1001   = 1+8<br>11=1011   = 1+2+8<br>12=1100   = 4+8<br>13=1101   = 1+4+8<br>14=1110   = 2+4+8<br>15=1111   = 1+2+4+8<br>16=10000  = 1+7+8<br>17=10001  = 2+7+8<br>18=10010  = 1+2+7+8<br>19=10011  = 4+7+8<br>20=10100  = 1+4+7+8<br>21=10101  = 2+4+7+8<br>22=10110  = 1+2+4+7+8<br></code></pre></td></tr></table></figure><p>　　可以看到，对于[1..22]的每个数，都可以转换成1、2、4、8、7这5个数的组合。5个数相当于5个物品，决策为“选”或者“不选”。例如17对应着{2、7、8}，即“不选1，选2，不选4，选7，选8”。同学们有没有觉得这个很像01普通背包里啊？</p><h3 id="将二进制拆分原理运用于多重背包模型">1.4.2将二进制拆分原理运用于多重背包模型</h3><p>　　继续看上面的例子，假设第i种物品的限制为cnt[i]=22个。在一维状态数组dp[]下，对于枚举的背包总容量j限制下，应该对23种方案求取最大值，来作为dp[j]的值。即有如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[j]=<span class="hljs-built_in">max</span>(   dp[j- <span class="hljs-number">0</span>*ys1[i]] + <span class="hljs-number">0</span>*val[i],     <span class="hljs-comment">// 第i种物品一个都不选</span><br>dp[j- <span class="hljs-number">1</span>*ys1[i]] + <span class="hljs-number">1</span>*val[i],     <span class="hljs-comment">// 选1个第i种物品</span><br>dp[j- <span class="hljs-number">2</span>*ys1[i]] + <span class="hljs-number">2</span>*val[i],     <span class="hljs-comment">// 选2个第i种物品</span><br>   dp[j- <span class="hljs-number">3</span>*ys1[i]] + <span class="hljs-number">3</span>*val[i],     <span class="hljs-comment">// 选3个第i种物品</span><br>   dp[j- <span class="hljs-number">4</span>*ys1[i]] + <span class="hljs-number">4</span>*val[i],     <span class="hljs-comment">// 选4个第i种物品</span><br>   dp[j- <span class="hljs-number">5</span>*ys1[i]] + <span class="hljs-number">5</span>*val[i],     <span class="hljs-comment">// 选5个第i种物品</span><br>   ......<br>   dp[j<span class="hljs-number">-22</span>*ys1[i]] + <span class="hljs-number">22</span>*val[i],    <span class="hljs-comment">// 选22个第i种物品</span><br> ) <br></code></pre></td></tr></table></figure><p>　　在多重背包的朴素版本中，我们需要选择[0..22]中的某个整数c（个），来作为dp[j]的最优决策。而c值必然等于1、2、4、8、7这5个数字的组合，即1、2、4、8、7这五个物品分别“选1次”或者“不选”，这和普通01背包中“每个物品都可能不选或者被选1次”正好吻合。所以，我们可以把原来求“对于第i种物品的多重背包问题”，转换成求“1倍、2倍、4倍、8倍和7倍这5个‘物品（虚拟的，捆绑在一起视为一个物品）’的'选1次'和'不选'”的01背包问题。</p><p>　　同学们应该还记得01普通背包的最原始做法吧，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= ys1[<span class="hljs-number">1</span>]; j--) &#123;<br>    dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j- ys1[<span class="hljs-number">1</span>]] + value[<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= ys1[<span class="hljs-number">2</span>]; j--) &#123;<br>    dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j- ys1[<span class="hljs-number">2</span>]] + <span class="hljs-number">2</span>*value[<span class="hljs-number">2</span>]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= ys1[<span class="hljs-number">3</span>]; j--) &#123;<br>    dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j- ys1[<span class="hljs-number">3</span>]] + value[<span class="hljs-number">3</span>]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= ys1[<span class="hljs-number">4</span>]; j--) &#123;<br>    dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j- ys1[<span class="hljs-number">4</span>]] + value[<span class="hljs-number">4</span>]);<br>&#125;<br>......<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= ys1[n]; j--) &#123;<br>    dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j- ys1[n]] + value[n]);<br>&#125;<br></code></pre></td></tr></table></figure><p>　　既然这个最优决策c值必然是1倍、2倍、4倍、8倍、7倍这五个虚拟物品的01组合，所以上面的代码等效于下面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= ys1[i]; j--) &#123;<br>    dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j- ys1[i]] + value[i]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= <span class="hljs-number">2</span>*ys1[i]; j--) &#123;<br>    dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j- <span class="hljs-number">2</span>*ys1[i]] + <span class="hljs-number">2</span>*value[i]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= <span class="hljs-number">4</span>*ys1[i]; j--) &#123;<br>    dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j- <span class="hljs-number">4</span>*ys1[i]] + <span class="hljs-number">4</span>*value[i]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= <span class="hljs-number">8</span>*ys1[i]; j--) &#123;<br>    dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j- <span class="hljs-number">8</span>*ys1[i]] + <span class="hljs-number">8</span>*value[i]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= <span class="hljs-number">7</span>*ys1[i]; j--) &#123;<br>    dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j- <span class="hljs-number">7</span>*ys1[i]] + <span class="hljs-number">7</span>*value[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p>　　不过上面的1、2、4、8、7这几个数字并不直观，书写起来也很冗余。对于任意的cnt[i]，精简后的最终版如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 1. 将第i个物品的c倍（2的幂倍）视为一个“物品” 进行dp[j]值刷新</span><br><span class="hljs-type">int</span> c = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 从1倍开始翻倍</span><br><span class="hljs-keyword">while</span>( cnt[i] - c &gt; <span class="hljs-number">0</span> ) &#123;<br>    cnt[i] -= c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= c * ys1[i]; j--) &#123;   <span class="hljs-comment">// 只能倒序，因为转换成的是01背包模型</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j- c * ys1[i]] + c * value[i]);<br>    &#125;<br>    c *= <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">// 2. 对剩余的数量也要做同样的dp[]值刷新处理</span><br><span class="hljs-keyword">if</span>( cnt[i] ) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= cnt[i] * ys1[i]; j--) &#123;<br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-cnt[i] * ys1[i]] + cnt[i] * value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　上述代码的时间复杂度怎么看？</p><p>　　while循环的时间复杂度为<spanclass="math inline">\(O(log_2cnt[i])\)</span>，而for循环的复杂度为<spanclass="math inline">\(O(YS1)\)</span>，所以整个代码的时间复杂度为<spanclass="math inline">\(O(YS1*log_2cnt[i])\)</span>，再配上外层循环对n种物品的处理，总复杂度是<spanclass="math inline">\(O(n*YS1*log_2cnt[i])\)</span>。当cnt[i]较大时，线性和对数之间的差距还是会比较大的。有效率！</p><h3 id="新开数组存ys1和value很少使用看懂即可">1.4.3新开数组存ys1[]和value[]（很少使用，看懂即可）</h3><p>　　根据1.4.2节的分析，对于每一类物品，我们可以看作是多个物品的01背包。我们可以先把所有的num种物品及相关数据转换成虚拟物品，然后在这些虚拟物品上来做01普通背包，即可求解。其转换过程代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 输入提供的物品总种数num 和 背包总容量YS1限制</span><br>cin &gt;&gt;num &gt;&gt;YS1;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=num; i++)<br>    cin &gt;&gt;pri[i] &gt;&gt;v[i] &gt;&gt;cnt[i];<br><br><span class="hljs-comment">// 根据num和pri[]， 算出n和ys1[]</span><br>n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=num; i++)<br>&#123;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (t &lt;= cnt[i]) &#123;<br>        <span class="hljs-comment">// 拆分（按照该物品的数量上限来拆分）</span><br>        ys1[++n] = pri[i] * t;<br>        value[n] = v[i] * t;<br>        <span class="hljs-comment">// 更新</span><br>        cnt[i] = cnt[i] - t;<br>        t = t * <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cnt[i] &gt; <span class="hljs-number">0</span>) &#123;<br>        ys1[++n] = pri[i] * cnt[i];<br>        value[n] = v[i] * cnt[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　上述代码的时间复杂度为<spanclass="math inline">\(O(n*log_2cnt[i])\)</span>，后续只需要针对n、ys1[]和value[]来做普通01背包即可。</p><h1 id="二实战训练">二、实战训练</h1><h2 id="庆功会">2.1 1269 庆功会</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1269">1269：【例9.13】庆功会</a></p><h3 id="分析">2.1.2 分析</h3><p>　　这是一个裸的多重背包题目。<span class="math inline">\(n \leq500,\ YS1 \leq 6000,\ cnt[i] \leq10\)</span>。数据规模都比较小，很适合用来练手。同学们可以先练朴素级做法，再练二进制优化法（直接干；或者另存数组干）。</p><h3 id="ac代码">2.1.3 AC代码</h3><p>　　下面展示四种方法，同学们都需要看懂，尤其是第四种方法，背下来哦！</p><h4 id="朴素做法-二维标准状态数组">2.1.3.1 朴素做法 +二维标准状态数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法1: 多重背包的朴素做法，一维成本，标准dp[][]，三重循环，求最大价值和</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">朴素做法，多重背包，标准dp[][]，求最大价值和</span><br><span class="hljs-comment">一维成本，成本是奖品的价格，</span><br><span class="hljs-comment">收益是奖品价值，</span><br><span class="hljs-comment">每种奖品的数量上限不一致且已知</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">（1）状态数组定义</span><br><span class="hljs-comment">dp[i][j]：前i种奖品且总成本在j元以内的奖品的最大价值之和</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">（2）所求目标</span><br><span class="hljs-comment">       dp[n][YS1] ：前n种奖品且总成本在YS1(即题上的m)元以内的奖品的最大价值之和</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">（3）状态转换方程</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">a). 第i种奖品一个都不选入，则</span><br><span class="hljs-comment">dp[i][j] = dp[i-1][j]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">b). 第i种奖品选 k 个   ( k &gt; 0)</span><br><span class="hljs-comment">前i-1种奖品的成本为j - k*ys1[i]，第i种选k个，则前i种奖品成本为j</span><br><span class="hljs-comment">dp[i][j] = max( dp[i-1][j - k*ys1[i]] + k*value[i] )</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">整合a) 和 b) 之后，公式为：</span><br><span class="hljs-comment">dp[i][j] = dp[i-1][j];</span><br><span class="hljs-comment">dp[i][j] = max( dp[i-1][j - k * ys1[i]] + k*value[i],   dp[i][j]  );</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">（4）循环边界和循环顺序</span><br><span class="hljs-comment">i: [1..n]     1 --&gt; n增序</span><br><span class="hljs-comment">j: [YS1..ys1[i]]  YS1 --&gt; ys1[i]降序</span><br><span class="hljs-comment">k: [0 .. cnt[i]]</span><br><span class="hljs-comment">&amp;&amp; j &gt;= k*ys1[i]    0 --&gt; cnt[i]    增序，体现出不选或重复多选</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">（5）状态初始化值和特例</span><br><span class="hljs-comment">dp[0][j] = 0 :  前 0 种奖品的最大价值之和是 0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> YS1, n;<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">501</span>], value[<span class="hljs-number">501</span>], cnt[<span class="hljs-number">501</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">501</span>][<span class="hljs-number">6001</span>];  <span class="hljs-comment">// 注意数据规模！</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 输入背包总重量YS1限制，及提供的物品总个数n</span><br>    cin &gt;&gt;n &gt;&gt;YS1;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        cin &gt;&gt;ys1[i] &gt;&gt;value[i] &gt;&gt; cnt[i];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)       <span class="hljs-comment">// 针对每1种物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 背包剩余空间j，注意，j的取值范围是[0, YS1]</span><br>            <span class="hljs-comment">// k表示放入物品i的个数，0个或者若干个的几种情况都拿来比一比，找到一个最大值给dp[i][j]！</span><br>            <span class="hljs-comment">// 先设定k=0的情况，即第i种奖品一个都不选</span><br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k * ys1[i] &lt;= j &amp;&amp; k &lt;= cnt[i]; k++ ) <span class="hljs-comment">//其实0是空转，不影响结果，但为了好记，且和后续其他模型的代码统一，建议这里写0</span><br>                dp[i][j] = <span class="hljs-built_in">max</span>( dp[i<span class="hljs-number">-1</span>][j - k * ys1[i]] + k*value[i],   dp[i][j]);<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dp[n][YS1]); ;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="朴素做法-一维滚动状态数组">2.1.3.2 朴素做法 +一维滚动状态数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法2: 多重背包的朴素做法，一维成本，滚动dp[]，三重循环，求最大价值和</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">多重背包，滚动dp[]，求最大价值和</span><br><span class="hljs-comment">一维成本，成本是奖品的价格，</span><br><span class="hljs-comment">收益是奖品价值，</span><br><span class="hljs-comment">每种奖品的数量上限不一致且已知</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">（1）状态数组定义</span><br><span class="hljs-comment">dp[j]：总成本在j元以内的奖品的最大价值之和</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">（2）所求目标</span><br><span class="hljs-comment">       dp[YS1] ：总成本在YS1(即题上的m)元以内的奖品的最大价值之和</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">（3）状态转换方程</span><br><span class="hljs-comment">dp[j] = max( data[j],    dp[j - k*ys1[i]] + k*value[i] )</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">（4）循环边界和循环顺序</span><br><span class="hljs-comment">i: [1..n]     1 --&gt; n增序</span><br><span class="hljs-comment">j: [YS1..ys1[i]]  YS1 --&gt; ys1[i]降序</span><br><span class="hljs-comment">k: [0 .. cnt[i]]</span><br><span class="hljs-comment">&amp;&amp; j &gt;= k*ys1[i]    0 --&gt; cnt[i]    增序，体现出不选或重复多选</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">（5）状态初始化值和特例</span><br><span class="hljs-comment">dp[0] = 0 :  成本在0元以内的奖品的最大价值之和是 0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 一维状态数组的解法  AC代码</span><br><span class="hljs-type">int</span> dp[<span class="hljs-number">6001</span>];  <span class="hljs-comment">// 注意数据规模！</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> YS1, n;<br>    <span class="hljs-comment">// 注意数据规模！！</span><br>    <span class="hljs-type">int</span> ys1[<span class="hljs-number">501</span>], value[<span class="hljs-number">501</span>], cnt[<span class="hljs-number">501</span>];<br>    <span class="hljs-comment">// 输入背包总重量YS1限制，及提供的物品总个数n</span><br>    cin &gt;&gt;n &gt;&gt;YS1;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        cin &gt;&gt;ys1[i] &gt;&gt;value[i] &gt;&gt;cnt[i];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)  <span class="hljs-comment">// 针对每1个物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)   <span class="hljs-comment">// 这里应该从右往左推，和1268完全背包问题不一样，千万要注意！！</span><br>            <span class="hljs-comment">// 这里不是判断放不放了，而是判断放几个！！</span><br>            <span class="hljs-comment">// k表示放入物品i的个数，把几种情况都拿来比一比，找到一个最大值！</span><br>            <span class="hljs-comment">// 本题和1268只有一个地方不一样，即下面的“&amp;&amp; k&lt;=cnt[i]”</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k*ys1[i]&lt;=j &amp;&amp; k&lt;=cnt[i]; k++)  <span class="hljs-comment">//其实0是空转，不影响结果，但为了好记，且和后续其他模型的代码统一，建议这里写0</span><br>                dp[j] = <span class="hljs-built_in">max</span>( dp[j],    dp[j - k*ys1[i]] + k*value[i] ) ;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dp[YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二进制优化一维状态数组-另存ys1和value">2.1.3.3二进制优化，一维状态数组 + 另存ys1[]和value[]</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法3: 多重背包的二进制优化版本，新开数组来存放ys1[]和value[]，一维成本，滚动dp[]，二重循环，求最大价值和</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">6001</span>];  <span class="hljs-comment">// 注意数据规模！</span><br><span class="hljs-type">int</span> YS1, n, num;<br><span class="hljs-comment">// 注意数据规模！！</span><br><span class="hljs-type">int</span> pri[<span class="hljs-number">501</span>], v[<span class="hljs-number">501</span>], cnt[<span class="hljs-number">501</span>];<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">5100</span>], value[<span class="hljs-number">5100</span>];   <span class="hljs-comment">// 之所以是5100，是因为cnt最多可到10倍 </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 输入背包总重量YS1限制，及提供的物品总个数n</span><br>    cin &gt;&gt;num &gt;&gt;YS1;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=num; i++)<br>        cin &gt;&gt;pri[i] &gt;&gt;v[i] &gt;&gt;cnt[i];<br><br>    <span class="hljs-comment">// 根据num、pri[]、v[]， 换算出n、ys1[]、value[] </span><br>    n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=num; i++)&#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (cnt[i] &gt;= t) &#123;<br>            <span class="hljs-comment">// 拆分（按照该物品的数量上限来拆分）</span><br>            ys1[++n] = pri[i] * t;<br>            value[n] = v[i] * t;<br>            <span class="hljs-comment">// 更新</span><br>            cnt[i] = cnt[i] - t;<br>            t = t * <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cnt[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            ys1[++n] = pri[i] * cnt[i];<br>            value[n] = v[i] * cnt[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 简单的01背包处理，没什么机关</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)              <span class="hljs-comment">// 针对每1个物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)   <span class="hljs-comment">// 这里应该从右往左推，和1268完全背包问题不一样，千万要注意！！</span><br>            dp[j] = <span class="hljs-built_in">max</span>( dp[j],    dp[j - ys1[i]] + value[i] ) ;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dp[YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二进制优化一维状态数组-最优背">2.1.3.4 二进制优化，一维状态数组(最优，背！)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法4 : 多重背包的二进制优化做法，不另外开设二进制优化的成本和收益数组</span><br><span class="hljs-comment">//         一维成本，滚动dp[]，三重循环，求最大价值和    O(YS1 * n * log(cnt[i])) </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">多重背包，滚动dp[]，求最大价值和</span><br><span class="hljs-comment">一维成本，成本是奖品的价格，</span><br><span class="hljs-comment">收益是奖品价值，</span><br><span class="hljs-comment">每种奖品的数量上限不一致且已知</span><br><span class="hljs-comment">一共不超过500种奖品，每种奖品的数量不超过10个，所以总奖品数不超过5000个，</span><br><span class="hljs-comment">可以把奖品展开，重新处理生成ys1[]，然后把多重背包化简成普通的01背包问题 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">（1）状态数组定义</span><br><span class="hljs-comment">dp[j]：总成本在j元以内的奖品的最大价值之和</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">（2）所求目标</span><br><span class="hljs-comment">       dp[YS1] ：总成本在YS1(即题上的m)元以内的奖品的最大价值之和</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">（3）状态转换方程</span><br><span class="hljs-comment">dp[j] = max( data[j],    dp[j - ys1[i]] + value[i] )</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">（4）循环边界和循环顺序</span><br><span class="hljs-comment">i: [1..n]      1 --&gt; n增序</span><br><span class="hljs-comment">j: [YS1..ys1[i]]  YS1 --&gt; ys1[i]降序</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">（5）状态初始化值和特例</span><br><span class="hljs-comment">dp[0] = 0 :  成本在0元以内的奖品的最大价值之和是 0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> dp[<span class="hljs-number">6001</span>];  <span class="hljs-comment">// 注意数据规模！</span><br><span class="hljs-type">int</span> YS1, n, num;<br><span class="hljs-type">int</span> pri[<span class="hljs-number">501</span>], v[<span class="hljs-number">501</span>], cnt[<span class="hljs-number">501</span>];<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">5100</span>], value[<span class="hljs-number">5100</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> YS1, n;<br><span class="hljs-comment">// 注意数据规模！！</span><br><span class="hljs-type">int</span> ys1[<span class="hljs-number">501</span>], value[<span class="hljs-number">501</span>], cnt[<span class="hljs-number">501</span>];<br><span class="hljs-comment">// 输入背包总重量YS1限制，及提供的物品总个数n</span><br>cin &gt;&gt;n &gt;&gt;YS1;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>cin &gt;&gt;ys1[i] &gt;&gt;value[i] &gt;&gt;cnt[i];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123; <span class="hljs-comment">// 针对每1种物品，分成2部分来处理 </span><br><span class="hljs-comment">// 1. 先针对第i个物品的2的幂倍 c=pow(2, XXX) 进行dp[]值刷新 </span><br><span class="hljs-type">int</span> c = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>( cnt[i] - c &gt; <span class="hljs-number">0</span> ) &#123; <br>cnt[i] -= c;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= c * ys1[i]; j--) &#123;   <span class="hljs-comment">// 只能倒序，01背包的模式 </span><br>dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j- c * ys1[i]] + c * value[i]);<br>&#125;<br>c *= <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">// 2. 对剩余的数量也要做同样的dp[]值刷新处理 </span><br><span class="hljs-keyword">if</span>( cnt[i] ) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= cnt[i] * ys1[i]; j--) &#123;<br>dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-cnt[i] * ys1[i]] + cnt[i] * value[i]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dp[YS1]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p1776-宝物筛选">2.2 P1776 宝物筛选</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P1776">P1776宝物筛选</a></p><h3 id="分析-1">2.2.2 分析</h3><p>　　这是一个裸的多重背包题目，求不超过背包总限制YS1的最大价值。<spanclass="math inline">\(n \leq 10^2,\ YS1 \leq 4*10^4\)</span>。<spanclass="math inline">\(n*YS1*cnt[i]=10^4*10^3*10^2=10^9 &gt;10^7\)</span>，但<spanclass="math inline">\(n*YS1=10^7\)</span>，所以朴素级做法难以得全分，而二进制优化可AC本题。</p><h3 id="ac代码-1">2.1.3 AC代码</h3><p>　　2.1节的朴素做法就不在这里展示了。同学们可以自行用朴素做法拿到30分，就已经达到练习朴素做法的目的了。下面展示二进制优化的最优做法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//  方法1 二进制优化后的多重背包，滚动dp[]，不另存数组，600ms，AC代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 10001</span><br><span class="hljs-type">int</span> dp[<span class="hljs-number">40001</span>];<br><span class="hljs-type">int</span> YS1, n, num;<br><span class="hljs-type">int</span> ys1, value, cnt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt;n &gt;&gt;YS1;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123; <span class="hljs-comment">// 针对每1种物品，分成2部分来处理</span><br>        cin &gt;&gt;value &gt;&gt;ys1 &gt;&gt;cnt;<br>        <span class="hljs-comment">// 1. 先针对第i个物品的2的幂倍 c=pow(2, XXX) 进行dp[]值刷新</span><br>        <span class="hljs-type">int</span> c = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>( cnt - c &gt; <span class="hljs-number">0</span> ) &#123;<br>            cnt -= c;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= c * ys1; j--)    <span class="hljs-comment">// 只能倒序，01背包的模式</span><br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j- c * ys1] + c * value);<br>            c *= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-comment">// 2. 对剩余的数量也要做同样的dp[]值刷新处理</span><br>        <span class="hljs-keyword">if</span>( cnt ) <br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= cnt * ys1; j--) <br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-cnt * ys1] + cnt * value);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dp[YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 背包问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>混合背包问题</title>
      <link href="/2024/05/17/%E6%B7%B7%E5%90%88%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2024/05/17/%E6%B7%B7%E5%90%88%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学　　</h1><h2 id="模型引入">1.1 模型引入</h2><p>　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1270">1270：【例9.14】混合背包</a></p><p>　　该题就是“多重背包”最常见的题面，裸题面，集01背包、完全背包和多重背包于同一个题内。</p><h2 id="视频教程">1.2 视频教程</h2><p>　　“E14 背包DP 混合背包”的<ahref="https://www.bilibili.com/video/BV1nV41127ZU/?spm_id_from=333.999.0.0&amp;vd_source=0e7cc4e4bbbb67e5c3c2a3e7d967f075">视频教程链接</a></p><h2 id="分析">1.3 分析</h2><p>　　对于混合背包，我们可以有如下两种做法。</p><h3 id="调整cnti统一用多重背包来实现">1.3.1调整cnt[i]，统一用多重背包来实现</h3><p>　　我们知道01背包是多重背包中cnt[i]=1时的特例；完全背包是多重背包中cnt[i]=INF时的特例。</p><p>　　其关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;ys1[i], &amp;value[i], &amp;cnt[i]);<br><span class="hljs-keyword">if</span> (cnt[i] == <span class="hljs-number">0</span>)<br>cnt[i] = <span class="hljs-number">1e9</span>;<br>&#125;<br><span class="hljs-comment">// 这里就统一按照多重背包的策略来做就行了，4种方法请随意！</span><br><span class="hljs-comment">// 多重背包的朴素做法，三重for，一维状态数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;=cnt[i] &amp;&amp; k*ys1[i] &lt;=j; k++)<br>dp[j] = <span class="hljs-built_in">max</span>( dp[j] ,   dp[j-k*ys1[i]] + k*value[i] );<br></code></pre></td></tr></table></figure><p>　　这种方法，粗暴，简单，但有效！哈哈！～</p><h3 id="不调整cnti分情况处理重要掌握">1.3.2不调整cnt[i]，分情况处理（重要，掌握）</h3><p>　　之前我们学习普通01背包、完全背包和多重背包时，都是假设每个或者每种物品的规则都是相同的，即所有物品都只能选或不选，或者所有物品都能选无限个，或者所有物品都有指定的个数限制。实际上，每种物品的规则是可以不同的，这就是现在的混合背包问题。<strong>混合背包问题，是可以针对每一种物品分开来处理的。这是因为有动态规划的局部最优化原理（前i个阶段的决策不受后续阶段数据的影响）。</strong>所以我们针对前i种物品在YS1的限制下的dp值，是不受后续其他物品的影响的，和后续其他物品无任何关系。不会因为出现了第i+1种物品的数据，就使得dp[1..i][0..YS1]的数据发生更改。因为有局部最优化原理，所以这种更改是不可能有的。</p><p>　　我们举个例子来看，假设01背包模型的核心代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)<br>        dp[j] = <span class="hljs-built_in">max</span>( dp[j - ys1[i]] + value[i],  dp[j]);<br></code></pre></td></tr></table></figure><p>　　上述代码实际上等效于如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[<span class="hljs-number">1</span>]; j--)<br>    dp[j] = <span class="hljs-built_in">max</span>( dp[j - ys1[<span class="hljs-number">1</span>]] + value[<span class="hljs-number">1</span>],  dp[j]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[<span class="hljs-number">2</span>]; j--)<br>    dp[j] = <span class="hljs-built_in">max</span>( dp[j - ys1[<span class="hljs-number">2</span>]] + value[<span class="hljs-number">2</span>],  dp[j]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[<span class="hljs-number">3</span>]; j--)<br>    dp[j] = <span class="hljs-built_in">max</span>( dp[j - ys1[<span class="hljs-number">3</span>]] + value[<span class="hljs-number">3</span>],  dp[j]);<br>......<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[n]; j--)<br>    dp[j] = <span class="hljs-built_in">max</span>( dp[j - ys1[n]] + value[n],  dp[j]);    <br></code></pre></td></tr></table></figure><p>　　注意：上述代码实际上对应着动态规划问题里的n个阶段。如果现在我们更改题目，让第2种物品可以选择无限个，即第2种物品是完全背包问题，则我们只需要更改第2阶段的策略即可，之前和之后的策略代码都不需要更改，即代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[<span class="hljs-number">1</span>]; j--)    <span class="hljs-comment">// 代码不变</span><br>    dp[j] = <span class="hljs-built_in">max</span>( dp[j - ys1[<span class="hljs-number">1</span>]] + value[<span class="hljs-number">1</span>],  dp[j]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=ys1[<span class="hljs-number">2</span>]; j&lt;=YS1; j++)    <span class="hljs-comment">// 只需要把第2种物品的决策过程改成完全背包的代码即可</span><br>    dp[j] = <span class="hljs-built_in">max</span>( dp[j - ys1[<span class="hljs-number">2</span>]] + value[<span class="hljs-number">2</span>],  dp[j]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[<span class="hljs-number">3</span>]; j--)    <span class="hljs-comment">// 代码不变</span><br>    dp[j] = <span class="hljs-built_in">max</span>( dp[j - ys1[<span class="hljs-number">3</span>]] + value[<span class="hljs-number">3</span>],  dp[j]);<br>......                            <span class="hljs-comment">// 代码不变</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[n]; j--)    <span class="hljs-comment">// 代码不变</span><br>    dp[j] = <span class="hljs-built_in">max</span>( dp[j - ys1[n]] + value[n],  dp[j]);    <br></code></pre></td></tr></table></figure><p>　　既然是混合背包问题，那么题目中一定会告知如何鉴别每种物品属于什么背包，例如用cnt[i]来区分。所以针对混合背包问题，就有如下的核心代码来解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法2：不改cnt[i]，直接分情况讨论，强烈建议掌握本方法噶</span><br><span class="hljs-keyword">if</span> (cnt[i]==<span class="hljs-number">1</span>)<br>    <span class="hljs-comment">// 将第 i 种物品按照01背包来处理</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)    <span class="hljs-comment">// 枚举背包总容量j，只能倒序</span><br>        dp[j] = <span class="hljs-built_in">max</span>( dp[j - ys1[i]] + value[i],  dp[j]);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt[i]==<span class="hljs-number">0</span>)<br>    <span class="hljs-comment">// 将第 i 种物品按照完全背包来处理</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=ys1[i]; j&lt;=YS1; j++) &#123;  <span class="hljs-comment">// 枚举背包总容量j，只能正序</span><br>        dp[j] = <span class="hljs-built_in">max</span>( dp[j] , dp[j - ys1[i]] + value[i] );<br>    &#125;<br><span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// // 将第 i 种物品按照多重背包来处理，二进制优化版本</span><br>    <span class="hljs-comment">// 1. 先针对第i个物品的2的幂倍 c=pow(2, XXX) 进行dp[]值刷新</span><br>    <span class="hljs-type">int</span> c = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>( cnt[i] - c &gt; <span class="hljs-number">0</span> ) &#123;<br>        cnt[i] -= c;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= c * ys1[i]; j--) &#123;   <span class="hljs-comment">// 只能倒序，01背包的模式</span><br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j- c * ys1[i]] + c * value[i]);<br>        &#125;<br>        c *= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-comment">// 2. 对剩余的数量也要做同样的dp[]值刷新处理</span><br>    <span class="hljs-keyword">if</span>( cnt[i] ) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= cnt[i] * ys1[i]; j--) &#123;<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-cnt[i] * ys1[i]] + cnt[i] * value[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　上述核心代码，是针对每种物品都需要去区分和处理的。所以外包一个for(i=[1..n])的循环就可以了。</p><h3 id="时间复杂度分析">1.3.3 时间复杂度分析</h3><p>　　普通01背包和完全背包的复杂度都是<spanclass="math inline">\(O(YS1*n)\)</span>。多重背包如果采用朴素做法，则复杂度为<spanclass="math inline">\(O(YS1*\Sigma_{i=1}^{i=n}cnt[i])\)</span>；如果采用二进制优化，则为<spanclass="math inline">\(O(\ YS1* \Sigma_{i=1}^{i=n}log_2\ cnt[i]\)\)</span>。所以混合背包要看情况了，一般来说复杂度介于01背包和多重背包之间。</p><h1 id="二实战训练">二、实战训练</h1><h2 id="混合背包">2.1 1270 混合背包</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1270">1270：【例9.14】混合背包</a></p><h3 id="分析-1">2.1.2 分析</h3><p>　　这是一个裸的混合背包题目。<span class="math inline">\(n \leq 30,\YS1 \leq200\)</span>。cnt[i]没有说数据范围，但实际上其范围也不大。整个题的数据规模都比较小，很适合用来练手。同学们可以先练下面的方法一，再练方法二，重点掌握方法二。</p><h3 id="ac代码">2.1.3 AC代码</h3><p>　　下面展示两种方法，同学们都需要看懂，尤其是第二种方法，背下来哦！</p><h4 id="改cnti-一维滚动状态数组-多重背包的解决方案">2.1.3.1 改cnt[i] +一维滚动状态数组 + 多重背包的解决方案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法1：混合背包，改cnt[i]，统一成多重背包问题来解决</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 31</span><br><span class="hljs-type">int</span> dp[<span class="hljs-number">201</span>];<br><span class="hljs-type">int</span> ys1[N], value[N], cnt[N];<br><span class="hljs-type">int</span> YS1, n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt;YS1 &gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;ys1[i], &amp;value[i], &amp;cnt[i]);<br>        <span class="hljs-keyword">if</span> (cnt[i] == <span class="hljs-number">0</span>)<br>            cnt[i] = <span class="hljs-number">1e9</span>;<br>    &#125;<br>    <span class="hljs-comment">//// 下面是多重背包的解决方案，可任意。 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;=cnt[i] &amp;&amp; k*ys1[i] &lt;=j; k++)<br>                dp[j] = <span class="hljs-built_in">max</span>( dp[j] ,   dp[j-k*ys1[i]] + k*value[i] );<br><br>    cout &lt;&lt; dp[YS1];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="直接分类处理硬干混合背包">2.1.3.2直接分类处理，硬干混合背包</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法2：不改cnt[i]，直接分情况讨论，强烈建议掌握本方法噶</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 31</span><br><span class="hljs-type">int</span> dp[<span class="hljs-number">201</span>];<br><span class="hljs-type">int</span> ys1[N], value[N], cnt[N];    <span class="hljs-comment">// 其实也可以不定义数组，只需3个变量即可</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> YS1, n;<br>    cin &gt;&gt;YS1 &gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;ys1[i], &amp;value[i], &amp;cnt[i]);<br>        <span class="hljs-comment">// 录一种，就马上处理一种</span><br>        <span class="hljs-keyword">if</span> (cnt[i]==<span class="hljs-number">1</span>)<br>            <span class="hljs-comment">// 将第 i 种物品按照01背包来处理</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)    <span class="hljs-comment">// 枚举背包总容量j，只能倒序</span><br>                dp[j] = <span class="hljs-built_in">max</span>( dp[j - ys1[i]] + value[i],  dp[j]);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt[i]==<span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 将第 i 种物品按照完全背包来处理</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=ys1[i]; j&lt;=YS1; j++) &#123;  <span class="hljs-comment">// 枚举背包总容量j，只能正序</span><br>                dp[j] = <span class="hljs-built_in">max</span>( dp[j] , dp[j - ys1[i]] + value[i] );<br>            &#125;<br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// // 将第 i 种物品按照多重背包来处理，二进制优化版本</span><br>            <span class="hljs-comment">// 1. 先针对第i个物品的2的幂倍 c=pow(2, XXX) 进行dp[]值刷新</span><br>            <span class="hljs-type">int</span> c = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>( cnt[i] - c &gt; <span class="hljs-number">0</span> ) &#123;<br>                cnt[i] -= c;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= c * ys1[i]; j--) &#123;   <span class="hljs-comment">// 只能倒序，01背包的模式</span><br>                    dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j- c * ys1[i]] + c * value[i]);<br>                &#125;<br>                c *= <span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-comment">// 2. 对剩余的数量也要做同样的dp[]值刷新处理</span><br>            <span class="hljs-keyword">if</span>( cnt[i] ) &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= cnt[i] * ys1[i]; j--) &#123;<br>                    dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-cnt[i] * ys1[i]] + cnt[i] * value[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; dp[YS1];<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="p1833-樱花">2.2 P1833 樱花</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P1833">P1833樱花</a></p><h3 id="分析-2">2.2.2 分析</h3><p>　　这是一个几乎裸的多重背包题目，和2.1节的1270基本上是一样的解法，可用来巩固混合背包的学习。</p><p>　　求不超过背包总限制YS1的最大价值。<span class="math inline">\(n\leq 10^4,\ YS1 \leq 1*10^3,\ cnt[i] \leq 10^2,\ ys1[i] \leq10^2\)</span>。<spanclass="math inline">\(n*YS1*cnt[i]=10^4*10^3*10^2=10^9 &gt;10^7\)</span>，但<spanclass="math inline">\(YS1*\Sigma_{i=1}^{i=n}log_2\cnt[i]=10^3*10^4*7=7*10^7\)</span>，所以朴素级做法难以得全分，而二进制优化可AC本题。</p><h3 id="ac代码-1">2.2.3 AC代码</h3><p>　　下面展示两种做法，同学们重点掌握第二种。</p><h4 id="改cnti-一维滚动状态数组-多重背包的解决方案-1">2.2.3.1 改cnt[i] +一维滚动状态数组 + 多重背包的解决方案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法一： 混合背包转为多重背包处理 + 滚动dp  AC 1.26s</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 10010</span><br><span class="hljs-type">int</span> h1, m1, h2, m2, YS1, num;<br><span class="hljs-type">int</span> ys1[N], value[N], cnt[N];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">1010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d:%d&quot;</span>, &amp;h1, &amp;m1);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d:%d&quot;</span>, &amp;h2, &amp;m2);<br>    YS1 = h2*<span class="hljs-number">60</span>+m2 - h1*<span class="hljs-number">60</span>-m1;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=num; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;ys1[i], &amp;value[i], &amp;cnt[i]);<br>        <span class="hljs-keyword">if</span> (cnt[i] == <span class="hljs-number">0</span>)<br>            cnt[i] = INF;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=num; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k*ys1[i]&lt;=j &amp;&amp; k&lt;=cnt[i] ; k++)<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-k*ys1[i]] + k*value[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dp[YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="直接分类处理硬干混合背包-1">2.1.3.2直接分类处理，硬干混合背包</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法2：混合背包，把多重背包做二进制优化，不新开数组，245ms，AC代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 10010</span><br><span class="hljs-type">int</span> h1,m1,h2,m2;<br><span class="hljs-type">int</span> num, YS1, dp[<span class="hljs-number">1010</span>];<br><span class="hljs-type">int</span> n, ys1[N], value[N], cnt[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d:%d%d:%d%d&quot;</span>,&amp;h1,&amp;m1,&amp;h2,&amp;m2,&amp;num);<br><span class="hljs-comment">// 根据录入的小时和分钟数据，计算出间隔的分钟数，即为总限制量YS1</span><br>YS1 = (h2*<span class="hljs-number">60</span>+m2) - (h1*<span class="hljs-number">60</span>+m1);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=num; i++)<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;ys1[i],&amp;value[i],&amp;cnt[i]);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=num; i++) &#123;<br><span class="hljs-comment">// 01普通背包，该物品只装1次</span><br><span class="hljs-keyword">if</span> (cnt[i]==<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)<br>dp[j] = <span class="hljs-built_in">max</span>( dp[j], dp[j-ys1[i]] + value[i] );<br>&#125;<br><span class="hljs-comment">// 完全背包，该物品可以装无限次 </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt[i] == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> j=ys1[i]; j&lt;=YS1; j++)<br>dp[j] = <span class="hljs-built_in">max</span>( dp[j], dp[j-ys1[i]] + value[i] );<br>&#125;<br><span class="hljs-comment">// 多重背包，该物品装cnt[i]次 </span><br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> ( c &lt;= cnt[i] )&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> j=YS1; j&gt;=c*ys1[i]; j--)<br>dp[j] = <span class="hljs-built_in">max</span>( dp[j], dp[j-c*ys1[i]] + c*value[i] );<br><br>cnt[i] = cnt[i]- c;   <span class="hljs-comment">// 别忘了cnt[i]要减少 </span><br>c=c*<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (cnt[i] &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> j=YS1; j&gt;=cnt[i]*ys1[i]; j--)<br>dp[j] = <span class="hljs-built_in">max</span>( dp[j], dp[j-cnt[i]*ys1[i]] + cnt[i]*value[i] );<br>&#125;<br><br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dp[YS1]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 背包问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完全背包问题</title>
      <link href="/2024/05/11/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2024/05/11/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学　　</h1><h2 id="模型引入">1.1 模型引入</h2><p>　　总约束量为YS1，n<font color="red"><strong>种</strong></font>可待选择的物品需要装入，每种物品有无限个，它们都有各自的重量和价值，你需要从中选择合适的组合来使得总约束量内的物品总价值最大（<strong>每种物品可以装0个，也可以装任意多个；不需要刚好装满，允许不"刚好"装满</strong>）</p><p>　　上面这段就是完全背包最常见的题面。</p><h2 id="完全背包和普通01背包之间的关系">1.2完全背包和普通01背包之间的关系</h2><p>　　从上面的模型可以看到，普通01背包是“有n个物品”可选“0个或者1个”，而完全背包是“有n种物品，每种物品可选0个或者任意个”。也就是说，完全背包可以对一种物品选任意个。虽然理论上来说是任意个，但实际上个数肯定不能超过总约束量的约束，即不能超过YS1/ys1[i]个（否则背包撑爆了）。</p><p>　　那这种“可以选任意个数”该如何处理呢？我们需要先想想之前的普通01背包模型中选1个是如何处理的？我们先看看之前01背包的分析，并稍微换一下措辞：</p><p>　　对于第i种物品：</p><ul><li><p>1）如果背包的总容量j不足以容纳第i种物品的1个，此时只能被迫放弃第i种物品，价值没有一点增加。所以有：<span class="math display">\[dp[i][j]=dp[i-1][j] \tag{1}\]</span></p></li><li><p>2）如果背包的总容量j能够容纳第i种物品的1个，此时可以有2种选择：“装0个”、“装1个”第i种物品。此时需要对这2种决策进行比较判断，选出价值最大的决策。</p><ul><li><p>a)如果<strong>装0个</strong>第i种物品，则有:</p><p><span class="math display">\[dp[i][j]=dp[i-1][j] \tag{2}\]</span>　　既然决定对第i种物品一个都不装，那么总价值不会增加，仍然和“前i-1种物品对于总容量j的策略”是一致的。</p></li><li><p>b)如果<strong>装1个</strong>第i种物品，则有:</p><p><span class="math display">\[dp[i][j]=dp[i-1][j-ys1[i]]+value[i] \tag{3}\]</span></p></li></ul></li><li><p>综上情况1）和情况2），则有状态转移方程为：</p></li></ul><p><span class="math display">\[dp[i][j]=\begin{cases}dp[i-1][j] &amp; (j&lt;ys1[i]) \\max(\ dp[i-1][j], \quad dp[i-1][j-ys1[i]]\ +\ value[i]\ ) &amp; (j\geqys1[i])\end{cases} \tag{4}\]</span></p><p>　　以上就是01背包的分析过程。当允许装同一种物品的多个时，我们发现，只需要把其中的第2）点分析稍微调整一下即可。调整后的内容如下：</p><ul><li><p>2）如果背包的总容量j能够容纳第i种物品的<strong>任意</strong>个，此时可以有<strong>多</strong>种选择：“装0个”、“装1个”<strong>、“装2个”、……“装j/ys1[i]个”</strong>第i种物品。此时需要对<strong>多</strong>种决策进行比较判断，选出价值最大的决策。维持a）和b）决策不变，并在后面加入其他决策，如下：</p><ul><li><p>c)如果<strong>装<font color="red">2</font>个</strong>第i种物品，此时可以把这2个第i种物品捆绑起来视为1个物品，其约束量为2*ys1[i]，其收益为2*value[i]，则有:</p><p><span class="math display">\[dp[i][j]=dp[i-1][j-2*ys1[i]]\ +\ 2*value[i] \tag{5}\]</span></p></li><li><p>d)如果<strong>装<font color="red">3</font>个</strong>第i种物品，此时可以把这3个第i种物品捆绑起来视为1个物品，其约束量为3*ys1[i]，其收益为3*value[i]，则有:</p><p><span class="math display">\[dp[i][j]=dp[i-1][j-3*ys1[i]]\ +\ 3*value[i] \tag{6}\]</span></p></li><li><p>……以此类推</p></li><li><p>如果<strong>装<spanclass="math inline">\(\textcolor{red}{\lfloor} j/ys1[i]\textcolor{red}{\rfloor}\quad(\lfloor  \ \rfloor表示向下取整)\)</span>个</strong>第i种物品，此时可以把这<spanclass="math inline">\(\lfloor j/ys1[i]\rfloor\)</span>个第i种物品捆绑起来视为1个物品，其约束量为<spanclass="math inline">\(\mathbf{ \textcolor{red}{\lfloor} j/ys1[i]\textcolor{red}{\rfloor}}\ *\ ys1[i]\)</span>，其收益为<spanclass="math inline">\(\mathbf{\lfloor j/ys1[i] \rfloor}\ *\value[i]\)</span>，则有:</p><p><span class="math display">\[dp[i][j]=dp[i-1]\textcolor[RGB]{0,225,0}[j-\textcolor[RGB]{225,0,0}\lfloorj/ys1[i]\textcolor[RGB]{225,0,0}\rfloor*ys1[i]\textcolor[RGB]{0,225,0}]\+\ \textcolor[RGB]{225,0,0}\lfloorj/ys1[i]\textcolor[RGB]{225,0,0}\rfloor*value[i] \tag{7}\]</span></p></li></ul><p>　　这里一共有<span class="math inline">\(\lfloor j/ys1[i]\rfloor+1\)</span>种决策（举个例子：整个背包总容量为20，当前要处理的总约束量j=10斤。对于第i种物品，ys1[i]=3斤，一共有<spanclass="math inline">\(\lfloor 10/3 \rfloor+1=4\\)</span>种决策，分别是“装0个第i种物品”、“装1个第i种物品”、“装2个第i种物品”、“装3个第i种物品”）。</p><p>　　因为dp[i][j]表示总容量为j时前i种物品能装入的最大价值，所以需要对这<spanclass="math inline">\(\lfloor j/ys1[i]\rfloor+1\)</span>​个决策的结果取其最大值。对于上述2种情况，多个决策（第1、2、3、5、6、7式）取最大值，数学公式整理如下：<span class="math display">\[dp[i][j]=\begin{cases}dp[i-1][j] &amp; (j&lt;ys1[i]) \\max(dp[i-1][j],\quaddp[i-1][j-ys1[i]]+value[i],\quad dp[i-1][j-2*ys1[i]]+2*value[i], \quaddp[i-1][j-3*ys1[i]]+3*value[i], \quad ......,dp[i-1]\textcolor[RGB]{0,225,0}[j-\textcolor[RGB]{225,0,0}\lfloorj/ys1[i]\textcolor[RGB]{225,0,0}\rfloor*ys1[i]\textcolor[RGB]{0,225,0}]+\textcolor[RGB]{225,0,0}\lfloorj/ys1[i]\textcolor[RGB]{225,0,0}\rfloor*value[i] \ &amp; (j\geq ys1[i]))\end{cases} \tag{8}\]</span></p><p>　　可以看到，完全背包实际上就是在01普通背包的基础上，对更多的决策取最大值而已。下面展示针对公式8的多种代码实现方法。</p></li></ul><h2 id="代码实现方法">1.3 代码实现方法</h2><h3 id="三重for-标准状态数组-正序逆序效率一般">1.3.1 三重for +标准状态数组 + 正序/逆序（效率一般）</h3><p>　　<strong>在标准状态数组和三重for的前提下</strong>，对于公式8不需做任何改动，直接照搬即可。实现代码如下：　　</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    //// 标准状态数组，三重for</span><br><span class="hljs-comment">    // 该代码尚未优化，不必硬背，只需对照着公式(8)来看即可</span><br><span class="hljs-comment">    for(int i=1; i&lt;=n; i++)        // 针对每1种物品</span><br><span class="hljs-comment">    for(int j=0; j&lt;=YS1; j++)&#123;   // 枚举填写背包总容量j，正序逆序均可，j=0也需要填写 </span><br><span class="hljs-comment">            if (j &lt; ys1[i])         </span><br><span class="hljs-comment">                dp[i][j]= dp[i-1][j];</span><br><span class="hljs-comment">            else&#123;</span><br><span class="hljs-comment">                dp[i][j]= dp[i-1][j];</span><br><span class="hljs-comment">                dp[i][j]= max(dp[i][j], dp[i-1][j-ys1[i]] + value[i]);</span><br><span class="hljs-comment">                dp[i][j]= max(dp[i][j], dp[i-1][j-2*ys1[i]] + 2*value[i]);</span><br><span class="hljs-comment">                dp[i][j]= max(dp[i][j], dp[i-1][j-3*ys1[i]] + 3*value[i]);</span><br><span class="hljs-comment">                ......</span><br><span class="hljs-comment">            &#125;  // end if</span><br><span class="hljs-comment">        &#125; // end for</span><br><span class="hljs-comment">*/</span><br><br>    <span class="hljs-comment">//// 对上面注释的代码进行优化后的代码如下：</span><br>    <span class="hljs-comment">//// 标准状态数组，三重for</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)        <span class="hljs-comment">// 针对每1种物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举填写背包总容量j，正序逆序均可，j=0也需要填写 </span><br>            dp[i][j]= dp[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">if</span> (j &gt;= ys1[i])<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=j/ys1[i]; k++) <br>                <span class="hljs-comment">//for (int k=1; k*ys1[i]&lt;=j; k++)  //这样写也是等效的 </span><br>                    dp[i][j]= <span class="hljs-built_in">max</span>(dp[i][j],  dp[i<span class="hljs-number">-1</span>][j-k*ys1[i]] + k*value[i] );<br>        &#125;<br></code></pre></td></tr></table></figure><p>　　这种实现方式，时间复杂度为<spanclass="math inline">\(O(n*YS1*k)\)</span>，空间复杂度为<spanclass="math inline">\(O(n*YS1)\)</span>。可以看到，不管是时间或是空间，该方法都是比较差的，无法应对n或者YS1较大的情况。但要求同学们还是要掌握该方法，因为它是后续多个改进版本的理论基石，有助于理解和掌握后续版本。</p><h3 id="三重for-滚动状态数组-逆序效率一般">1.3.2 三重for +<font color="red">滚动</font>状态数组 + 逆序（效率一般）</h3><p>　　<strong>在<font color="red">滚动</font>状态数组和三重for的前提下</strong>，需要对1.3.1节的代码做数组压缩。实现的关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    for(int i=1; i&lt;=n; i++)        </span><br><span class="hljs-comment">    for(int j=YS1; j&gt;=0; j--)&#123;   // 枚举填写背包总容量j，逆序，j=0也需要填写 </span><br><span class="hljs-comment">            dp[j]= dp[j];</span><br><span class="hljs-comment">            if (j &gt;= ys1[i])</span><br><span class="hljs-comment">                for (int k=1; k&lt;=j/ys1[i]; k++) </span><br><span class="hljs-comment">                //for (int k=1; k*ys1[i]&lt;=j; k++)  //这样写也是等效的 </span><br><span class="hljs-comment">                    dp[j]= max(dp[j],  dp[j-k*ys1[i]] + k*value[i] );</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    上面这个代码存在大量冗余，优化后的代码如下：</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)        <span class="hljs-comment">// 针对每1种物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)&#123;   <span class="hljs-comment">// 枚举填写背包总容量j，只能逆序，j=0也需要填写 </span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=j/ys1[i]; k++) <br>                <span class="hljs-comment">//for (int k=1; k*ys1[i]&lt;=j; k++)  //这样写也是等效的 </span><br>                    dp[j]= <span class="hljs-built_in">max</span>(dp[j],  dp[j-k*ys1[i]] + k*value[i] );<br>        &#125;<br></code></pre></td></tr></table></figure><p>　　其实上面的代码，枚举j也可以用正序，只不过这样一来，就变成带冗余循环的方法四了。</p><p>　　上面的这种实现方式，时间复杂度为<spanclass="math inline">\(O(n*YS1*k)\)</span>，空间复杂度为<spanclass="math inline">\(O(\textcolor[RGB]{225,0,0}{YS1})\)</span>。</p><p>　　可以看到，1.3.1和1.3.2节的代码都是三重for，这是阻碍算法效率的瓶颈。有没有什么办法进一步优化呢？还真有。请看下节。</p><h3 id="二重for-标准状态数组-正序较优掌握是下一节的铺垫">1.3.3<font color="red">二重</font>for + 标准状态数组 +正序（较优，掌握，是下一节的铺垫）</h3><p>　　本节内容建议同学们还是应该掌握，以便于加深对背包问题的理解。有些题解是采用这种方法和结构来写代码的。看懂本节后有利于同学们读懂这些题解代码。而且，标准状态数组能够记录路径，能倒推出具体的决策内容，这是滚动数组无法比拟的。</p><h4 id="分析">1.3.3.1 分析</h4><p>　　之前在普通01背包的处理时，对于标准状态数组枚举总容量j时顺序是可正可逆的。因为dp[i][j]完全依赖于dp[i-1][0..YS1]的数据，即依赖于上一行的数据，和本行数据无关，所以第i行的填写顺序可正可逆。dp[i][j]和dp[i][j-ys1[i]]之间会有什么关系吗？请看下图：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240515101440755.png"alt="image-20240515101440755" /><figcaption aria-hidden="true">image-20240515101440755</figcaption></figure><p>　　在右图中，当i=2，更新dp[2][5]时，dp[2][5]=max(dp[1][5],dp[2][3]+10)=max(5,10+10)=20。这里需要注意到一点：<strong>dp[1][3]之前已经针对物品B而更新过了，其值为10，表示背包总容量为3斤时的最优决策是“只装入了一个物品B”。在这种情况下，dp[2][5]选择了dp[2][3]+10这个决策，表示“在dp[2][3]对应决策的基础上，再装入第二个物品B”，</strong>也就是说，dp[2][5]对应的决策是“只装入两个物品B”。这就体现了完全背包的含义。其关键动作在于“一定要从左往右更新dp[i][]”。<strong>只有这样，才能在之前已针对第i个物品做过决策的基础上，再次针对第i个物品做当前的决策</strong>，这样就体现出完全背包的“重复选择”含义。</p><h4 id="关键代码">1.3.3.2 关键代码</h4><p>　　关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)       <span class="hljs-comment">// 针对每1种物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举背包总空间j，必须只能正序，不能逆序！</span><br><span class="hljs-keyword">if</span> ( j &lt; ys1[i] )<br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];   <span class="hljs-comment">// 别忘了公式8是两种情况，不够装时只能放弃物品i，照抄即可 </span><br><span class="hljs-keyword">else</span>  <br>    <span class="hljs-comment">// dp[i-1][j] 表示“能装而不装”，照抄上一行数据，注意是[i-1] </span><br>               <span class="hljs-comment">// dp[i][j - ys1[i]] + value[i]是当前行左侧（注意是[i]），它可能已经装有若干个物品i </span><br>dp[i][j] = <span class="hljs-built_in">max</span>( dp[i<span class="hljs-number">-1</span>][j] , dp[i][j - ys1[i]] + value[i] );<br>&#125;<br><br></code></pre></td></tr></table></figure><p>　　上述代码中的if语句和普通01背包的标准状态数组实现代码中的if语句只有一个地方不一样，那就是dp[<font color="red"><strong>i</strong></font>][j-ys1[i]]+value[i]，其他都完全一样。另外，完全背包要求枚举背包空间j必须只能正序！不能再“正序逆序均可（适用于普通01背包）”了。</p><h4 id="路径管理和输出不常考有时间建议还是看看">1.3.3.3路径管理和输出（不常考，有时间建议还是看看）</h4><p>　　在这个模型下，背包决策路径如何记录和输出呢？即如何看出来每个物品选择了多少个？</p><ol type="1"><li>方法一（不额外定义路径数组，直接从dp[][]倒推决策）</li></ol><p>　　其实很简单，原理和普通01背包的处理是一样的。如果dp[i][j]!=dp[i-1][j]，则背包里必然有物品i，水平往左跳转到dp[i][j-ys1[i]]，再和其上一行数据dp[i-1][j-ys1[i]]相比：如果相同，说明物品i只选择了1个，该处理物品i-1了；如果值不相同，说明还选择了第二个物品i，继续水平往左跳到dp[i][j-2*ys1[i]]，以此类推。通过这样的方式就能找到所有的决策。</p><p>　　举个例子，如下图所示：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240515113238734.png"alt="image-20240515113238734" /><figcaption aria-hidden="true">image-20240515113238734</figcaption></figure><ol start="2" type="1"><li>方法二（定义专门的路径数组ppre[][]来实现）</li></ol><p>　　在二维数组中如果存在多条树状路径，每个点的位置标记为(x,y)，且有唯一的前驱。这种模型下要记录路径，可以采用如下的模式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> r, c;<br>&#125;path[maxn][maxYS1];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pri</span><span class="hljs-params">(node cur)</span></span>&#123;<br><span class="hljs-keyword">if</span> (cur.r==<span class="hljs-number">-1</span> &amp;&amp; cur.c==<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">pri</span>( ppre[cur.r][cur.c] );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;选择物品%d\n&quot;</span>, cur.r);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)       <span class="hljs-comment">// 针对每1种物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举背包总空间j，必须只能正序，不能逆序！</span><br><span class="hljs-keyword">if</span> ( j &lt; ys1[i] )&#123;<br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];   <span class="hljs-comment">// 别忘了公式8是两种情况，不够装时只能放弃物品i，照抄即可</span><br>                ppre[i][j]=(node)&#123;i<span class="hljs-number">-1</span>, j&#125;;<br>            &#125;<br><span class="hljs-keyword">else</span>  <br>    <span class="hljs-comment">// dp[i-1][j] 表示“能装而不装”，照抄上一行数据，注意是[i-1] </span><br>                <span class="hljs-comment">// dp[i][j - ys1[i]] + value[i]是当前行左侧（注意是[i]），它可能已经装有若干个物品i </span><br>                <span class="hljs-keyword">if</span> (dp[i<span class="hljs-number">-1</span>][j] &lt;= dp[i][j - ys1[i]] + value[i]) <br>   dp[i][j] = dp[i][j - ys1[i]] + value[i] , ppre[i][j]=(node)&#123;i, j-ys1[i]&#125;;<br>            <span class="hljs-keyword">else</span><br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j], ppre[i][j]=(node)&#123;i<span class="hljs-number">-1</span>, j&#125;;<br>&#125;<br><span class="hljs-comment">/////// 上面代码可以简化一下。此处为了让同学们理解其根源，所以没去简化。</span><br></code></pre></td></tr></table></figure><h3 id="二重for-滚动状态数组-正序最优做法背">1.3.4<font color="red">二重</font>for + <font color="red">滚动</font>状态数组+ 正序（最优做法，背）</h3><h4 id="分析-1">1.3.4.1 分析</h4><p>　　之前在普通01背包的处理时，对于滚动数组，要求从右往左枚举总容量j，以顺利完成新旧数据的读取和更新。那如果非要从左往右更新，会出现什么情况呢？请看下图：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240515091316889.png"alt="image-20240515091316889" /><figcaption aria-hidden="true">image-20240515091316889</figcaption></figure><p>　　在右图中，当i=2，更新dp[5]时，dp[5]=max(dp[5],dp[3]+10)=max(5,20)=20。这里需要注意到一点：<strong>dp[3]之前已经针对物品B而更新过了，其值为10，表示背包总容量为3斤时的最优决策是“装入了一个物品B”。在这种情况下，dp[5]选择了dp[3]+10这个决策，表示“装入第二个物品B”</strong>，也就是说，dp[5]对应的决策是“在dp[2][3]对应决策的基础上，再装入两个物品B”。这就体现了完全背包的含义。其关键动作在于“一定要从左往右更新dp[]，才能体现出完全背包的‘重复选择’含义”。</p><h4 id="关键代码-1">1.3.4.2 关键代码</h4><p>　　关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//版本3. AC代码, 一维状态数组 + 2重for + 增序 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)       <span class="hljs-comment">// 针对每1种物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=ys1[i]; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举背包总容量j，正序，j的取值范围是[ys1[i], YS1] </span><br>dp[j] = <span class="hljs-built_in">max</span>( dp[j] , dp[j - ys1[i]] + value[i] );<br>&#125;<br><span class="hljs-comment">// 或者如下，等效，但不如上述代码更优 </span><br><span class="hljs-comment">//for(int j=0; j&lt;=YS1; j++)&#123;   </span><br><span class="hljs-comment">//if ( ys1[i] &lt;= j ) </span><br><span class="hljs-comment">//dp[j] = max( dp[j] , dp[j - ys1[i]] + value[i] );</span><br><span class="hljs-comment">//&#125;</span><br></code></pre></td></tr></table></figure><h4 id="路径管理和输出不常考有时间建议还是看看-1">1.3.4.3路径管理和输出（不常考，有时间建议还是看看）</h4><p>　　在滚动状态数组模型下，无法根据状态数组来倒推路径，所以1.3.3.3节的方法一不再适用，但方法二是可以的。同学们可以自行调整其代码，此处不再多说。</p><h2 id="彩蛋">1.4 彩蛋</h2><p>　　如果现在有一个题如下：</p><p>　　总背包容量YS1，2种物品，第1种只能选0个或者1个，而第2种物品可以选无限个，求最大价值。分别给出ys1[1..2]和value[1..2]。</p><p>　　这样的题，怎么破？同学们可以思考一下。后续帖会给出答案。</p><h1 id="二.-实战练习">二. 实战练习</h1><h2 id="section">2.1 1268</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1268">1268：【例9.12】完全背包问题</a></p><h3 id="分析-2">2.1.2 分析</h3><p>　　这是一个裸的完全背包的题目，maxn=30，maxYS1=200，这么小的数据量，适合新手用来练习上面的四种方法。本题不需要输出路径。同学们要求掌握四种方法，并重点掌握第四种。</p><h3 id="ac代码">2.1.3 AC代码</h3><h4 id="二维状态数组-3重for-增序降序">2.1.3.1 二维状态数组 + 3重for +增序/降序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 1. AC代码, 二维状态数组 + 3重for + 增序/降序 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">35</span>][<span class="hljs-number">211</span>];<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">35</span>], value[<span class="hljs-number">35</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> YS1, n;<br>cin &gt;&gt;YS1 &gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>cin &gt;&gt;ys1[i] &gt;&gt;value[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)       <span class="hljs-comment">// 针对每1种物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举背包总空间j，正序逆序均可，和第i行数据无关</span><br><span class="hljs-comment">// 这里不是判断放不放了，而是判断放几个！！</span><br><span class="hljs-comment">// k表示放入物品i的个数，把dp[i-1][j]和放不同个数的几种情况都拿来比一比，找到一个最大值！ </span><br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br><span class="hljs-keyword">if</span> ( ys1[i] &lt;= j ) <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k * ys1[i] &lt;= j; k++ ) <br>dp[i][j] = <span class="hljs-built_in">max</span>( dp[i<span class="hljs-number">-1</span>][j - k * ys1[i]] + k*value[i],     dp[i][j]  );<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max=%d&quot;</span>, dp[n][YS1]); ;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一维状态数组-3重for-降序">2.1.3.2 一维状态数组 + 3重for +降序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 2. AC代码, 一维状态数组 + 3重for + 降序 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">201</span>], ys1[<span class="hljs-number">31</span>], value[<span class="hljs-number">31</span>];<br><span class="hljs-type">int</span> YS1, n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin &gt;&gt;YS1 &gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>cin &gt;&gt;ys1[i] &gt;&gt;value[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)              <span class="hljs-comment">// 针对每1个物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)   <span class="hljs-comment">// </span><br><span class="hljs-comment">// 这里不是判断放不放了，而是判断放几个！！</span><br><span class="hljs-comment">// k表示放入物品i的个数，把几种情况都拿来比一比，找到一个最大值！ </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k*ys1[i]&lt;=j; k++) <br>dp[j] = <span class="hljs-built_in">max</span>( dp[j - k*ys1[i]] + k*value[i],  dp[j]);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max=%d&quot;</span>, dp[YS1]); <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="二维状态数组-2重for-正序">2.1.3.3 二维状态数组 + 2重for +正序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//3. AC代码, 二维状态数组 + 2重for + 增序 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">35</span>][<span class="hljs-number">211</span>];<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">35</span>], value[<span class="hljs-number">35</span>];<br><span class="hljs-type">int</span> YS1, n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin &gt;&gt;YS1 &gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>cin &gt;&gt;ys1[i] &gt;&gt;value[i];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)       <span class="hljs-comment">// 针对每1种物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举背包总空间j，只能正序 </span><br><span class="hljs-keyword">if</span> ( j &lt; ys1[i] )<br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];   <span class="hljs-comment">// 别忘了公式8是两种情况，不够装时只能放弃物品i，照抄即可 </span><br><span class="hljs-keyword">else</span>  <br>    <span class="hljs-comment">// dp[i-1][j] 表示“能装而不装”，照搬上一行，注意是i-1 </span><br>                <span class="hljs-comment">// dp[i][j - ys1[i]] + value[i]是当前行左侧（注意是i），它可能已经装有若干个物品i </span><br>dp[i][j] = <span class="hljs-built_in">max</span>( dp[i<span class="hljs-number">-1</span>][j] , dp[i][j - ys1[i]] + value[i] );<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max=%d&quot;</span>, dp[n][YS1]); ;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="一维状态数组-2重for-正序">2.1.3.4 一维状态数组 + 2重for +正序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//4. AC代码, 一维状态数组 + 2重for + 增序 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">211</span>];<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">35</span>], value[<span class="hljs-number">35</span>];<br><span class="hljs-type">int</span> YS1, n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin &gt;&gt;YS1 &gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>cin &gt;&gt;ys1[i] &gt;&gt;value[i];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)               <span class="hljs-comment">// 针对每1种物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=ys1[i]; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举背包总容量j，只能正序，j的取值范围是[ys1[i], YS1] </span><br>dp[j] = <span class="hljs-built_in">max</span>( dp[j] , dp[j - ys1[i]] + value[i] );<br>&#125;<br><span class="hljs-comment">// 或者如下，等效。 </span><br><span class="hljs-comment">//for(int j=0; j&lt;=YS1; j++)&#123;   </span><br><span class="hljs-comment">//if ( ys1[i] &lt;= j ) </span><br><span class="hljs-comment">//dp[j] = max( dp[j] , dp[j - ys1[i]] + value[i] );</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max=%d&quot;</span>, dp[YS1]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="p1616-疯狂的采药">2.2 P1616 疯狂的采药</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P1616">P1616疯狂的采药</a></p><h3 id="分析-3">2.2.2 分析</h3><p>　　所有草药可以无限采摘，这是完全背包的题。</p><p>　　本题数据规模与约定中明确指出了“$1 n*YS1 ^7 <spanclass="math inline">\(”，所以时间复杂度并不会有问题。但是因为\)</span>n^4，YS1^7$，如果定义成标准状态数组，则二维数组空间达到了1e11，这必然会造成MLE。本题只能使用本帖的方法四来破。</p><p>　　从数据规模和约定中看到，每个草药的价值最大可到1e4，最少可1秒内搞定，而且最大可有1e7秒的背包总容量，所以总价值可能达到1e11，故为稳妥起见，开longlong类型。</p><h3 id="ac代码-1">2.2.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">二重for + 一维滚动状态数组 + 正序</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">（1）状态数组定义</span><br><span class="hljs-comment">intdp[i]：在j时间之内能采摘的最大价值</span><br><span class="hljs-comment">（2）所求目标</span><br><span class="hljs-comment">       dp[YS1]</span><br><span class="hljs-comment">（3）状态转换方程</span><br><span class="hljs-comment">A. 时间j内不够，不装第i种草药</span><br><span class="hljs-comment">假设前i-1轮处理中，在时间j内的总价值是dp[j]，既然不采摘第i种草药，</span><br><span class="hljs-comment">所以前i种草药在时间j内的最大总价值dp[j] 和前i-1种草药在时间j内的最大总价值dp[j]是一样的，</span><br><span class="hljs-comment">dp[j] = dp[j]  简单地说，就是什么都不改即可</span><br><span class="hljs-comment">B. 时间j内够装第i种草药  j &gt;= ys[i]</span><br><span class="hljs-comment">a. 装上</span><br><span class="hljs-comment">如果前i-1种草药在时间j-ys1[i]内的最大总价值是dp[j-ys1[i] ]，</span><br><span class="hljs-comment">那么我们可以用剩下的ys1[i]这个时间来装第i种草药的1个，所以有下式：</span><br><span class="hljs-comment">dp[j] = dp[j-ys1[i] ] + value[i];</span><br><span class="hljs-comment">b. 不装 （能装但不装，我当然可以不装，谁说我看到一种草药就非得装啊？要懂策略嘛！）</span><br><span class="hljs-comment">如果不装，那么在j时间内，我面对前i种草药在时间j内能获得的最大价值</span><br><span class="hljs-comment">和 我面对前i-1种草药在时间j内获得的最大价值是一样的</span><br><span class="hljs-comment">dp[j] = dp[j];    这种处理，和前面的A相似</span><br><span class="hljs-comment">归纳汇总：</span><br><span class="hljs-comment">dp[j] = max(dp[j], dp[j-ys1[i] ] + value[i]);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">（4）循环边界和循环顺序</span><br><span class="hljs-comment">j: [ys1[i]..YS1] ys1[i] --&gt; YS1必须增序，这样才能体现出重复背包的含义</span><br><span class="hljs-comment">（5）状态初始化值和特例</span><br><span class="hljs-comment">当value都为0时，不管怎么采，最大价值都为 0, 所以 dp[] 初始化为 0 最合适；</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">动态规划的题，变量众多，请严格遵守命名规则和风格，不要乱取名字</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 10001</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T 10000001</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[T];         <span class="hljs-comment">// 不开long long真的是要见祖宗的，哈哈！～</span><br><span class="hljs-type">int</span> n, YS1;<br><span class="hljs-type">int</span> ys1[N], value[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;YS1, &amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;ys1[i], &amp;value[i]);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=ys1[i]; j&lt;= YS1; j++)<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-ys1[i]] + value[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, dp[YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p2722-总分">2.3 P2722 总分</h2><h3 id="原题链接-2">2.3.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P2722">P2722 [USACO3.1]总分 Score Inflation</a></p><h3 id="分析-4">2.3.2 分析</h3><p>　　每一种题可以无限出多个题，这是完全背包的题。</p><p>　　本题数据规模与约定中明确指出<span class="math inline">\(n \leq10^4，YS1 \leq10^4\)</span>，每个题的收益最大也可到1e4，最少可1秒内搞定，总价值可能达到1e8。本题可用来训练本帖的四种方法。<strong>想练习的同学可以书写四种方法，不必拘泥本帖给出的AC代码。</strong></p><h3 id="ac代码-2">2.3.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 一维状态数组 + 二重for + 正序</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 10001</span><br><span class="hljs-type">int</span> n, YS1, ys1[N], value[N], dp[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;YS1, &amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;value[i], &amp;ys1[i]);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=ys1[i]; j&lt;=YS1; j++)<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-ys1[i]] + value[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dp[YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-1"></h2>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 背包问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>其他的线性DP（简单）</title>
      <link href="/2024/05/04/%E5%85%B6%E4%BB%96%E7%9A%84%E7%BA%BF%E6%80%A7DP%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/"/>
      <url>/2024/05/04/%E5%85%B6%E4%BB%96%E7%9A%84%E7%BA%BF%E6%80%A7DP%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><p>　　因为dp的本质是递推，所以普通的线性dp，本质上就是线性递推的题，同学们只要定义好状态数组和递推方程等，严格做好六点分析，就能破之。</p><h1 id="二.-实战训练">二. 实战训练</h1><h2 id="城市交通网最短路径">2.1 1261 城市交通网——最短路径</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1261"><strong>1261：【例9.5】城市交通路网</strong></a></p><h3 id="分析">2.1.2 分析</h3><p>　　该题需要在带权的网中，求<strong>指定的两个点之间的最短路径</strong>。最短路径问题的各个解法，本质上就是动态规划。本题可以作为最短路径的入门题，虽然不是最短路径的最优算法，但属于朴素级的算法，简单易懂。</p><ol type="1"><li>状态数组定义</li></ol><p>　　dp[i]：从出发点A走到点i的最短路径值</p><ol start="2" type="1"><li>所求目标</li></ol><p>　　dp[n]，目标点是编号值最大的第n点（即E点）。</p><ol start="3" type="1"><li>状态转换方程</li></ol><p>　　动态规划的本质是递推，现在要找关于dp[i]的状态转移方程，就需要假设dp[i-1]、dp[i-2]……等已知，然后找dp[i]和dp[i-1]、dp[i-2]……等之间的关系式。“A点到i号点的最短路径值”，和“A点到i-1号点的最短路径值”、“A点到i-2号点的最短路径值”等之间有什么关系吗？</p><p>　　以8号点为例，从图上可以看到，从5号点和6号点都能走到8号点，且长度已知。要想从A点走到8号点，必然要经过5号点或者6号点，这是必经之路。只要我们求出“从A点走到5号点的最短路径值”，以及“从A点走到6号点的最短路径值”，分别加上<spanclass="math inline">\(5-&gt;8\)</span>的权值<spanclass="math inline">\(mapp_{5-&gt;8}\)</span>和<spanclass="math inline">\(6-&gt;8\)</span>的权值<spanclass="math inline">\(mapp_{6-&gt;8}\)</span>，两个<strong>和值</strong>比较，取最小值（因为是求最短路）即可。</p><p>　　<strong>我们用mapp[i][j]来表示从i号点<font color="red">直接</font>走到j号点的边弧长度值，如果从i号点不能走到j号点，则该值用INF（一个极大值，表示“无穷大”）表示。这是图论中的“邻接矩阵存储表示法”。</strong>因为较为简单，所以同学们可以记下该方法。</p><p>　　我们根据上面的样例分析，可以得出状态转移方程如下： <spanclass="math display">\[dp[i]=min(dp[from]+mapp[from][i])  \qquad \ (from: mapp[from][i]\ \!=INF)\]</span>　　from号点，为“能直接走到i号点的所有点”（这些点到i号点有一条<strong>或者多条</strong>直接的边弧），通过循环筛选，多次取min值，找到最小值。</p><ol start="4" type="1"><li>循环顺序和边界</li></ol><p>　　递推的核心，是“填数组，即根据已知填写未知”。本题有一个很重要的特点，那就是“所有点的编号都是从图的左侧往右侧进行编号的，所以所有能直接走到i号点的点，其编号值都肯定比i小”。可以看到样例数据的这个邻接矩阵，是一个上三角矩阵（矩阵右下部分为全0）所以要找所有能直接走到i号点的点from，只需要搜[1..i-1]这个范围编号的所有点即可。至于当前点i的循环顺序，只能从左往右填。总结如下：</p><p>　　 i：2 ---&gt; n增序（1号点就不必填了，自己到自己的路径长度值肯定是0了）</p><p>　　from：1 &lt;---&gt; i-1增减序均可（按什么序去比最小值都可以，只要找到了就行）</p><ol start="5" type="1"><li>特例</li></ol><p>　　状态转移方程中并没有出现dp[i-1]这种东西，所以不太直观。仔细思考，可以发现，有点是不需要算的，比如dp[1]，1号点到1号点自己的最短路径长度值，那肯定是0咯！</p><p>　　dp[1]=0;</p><ol start="6" type="1"><li>初始化值</li></ol><p>　　除了特例位置dp[1]上的值之外，dp[2..n]应该给什么初值呢？另外一个数组mapp[][]应该给什么初值呢？</p><ul><li>关于mapp[][]：我们仔细观察样例数据可以发现，如果i号点到j号点不可直达，样例数据是以0来表示两点之间的距离。对于标准的邻接矩阵来说，这是不规范的处理。为了方便和杜绝后患，在录入mapp[][]时，建议最好是把0更改为INF。当然，也可以不处理，但在后续二重dor里对dp[]更新时，一定就要预先筛选剔除掉“不可直达”的情况。鉴于本题在录入邻接矩阵时，已提供了完整的n*n个数据，所以mapp[][]不需要在录入之前做初始化了。</li><li>关于dp[]：从状态转移方程中可以看出，dp[i]的值，需要先找到符合条件（<spanclass="math inline">\(mapp[from][i]\ \!=INF\)</span>）的from点。如果没有找到这样的from点，if语句的判断条件不符合，则dp[i]并不会被修改。换句话说，如果没有任何点能直接走到i号点，那么从1号点走到i号点的最短路径长度值，必然只能是“无穷大”，千万不能赋值为0。</li></ul><p>　　所以：dp[2..n]=INF</p><ol start="7" type="1"><li>关于无穷大（INF）在图论算法中的特别说明</li></ol><p>　　需要注意的是，无穷大“INF”在图论算法中的处理非常重要，不同的图论算法对无穷大的处理是不同的，需要小心处理。否则容易形成坑点，难以拿到全分。详情请见本站专门的帖子，看这里。</p><ol start="8" type="1"><li>输出最短路径</li></ol><p>　　首先需要意识到一点，从一个点到另一个点的最短路径，可能不止一条。从地图上来看，我们从左往右求解从1号点到其他每一个点的最短路径值，在计算或更新每个dp[to]值时，from和to的值都是知道的，只需要同步地记录下from和to之间的这个选择关系即可。</p><p>　　1）该采用什么样的方式来记录路径呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> to=<span class="hljs-number">2</span>; to&lt;=n; to++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> from=<span class="hljs-number">1</span>; from&lt;=to<span class="hljs-number">-1</span>; from++)<br><span class="hljs-keyword">if</span>( dp[to] &gt; dp[from] + mapp[from][to] )&#123; <br>    dp[to] = dp[from] + mapp[from][to];<br>    ？？？？？ <span class="hljs-comment">// 此处该如何记录from和to之间的关系？？？</span><br>&#125;<br></code></pre></td></tr></table></figure><p>　　我们知道每个from都可以指向多个to点，也知道每个to点可以被多个from点指过来。我们可以用pre[to]=from或者nxt[from]=to来记录from和to之间的关系。但在此用nxt[from]=to是错误的！为什么呢？因为上面二重循环的代码是给定一个to值，找出与该to值最符合条件的from值（即找出to点的路径前驱节点）。要记录也应该是记录to点的前驱节点，而不应该记录from点的后继节点，否则会引起数据记录混乱。</p><p>　　举个例子，就拿本题的样例数据来说吧，看4号点的更新过程，它只有1个from点（即1号点）可供筛选，需要更新，dp[4]=1，但若记录为nxt[1]=4，这是错误的。因为实际上的最短路径是1号点走向3号点。那为什么1号点的后继结点会被改为4号点呢？仅仅只是因为4比3大，先更新3号点的dp值，nxt[1]=3，然后更新4号点的dp值。nxt[1]=4，这是绝对谬误的。</p><p>　　<strong>归纳总结</strong>：从左往右更新每个点的dp[]值时，根据当前点选择其正确的前驱节点，那么就应该用pre[to]=from的方式来记录前驱节点信息即可。反过来，如果是从右往左处理每个点，根据当前点选择其正确的后继结点，则应该用nxt[from]=to来记录from的后继结点即可。</p><p>　　<strong>结论</strong>：定义pre[]表示每个节点在最短路径中的上一个（即前驱）节点的编号值。</p><p>　　2）如何输出路径？</p><p>　　需要明白一点，上述的这种方式，只能存一条路径，并不能输出多条最短路径。</p><p>　　对于pre[]数组，要想输出路径很简单，只需要从终点倒推到起点即可。可以采用递归函数来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>( k!=<span class="hljs-number">1</span> )<br><span class="hljs-built_in">find</span>( pre[k] );<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, k);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ac代码">2.1.3 AC代码</h3><p>　　1261题的AC代码如下：</p><p>　　1) “mapp[][]初值不改为INF”的版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span>                                                                 </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;                                                               <span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1010</span><br><span class="hljs-type">int</span> mapp[N][N],n;<br><span class="hljs-comment">// dp[5] = 10: 从出发点到5号点的最短路径值为 10 </span><br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-type">int</span> pre[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>( k!=<span class="hljs-number">1</span> )<br><span class="hljs-built_in">find</span>( pre[k] );<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, k);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-comment">// 因为每条弧都是从编号小的点指向编号大的点，</span><br><span class="hljs-comment">// 所以在邻接矩阵中的值，是一个上三角矩阵(主对角线以下都是0) </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;mapp[i][j]);<br>    <span class="hljs-comment">// 既然是对dp[]进行收缩，求min，所以这里需要先赋初值为INF </span><br><span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br><span class="hljs-comment">// 出发点1到自己的最短路径值 是 0 </span><br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;  <br><span class="hljs-comment">// 因为状态转换方程里是根据dp[]左侧来计算dp[]右侧的值，</span><br><span class="hljs-comment">// 所以from需要从1到n-1循环，to无所谓。 </span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> to=<span class="hljs-number">2</span>; to&lt;=n; to++)          <span class="hljs-comment">// 因为是根据dp左边算dp右边，所以必须是升序 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> from=<span class="hljs-number">1</span>; from&lt;=to<span class="hljs-number">-1</span>; from++)   <span class="hljs-comment">// 正序逆序均可，上三角矩阵，from的范围是[1..to-1]</span><br>            <span class="hljs-keyword">if</span> ( mapp[from][to] != <span class="hljs-number">0</span> )&#123;   <span class="hljs-comment">// 单独先剔除掉“不可直达的边弧”情况 </span><br>            <span class="hljs-comment">// 如果从from到to有弧，并且从出发点到to的距离 大于 从出发点到点from的距离 加上 从点from到点to的弧长值 </span><br>                <span class="hljs-keyword">if</span>( dp[to] &gt; dp[from] + mapp[from][to] )&#123; <span class="hljs-comment">// 本代码中mapp[from][to]没有初始化为INF，所以不会爆int </span><br>                    dp[to] = dp[from] + mapp[from][to];<br>                    <span class="hljs-comment">// 因为是根据左边来计算右边，所以下面只能用pre[to]=left，而不能用next[from]=to; </span><br>                    pre[to] = from;<br>                &#125;<br>            &#125;<br><span class="hljs-comment">// 打印最短路径值 </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;minlong=%d\n&quot;</span>, dp[n]);<br>    <span class="hljs-comment">// 打印路径上各个点 </span><br>    <span class="hljs-built_in">find</span>( n );<br>&#125;<br></code></pre></td></tr></table></figure><p>　　2）“mapp[][]改为INF”的版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span>                                                                 </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f   <span class="hljs-comment">// 可能存在无穷大+无穷大，应定义为0x3f3f3f3f</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1010</span><br><span class="hljs-type">int</span> mapp[N][N],n;<br><span class="hljs-comment">// dp[5] = 10: 从出发点到5号点的最短路径值为 10</span><br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-type">int</span> pre[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>( k!=<span class="hljs-number">1</span> )<br>        <span class="hljs-built_in">find</span>( pre[k] );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, k);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;mapp[i][j]);<br>            <span class="hljs-keyword">if</span> (mapp[i][j] == <span class="hljs-number">0</span>)   <span class="hljs-comment">// 和上一个版本不同的地方</span><br>                mapp[i][j] = INF;<br>        &#125;<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> to=<span class="hljs-number">2</span>; to&lt;=n; to++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> from=<span class="hljs-number">1</span>; from&lt;=to<span class="hljs-number">-1</span>; from++)<br>            <span class="hljs-keyword">if</span>( dp[to] &gt; dp[from] + mapp[from][to] ) &#123; <span class="hljs-comment">// 和上一个版本不同的地方</span><br>                dp[to] = dp[from] + mapp[from][to];<br>                pre[to] = from;<br>            &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;minlong=%d\n&quot;</span>, dp[n]);<br>    <span class="hljs-built_in">find</span>( n );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="挖地雷最长路径">2.2 1262 挖地雷——最长路径</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><h3 id="例9.6挖地雷">　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1262">1262：【例9.6】挖地雷</a></h3><h3 id="分析-1">2.2.2 分析</h3><p>　　模型精简：在一个有向无环图中，点带权，边弧不带权，不规定起点和终点，求该图中带权路径最长的路径长度值及路径经过的点序列。</p><p>　　题目中有一句非常重要的信息：“且保证都是小序号地窖指向大序号地窖”。也就是说，边弧只能从编号小的点指向编号大的点。所以，该图不存在环路。如果以i号点为某一条路径的终点，则这些路径的起点编号必然是小于i号点的。题目中样例数据得出如下图所示：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240507152015118.png"alt="image-20240507152015118" /><figcaption aria-hidden="true">image-20240507152015118</figcaption></figure><p>　　这个题，和1261在某些地方上是相似的，例如它也是需要求路径，也需要锚定一个当前点，然后在当前点的所有“前驱”或者“后继”点中去做选择。但本题并没有规定起点和终点，我们该如何定义状态数组呢？</p><p>　　稍加思考，可以发现，我们可以设定“dp[i]表示以当前点i作为路径起点（或者终点）的最长路径值”，也就是说，有两种方法。事实上，本题用这两种方法都可以解出来。下面分别分析之。两种方法都需要同学们学会掌握，通过本题学会如何在dp中进行正推，或逆推。</p><h4 id="以当前点为路径起点">2.2.2.1以当前点为<font color="red"><strong>路径起点</strong></font></h4><ol type="1"><li>状态数组定义</li></ol><p>　　dp[i]表示从当前点<strong>出发</strong>（含），最多能挖到的地雷个数</p><ol start="2" type="1"><li>所求目标</li></ol><p>　　带权最长路径的终点不一定是n号点，所以有： <spanclass="math display">\[max(dp[i])\quad(1\leq i \leq n)\]</span></p><ol start="3" type="1"><li>状态转移方程</li></ol><p>　　以上图中的5号点为例进行分析：从5号点出发最多能挖到的地雷个数，肯定与以6号点、7号点等右侧的点出发挖到的地雷数密切相关。只要右侧的dp值确定，则dp[5]可以很容易算出。所以有：<span class="math display">\[dp[from]=w[from] + max(dp[to]) \quad(to:mapp[from][to]!=INF)\]</span></p><ol start="4" type="1"><li>循环顺序和边界</li></ol><p>　　from: 1 &lt;---- n 逆序（右侧点的dp值先算，根据右侧填左侧）</p><p>　　to：from + 1 &lt;---&gt; n正序、逆序均可（只要筛完from的所有邻接点就行，什么顺序不重要）</p><ol start="5" type="1"><li>特例</li></ol><p>　　因为from必须从右往左填写，所以dp[n]必须是已知的特定值。根据dp[]的定义，我们可以知道，从n号点出发往右走，是没法走的，后面一个点都没有了。所以该路径只能包含n号点自己。</p><p>　　故有dp[n]=w[n]。</p><ol start="6" type="1"><li>初始化值</li></ol><p>　　本题有dp[]和mapp[][]这两个数组需要考虑初始化的问题。</p><p>　　对于mapp[][]，因为本题是“点带权值且边弧无权值的有向图”，所以mapp[][]只需要填写1/0或者true/false即可。根据样例提供的数据形式，我们可以默认最初mapp[][]为全false/0即可。</p><p>　　对于dp[]，可能很多同学会认为初值应该是0（毕竟很多题中dp[]的初值都是0，写习惯了）。我们仔细看状态转移方程，对于每个from点的dp[]值，当找到合适的to值时，会去取最大值，更新dp[from]。但同学们务必要小心这种状态转移方程的写法，因为它暗含了一个假设前提：你得先能够找到满足条件的to值。那万一不存在或者没找到符合条件的to值呢？（例如from号点在图中是一个<strong>汇点，没有任何边弧从from点出去</strong>，例如n号点就肯定是一个汇点）这种情况下，dp[from]无法被更新，最终结果仍然会是其初值。那这个初值应该是多少呢？当from点为汇点时，从from点出发的路径是没有后续节点的，只有from号地窖的地雷可挖，故dp[1..n]的初值应该就是w[1..n]。</p><p>　　注意，这里的初值设置，正好涵盖了本题对特例的处理。所以就不再单独处理特例了。</p><ol start="7" type="1"><li>路径输出</li></ol><p>　　1）路径如何表示或记录？</p><p>　　因为外层循环变量from是从右往左填写的，而to在其右侧，所以<strong>只能用next[from]=to的方式来记录</strong>，而不能用pre[to]=from来记录。<strong>同学们可以配合着2.1.2节第8点中的分析来学习，体会两种情况下的不同处理方式，归纳总结好。</strong></p><p>　　2）最长路径如何输出？</p><p>　　首先应找到最长路径的起点。鉴于dp[]的基本定义，我们可以先找到max(dp[1..n])，然后从该点位置开始，不断去next，就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> k = startpos;<br><span class="hljs-keyword">while</span> ( next[k] != <span class="hljs-number">0</span> )&#123;  <span class="hljs-comment">// 如果最长路径有下一个节点，就一直输出打印下一个节点，直到没有下一个点（==0）为止</span><br>    k = next[k];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-%d&quot;</span>, k);<br>&#125;<br></code></pre></td></tr></table></figure><p>　　当然，上面的这个代码，也可以通过递归函数来实现。同学们可以自行思考一下。</p><ol start="8" type="1"><li>AC代码</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 模型提炼： 求整个有向图中的最长路径的长度值，不规定起点和终点。</span><br><span class="hljs-comment">// 1262 和P2196是高度类似的题，只是图的输入方式不同，图结点规模不同</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*                             o</span><br><span class="hljs-comment">方法一： 用dp动态规划</span><br><span class="hljs-comment">（1）状态数组定义</span><br><span class="hljs-comment">dp[i]：从第i号点出发，最多能挖到的地雷个数（和方法二含义不同）</span><br><span class="hljs-comment">e.g.   dp[3]=20 表示 从3号点出发最多能挖到20个地雷</span><br><span class="hljs-comment">（2）所求目标</span><br><span class="hljs-comment">       max(dp[i])：   i:[1..n]， 需要找出dp[i]的最大值</span><br><span class="hljs-comment">（3）状态转换方程</span><br><span class="hljs-comment">dp[from] = w[from] + max(dp[to]);</span><br><span class="hljs-comment">（4）循环边界和循环顺序</span><br><span class="hljs-comment">from: [1..n-1]        n-1  --&gt;  1从右往左降序（方程是根据右边决定左边）</span><br><span class="hljs-comment">    to: [from+1..n]      from+1 &lt;--&gt; n增减均可</span><br><span class="hljs-comment">（5）状态初始化值和特例</span><br><span class="hljs-comment">dp[i] = w[i]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   本题两种方法，希望学生都要掌握，并认真体会如果获得pre[]和next[]，编写tonext()来表达和输出一条路径</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 201</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> w[N];         <span class="hljs-comment">// 每个点上具有的地雷，  w[3]=10 表示第3号点上有10个地雷</span><br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-type">int</span> next[N];      <span class="hljs-comment">// 最长路径中，当前点的下一个点编号</span><br><span class="hljs-type">bool</span> mapp[N][N];  <span class="hljs-comment">// 0-1邻接矩阵</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>( <span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i] );<br>        dp[i] = w[i];  <span class="hljs-comment">// 就算一条边都不走，最起码能够获得出发点的地雷个数</span><br>        next[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-keyword">while</span> ( <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), x != <span class="hljs-number">0</span> )<br>        mapp[x][y] = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 如果从点x能到点y，则mapp数组对应元素值标记为true</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> from = n<span class="hljs-number">-1</span>; from &gt;= <span class="hljs-number">1</span> ; from-- )   <span class="hljs-comment">// from的填写顺序是从右往左</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> to = from+<span class="hljs-number">1</span>; to&lt;=n; to++)      <span class="hljs-comment">// to的顺序可正可逆！ </span><br>            <span class="hljs-keyword">if</span> ( mapp[from][to] &amp;&amp; dp[from] &lt; w[from] + dp[to] ) &#123;<br>                dp[from] = w[from] + dp[to];<br>                <span class="hljs-comment">// 因为from是从右往左填写，所以此处敲定的应该是from号点的信息，而不是to号点的信息</span><br>                next[from] = to;   <span class="hljs-comment">// 此处只能用next[]，不能用pre[]来表示 </span><br>            &#125;<br>    <span class="hljs-comment">//找到maxx= max(dp[i])并找出其最长路径起点的下标值startpos</span><br>    <span class="hljs-type">int</span> startpos =<span class="hljs-number">1</span>, maxx = dp[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++ )<br>        <span class="hljs-keyword">if</span> ( dp[i] &gt; maxx )&#123;<br>            maxx = dp[i];<br>            startpos = i;<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, startpos); <span class="hljs-comment">//输出最长路径的第一个点下标值</span><br>    <span class="hljs-type">int</span> k = startpos;<br>    <span class="hljs-keyword">while</span> ( next[k] != <span class="hljs-number">0</span> )&#123;  <span class="hljs-comment">// 如果最长路径有下一个节点，就一直输出打印下一个节点</span><br>        k = next[k];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-%d&quot;</span>, k);<br>    &#125;<br>    <span class="hljs-comment">// 打印路径的权值和</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>, maxx);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="以当前点为终点">2.2.2.2以当前点为<font color="red"><strong>终点</strong></font></h4><ol type="1"><li>状态数组定义</li></ol><p>　　dp[i]表示以当前点<strong>为终点</strong>，最多能挖到的地雷个数</p><ol start="2" type="1"><li>所求目标</li></ol><p>　　最长路径的起点不一定是1号点，所以有： <spanclass="math display">\[max(dp[i])\quad(1\leq i \leq n)\]</span></p><ol start="3" type="1"><li>状态转移方程</li></ol><p>　　以上图中的5号点为例进行分析：从5号点为终点，最多能挖到的地雷个数，肯定与以3号点、4号点等以左侧点结束而挖到的地雷数密切相关。只要左侧的dp值确定，则dp[5]可以很容易算出。所以有：<span class="math display">\[dp[to]=w[to] + max(dp[from]) \quad(from:mapp[from][to]!=INF)\]</span></p><ol start="4" type="1"><li>循环顺序和边界</li></ol><p>　　to: 1 ----&gt; n 正序（左侧点的dp值先算，根据左侧填右侧）</p><p>　　from： 1 &lt;---&gt; to-1正序、逆序均可（只要筛完to的所有逆邻接点就行，什么顺序不重要）</p><ol start="5" type="1"><li>特例</li></ol><p>　　因为to必须从左往右填写，所以dp[1]必须是已知的特定值。根据dp[]的定义，我们可以知道，以1号点结束的路径，其左端肯定是没有节点的。所以该路径只能包含1号点自己。</p><p>　　故有dp[1]=w[1]。</p><ol start="6" type="1"><li>初始化值</li></ol><p>　　初始化方法和2.2.2.1节中的处理是一样的。此处不再赘述。　　</p><ol start="7" type="1"><li>路径输出</li></ol><p>　　1）路径如何表示或记录？</p><p>　　因为外层循环变量to是从左往右填写的，而from在其左侧，所以<strong>只能用pre[to]=from的方式来记录</strong>，而不能用next[from]=to来记录。<strong>同学们可以配合着2.1.2节第8点中的分析来学习，体会两种情况下的不同处理方式，归纳总结好。</strong></p><p>　　2）最长路径如何输出？</p><p>　　鉴于pre[]的定义，所以应找到最长路径的终点。鉴于dp[]的基本定义，我们可以先找到max(dp[1..n])，然后从该点位置开始，不断去pre，就可以了。方法可以采用递归函数来实现。</p><ol start="8" type="1"><li>AC代码</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">方法二： 用dp动态规划，dp[]含义和路径表示及推导的方法一刚好相反</span><br><span class="hljs-comment">（1）状态数组定义</span><br><span class="hljs-comment">dp[i]：从任意点出发到第i号点结束，最多能挖到的地雷个数（和方法一含义不同）</span><br><span class="hljs-comment">e.g.   dp[3]=20 表示从任意点出发到3号点结束，最多能挖到20个地雷</span><br><span class="hljs-comment">（2）所求目标</span><br><span class="hljs-comment">       max(dp[i])：   i:[1..n]， 需要找出dp[i]的最大值</span><br><span class="hljs-comment">（3）状态转换方程</span><br><span class="hljs-comment">dp[to] = w[to] + max(dp[from]);</span><br><span class="hljs-comment">（4）循环边界和循环顺序</span><br><span class="hljs-comment">    to:   [1..n] 1 &lt;--&gt; n必须增序（方程是根据左边决定右边）</span><br><span class="hljs-comment">    from: [1..to-1]        1 &lt;--&gt; to-1    增减均可</span><br><span class="hljs-comment">（5）状态初始化值和特例</span><br><span class="hljs-comment">dp[i] = w[i]</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 201</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> w[N];       <span class="hljs-comment">// 每个点上具有的地雷，  w[3]=10 表示第3号点上有10个地雷</span><br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-type">int</span> pre[N];     <span class="hljs-comment">// 权值和最长的路径中，当前点的上一个点编号</span><br><span class="hljs-type">int</span> next[N];<br><span class="hljs-type">bool</span> mapp[N][N];<br><span class="hljs-comment">// 根据pre[]数组来得到next[]数组的值，以方便后续输出打印</span><br><span class="hljs-comment">// 注意递归函数的写法，本函数中“先递归，后特例”，这是有向路径从尾到头倒序访问的标准做法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tonext</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br><span class="hljs-comment">// 先递归</span><br><span class="hljs-type">int</span> pp = pre[k];<br><span class="hljs-keyword">if</span> ( pp != <span class="hljs-number">0</span> )  <span class="hljs-comment">// 如果最长路径有下一个节点，就一直输出打印下一个节点</span><br><span class="hljs-built_in">tonext</span>( pre[k] );<br><span class="hljs-comment">// 后特例</span><br>next[ pp ] = k; <span class="hljs-comment">//输出最长路径的第一个点下标值</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">1</span>; i&lt;= n; i++) &#123;<br><span class="hljs-built_in">scanf</span>( <span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i] );<br>dp[i] = w[i];  <span class="hljs-comment">// 就算一条边都不走，最起码能够获得出发点的地雷个数</span><br>pre[i] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> x, y;<br><span class="hljs-keyword">while</span> ( <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), x != <span class="hljs-number">0</span> )<br>mapp[x][y] = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 如果从点x能到点y，则mapp数组对应元素值标记为true</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> to=<span class="hljs-number">2</span>; to&lt;=n; to++)    <span class="hljs-comment">// 从1开始也可以，反正是会空转 </span><br><span class="hljs-comment">// 根据不同的from来决定dp[to]的值，决定出pre[to]的值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> from=<span class="hljs-number">1</span>; from&lt;=to<span class="hljs-number">-1</span>; from++) &#123;<br><span class="hljs-comment">// from点必须是指向to点的弧尾点，即mapp[from][to]要==true</span><br><span class="hljs-keyword">if</span>( mapp[from][to] &amp;&amp;  dp[to] &lt; dp[from] + w[to] ) &#123;<br>dp[to] = dp[from] + w[to];<br><span class="hljs-comment">// 既然是根据左侧来决定右侧的值，next[from]=to这样写在此处，</span><br><span class="hljs-comment">// 无法确定出next[from]的最终值，所以next[from]=to这个写法就不正确了！</span><br><span class="hljs-comment">// 此处必须要用pre[]这样写，。后续需要根据pre[]来决定next[]的值！</span><br>pre[to] = from;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//找到maxx= max(dp[i])并找出其最长路径的终点下标值startpos</span><br><span class="hljs-type">int</span> lastpos =<span class="hljs-number">1</span>, maxx = dp[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (  i = <span class="hljs-number">2</span>; i &lt;= n; i++ )<br><span class="hljs-keyword">if</span> ( dp[i] &gt; maxx ) &#123;<br>maxx = dp[i];<br>lastpos = i;<br>&#125;<br>    <span class="hljs-comment">// 根据pre[]计算出next[]的值，以方便输出</span><br><span class="hljs-built_in">tonext</span>(lastpos);<br><span class="hljs-comment">//根据next[]来输出路径</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, next[<span class="hljs-number">0</span>]);<br><span class="hljs-type">int</span> k = next[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">while</span> ( next[k] != <span class="hljs-number">0</span> ) &#123;<br>k = next[k];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-%d&quot;</span>, k);<br>&#125;<br><span class="hljs-comment">// 打印路径的权值和</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d\n&quot;</span>, maxx);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p2196-挖地雷">2.3 P2196 挖地雷</h2><h3 id="原题链接-2">2.3.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P2196">P2196 [NOIP1996提高组] 挖地雷</a></p><h3 id="分析-2">2.3.2 分析</h3><p>　　本题和1262高度相似，只是图的录入方式稍有变化。本题可作为同学们复习巩固1262的一个题，稍等一段时间再来复习，效果会更好。</p><h3 id="ac代码-1">2.3.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 模型提炼： 求整个有向图中的最长路径的长度值，不规定起点和终点。</span><br><span class="hljs-comment">// 1262 和P2196是高度类似的题，只是图的输入方式不同，图结点规模不同</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">方法一： 用dp动态规划</span><br><span class="hljs-comment">（1）状态数组定义</span><br><span class="hljs-comment">dp[i]：从第i号点出发，最多能挖到的地雷个数（和方法二含义不同）</span><br><span class="hljs-comment">e.g.   dp[3]=20 表示 从3号点出发最多能挖到20个地雷</span><br><span class="hljs-comment">（2）所求目标</span><br><span class="hljs-comment">       max(dp[i])：   i:[1..n]， 需要找出dp[i]的最大值</span><br><span class="hljs-comment">（3）状态转换方程</span><br><span class="hljs-comment">dp[from] = w[from] + dp[to];</span><br><span class="hljs-comment">（4）循环边界和循环顺序</span><br><span class="hljs-comment">from: [1..n-1]        n-1  --&gt; 1从右往左降序（方程是根据右边决定左边）</span><br><span class="hljs-comment">   to: [from+1..n] from+1 &lt;--&gt; n增减均可</span><br><span class="hljs-comment">（5）状态初始化值和特例</span><br><span class="hljs-comment">dp[i] = w[i]</span><br><span class="hljs-comment">   本题两种方法，希望学生都要掌握，并认真体会如果获得pre[]和next[]，编写tonext()来表达和输出一条路径</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 201</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> w[N];       <span class="hljs-comment">// 每个点上具有的地雷，  w[3]=10 表示第3号点上有10个地雷</span><br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-type">int</span> next[N];    <span class="hljs-comment">// 权值和最长的路径中，当前点的下一个点编号</span><br><span class="hljs-type">bool</span> mapp[N][N];  <span class="hljs-comment">// 0-1邻接矩阵</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-comment">// 录入原始数据，每个点上的地雷个数（给每个点赋权值）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>( <span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i] );<br>        dp[i] = w[i];  <span class="hljs-comment">// 就算一条边都不走，最起码能够获得出发点的地雷个数</span><br>        next[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-comment">// 录入 弧的关系，根据题意，不用考虑 r &lt; c 的情况</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r=<span class="hljs-number">1</span>; r&lt;=n; r++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c=r+<span class="hljs-number">1</span>; c&lt;=n; c++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>            mapp[r][c] = x;<br>        &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> from = n<span class="hljs-number">-1</span>; from &gt;= <span class="hljs-number">1</span> ; from-- )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> to = from+<span class="hljs-number">1</span>; to&lt;=n; to++)<br>            <span class="hljs-keyword">if</span> ( mapp[from][to] &amp;&amp; dp[from] &lt; w[from] + dp[to] ) &#123;<br>                dp[from] = w[from] + dp[to];<br>                <span class="hljs-comment">// 外层循环变量是from，故此处左侧应该是from </span><br>                next[from] = to;<br>            &#125;<br>    <span class="hljs-comment">//找到maxx= max(dp[i])并找出其最长路径起点的下标值startpos</span><br>    <span class="hljs-type">int</span> startpos =<span class="hljs-number">1</span>, maxx = dp[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++ )<br>        <span class="hljs-keyword">if</span> ( dp[i] &gt; maxx )&#123;<br>            maxx = dp[i];<br>            startpos = i;<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, startpos); <span class="hljs-comment">//输出最长路径的第一个点下标值</span><br>    <span class="hljs-type">int</span> k = startpos;<br>    <span class="hljs-keyword">while</span> ( next[k] != <span class="hljs-number">0</span> )&#123;  <span class="hljs-comment">// 如果最长路径有下一个节点，就一直输出打印下一个节点</span><br>        k = next[k];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>, k);<br>    &#125;<br>    <span class="hljs-comment">// 打印路径的权值和</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>, maxx);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">//#include &lt;cstdio&gt;</span><br><span class="hljs-comment">//#include &lt;cstring&gt;</span><br><span class="hljs-comment">//#include &lt;iostream&gt;</span><br><span class="hljs-comment">//using namespace std;</span><br><span class="hljs-comment">///*</span><br><span class="hljs-comment">//方法二： 用dp动态规划，dp[]含义和路径表示及推导的方法一刚好相反</span><br><span class="hljs-comment">//（1）状态数组定义</span><br><span class="hljs-comment">//dp[i]：从任意点出发到第i号点结束，最多能挖到的地雷个数（和方法一含义不同）</span><br><span class="hljs-comment">//e.g.   dp[3]=20 表示从任意点出发到3号点结束，最多能挖到20个地雷</span><br><span class="hljs-comment">//（2）所求目标</span><br><span class="hljs-comment">//       max(dp[i])：   i:[1..n]， 需要找出dp[i]的最大值</span><br><span class="hljs-comment">//（3）状态转换方程</span><br><span class="hljs-comment">//dp[to] = w[to] + dp[from];</span><br><span class="hljs-comment">//（4）循环边界和循环顺序</span><br><span class="hljs-comment">//   to: [1..n] 1 &lt;--&gt; n必须增序（方程是根据左边决定右边）</span><br><span class="hljs-comment">//from: [1..to-1]    1 &lt;--&gt; to-1增减均可</span><br><span class="hljs-comment">//（5）状态初始化值和特例</span><br><span class="hljs-comment">//dp[i] = w[i]</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//*/</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//#define N 201</span><br><span class="hljs-comment">//#define INF 0x7f7f7f7f</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//int n;</span><br><span class="hljs-comment">//// 每个点上具有的地雷，  w[3]=10 表示第3号点上有10个地雷</span><br><span class="hljs-comment">//int w[N];</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//int dp[N];</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//// 权值和最长的路径中，当前点的上一个点编号</span><br><span class="hljs-comment">//int pre[N];</span><br><span class="hljs-comment">//int next[N];</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//bool mapp[N][N];</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//// 根据pre[]数组来得到next[]数组的值，以方便后续输出打印</span><br><span class="hljs-comment">//// 注意递归函数的写法，本函数中“先递归，后特例”，这是有向路径从尾到头倒序访问的标准做法</span><br><span class="hljs-comment">//void tonext(int k) &#123;</span><br><span class="hljs-comment">//// 先递归</span><br><span class="hljs-comment">//int pp = pre[k];</span><br><span class="hljs-comment">//if ( pp != 0 )  // 如果最长路径有下一个节点，就一直输出打印下一个节点</span><br><span class="hljs-comment">//tonext( pre[k] );</span><br><span class="hljs-comment">//// 后特例</span><br><span class="hljs-comment">//next[ pp ] = k; //输出最长路径的第一个点下标值</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//int main() &#123;</span><br><span class="hljs-comment">//int i;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//scanf(&quot;%d&quot;, &amp;n);</span><br><span class="hljs-comment">//// 录入原始数据，每个点上的地雷个数（给每个点赋权值）</span><br><span class="hljs-comment">//for ( i = 1; i&lt;= n; i++) &#123;</span><br><span class="hljs-comment">//scanf( &quot;%d&quot;, &amp;w[i] );</span><br><span class="hljs-comment">//dp[i] = w[i];  // 就算一条边都不走，最起码能够获得出发点的地雷个数</span><br><span class="hljs-comment">//pre[i] = 0;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//int x;</span><br><span class="hljs-comment">//// 录入 弧的关系，根据题意，不用考虑 r &lt; c 的情况</span><br><span class="hljs-comment">//for (int r=1; r&lt;=n; r++)</span><br><span class="hljs-comment">//for (int c=r+1; c&lt;=n; c++)&#123;</span><br><span class="hljs-comment">//scanf(&quot;%d&quot;, &amp;x);</span><br><span class="hljs-comment">//mapp[r][c] = x;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//for(int to=2; to&lt;=n; to++)</span><br><span class="hljs-comment">//// 根据不同的from来决定dp[to]的值，决定出pre[to]的值</span><br><span class="hljs-comment">//for(int from=1; from&lt;=to-1; from++) &#123;</span><br><span class="hljs-comment">//// from点必须是指向to点的弧尾点，即mapp[from][to]要==true</span><br><span class="hljs-comment">//if( mapp[from][to] &amp;&amp;  dp[to] &lt; dp[from] + w[to] ) &#123;</span><br><span class="hljs-comment">//dp[to] = dp[from] + w[to];</span><br><span class="hljs-comment">//// 既然是根据左侧来决定右侧的值，next[from]=to这样写在此处，</span><br><span class="hljs-comment">//// 无法确定出next[from]的最终值，所以next[from]=to这个写法就不正确了！</span><br><span class="hljs-comment">//// 此处必须要用pre[]这样写，。后续需要根据pre[]来决定next[]的值！</span><br><span class="hljs-comment">//pre[to] = from;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">////找到maxx= max(dp[i])并找出其最长路径的终点下标值startpos</span><br><span class="hljs-comment">//int lastpos =1, maxx = dp[1];</span><br><span class="hljs-comment">//for (  i = 2; i &lt;= n; i++ )</span><br><span class="hljs-comment">//if ( dp[i] &gt; maxx ) &#123;</span><br><span class="hljs-comment">//maxx = dp[i];</span><br><span class="hljs-comment">//lastpos = i;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//    // 根据pre[]计算出next[]的值，以方便输出</span><br><span class="hljs-comment">//tonext(lastpos);</span><br><span class="hljs-comment">////根据next[]来输出路径</span><br><span class="hljs-comment">//printf(&quot;%d&quot;, next[0]);</span><br><span class="hljs-comment">//int k = next[0];</span><br><span class="hljs-comment">//while ( next[k] != 0 ) &#123;</span><br><span class="hljs-comment">//k = next[k];</span><br><span class="hljs-comment">//printf(&quot;-%d&quot;, k);</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//// 打印路径的权值和</span><br><span class="hljs-comment">//printf(&quot;\n%d\n&quot;, maxx);</span><br><span class="hljs-comment">//return 0;</span><br><span class="hljs-comment">//&#125;   </span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 线性DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>普通的01背包问题</title>
      <link href="/2024/05/04/%E6%99%AE%E9%80%9A%E7%9A%8401%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2024/05/04/%E6%99%AE%E9%80%9A%E7%9A%8401%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><p>　　背包问题是动态规划中的一个大类知识点，也是csp的普及组或提高组几乎必考的内容，非常重要。要学习背包问题，<strong>首先需要必须掌握递推、递归，</strong>同时强烈建议也掌握深搜、广搜、贪心、分治等。<strong>背包问题具有较强的模板特性，所以这部分的内容是可以通过多个不同的模板来快速拿下的。</strong>希望同学们务必认真学习每个题型及其变化和拓展。</p><p>　　因为这个大类知识点具有较强的模板性，所以<strong>强烈建议同学们在学习模板时对分析流程（7点步骤）和变量命名规则进行固化，以应对变化各异的应用</strong>。不必理睬题目中五花八门的变量命名，而统一采用一套命名规则来写代码，以方便自己在以后的复习和归纳总结。具体的命名规则请参看本帖以及后面关于背包问题的AC代码的命名规则。</p><h2 id="模型引入和变量命名规则约定">1.1 模型引入和变量命名规则约定</h2><p>　　背包问题主要求解的是<strong>带约束的收益最优化问题</strong>。其所使用的方法主要就是递推填表，用动态规则的方法来解决。而01背包问题则是背包问题的入门题型。</p><p>　　有一个总装量为YS1（约束1，<strong>y</strong>ue<strong>s</strong>hu，取两个字的拼音首字母ys）的背包，有n个可待选择的物品需要装入，每个物品<strong>只有一件</strong>，它们都有各自的重量和价值，你需要从中选择合适的组合来使得你背包中的物品总价值最大（<strong>每个物品不能拆分，且不需要刚好装满，允许不"刚好"装满</strong>）</p><p>　　上面这段就是普通01背包最常见的题面。强烈要求每个同学都按照下面的命名规则来写代码：</p><ul><li>背包一共能装多少斤的物品，在本题中这是总约束（<strong>命名为YS1</strong>，区别于以后的二维费用背包，第二维总约束可以命名为YS2，注意全大写表示总量）。</li><li>第<span class="math inline">\(\ i\ (1 \leq i \leqn)\)</span>个物品的“重量”是约束量，命名为ys1[i]。可能有些同学对这种命名不太适应，但其实在后续题型中可能会出现“每个物品有多个属性都是约束量”，故可能出现ys2[i]、ys3[i]等）。而且物品的重量并不绝对就是约束量，可能在其他题中重量变成是收益。所以，同学们不要固化自己的思维，不要根据物品属性来决定，而必须要根据抽象出来的题型来决定谁是约束、谁是收益。</li><li>第<span class="math inline">\(\ i\ (1 \leq i \leqn)\)</span>个物品的“价值”是收益量，命名为value[i]。</li><li>状态数组命名统一为dp[]或者dp[][]等。</li></ul><h2 id="dp和深搜贪心等的关系分析">1.2 dp和深搜、贪心等的关系分析</h2><p>　　为了方便下面的阐述，我们可以假定一些样例数据来帮我们更方便准确地说明问题。</p><p>　　现在假设背包总容量为YS1=10斤，有n=4个物品，重量ys1[]和价格value[]分别如下：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240510093216861.png" /></p><h3 id="为什么不能用暴力深搜">1.2.1 为什么不能用暴力深搜</h3><p>　　4个物品，每个物品都有“选择”和“不选择”两种结果，故一共有<spanclass="math inline">\(2^4=16\)</span>种结果。如果用暴力深搜的方法把16种结果一一枚举，时间复杂度呈现指数级增长，一旦n较大，即使能够及时剪枝，复杂度仍然很大。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240510134036335.png" alt="image-20240510134036335" style="zoom:60%;" /></p><h3 id="为什么不能用贪心算法">1.2.2 为什么不能用贪心算法</h3><p>　　可能有些同学会认为，对于n个物品，按照性价比进行排序，然后依次选择，直到装不下为止。这就是贪心算法的思路。但实际上这种做法是错误的。性价比并不能完全等价于总价值。</p><p>　　下面举个例子：假设背包容量为10斤，3个物品分别为A：6斤8元，B：5斤5元，C：5斤5元。如果按照性价比来排序，物品A的性价比最高，应该先选择物品A装入背包。然后，就没有然后了，因为剩下4斤容量，装不下任何第二个物品了。这种“装入A”的方案，总价值就为8元。</p><p>　　但如果选择不装A而装B和C，则总价值为5+5=10元。所以最优方案是“装BC”。</p><p>　　那贪心算法的问题出在哪里呢？问题就出在“物品不可分割”。在“装入A”的方案中，当只剩4斤容量时，如果物品可分割，那么大可以把物品B切下4斤来装入，就能达到最大价值8+4=12元。“<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1225">1225：金银岛</a>”就可以用贪心算法破解。但现在因为不可分割，没，为了贪那一点点的性价比，结果让背包空闲浪费了4斤的容量没有装任何物品，从而使得整个方案低效。</p><h2 id="标准状态数组">1.3 标准状态数组</h2><h3 id="六步分析">1.3.1 六步分析</h3><ol type="1"><li><p>状态数组定义</p><p>　　dp[i][j]：代表当背包的总容量为 j 时，前 i个物品选择一部分物品放入后，背包内物品的最大总价值；</p></li><li><p>所求目标</p><p>　　dp[n][YS1]：代表背包的总容量为YS1时，前 n个物品选择一部分物品放入后，背包内物品的最大总价值；</p></li><li><p>状态转移方程</p><p>我们这里暂时假设从1到n，依次考虑每个物品。（有些时候我们必须要逆序来考虑，请参看《求背包问题的具体方案》。初学的同学暂时可以不看）</p><p>对于第i个物品：</p></li></ol><ul><li><p>1）如果背包的总容量j不足以容纳第i个物品，此时“心有余而力不足”，只能被迫放弃第i个物品，价值没有一点增加。所以有：<span class="math display">\[dp[i][j]=dp[i-1][j] \tag{1}\]</span></p></li><li><p>2）如果背包的总容量j能够容纳第i个物品，此时可以有两种选择：“装”或者“不装”第i个物品。此时需要进行比较判断，因为装了当前的第i个物品，不一定能使最后组合达到最大价值。</p><ul><li><p>a)如果<strong>能装但不装</strong>第i个物品，则有:</p><p><span class="math display">\[dp[i][j]=dp[i-1][j] \tag{2}\]</span>　　既然决定不装入第i个物品，那么总价值不会增加，仍然和“前i-1个物品对于总容量j的策略”是一致的。</p></li><li><p>b)如果<strong>能装且装入</strong>第i个物品，则有:</p><p><span class="math display">\[dp[i][j]=dp[i-1][j-ys1[i]]+value[i] \tag{3}\]</span> 　　为什么会有这样的等式呢？</p><p>　　如果已经处理完前i-1个物品，且总容量没有超过j-ys1[i]，其最大总价值为dp[i-1][j-ys1[i]]。在这种情况下，选择装入第i个物品，那么总容量不会超过j-ys1[i]+ys1[i]=j，而总价值为dp[i-1][j-ys1[i]]+value[i]。</p><p>　　我们可以从公式（2）和（3）中选择较大值，来作为情况2）的决策。</p></li></ul></li></ul><p>　　综上情况1）和情况2），则有状态转移方程为： <spanclass="math display">\[dp[i][j]=\begin{cases}dp[i-1][j] &amp; (j&lt;ys1[i]) \\max(\ dp[i-1][j], \quad dp[i-1][j-ys1[i]]\ +\ value[i]\ ) &amp; (j\geqys1[i])\end{cases} \tag{4}\]</span></p><ol start="4" type="1"><li><p>循环顺序和边界</p><ul><li><p>i：1 -----&gt; n 只能增序</p></li><li><p>j：0 <font color ="red"><strong>&lt;-----&gt;</strong> </font>YS1<strong>增序、降序都可以</strong></p><p>　　虽然第j列的数据需要来自于第j-ys1[i]列，但却是上一排的第j-ys1[i]列。所以，只要上一排的数据全部已知，那么对于当前第i排，从左往右填写，或者从右往左填写，都是正确的！</p></li></ul></li><li><p>特例</p><p>　　当i=1时，i-1=0，所以需要把第0行当做特例来处理。当任何物品都还没处理时，总价值肯定是0，故有</p><p>dp[0][0..YS1]=0。</p></li><li><p>初始化值</p><p>　　从转移方程可以看出，dp数组的每个值都来自于以前的dp值或者value数组，会被完整覆盖。所以dp数组可以不初始化。一个简单做法就是“将dp数组定义为全局数组，自动初始化为全0”。这样也能自动搞定特例。</p></li></ol><h3 id="关键代码">1.3.2 关键代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)            <span class="hljs-comment">// 针对每1个物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)   <span class="hljs-comment">// 背包剩余空间j，注意，j的取值范围是[0, YS1]</span><br>     <span class="hljs-comment">//for(int j=YS1; j&gt;=0; --j)   // 正反序，在普通01背包中，都是可以的 </span><br><span class="hljs-comment">// 如果背包剩余空间够放第i个物品， </span><br><span class="hljs-keyword">if</span> ( ys1[i] &lt;= j )<br><span class="hljs-comment">// 需要判断放与不放，到底哪个更划算！ </span><br>dp[i][j]= <span class="hljs-built_in">max</span>( dp[i<span class="hljs-number">-1</span>][j-ys1[i]] + value[i],  dp[i<span class="hljs-number">-1</span>][j]);<br><span class="hljs-keyword">else</span><br><span class="hljs-comment">// 如果背包剩余空间不够放第i个物品，然并卵，肯定就不放进去了哈！上下照抄不变 </span><br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j]; <br></code></pre></td></tr></table></figure><p>　　需要注意一下的就是，内层循环的代码也可以写成如下的形式，是等效的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 背包剩余空间j，注意，j的取值范围是[0, YS1]</span><br>           dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];   <span class="hljs-comment">// 不管三七二十一，先照抄上一行的数据下来</span><br><span class="hljs-keyword">if</span> ( ys1[i] &lt;= j )       <span class="hljs-comment">// 如果背包剩余空间够放第i个物品， </span><br><span class="hljs-comment">// 需要判断放与不放，到底哪个更划算！ 此时赋值式右侧的dp[i][j]值实际上是dp[i-1][j]值</span><br>dp[i][j]= <span class="hljs-built_in">max</span>( dp[i][j], dp[i<span class="hljs-number">-1</span>][j-ys1[i]] + value[i]);<br>      &#125;<br></code></pre></td></tr></table></figure><h3 id="决策输出">1.3.3 决策输出</h3><p>　　我们可以以1267这个题为例来做分析决策。其样例数据对应的dp[][]初始化值如下图所示。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240510162522771.png" /></p><p>　　为了巩固对状态转移方程公式的理解深度，同学们可以自行拿出草稿纸来填写该表的所有数据，模拟程序实现过程，强化理解填表的步骤。其正确答案如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240510163109884.png" alt="image-20240510163109884" style="zoom:80%;" /></p><p>　　从这张表中我们可以看出，dp[4][10]=12元，是本样例的答案。但如果我想知道到底选择了哪些物品？该如何解决这个问题呢？</p><p>　　其实标准状态数组已经给我们暗示出了所有的决策。</p><ol type="1"><li>dp[4][10]=12元 !=9元=dp[3][10]，所以必然是因为选择了物品4。因为物品4重7斤，所以从当前的10斤扣除物品4的7斤，还剩3斤，找到dp[3][3]。</li><li>因为dp[3][3]=3=dp[2][3]，上下格子的值相等，这说明没有选择第3个物品。</li><li>因为dp[2][3]=3!=1=dp[1][3]，上下格子的值不相等，这说明选择了第2个物品。因为物品2重3斤，所以从当前的3斤扣除物品2的3斤，还剩0斤，找到dp[1][0]。</li><li>因为dp[1][0]=0=dp[0][0]，上下格子的值相等，这说明没有选择第1个物品。</li></ol><p>　　结论：选择了第2、4个物品，总重量10斤，总价值12元。</p><ul><li><p>如果从当前行往 <font color ="red"><strong>上</strong></font>走，说明<font color ="red"><strong>不选</strong></font>当前行的物品；</p></li><li><p>如果从当前行往 <font color ="green"><strong>左上</strong></font>走，说明 <font color ="green"><strong>选</strong></font>当前行的物品。</p></li></ul><h3 id="复杂度分析">1.3.4 复杂度分析</h3><p>　　上述的标准状态数组的AC代码，影响程序时间复杂度的关键在于那个二重for，复杂度为<spanclass="math inline">\(O(n*YS1)\)</span>，空间复杂度为状态数组的容量，也是<spanclass="math inline">\(O(n*YS1)\)</span>。</p><h2 id="滚动数组压缩数组">1.4 滚动数组/压缩数组</h2><p>　　从1.3.4节可以看到，标准状态数组的解法需要空间复杂度为<spanclass="math inline">\(O(n*YS1)\)</span>。当YS1较大时，可能会造成整个程序MLE。我们在本节提出“滚动状态数组”（有的地方也叫做“压缩状态数组”）的概念，并对空间复杂度进行优化，而时间复杂度不变。</p><p>　　从1.3.3节中的图上可以看到，表里大部分的内容都是上下照抄，并没有发生值的改变，这表示存在空间精简压缩的可能性。仔细观察上一节的填表过程，我们填写每一个网格（第i行，第j列）的数据时，都只依赖于第i-1行的数据，而不需要访问第i-2行、i-3行等。为了更直观的理解，下面再画一张图，并以i=3为例，详细展示一维数组的更新细节：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240511112403158.png" style="zoom:150%;" /></p><p>　　在填写一趟一维数组时，需要从右往左更新每个格子的数据。因为更新需要读取当前位置左侧的旧数据来进行比对，此时旧数据尚未被更新，仍然存储的是“上一行”的数据，所以这种更新是没有问题的。只是需要注意，这里必须只能“从右往左”更新每个格子！</p><p>因此，我们可以将求解空间进行优化，将二维数组压缩成一维数组。</p><h3 id="六步分析-1">1.4.1 六步分析</h3><ol type="1"><li><p>状态数组定义</p><p>　　dp[j]：代表当背包的总容量为 j时，前若干个物品选择一部分物品放入后，背包内物品的最大总价值；</p></li><li><p>所求目标</p><p>　　dp[YS1]：代表背包的总容量为YS1时，前若干个物品选择一部分物品放入后，背包内物品的最大总价值；</p></li><li><p>状态转移方程</p><p>对于第i个物品：</p></li></ol><ul><li>原有的状态转移方程为：</li></ul><p><span class="math display">\[dp[i][j]=\begin{cases}dp[i-1][j] &amp; (j&lt;ys1[i]) \\max(\ dp[i-1][j], \quad dp[i-1][j-ys1[i]]\ +\ value[i]\ ) &amp; (j\geqys1[i])\end{cases} \tag{1}\]</span></p><ul><li>经过滚动状态数组设计后的状态转移方程为：</li></ul><p><span class="math display">\[\begin{align*}dp[j]&amp;=\begin{cases}dp[j] &amp; (j&lt;ys1[i]) \\max(\ dp[j], \quad dp[j-ys1[i]]\ +\ value[i]\ ) &amp; (j\geq ys1[i])\end{cases} \tag{2}\\\end{align*}\]</span></p><ol start="4" type="1"><li><p>循环顺序和边界</p><ul><li><p>i： 1 -----&gt; n 只能增序</p></li><li><p>j： ys1[i] <font color ="red"><strong>&lt;-----</strong></font>YS1 <strong>只能降序</strong></p><ul><li><p>1）为什么必须降序？</p><p>　　dp[j]的更新需要读取dp[j-ys1[i]]，但要求dp[j-ys1[i]]必须是旧数据（因为（1）式中是<spanclass="math inline">\(dp[i-1][j-ys1[i]]\)</span>，是第i-1行的，是旧数据）。所以dp[j]必须比dp[j-ys1[i]]先更新，即必须从右往左更新。</p></li><li><p>2）从右往左，只需要到ys1[i]就可以了。为什么不能到0呢？</p><p>　　原因很简单，因为当j在[0..ys1[i]-1]这个范围内时，根据公式（2）有dp[j]=dp[j]。这实际上是一句废话，意思就是“什么都不需要做”。既然什么都不做，那干嘛还循环这个范围？所以只需要循环到ys1[i]就行了。</p><p>　　从另一个角度来思考，在公式（2）中的dp[j-ys1[i]]，当j&lt;ys1[i]时，j-ys1[i]&lt;0，这下标怎么能小于0？那还不乱套，爆一个RE？</p></li></ul></li></ul></li><li><p>特例</p><p>　　dp[0]=0</p></li><li><p>初始化值</p><p>　　在标准状态数组中的特例是dp[0][0..YS1]=0，所以在滚动状态数组结构下的特例应该是dp[0..YS1]=0。</p></li></ol><h3 id="关键代码-1">1.4.2 关键代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)  <span class="hljs-comment">// 针对每1个物品</span><br>    <span class="hljs-comment">// 这里j应该从右往左推，千万要注意！！注意是&gt;=ys1[i]截止，因为下标[j-ys1[i]]不可能为负数！</span><br>    <span class="hljs-comment">// 对于那些小于ys1[i]的j，在这里就不去处理（默认等于前值）了，也就是说，等效于dp[i][j] = dp[i-1][j]了！</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)<br>        <span class="hljs-comment">// 需要判断放与不放，到底哪个更划算！</span><br>        dp[j] = <span class="hljs-built_in">max</span>( dp[j - ys1[i]] + value[i],  dp[j]);<br></code></pre></td></tr></table></figure><p>　　需要注意一下的就是，第17～19行代码也可以写成如下的形式，是等效的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)  <span class="hljs-comment">// 针对每1个物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)<br><span class="hljs-keyword">if</span> (j &gt;= ys1[i])<br>            dp[j] = <span class="hljs-built_in">max</span>( dp[j - ys1[i]] + value[i],  dp[j]);<br></code></pre></td></tr></table></figure><h3 id="决策输出-1">1.4.3 决策输出</h3><p>　　以1267这个题为例来看，其标准状态数组的值如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240510163109884.png" alt="image-20240510163109884" style="zoom:80%;" /></p><p>　　如果改为滚动数组后，只剩最底层一排的数值，无法找其他排数据，自然也无法找到决策。　　</p><h3 id="复杂度分析-1">1.4.4 复杂度分析</h3><p>　　影响程序时间复杂度的关键在于那个二重for，复杂度为<spanclass="math inline">\(O(n*YS1)\)</span>，空间复杂度为<spanclass="math inline">\(O(YS1)\)</span>。</p><h2 id="其他重要资料学习">1.5 其他重要资料学习</h2><p>　　如果对上述资料学习之后，还觉得不够尽兴的，可以看下面的资料。</p><h3 id="视频链接">1.5.1 视频链接</h3><p>　　<ahref="https://www.bilibili.com/video/BV1kp4y1e794/?spm_id_from=333.999.0.0&amp;vd_source=0e7cc4e4bbbb67e5c3c2a3e7d967f075">E08【模板】背包DP01背包</a></p><h3 id="背包九讲">1.5.2 背包九讲</h3><p>　　非常经典牛逼的“背包九讲”，请看<a href="https://www.kancloud.cn/kancloud/pack/70124" target="_blank">这里</a>。</p><h1 id="二实战训练">二、实战训练</h1><h2 id="背包问题">2.1 1267 01背包问题</h2><h3 id="原题链接">2.1.1 原题链接</h3><h3 id="例9.1101背包问题">　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1267">1267：【例9.11】01背包问题</a></h3><h3 id="ac代码">2.1.2 AC代码</h3><h4 id="标准状态数组版本">2.1.2.1 标准状态数组版本</h4><p>　　时间复杂度：<spanclass="math inline">\(O(n*YS1)=30*200=6000\)</span></p><p>　　空间复杂度：<spanclass="math inline">\(O(n*YS1)=30*200=6000\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 0-1背包模型， 二维dp[][]， 的解法！</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 31</span><br><span class="hljs-comment">// dp[5][100] = 50  前5个物品装在背包容量为100斤的背包中的最大价值为50元</span><br><span class="hljs-type">int</span> dp[N][<span class="hljs-number">201</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i, YS1, n;<br>    <span class="hljs-type">int</span> ys1[N], value[N];<br>    <span class="hljs-comment">// 输入背包总重量YS1限制，及提供的物品总个数n</span><br>    cin &gt;&gt;YS1 &gt;&gt;n;<br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        cin &gt;&gt;ys1[i] &gt;&gt;value[i];<br><br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)            <span class="hljs-comment">// 针对每1个物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)   <span class="hljs-comment">// 背包剩余空间j，注意，j的取值范围是[0, YS1]</span><br>            <span class="hljs-comment">//for(int j=YS1; j&gt;=0; --j)   // 正反序，在标准状态数组中，都是可以的</span><br>            <span class="hljs-keyword">if</span> ( ys1[i] &lt;= j )<br>                dp[i][j]= <span class="hljs-built_in">max</span>( dp[i<span class="hljs-number">-1</span>][j-ys1[i]] + value[i],  dp[i<span class="hljs-number">-1</span>][j]);<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 如果背包剩余空间不够放第i个物品，然并卵，肯定就不放进去了哈！上下照抄不变</span><br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br><br>    cout &lt;&lt;dp[n][YS1];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="滚动状态数组版本">2.1.2.2<font color="red">滚动</font>状态数组版本</h4><p>　　时间复杂度：<spanclass="math inline">\(O(n*YS1)=30*200=6000\)</span></p><p>　　空间复杂度：<span class="math inline">\(O(YS1)=200\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//0-1背包，一维dp[] 的解法</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 31</span><br><span class="hljs-type">int</span> YS1, n;<br><span class="hljs-type">int</span> ys1[N], value[N];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">201</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 输入背包总重量YS1限制，及提供的物品总个数n</span><br>    cin &gt;&gt;YS1 &gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        cin &gt;&gt;ys1[i] &gt;&gt;value[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)  <span class="hljs-comment">// 针对每1个物品</span><br>        <span class="hljs-comment">// 这里j应该从右往左推，千万要注意！！注意是&gt;=ys1[i]截止，因为下标[j-ys1[i]]不可能为负数！</span><br>        <span class="hljs-comment">// 对于那些小于ys1[i]的j，在这里就不去处理（默认等于前值）了，也就是说，等效于dp[i][j] = dp[i-1][j]了！</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)<br>            <span class="hljs-comment">// 需要判断放与不放，到底哪个更划算！</span><br>            dp[j] = <span class="hljs-built_in">max</span>( dp[j - ys1[i]] + value[i],  dp[j]);<br><br>    cout &lt;&lt;dp[YS1];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p1048-采药">2.2 P1048 采药</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　下面两个题，基本上完全一样。</p><ul><li><h3 id="p1048-noip2005-普及组-采药">　　<ahref="https://www.luogu.com.cn/problem/P1048">P1048 [NOIP2005 普及组]采药</a></h3></li><li><a href="https://www.luogu.com.cn/problem/P2871">P2871 [USACO07DEC]Charm Bracelet S</a></li></ul><h3 id="ac代码-1">2.2.2 AC代码</h3><h4 id="标准状态数组版本-1">2.2.2.1 标准状态数组版本</h4><p>　　时间复杂度：<spanclass="math inline">\(O(n*YS1)=100*1000=1e5\)</span></p><p>　　空间复杂度：<spanclass="math inline">\(O(n*YS1)=100*1000=1e5\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 101</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T 1001</span><br><span class="hljs-type">int</span> dp[N][T]; <br><span class="hljs-type">int</span> n, YS1;<br><span class="hljs-type">int</span> ys1[N], value[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;YS1, &amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;ys1[i], &amp;value[i]);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;= YS1; j++)<br><span class="hljs-comment">//for(int j=YS1; j&gt;= 0; j--)   // 逆序在标准状态数组结构中也是可以的 </span><br><span class="hljs-keyword">if</span> (ys1[i] &lt;= j)<br>dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i<span class="hljs-number">-1</span>][j-ys1[i]] + value[i]);<br><span class="hljs-keyword">else</span><br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dp[n][YS1]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="滚动状态数组版本-1">2.2.2.2 滚动状态数组版本</h4><p>　　时间复杂度：<spanclass="math inline">\(O(n*YS1)=100*1000=1e5\)</span></p><p>　　空间复杂度：<span class="math inline">\(O(YS1)=1000\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 法2，滚动状态</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 101</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T 1001</span><br><span class="hljs-type">int</span> dp[T]; <br><span class="hljs-type">int</span> n, YS1;<br><span class="hljs-type">int</span> ys1[N], value[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;YS1, &amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;ys1[i], &amp;value[i]);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;= ys1[i]; j--)   <span class="hljs-comment">// 逆序在标准状态数组结构中也是可以的 </span><br>dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-ys1[i]] + value[i]);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dp[YS1]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 背包问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编辑距离问题</title>
      <link href="/2024/05/04/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
      <url>/2024/05/04/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="视频教学链接">1.1 视频教学链接</h2><p>　　<ahref="https://www.bilibili.com/video/BV1gk4y1177j/?spm_id_from=333.999.0.0&amp;vd_source=0e7cc4e4bbbb67e5c3c2a3e7d967f075">编辑距离</a></p><h2 id="理论分析">1.2 理论分析</h2><h3 id="提出问题">1.2.1 提出问题</h3><p><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240501145909134.png" /></p><h3 id="六步分析">1.2.2 六步分析</h3><p>　　本题能不能用dp来做呢？回答是肯定的。两个字符串，随着长度的变化，其编辑的距离值肯定是在变化的。并且从左往右，前面的决策对后面的决策不会产生任何影响，因为前面的决策结果都是产生内容相同的两个串。而后面的决策并不依赖于前面的不同决策。满足局部最优和无后效性这两个基本要求。</p><p>　　下面的分析，适用于<strong>字符串从1开始编号</strong>的情况。</p><ol type="1"><li><p>定义状态数组</p><p>　　假设有两个字符串a[1..lena]和b[1..lenb]，状态数组肯定是一个二维数组无疑。现在定义dp[i][j]为“<strong>把a[1..i]修改为值为b[1..j]的最小编辑次数值</strong>”。</p></li><li><p>所求目标</p><p>　　在这种定义下，dp[lena][lenb]即为所求目标。</p></li><li><p>状态转移方程：</p><p>　　如果有两个字符串a[]和b[]，现在要计算把a[1..i]修改为b[1..j]的最小编辑次数值。分两种情况如下：</p><p>　　<strong>情况1</strong>：如果a[i]==b[j]，需要先把a[1,…,i-1]修改为b[1,…,j-1]（修改次数为dp[i-1][j-1]），至于第j个字符已吻合，无需更改。所以总次数<strong>dp[i][j]=dp[i-1][j-1]</strong>。</p><p>　　<strong>情况2</strong>：如果a[i]!=b[j]，因为现在a[1..i-1]修改为了b[1..j-1]，就差a[i]还没改为b[j]了。有下面3种情况，对应3种计算方法。我们需要从中选择一个最小值作为方案。</p><p>　　-<strong>子情况a）</strong>：已经完成了“把a[1..i-1]修改为b[1..j]”————这种情况下，目的已达成，a[i]已显得多余，只需要删除它（需耗1次编辑），即可完成“把a[1..i]修改为b[1..j]”。其总次数有<strong>dp[i][j]= 1 + dp[i-1][j];</strong></p><p>　　-<strong>子情况b）</strong>：已经完成了“把a[1..i]修改为b[1..j-1]”————这种情况下，只需要在b[]中b[j-1]位置后面插入值为b[j]的字符（需耗1次编辑），即可完成“把a[1..i]修改为b[1..j]”。其总次数有<strong>dp[i][j]= 1 + dp[i][j-1];</strong></p><p>　　-<strong>子情况c）</strong>：已经完成了“把a[1..i-1]修改为b[1..j-1]”————这种情况下，只需要把a[i]位置上的字符直接改为值为b[j]的字符（需耗1次编辑），即可完成“把a[1..i]修改为b[1..j]”。其总次数有<strong>dp[i][j]= 1 + dp[i - 1][j - 1];</strong></p><p>　　整合a)、b)和c)，即<strong>dp[i][j] = 1 + min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])</strong>。这里要取3个值的最小值，但min函数只能取2个数的最小值，所以有两种办法实现：</p></li></ol><p>　　方案a：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], <span class="hljs-built_in">min</span>(dp[i][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]))<br></code></pre></td></tr></table></figure><p>　　方案b：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[i][j]= INF;     <span class="hljs-comment">// 既然求最小值，那先把dp[][]设定为一个极大值，int的极大值，定义成0x7f7f7f7f就好了</span><br>dp[i][j]= <span class="hljs-built_in">min</span>(dp[i][j], dp[i<span class="hljs-number">-1</span>][j]);     <span class="hljs-comment">// 依次和三个值相比</span><br>dp[i][j]= <span class="hljs-built_in">min</span>(dp[i][j], dp[i][j<span class="hljs-number">-1</span>]);<br>dp[i][j]= <span class="hljs-built_in">min</span>(dp[i][j], dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]);<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li><p>循环顺序和循环边界</p><p>　　根据已知填未知，填写当前位置时，左侧、左上、正上三个方向的数据必须已知，所以循环顺序肯定是需要<strong>从上往下、从左往右</strong>填写</p></li></ol><p>　　　　i：1-----&gt;lena 增序</p><p>　　　　j：1-----&gt;lenb 增序</p><ol start="5" type="1"><li><p>特例</p><p>　　既然上面的循环i、j能取1，而公式出现了i-1和j-1，所以第0行和第0列是特例。</p><p>　　dp[0][j]= j;//空串A和长度为j的串B之间的最短编辑距离是j（从空串变成长度为j的指定串，至少要做j次插入，不可能比这更少）</p><p>　　dp[i][0]= i; // 理由同上</p><p>　　注意：不要想当然地认为dp[i][0]=dp[0][j]=0，高手一定要注意细节的处理，要多问几个“为什么”。</p></li><li><p>数组初始化值</p><p>　　状态转移方程如果采用方案a)，则不需要专门处理普通位置上的初值，因为初值都会被覆盖的，没有提前读取。</p><p>　　状态转移方程如果采用方案b)，则需要专门处理普通位置上的初值，因为是求最小值，所以初值定为INF。</p></li><li><p>补充</p><p>　　如果lena和lenb较大，使得dp[][]过大。如果引起MLE，则需要适当压缩状态数组。鉴于状态转移方程中，dp[i][j]只和dp的第i-1行数据有关，一个比较简单的做法就是“令dp2[0..lenb-1]为dp[0..lenb-1]的复制，相当于dp[i-1][0..lenb-1]。每次内层循环执行完，设置完dp[]后，复制一份给dp2[]即可”。</p><p>　　这样可以把空间复杂度降为<spanclass="math inline">\(O(lenb)\)</span>。</p></li></ol><h1 id="二.-实战训练">二. 实战训练</h1><h2 id="section">2.1 1276</h2><p>　　原题链接：</p><p>　　　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1276"><strong>1276：【例9.20】编辑距离</strong></a></p><p>　　分析：</p><p>　　1.2.2节中的分析是针对“字符串存储以下标1开始”。如果字符串以下标0开始存储，则六步分析需要稍作调整。下面的文字和1.2.2节高度相似，只是部分下标不同而已。理解深刻的同学可以跳过这部分不看，直接看AC代码。</p><ol type="1"><li>dp[i][j]定义：即“把a[0..i-1]修改为值为b[0..j-1]的最小编辑次数值”。</li><li>所求目标：dp[lena-1][lenb-1]即为所求目标。</li><li>状态转移方程：</li></ol><p>　　如果有两个字符串a[]和b[]，现在要计算把a[0..i-1]修改为b[0..j-1]的最小编辑次数值。分两种情况如下：</p><p>　　<strong>情况1</strong>：如果a[i-1]==b[j-1]，需要先把a[0,…,i-2]修改为b[0,…,j-2]（修改次数为dp[i-2][j-2]），至于第j-1个字符已吻合，无需更改。所以总次数<strong>dp[i][j]=dp[i-1][j-1]</strong>。（注意：这里i和j仍然从1开始循环，与dp[i][j]对应好）</p><p>　　<strong>情况2</strong>：如果a[i-1]!=b[j-1]，因为现在a[0..i-2]修改为了b[0..j-2]，就差a[i-1]还没改为b[j-1]了。有下面3种情况，对应3种计算方法。我们需要从中选择一个最小值作为方案。</p><ul><li><p>子情况a）：已经完成了“把a[1..i-1]修改为b[1..j]”————这种情况下，目的已达成，a[i]已显得多余，只需要<strong>删除它</strong>（需耗1次编辑），即可完成“把a[1..i]修改为b[1..j]”。其总次数有<strong>dp[i][j]= 1 + dp[i-1][j];</strong></p></li><li><p>子情况b）：已经完成了“把a[1..i]修改为b[1..j-1]”————这种情况下，只需要在b[]中b[j-1]位置后面<strong>插入值为b[j]的字符</strong>（需耗1次编辑），即可完成“把a[1..i]修改为b[1..j]”。其总次数有<strong>dp[i][j]= 1 + dp[i][j-1];</strong></p></li><li><p>子情况c）：已经完成了“把a[1..i-1]修改为b[1..j-1]”————这种情况下，只需要把a[i]位置上的字符<strong>修改</strong>为值为b[j]的字符（需耗1次编辑），即可完成“把a[1..i]修改为b[1..j]”。其总次数有<strong>dp[i][j]= 1 + dp[i - 1][j - 1];</strong></p></li></ul><p>　　整合a)、b)和c)，即<strong>dp[i][j]=1+min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])</strong>。这里要取3个值的最小值，但min函数只能取2个数的最小值，所以有两种办法实现：</p><p>　　方案a：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], <span class="hljs-built_in">min</span>(dp[i][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]))<br></code></pre></td></tr></table></figure><p>　　方案b：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[i][j]= INF;     <span class="hljs-comment">// 既然求最小值，那先把dp[][]设定为一个极大值，int的极大值，定义成0x7f7f7f7f就好了</span><br>dp[i][j]= <span class="hljs-built_in">min</span>(dp[i][j], dp[i<span class="hljs-number">-1</span>][j]);     <span class="hljs-comment">// 依次和三个值相比</span><br>dp[i][j]= <span class="hljs-built_in">min</span>(dp[i][j], dp[i][j<span class="hljs-number">-1</span>]);<br>dp[i][j]= <span class="hljs-built_in">min</span>(dp[i][j], dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]);<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>循环顺序和循环边界</li></ol><p>　　根据已知填未知，填写当前位置时，左侧、左上、正上三个方向的数据必须已知，所以循环顺序肯定是需要<strong>从上往下、从左往右</strong>填写</p><p>　　　　i：1-----&gt;lena 增序 （仍以1开始，因要和dp[][]对应）</p><p>　　　　j：1-----&gt;lenb 增序 （仍以1开始，因要和dp[][]对应）</p><ol start="5" type="1"><li>特例</li></ol><p>　　既然上面的循环i、j能取1，而公式出现了i-1和j-1，所以第0行和第0列是特例。</p><p>　　dp[0][j]= j;//空串A和长度为j的串B之间的最短编辑距离是j（从空串变成长度为j的指定串，至少要做j次插入，不可能比这更少）</p><p>　　dp[i][0]= i; // 理由同上</p><p>　　注意：不要想当然地认为dp[i][0]=dp[0][j]=0，高手一定要注意细节的处理，要多问几个“为什么”。</p><ol start="6" type="1"><li>数组初始化值</li></ol><p>　　状态转移方程如果采用方案a)，则不需要专门处理普通位置上的初值，因为初值都会被覆盖的，没有提前读取。</p><p>　　状态转移方程如果采用方案b)，则需要专门处理普通位置上的初值，因为是求最小值，所以初值定为INF。</p><p>　　AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 2001 </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">两个字符串之间的编辑距离， 和1298题高度相似，结合起来一起看</span><br><span class="hljs-comment">洛谷 P2758 “编辑距离” 和本题相同。 </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-comment">// dp[5][8] = 4  意思是指：str1的前5个字母和str2的前8个字母，如果要一致，至少需要做4步的改动 </span><br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">char</span> str1[N] , str2[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> len1, len2;<br>    cin &gt;&gt; str1 &gt;&gt; str2;<br>    len1 = <span class="hljs-built_in">strlen</span>(str1);<br>    len2 = <span class="hljs-built_in">strlen</span>(str2);<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0x7f</span>, <span class="hljs-built_in">sizeof</span>(dp));  <span class="hljs-comment">// 设置f数组中的int值为无穷大</span><br><span class="hljs-comment">// 一方有i或者j个字母，另一方是0个字母，则两者距离是i或者j </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; len1 ; ++i)   <br>dp[i][<span class="hljs-number">0</span>] = i;<span class="hljs-comment">//重要的初始化       </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; len2 ; ++j)   <br>dp[<span class="hljs-number">0</span>][j] = j;<span class="hljs-comment">//重要的初始化 </span><br>    <br><span class="hljs-comment">//为了讨论方便，假设str1不变，只考虑“通过改动str2来凑成两个字串相等 ” </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= len1 ; i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= len2 ; j++)&#123;<br>        <span class="hljs-comment">// 如果两个子串的末尾字符已经相同 </span><br>            <span class="hljs-keyword">if</span>(str1[i - <span class="hljs-number">1</span>] == str2[j - <span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-comment">// 那就不需要任何改动了 </span><br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123; <br><span class="hljs-comment">// 在三种操作中选一种最省的最小的，来作为当前值 </span><br>            dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], <span class="hljs-number">1</span> + dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]);   <span class="hljs-comment">// 在str2中修改1个 </span><br>            dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], <span class="hljs-number">1</span> + dp[i][j<span class="hljs-number">-1</span>]);     <span class="hljs-comment">// 在str2中删除1个 </span><br>            dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], <span class="hljs-number">1</span> + dp[i<span class="hljs-number">-1</span>][j]);     <span class="hljs-comment">// 在str2中插入1个 </span><br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[len1][len2] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p2758">2.2 P2758</h2><p>　　原题链接：</p><p>　　　　<ahref="https://www.luogu.com.cn/problem/P2758"><strong>P2758编辑距离</strong></a></p><p>　　分析：</p><p>　　　　本题和2.1节中的1276题基本上一模一样。直接复习即可。</p><p>　　AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 2001</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">两个字符串之间的编辑距离， 和1298题高度相似，结合起来一起看</span><br><span class="hljs-comment">时间复杂度和空间复杂度都是O(lenA * lenB)   </span><br><span class="hljs-comment">    晓9.70中阐述了滚动dp的做法，但略难懂。本帖有更好懂的做法。 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// dp[5][8] = 4  意思是指：str1的前5个字母和str2的前8个字母，如果要一致，至少需要做4步的改动</span><br><span class="hljs-type">int</span> dp[N][N];                   <br><span class="hljs-type">char</span> str1[N] , str2[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> len1, len2;<br>cin &gt;&gt; str1 &gt;&gt; str2;<br>len1 = <span class="hljs-built_in">strlen</span>(str1);<br>len2 = <span class="hljs-built_in">strlen</span>(str2);<br><span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0x7f</span>, <span class="hljs-built_in">sizeof</span>(dp));  <span class="hljs-comment">// 设置f数组中的int值为无穷大</span><br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;                  <span class="hljs-comment">// 两个空串之间的距离为 0</span><br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;                  <span class="hljs-comment">// str1的前0个字母和str2的前1个字母的距离是 1</span><br>dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;                  <span class="hljs-comment">// 反之亦然</span><br><span class="hljs-comment">// 一方有i或者j个字母，另一方是0个字母，则两者距离是i或者j</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= len1 ; ++i)<br>dp[i][<span class="hljs-number">0</span>] = i;<span class="hljs-comment">//重要的初始化</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt;= len2 ; ++j)<br>dp[<span class="hljs-number">0</span>][j] = j;<span class="hljs-comment">//重要的初始化</span><br><span class="hljs-comment">//为了讨论方便，假设“将str1[]改为str2[]即可” </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= len1 ; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= len2 ; j++) &#123;<br><span class="hljs-comment">// 如果两个子串的末尾字符已经相同</span><br><span class="hljs-keyword">if</span>(str1[i - <span class="hljs-number">1</span>] == str2[j - <span class="hljs-number">1</span>]) <br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];   <span class="hljs-comment">// 那就不需要任何改动了</span><br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 在三种操作中选一种最省的最小的，来作为当前值</span><br>dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], <span class="hljs-number">1</span> + dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]);   <span class="hljs-comment">// 在str2中修改1个 左上方  在滚动dp中不太方便表达 </span><br>dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], <span class="hljs-number">1</span> + dp[i][j<span class="hljs-number">-1</span>]);     <span class="hljs-comment">// 在str2中删除1个 左方    在滚动dp中好表达 </span><br>dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], <span class="hljs-number">1</span> + dp[i<span class="hljs-number">-1</span>][j]);     <span class="hljs-comment">// 在str2中插入1个 正上方  在滚动dp中好表达</span><br>&#125;<br>&#125;<br>&#125;<br>cout &lt;&lt; dp[len1][len2] &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 线性DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长公共子串问题</title>
      <link href="/2024/04/30/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
      <url>/2024/04/30/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="视频教学链接">1.1 视频教学链接</h2><p>　　<ahref="https://www.bilibili.com/video/BV1hv41117gC/?vd_source=0e7cc4e4bbbb67e5c3c2a3e7d967f075">最长公共子串</a></p><h2 id="理论分析">1.2 理论分析</h2><h3 id="什么是子串">1.2.1 什么是子串？</h3><p>　　如图所示:</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240430094645379.png" style="zoom: 50%;" /></p><p>　　它的子串示例：{c,d,e,f}即连续元素c,d,e,f组成的串是给定序列的子串。同理，{a,b,c,d},{g,h}等都是它的子串。</p><p>　　两个序列的最长公共子串的长度值是唯一的，但<strong>公共子串在两个序列中的字符选择，可能是不唯一的</strong>。例如S1="AABAA",S2="AA"，则S2的字符AA和S1中的两个AA都分别构成最长公共子串，长度值都为2。</p><h3 id="动态规划的六步分析">1.2.2 动态规划的六步分析</h3><p>　　1）定义状态数组</p><p>　　假设有两个字符串a[1..lena]和b[1..lenb]，状态数组肯定是一个二维数组无疑。一个直觉是“定义dp[i][j]为‘a[1..i]和b[1..j]的最长公共子串的长度值’”。<strong>但实际上这个定义是错误的</strong>，因为它违反了动态规划方法所要求的第二个前提，即“无后效性”。下面我们举个例子来说明：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240430180913104.png" style="zoom: 70%;" /></p><p>　　上图是两个序列a[]="ABACCB"和b[]="AACCAB"按照“dp[i][j]为a[1..i]和b[1..j]的最长公共子串的长度值”的规定而填写的。仔细研究每一个红圈处，可以发现，都是“a[i]==b[j]且a[i-1]==b[j-1]且a[i-2]==b[j-2]且......”直到“a值和b值不相等”为止。而每一个篮圈处，都是“a[i]==b[j]且a[i-1]!=b[j-1]”的情况，不能简单地加1。<strong>当我们固定a[1..i]，已填好dp[i][j-1]，并且打算填写dp[i][j]时，我们无法确定a[i]在两个序列a[1..i]和b[1..j-1]的公共子串中是否已经被选中过了（若a[i]已用过，则不能再用来和b[j]匹配）。</strong></p><p>　　例如从dp[4][2]开始填写dp[4][3]时，b[3]为字符C，与a[4]相等，且a[4]在a[1..4]和b[1..2]的公共子串"A"中从未出现过，故可用来和b[3]相配，延长子串为“AC”。而填写dp[4][4]时，b[4]为字符C，与a[4]相等，但a[4]在a[1..4]和b[1..3]的公共子串"AC"中已经用过，不能再用来和b[4]相配，故不可加1。</p><p>　　仔细思考，可以发现<strong>因为要求子串必须连续，而“dp[i][j]为a[1..i]和b[1..j]的最长公共子串的长度值”这样的设计，并不能体现和预判出这种“连续性”。这就是问题产生的根源</strong>。</p><p>　　但如果把设计改为“dp[i][j]为a[1..i]和b[1..j]中a[i]==b[j]且a[i]为公共子串的末尾字符时的最长子串长度值”，问题就迎刃而解了。听起来有点长，实际上就是在原来定义的基础上，加上“要求必须两个子串的末尾字符相等，且等于a[i]和b[j]”即可。</p><p>　　按照新的定义，则dp[][]的值如下：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240430204356117.png"alt="image-20240430204356117" /><figcaption aria-hidden="true">image-20240430204356117</figcaption></figure><p>　　从上图中可以看出，<strong>当a[i]==b[j]时，既然不能确定a[i]是否之前已用过，那干脆直接从dp[i-1][j-1]推过来就可以了。这样的话a[i]就肯定没用过了，而b[j]也没用过，正好相配，成为子串的新成员。</strong></p><p>　　2）所求目标</p><p>　　在这种情况下，dp[lena][lenb]不一定是最大值了。所求目标应该是max(dp[1..lena][1..lenb])。</p><p>　　3）状态转移方程：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240430143937061.png" style="zoom: 50%;" /></p><p>　　a）若a[i]==b[j],则至少有它们两个可以构成长度值为1的公共子串。对于a[1..i-1]和b[1..j-1]，根据dp的定义，dp[i-1][j-1]表示它们的最长公共子串的长度值。再尾续上a[i]，长度值应+ 1。</p><p>　　b）若a[i]!=b[j],则不管a[1..i-1]和b[1..j-1]能否构成公共子串，因为必须要以a[i]或者b[j]作为子串的最后一个字符，现在二者不等，所以dp[i][j]=0。</p><p>　　整合a）和b），得状态转移方程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (a[i]==b[j])  <br>    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <br>    dp[i][j] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>　　4）循环顺序和循环边界</p><p>　　　　肯定是需要从上往下、从左往右填写</p><p>　　　　i: 1-----&gt;lena 增序</p><p>　　　　j：1&lt;----&gt;lenb 增序降序均可</p><p>　　5）特例</p><p>　　　　dp[0][j]=dp[i][0]= 0;</p><p>　　　　注意：<del>dp[1][j]=dp[i][1]= 1</del>;是错误的！</p><p>　　6）数组初始化值</p><p>　　　　不需要专门处理普通位置上的初值，都会被覆盖的。</p><h1 id="二.-实战训练">二. 实战训练</h1><h2 id="or15-最长公共子串的长度值">2.1 OR15 最长公共子串的长度值</h2><p>　　原题链接：</p><p>　　　　<ahref="https://www.nowcoder.com/practice/02e7cc263f8a49e8b1e1dc9c116f7602?dayCountBigMember=%E8%BF%9E%E7%BB%AD%E5%8C%85%E6%9C%88&amp;tpId=0&amp;difficulty=&amp;judgeStatus=&amp;tags=&amp;title=%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2&amp;sourceUrl=&amp;gioEnter=menu"><strong>最长公共子串</strong></a>（微信扫码登录)</p><p>　　分析：</p><p>　　dp[i][j]表示str1[0..i-1]和str2[0..j-1]的<strong>以str1[i-1]结尾</strong>的最长公共子串的长度，本题的关键是在于错位存储。因为两个字符串必须以下标0开始存储，所以dp[i][j]表示的不是str1[0..i]和str2[0..j]的子串，换句话说，要在原来1.2.2节分析的基础上，把dp数组的数据区整体往右下方向移动1格即可。</p><p>　　另外，还需要注意一下用vector定义二维数组的写法。</p><p>　　AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LongestSubstring</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLongest</span><span class="hljs-params">(string A, <span class="hljs-type">int</span> n, string B, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> max_len = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//用vector来定义二维数组，长度为[n + 1][m + 1]，默认值为0</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                <span class="hljs-keyword">if</span> (A[i] == B[j]) &#123;<br>                    <span class="hljs-comment">// 递推方程。因为是从00开始，所以把dp的数据区域往右下的方向挪一下而已</span><br>                    <span class="hljs-comment">// dp[i][j]表示a[1..i-1]和b[1..j-1]中a[i-1]==b[j-1]且a[i-1]为公共子串的末尾字符时的最长子串长度值</span><br>                    <span class="hljs-comment">// dp[i+1][j+1]表示a[1..i]和b[1..j]中a[i]==b[j]且a[i]为公共子串的末尾字符时的最长子串长度值</span><br>                    dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = dp[i][j] + <span class="hljs-number">1</span>;<br>                    <span class="hljs-comment">// 找二维数组的最大值</span><br>                    <span class="hljs-keyword">if</span> (max_len &lt; dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 如果不记录下标，&lt;和&lt;=就没区别</span><br>                        max_len = dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max_len;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="cd33-最长公共子串的长度值和子串值">2.2 cd33最长公共子串的长度值和子串值</h2><p>　　原题链接：</p><p>　　　　<ahref="https://www.nowcoder.com/practice/210741385d37490c97446aa50874e62d?dayCountBigMember=%E8%BF%9E%E7%BB%AD%E5%8C%85%E6%9C%88&amp;tpId=0&amp;difficulty=&amp;judgeStatus=&amp;tags=&amp;title=%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2&amp;sourceUrl=&amp;gioEnter=menu"><strong>最长公共子串</strong></a>（微信扫码登录)</p><p>　　分析：</p><p>　　dp[i][j]表示str1[0..i-1]和str2[0..j-1]的以str1[i-1]结尾的最长公共子串的长度，本题在2.1节基础上增加了对“输出子串内容”的要求。所以本题的关键是在dp遍历的过程中记录最长公共子串的结尾下标epos，根据结尾下标以及长度就可以求出子串。</p><p>　　AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>string s1, s2;<br><span class="hljs-comment">//用vector来定义二维数组，长度为[len1 + 1][len2 + 1]，默认值为0</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt;s1 &gt;&gt;s2;<br>    <span class="hljs-type">int</span> len1=s1.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> len2=s2.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> max_len=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> epos=<span class="hljs-number">-1</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len1+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len2+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len1; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;len2; j++) &#123;<br>            <span class="hljs-keyword">if</span>(s1[i]==s2[j]) &#123;<br>                <span class="hljs-comment">// 递推方程。因为是从00开始，所以把dp的数据区域往右下的方向挪一下而已</span><br>                <span class="hljs-comment">// dp[i][j]表示a[1..i-1]和b[1..j-1]中a[i-1]==b[j-1]且a[i-1]为公共子串的末尾字符时的最长子串长度值</span><br>                <span class="hljs-comment">// dp[i+1][j+1]表示a[1..i]和b[1..j]中a[i]==b[j]且a[i]为公共子串的末尾字符时的最长子串长度值</span><br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=dp[i][j] + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 找二维数组的最大值</span><br>                <span class="hljs-keyword">if</span>(max_len &lt; dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 既然要记录下标，此处表示从左往右“第1个”长度为max_len的公共子串的结束下标。如果改为&lt;=，则表示“最后1个”</span><br>                    max_len = dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>];<br>                    epos = i;  <span class="hljs-comment">// 公共子串在s1的结束下标</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> spos=epos - max_len + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 根据“结束下标”和子串长度，算出子串的“起始下标”spos</span><br>    <span class="hljs-keyword">if</span> (epos==<span class="hljs-number">-1</span>)<br>        cout &lt;&lt; <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; s1.<span class="hljs-built_in">substr</span>(spos, max_len);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="hj65-最长公共子串的长度值">2.3 hj65 最长公共子串的长度值</h2><p>　　原题链接：</p><p>　　　　<ahref="https://www.nowcoder.com/practice/02e7cc263f8a49e8b1e1dc9c116f7602?dayCountBigMember=%E8%BF%9E%E7%BB%AD%E5%8C%85%E6%9C%88&amp;tpId=0&amp;difficulty=&amp;judgeStatus=&amp;tags=&amp;title=%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2&amp;sourceUrl=&amp;gioEnter=menu"><strong>查找两个字符串a,b中的最长公共子串</strong></a>（微信扫码登录)</p><p>　　分析：</p><p>　　　　本题在2.2节基础上，加入了“输出在较短串中最先出现的那个”。首先我们需要明白，最长公共子串，是有可能有多个解的。例如s1=“AAXXXXXXXBB”和s2=“BBYAA”就有“AA”和“BB”这两个最长公共子串，长度都是2，都最长。如果按照本题的意思，则应该输出较短的串（即s2）中的“BB”，因为它先出现。</p><p>　　我们需要先比较两串长度，用swap让s1成为最短的串，以方便后面的代码书写。至于“最先出现”该如何搞定呢？只需要在子串最大长度值进行刷新时规定当长度值相等时仍然不刷新对应下标，仍然保留第一次出现长度值为max_len的子串的下标epos。</p><p>　　AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function">string <span class="hljs-title">LCS</span><span class="hljs-params">(string str1, string str2)</span> </span>&#123;<br>    <span class="hljs-comment">// write code here</span><br>    <span class="hljs-keyword">if</span> (str1.<span class="hljs-built_in">size</span>() &gt; str2.<span class="hljs-built_in">size</span>())  <span class="hljs-comment">// 确保str1是最短的串</span><br>        <span class="hljs-built_in">swap</span>(str1, str2);<br>    <span class="hljs-type">int</span> m = str1.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> n = str2.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// dp[i][j] str1前i个字符和str2前j个字符（以其为尾字符）的最长公共子串长度</span><br>    <span class="hljs-type">int</span> dp[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> maxlen = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//base case</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; ++j) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (str1[i - <span class="hljs-number">1</span>] == str2[j - <span class="hljs-number">1</span>]) <br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                dp[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (dp[i][j] &gt; maxlen) &#123; <span class="hljs-comment">// 这里不能写&gt;=，必须是&gt;，确保了“首次出现”</span><br>                maxlen = dp[i][j];<br>                end = i - <span class="hljs-number">1</span>;         <span class="hljs-comment">// 记录i-1，而i对应着str1（短串），所以确保了是短串中的结束下标</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (maxlen == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;-1&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> str1.<span class="hljs-built_in">substr</span>(end - maxlen + <span class="hljs-number">1</span>, maxlen);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s1, s2;<br>    cin &gt;&gt; s1 &gt;&gt; s2；<br>    cout &lt;&lt; <span class="hljs-built_in">LCS</span>(s1, s2) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 线性DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长公共子序列（LCS）问题</title>
      <link href="/2024/04/25/LCS%E9%97%AE%E9%A2%98/"/>
      <url>/2024/04/25/LCS%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="视频教学链接">1.1 视频教学链接</h2><p>　　<ahref="https://www.bilibili.com/video/BV1EK411K7Eb/?spm_id_from=333.999.0.0">最长公共子序列</a></p><h2 id="理论分析">1.2 理论分析</h2><p>　　最长公共子序列（Longest Common Subsequence,LCS）问题，是锻炼同学们的递推思维和线性DP的好题型。给定两个序列A和B，求这两个序列的最长公共子序列的长度值，这就是最长公共子序列问题。</p><h3 id="什么是子序列">1.2.1 什么是子序列？</h3><p>　　最长公共子序列（longest common sequence）和最长公共子串（longestcommonsubstring）不是一回事儿。什么是子序列呢？即一个给定的序列的子序列，就是将给定序列中零个或多个元素去掉之后得到的结果。什么是子串呢？给定串中任意个连续的字符组成的子序列称为该串的子串。给一个图再解释一下：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240430094645379.png" style="zoom: 50%;" /></p><p>　　如上图，给定的字符序列： {a,b,c,d,e,f,g,h}，它的子序列示例：{a,c,e,f}即元素b,d,g,h被去掉后，保持原有的元素序列所得到的结果就是子序列。同理，{a,h},{c,d,e}等都是它的子序列。</p><p>　　它的子串示例：{c,d,e,f}即连续元素c,d,e,f组成的串是给定序列的子串。同理，{a,b,c,d},{g,h}等都是它的子串。</p><p>　　需要提醒一下：两个序列的最长公共子序列的长度值是唯一的，但<strong>公共子序列在两个序列中的字符选择，可能是不唯一的</strong>。例如S1="AABA",S2="A"，则S2的字符A和S1中的3个字符A都分别构成最长公共子序列，长度值都为1。</p><h3 id="如何求最长公共子序列的长度值">1.2.2如何求最长公共子序列的长度值？</h3><p>　　在产生子序列时，一个长度为n的序列中的每个字符，只有两种选择：“被选择”和“不被选择”。根据组合数学的乘法原理：1个字符有2种选择，n个字符就有<spanclass="math inline">\(2*2*2*...*2=2^n\)</span>种选择结果。两个序列，数量还得翻倍。用暴力搜索的方法是根本不可能求解LCS问题的。</p><p>　　该题型可以从动态规划的角度来思考。两个序列S1和S2的内容一旦定了，其最长公共子序列的长度值就肯定定了。而且对任意一个序列的末尾增加或者删除一个字符，都有可能造成长度值的变化。所以，长度值是S1和S2的长度值的函数，换句话说，dp中的“一个状态”是由length(S1)和length(S2)决定的。dp[i][j]表示序列S1的前i个字符和序列S2的前j个字符的最长公共子序列的长度值。令<spanclass="math inline">\(m=strlen(S1),n=strlen(S2)\)</span>，则dp[m][n]即为LCS问题的最终答案。搞定“六点法”中的第一点和第二点。</p><p>　　那第三点，即状态转移方程该如何推导呢？</p><p>　　既然是找递推方程，那么我们就应该想办法，把dp[i][j]的问题和dp[i-1][j]、dp[i][j-1]、dp[i-1][j-1]等数据关联起来。同学们应该朝着这个方向去思考和推导。仔细分析一下当前的S1[i]和S2[j]，无非就是下面列的4种情况。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240430120555498.png" style="zoom: 67%;" /></p><p>　　1）上述中的情况1，转移方程为dp[i][j]=dp[i-1][j-1]+1</p><p>　　2）上述中的情况2、3、4，可以整合成一个方程，即dp[i][j]=max(dp[i-1][j],dp[i][j-1])、</p><p>　　所以，状态转移方程合并起来为：　　</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (S1[i]==S2[j])<br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);<br></code></pre></td></tr></table></figure><p>　　现在来看第四点，循环顺序和边界。从转移方程可以看出，当前行当前列的数据，依赖于左端、上端、左上端的数据。所以循环顺序可以是“从上往下、从左往右”或者“从左往右、从上往下”，不能再有其他顺序。</p><p>　　第五点是特例。当i==0或者j==0时，即如果S1或者S2其中一个序列为空序列时，两者的最长公共子序列为空序列，其长度值是0，所以dp[0][j]=0,dp[i][0]=0；</p><p>　　第六点是初始化dp[][]。初始化应避开特例值。本转移方程中都是根据已知推未知，其他普通位置上的dp值可以为任意数值。为简单起见，可以赋初值为0（定为全局数组，自动为全0）即可。</p><h3 id="如何根据dp的值反推出最长公共子序列的具体值">1.2.3如何根据dp[][]的值反推出最长公共子序列的具体值？</h3><p>　　下面给同学们看两个dp[][]的值，同学们能看得出来这两个案例分别选择了什么样的公共子序列吗？</p><p>　　图一：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240430125908420.png" style="zoom: 50%;" /></p><p>　　其公共子序列为"CEGGH"(注意，最长公共子序列的答案并不唯一，“CEGGH”只是上图的彩色路径下所展示出来的结果，还存在其他路径，但长度都是5)</p><p>　　图二：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/clip_image001.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>　　现在同学们能否可以总结一下公共子序列具体字符的推导方法呢？</p><p>　　1）应从矩阵的右下角元素dp[m][n]开始，往左上角的方向，倒推。</p><p>　　2）如果S1[i]==S2[j]，则往当前格的左上方走，此时表示S1[i]这个字符是公共子序列的一个字符，选择！</p><p>　　3）如果S1[i]!=S2[j]，则看当前格的上方和左方，谁大就往谁走，如果一样大则任选一方（此时就产生了多条路径，即多种答案）</p><p>　　4）反复执行2）和3）的步骤，直到走到左上角的dp[0][0]位置结束。此时把选择的字符反序输出即可。</p><h3 id="复杂度分析">1.2.4 复杂度分析</h3><p>　　1）时间复杂度</p><p>　　　　从1.2.2中的“第四点”可以看出，dp推导是二重for，时间复杂度为<spanclass="math inline">\(O(\ len(S1)*len(S2)\ )\)</span>。</p><p>　　2）空间复杂度</p><p>　　　　标准的求解过程，是需要定义dp[][]的，数组大小为<spanclass="math inline">\(len(S1)*len(S2)\)</span>。从状态转移方程可以看出，该二维状态数组可以用一维滚动状态数组来代替，从而压缩空间。但压缩后，第1..m-1排的数据丢失，无法倒推路径，无法得到最长公共子序列的具体字符。</p><h1 id="二.-实战训练">二. 实战训练</h1><h2 id="例9.9最长公共子序列">2.1 1265：【例9.9】最长公共子序列</h2><p>　　原题链接：</p><p>　　　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1265">1265：【例9.9】最长公共子序列</a></p><p>　　AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">和1297题结合起来一起看 </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1005</span>;<br><span class="hljs-type">char</span> str11[N], str22[N], common[N];<br><span class="hljs-type">int</span> cnt[N][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 从1开始编号，故而地址值+1 </span><br>cin &gt;&gt;str11+<span class="hljs-number">1</span> &gt;&gt;str22+<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> len11 = <span class="hljs-built_in">strlen</span>( str11+<span class="hljs-number">1</span> );<br><span class="hljs-type">int</span> len22 = <span class="hljs-built_in">strlen</span>( str22+<span class="hljs-number">1</span> );<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len11; i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= len22; j++)<br><span class="hljs-keyword">if</span> ( str11[i] == str22[j] )<br>cnt[i][j] = cnt[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>cnt[i][j] = <span class="hljs-built_in">max</span>(cnt[i][j<span class="hljs-number">-1</span>], cnt[i<span class="hljs-number">-1</span>][j]);<br><br>cout&lt;&lt;cnt[len11][len22]&lt;&lt;endl;<br><br><span class="hljs-comment">// 输出最长公共子序列</span><br><span class="hljs-comment">//memset(common, 0, sizeof(common));</span><br><span class="hljs-comment">//int i = len11, j = len22;</span><br><span class="hljs-comment">//while ( i &gt;= 1  &amp;&amp; j &gt;= 1 )&#123; </span><br><span class="hljs-comment">//        if ( str11[i] == str22[j] ) &#123;</span><br><span class="hljs-comment">//            common[k++] = str11[i];</span><br><span class="hljs-comment">//            i--;</span><br><span class="hljs-comment">//            j--;</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        else &#123;</span><br><span class="hljs-comment">//            if (cnt[i][j-1] &gt; cnt[i-1][j])</span><br><span class="hljs-comment">//                j--;</span><br><span class="hljs-comment">//            else       </span><br><span class="hljs-comment">//                i--;   // 相等时i--。当然，要j--也是可以的，两条不同的路径 </span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-comment">//    </span><br><span class="hljs-comment">//    for(int i=k-1; i&gt;=0; i--)</span><br><span class="hljs-comment">//    cout &lt;&lt;common[i];</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="公共子序列">2.2 1297：公共子序列</h2><p>　　原题链接：</p><p>　　　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1297">1297：公共子序列</a></p><p>　　分析：</p><p>　　　　本题和2.1节中的1265题没什么大的差别，就当是复习巩固题了。</p><p>　　AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 因为字符串最长只有200个，所以公共子序列长度不会超过200，</span><br><span class="hljs-type">int</span> dp[<span class="hljs-number">201</span>][<span class="hljs-number">201</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i, j, len1, len2;<br><span class="hljs-type">char</span> str1[<span class="hljs-number">201</span>], str2[<span class="hljs-number">201</span>];<br><span class="hljs-comment">// 这里稍微要注意一下，不是NULL或0，而是EOF(-1) </span><br><span class="hljs-comment">// 此处也可以用while( cin &gt;&gt; str1+1 &gt;&gt;str2+1 ) </span><br><span class="hljs-keyword">while</span> ( <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>, str1+<span class="hljs-number">1</span>, str2+<span class="hljs-number">1</span>) != EOF )&#123;<br>len1 = <span class="hljs-built_in">strlen</span>(str1+<span class="hljs-number">1</span>);<br>len2 = <span class="hljs-built_in">strlen</span>(str2+<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 初始化dp数组为全0                    </span><br><span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;= len1; ++i)<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>; j&lt;=len2; ++j)&#123;<br><span class="hljs-comment">// 这步如果看不懂，请看笔记题解文字 </span><br><span class="hljs-keyword">if</span> ( str1[i] == str2[j] )<br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <br>dp[i][j] = <span class="hljs-built_in">max</span>( dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>] ) ; <br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[len1][len2]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 线性DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长不下降子序列（LIS）问题</title>
      <link href="/2024/04/25/LIS%E9%97%AE%E9%A2%98/"/>
      <url>/2024/04/25/LIS%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="视频教学链接">1.1 视频教学链接</h2><p><ahref="https://www.bilibili.com/video/BV1Rk4y1173p/">最长上升子序列</a></p><h2 id="题型综述">1.2 题型综述</h2><p>　　最长上升子序列（Longest Increasing Subsequence,LIS）问题，是动态规划学习者学习dp的第一个比较系统化的题型问题。这个系列的问题主要包含如下四种：</p><p>　　<strong>１）最长不下降子序列</strong></p><p>　　２）最长下降子序列</p><p>　　<strong>３）最长不上升子序列</strong></p><p>　　４）最长上升子序列</p><p>　　上述的这四种问题，其解法过程是高度相似的。</p><p>　　如果原始序列中可能有重复数据，则1）和4）的代码以及运算结果是不相同的；如果原始序列中没有重复数据，则1）和4）的代码以及运算结果是相同的，用谁都能搞定；对2）和3）也类似如上理解。</p><p>　　LIS问题常见的解法有以下三种：</p><p>　　１）朴素级做法，<spanclass="math inline">\(O(n^2)\)</span>，思路不难，可应对普及组级别的绝大部分数据，但难以得全分；</p><p>　　２）贪心＋二分答案的做法，<spanclass="math inline">\(O(n*log_2n)\)</span>，思路较难，不易敲对，可得全分；</p><p>　　３）树状数组的做法，<spanclass="math inline">\(O(n*log_2n)\)</span>，基本思路类似于第一种，但要求同学掌握树状数组，有一定的难度，暂可不学，本帖暂不讲；</p><p>　　打普及组的同学学习掌握第一种即可，打提高组的同学推荐最好是能掌握第二种，甚至第三种。</p><h2 id="dilworth定理">1.3 Dilworth定理</h2><ul><li>Dilworth定理：<strong>对于一个偏序集，最少的正链划分数 =反链的最大长度</strong>。</li><li>Dilworth定理的<strong>对偶定理</strong>：对于一个偏序集，其最少的反链划分数等于 其正链的最大长度。</li></ul><p>　　也就是说把一个数列划分成最少的最长不升子序列的数目就等于这个数列的最长上升子序列的长度。</p><p>　　这个定理的证明过程，就不在这里演示了，证明过程难度大，只要同学们学会运用即可，具体运用可看2.5节。</p><h1 id="二.-实战训练">二. 实战训练</h1><h2 id="最长不下降子序列">2.1 1259 最长不下降子序列</h2><p>　　原题链接：<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1259">1259：【例9.3】求最长不下降序列</a>/</p><p>　　分析：</p><p>　　这个题在表述上有点小问题，前面说n个数不相同，后面又说<spanclass="math inline">\(b(i_1)\leq b(i_2)\leq ...\leqb(i_e)\)</span>，前后矛盾。本题的测试数据中实际上n个数的确都不相同，所以求“上升子序列”和求“不下降子序列”的算法都能AC掉本题。但如果本题的测试数据中n个数有相同的数据，则“求不下降子序列”和“求上升子序列”就不一样了，“不下降”涵盖的含义更宽泛。体现到代码方面，主要是2.1.1节AC代码中二重for模块内的if语句中data[i]和data[pre]之间的比较符号有差异，或者体现在2.1.2节中lower_bound函数的第4个参数是选择less_equal<int>()或者选择less<int>()（默认参数为less<int>()）</p><p>　　固定动作：数组下标从1开始，尽量不要从0开始，免得后续很多麻烦。原始数据用data[]表示，状态数组用dp[]表示。</p><p>　　先看看本题是否满足动态规划的两个基本前提？</p><p>　　<strong>局部最优化原理</strong>——模型的求解过程能够被分成多个阶段；<strong>第i个阶段的决策方案</strong>，是该问题前i个阶段范围内的最优解，<strong>它不受后续其他阶段各种信息的影响</strong>。本题从左往右求解，从第1个数到后续每一个数都是一个阶段。data[1..5]的最长不下降字序列，其决策方案不受data[6]、data[7]、data[8]等数值变化的影响。满足“局部最优化原理”。</p><p>　　<strong>无后效性原理</strong>——<strong>前i个阶段的所有决策及操作，对后续阶段的决策及操作，不构成任何的干扰或影响</strong>。本题要如何设计dp[]的含义，才能满足“前i个阶段的决策对后续阶段不产生影响”呢？</p><p>　　<strong>错误做法</strong>：一种常见的错误方法是“把dp[i]设置为‘前i个数的最长不下降子序列的长度值’”。这种定义错在它会对后续阶段的决策产生影响，它是有后效性的。假设<span class="math inline">\(dp(i)=x\)</span>，可能前<spanclass="math inline">\(i\)</span>个数中有多个子序列都能满足<spanclass="math inline">\(dp(i)=x\)</span>。前<spanclass="math inline">\(i\)</span>个数中可能有多个最长不下降子序列，其中有的子序列的最后一个元素<spanclass="math inline">\(a_k\leq a_{i+1}\)</span>，则加上<spanclass="math inline">\(a_{i+1}\)</span>就能形成更长的不下降子序列；而有的子序列最后一个元素<spanclass="math inline">\(a_t \geq a_{i+1}\)</span>，使得<spanclass="math inline">\(a_{i+1}\)</span>无法接在其后。也就是说，<spanclass="math inline">\(dp(i+1)\)</span>的值要受到<spanclass="math inline">\(dp(i)\)</span>的决策内容（选取哪一个元素作为前<spanclass="math inline">\(i\)</span>个元素最长不下降子序列的最后一个点？）的影响，即<spanclass="math inline">\(dp(i)\)</span>的决策不具备“无后效性”。这明显不符合动态规划的基本要求了！所以不能这么设计子问题哦！</p><p>　　举个例子：data[]={10, 700，800, 20, 15,30，50}。假设数据从1开始编号。在讨论第6个数30时，前6个数的最长不下降子序列可以是{10,700,800}，也可以是{10,15,30}，还可以是{10,20,30}，不管是哪种选择，都是dp[6]=3。但是当我们分析第7个数50时，我们发现，如果之前选择的是{10,700,800}，那此时前7个数的最长不下降子序列仍然是{10,700,800}，因为800&gt;50，使得50无法尾续。而如果之前选择的是{10,15,30}或{10,20,30}，则可以接入50，使得最长子序列变成{10,15,30,50}或{10,20,30,50}。也就是说，dp(6)选哪个子序列，会对后续第7个阶段的决策产生影响。这违反了“无后效性”原则。</p><p>　　<strong>正确做法</strong>：本题正确做法应该是“把dp[i]设置为‘前i个数且<strong>以第i个数结束</strong>的最长不下降子序列的长度值’”。这里为何要强调“以第i个数结束”呢？对上述的错误例子稍作分析可以发现，在这样的定义下，dp(6)就不能选择{10,700,800}，而只能选择{10,15,30}或者{10,20,30}了。可能有同学会说“你这样设置，结果还是不唯一呀，你看，仍有这两种选择”。注意，我可没说过一定只能有唯一的子序列才行哦！～同学们仔细观察可以看出：不管是选择{10,15,30}或者{10,20,30}，都能尾续上50这个数，也就是说：dp(7)是有两种选法的，因为都是以同一个数（50）结尾，所以不影响后续对dp(8)、dp(9)等的决策。</p><p>　　综上两点，本题可以用“动态规划”来解决。</p><h3 id="朴素做法-路径管理on2">2.1.1 朴素做法 + 路径管理，<spanclass="math inline">\(O(n^2)\)</span></h3><p>　　（一）六点分析</p><p>　　1).状态数组：dp[i]：从data[1]到data[i]，并以data[i]结尾的最长不下降子序列的长度值</p><p>　　2).所求目标：max(dp[1..n])(最长的子序列，不一定是以data[n]为最后一个元素，所以只能搜一遍)</p><p>　　3).状态转换方程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">dp[i] = <span class="hljs-built_in">max</span>(dp[le]) + <span class="hljs-number">1</span>            ( le&lt;i 且 data[le] &lt;= data[i] )<br></code></pre></td></tr></table></figure><p>　　　　此处的“&lt;=”体现出了本题是求“不下降”　　</p><p>　　4).循环边界和循环顺序</p><p>　　　　　i:　[2..n]　　　　2　--&gt;　n　　　　　　增序</p><p>　　　　　le:　[1..i-1]　　　1　&lt;--&gt;　i-1　　　　增减均可</p><p>　　5).状态初始化值</p><p>　　此类题型还有一个非常重要的极端情况需要考虑，即“所有元素都无法连成串”。以本题为例，求“最长不下降子序列”，如果原始序列为{50，40，30，20，10}，没有任何两个数能构成“不下降”的子序列。在这种情况下，最长不下降子序列的长度值为1（如果找不到符合条件的le时，最起码可以以data[i]自己作为子序列的唯一元素），所以dp[]全体应给初值1，以预备万一出现该极端情况。</p><p>　　6).特例</p><p>　　因为le要小于i，所以对于第一个数data[1]，是肯定不存在对应的le的，所以有dp[1]=1。所以5）和6）可以整合起来。</p><p>　　（二）路径如何解决？</p><p>　　除了上述的6点之外，本题还需要求最长子序列的每个元素，这个问题如何解决呢？</p><p>　　假设现在是要求最长上升子序列，如下图所示：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240426112050626.png" /></p><p>　　在上图中，除了0节点之外，每个元素有唯一的“上一个节点”，但可能存在0个或者多个“下一个节点”，所以此处应该用ppre[]来记录每个元素的上一个节点（学过树结构的同学可以看出，这个数组和树的双亲表示法非常相似，但此处可能存在多棵树），然后想办法找出其中最长的路径。这种方法可以保存多条不同走向的一维路径，适用于其他很多算法中的路径筛选。</p><p>　　1）ppre数组如何进行初始化呢？针对上面5）中所述的极端情况，ppre[]应该全体为-1，因为这种极端情况下全体元素都是根节点（也就是说，有n棵树，每棵树只有一个节点）。　</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>cin &gt;&gt;data[i];<br><span class="hljs-comment">// 逆序是最糟糕的情况，但无论如何，序列中也至少能有1个数嘛</span><br>dp[i] = <span class="hljs-number">1</span>;       <br>ppre[i] = <span class="hljs-number">-1</span>;    <span class="hljs-comment">// 初始化ppre[]，千万别忘了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>　　2）如何利用ppre数组来做路径的打印呢？</p><p>　　首先，我们需要编写递归函数，以事先约定好的-1或者0表示递归结束。递归函数中需要先递归，再打印当前点，顺序不能错，因为打印顺序和访问顺序是相反的。这一点是递归函数的基本功，听不懂的同学可自己先用代码模拟做一下测试。如下局部代码所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 本题中的ppre[]，例如： ppre[3] = 5; 意思是指：5号点的前一个结点，是3号点。 </span><br><span class="hljs-type">int</span> ppre[N];<br><span class="hljs-comment">// 虽然是输入子序列最后一个点的下标，但是利用递归函数，可以实现从前往后地打印， </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prin</span><span class="hljs-params">( <span class="hljs-type">int</span> cur )</span></span>&#123;<br><span class="hljs-comment">// 递归结束条件，特例，当前点下标为-1时不再往下走了 </span><br>    <span class="hljs-keyword">if</span>( cur == <span class="hljs-number">-1</span> )<span class="hljs-keyword">return</span> ;<br><span class="hljs-comment">// 先打印前面的点 </span><br><span class="hljs-built_in">prin</span>( ppre[cur] );<br><span class="hljs-comment">// 然后再打印当前点 </span><br>cout &lt;&lt;data[cur] &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　然后，如果要打印所有路径，则需要把每条路径从终点开始反向遍历，直到节点不再有“上一个节点”（即根节点）结束。终点的个数就是不同路径的总条数（因为所有路径的起点都是0号点，该点是虚拟的点，实际上并不存在）。如果想要输出其中某一条路径，例如本题中的最长路径，需要先找到最长路径的终点下标（即dp[]中最大值所在的下标），然后从该终点节点出发，利用递归函数来实现逆序打印，如下局部代码所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 针对dp数组的后期处理 </span><br><span class="hljs-type">int</span> maxcount = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> lastpos = <span class="hljs-number">-1</span>;  <br><span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>    <span class="hljs-comment">// 走完一轮之后，记录最大值，并记录切入位置。注意有等号= </span><br>   <span class="hljs-keyword">if</span> (dp[i] &gt;= maxcount)&#123;<br>        maxcount = dp[i];<br>     lastpos = i;<br>    &#125;<br>&#125;<br>cout &lt;&lt;<span class="hljs-string">&quot;max=&quot;</span> &lt;&lt;maxcount &lt;&lt;endl;<br><span class="hljs-built_in">prin</span>( lastpos );<br></code></pre></td></tr></table></figure><p>　　整个程序完整的AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 201        </span><br><span class="hljs-comment">// 原始数据存在这里 </span><br><span class="hljs-type">int</span> data[N]; <br><span class="hljs-comment">// 状态数组是一维的即可，规模和原始数据长度一致 </span><br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-comment">// 在n个数中选一部分来，其实也可以用choosed[]的方式， 选了为1，没选为0，然后循环撸一遍就出来了 </span><br><span class="hljs-comment">// 本题中的ppre[]，例如： ppre[3] = 5; 意思是指：5号点的前一个结点，是3号点。 </span><br><span class="hljs-type">int</span> ppre[N];<br><span class="hljs-comment">// 虽然是输入子序列最后一个点的下标，但是利用递归函数，可以实现从前往后地打印， </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prin</span><span class="hljs-params">( <span class="hljs-type">int</span> cur )</span></span>&#123;<br><span class="hljs-comment">// 递归结束条件，特例，当前点下标为-1时不再往下走了 </span><br>    <span class="hljs-keyword">if</span>( cur == <span class="hljs-number">-1</span> )<br><span class="hljs-keyword">return</span> ;<br><span class="hljs-comment">// 先打印前面的点 </span><br><span class="hljs-built_in">prin</span>( ppre[cur] );<br><span class="hljs-comment">// 然后再打印当前点 </span><br>cout &lt;&lt;data[cur] &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-type">int</span> i, n;<br>cin &gt;&gt;n;<br><span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>cin &gt;&gt;data[i];<br><span class="hljs-comment">// 逆序是最糟糕的情况，但无论如何，序列中也至少能有1个数嘛</span><br>dp[i] = <span class="hljs-number">1</span>;       <br>ppre[i] = <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">// 针对2到n这n-1个阶段 </span><br><span class="hljs-keyword">for</span>( i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123;     <span class="hljs-comment">// 此处i=1也可AC，内层for什么都不会做 </span><br><span class="hljs-comment">// 根据i前面的所有原始数据及状态值，来考虑刷新当前第i个状态值dp[i]，</span><br><span class="hljs-comment">// 并利用反向的方法来记录最长子序列，及刷新该子序列的元素个数值maxcount </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> pre=<span class="hljs-number">1</span>; pre&lt;i; pre++)&#123;<br>    <span class="hljs-comment">// 注意有等号= ！ 如果不允许序列中有相等的元素，则此处就别加=号 </span><br>        <span class="hljs-keyword">if</span>( data[pre] &lt;= data[i]    &amp;&amp;  dp[pre] + <span class="hljs-number">1</span> &gt; dp[i] )&#123;<br>        <span class="hljs-comment">// 刷新dp[i]为一个更大的个数 </span><br>                dp[i] = dp[pre] + <span class="hljs-number">1</span>;<br>                ppre[i] = pre;   <span class="hljs-comment">// 设定pre为i的上一个元素，始终保持和dp[]的改变同步 </span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 针对dp数组的后期处理 </span><br><span class="hljs-type">int</span> maxcount = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> lastpos = <span class="hljs-number">-1</span>;  <br><span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>    <span class="hljs-comment">// 走完一轮之后，记录最大值，并记录切入位置。注意有等号= </span><br>    <span class="hljs-keyword">if</span> (dp[i] &gt;= maxcount)&#123;<br>        maxcount = dp[i];<br>      lastpos = i;<br>    &#125;<br>&#125;<br>cout &lt;&lt;<span class="hljs-string">&quot;max=&quot;</span> &lt;&lt;maxcount &lt;&lt;endl;<br><span class="hljs-built_in">prin</span>( lastpos );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　同学们可以自行思考，如果想保存在一个二维地图中的多条不同走向的路径，该如何设计和使用ppre数组呢？</p><p>　　对于这个问题，ppre数组应设计为struct nodeppre[N][N]。一维的情况下只需要ppre[i]=pre即可搞定，而在二维情况下，需要ppre[i][j].r=prerow,ppre[i][j].c=precol两句代码分别保存上一个点的行号和列号。</p><h3 id="贪心二分做法-路径管理">2.1.2 “贪心+二分”做法 + 路径管理</h3><p>　　我们需要的是找到一个最长的不下降的子序列，想要子序列尽量长，那在选择元素的过程中，我们当然希望该子序列上涨得越慢越好。<strong>因为只有子序列的数上涨得慢，才有更大的可能性尾续上后面的数。这就是贪心思想在本题中的贪心点</strong>。该方法和本帖的动态规划没有直接关系，就是一个贪心算法而已。</p><p>　　(一)知识预备：</p><p>　　　　需要掌握upper_bound()函数的含义和用法。如有不会，请看这里。</p><p>　　（二）数据结构介绍:</p><p>　　1)seqval[]：暂存符合题意（“不下降”）的子序列的元素值（例如seqval[5]=20表示最长不下降子序列的第5个数是20），但因为其元素接受被后续数据替换，所以值可能失真，但因为是一一替换，所以长度值还是正确的。</p><p>　　2）maxlen[]：暂存以每个元素结尾的符合题意（“不下降”）的最长子序列的长度值（例如maxlen[6]=4表示以data[6]结尾的最长不下降子序列的长度值为4）</p><p>　　3）seqpos[]：输出子序列的时候需要该数组，存储最长不下降子序列中各个元素的下标值。根据maxlen[]和data[]联合起来，产生seqpos[]。</p><p>　　（三）视频链接</p><p>　　<a href="https://www.bilibili.com/video/BV1Kp4y1e77H/">E04 线性DP最长上升子序列 二分优化</a></p><p>　　（四）图解分析</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240426173854324.png"alt="image-20240426173854324" /><figcaption aria-hidden="true">image-20240426173854324</figcaption></figure><p>　　（五）文字分析</p><p>　　seqval[]因为可能存在被替换，所以其值往往并不是最长不下降子序列的所有元素值（上图纯属特例）。既然如此，那最长不下降子序列的所有元素该如何才能精确地找出来呢？我们可以从maxlen[]来入手。以上图的数据为例，其做法如下：</p><p>　　1）<strong>找到maxlen[]中的最大值</strong>（即10号元素7），为整个数组的最长不下降子序列的长度值。cur=10。<strong>其下标作为向左遍历的起点下标</strong>。</p><p>　　2）从data[cur]开始，循环往左一直找第一个&lt;=data[cur]的值。如果&gt;data[cur]则跳过继续往左找，直到找完data[]的所有元素为止。此处找到data[9]=21&lt;= 22=data[cur]。（9号元素即为子序列的倒数第2个数）</p><p>　　3）cur=9， 回到2）继续做。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240426181546125.png"alt="image-20240426181546125" /><figcaption aria-hidden="true">image-20240426181546125</figcaption></figure><p>　　可以设置一个数组seqpos[]用来存放所有被选中的（绿色）元素的下标或者值，即为真正准确的最长不下降子序列。</p><p>　　（六）关于XXX_bound的选择及其第四个参数的填写</p><p>　　1）先确定<font color="red"><strong>子序列</strong></font>的左右顺序的规则（即子序列的排序规则）</p><p>　　　　<strong>a) 不下降子序列—— &lt;=</strong></p><p>　　　　b) 下降子序列—— &gt;</p><p>　　　　<strong>c) 不上升子序列—— &gt;=</strong></p><p>　　　　d) 上升子序列—— &lt;</p><p>　　2）再确定第四个参数——<font color="red"><strong>应和子序列的左右顺序规则保持一致</strong></font></p><p>　　　　为何需要一致呢？XXX_bound函数返回的是违反其第四个参数所代表的比较规则的第一个数的下标。而在LIS问题的贪心+二分算法中，恰好也是要去寻找子序列中第一个违反子序列规则的第一个数，并将其替换掉。所以，两者的含义一致，只需要在第四个参数中填入子序列的排序规则即可。为避免同学们“反反得正”地把自己的思维绕晕，大家直接记住这个结论去照做就行了。　　　　</p><p>　　　　a) 不下降子序列—— “&lt;=”——第四个参数写less_equal<int>()。禁填greater或greater_equal，否则不管是lower或者upper都会结果失准</p><p>　　　　b) 下降子序列—— “&gt;”——第四个参数写greater<int>()。禁填less或less_equal，否则不管是lower或者upper都会结果失准</p><p>　　　　c) 不上升子序列—— “&gt;=”——第四个参数写greater_equal<int>()。禁填less或less_equal，否则不管是lower或者upper都会结果失准</p><p>　　　　d) 上升子序列—— “&lt;”——第四个参数写less<int>()。禁填greater或greater_equal，否则不管是lower或者upper都会结果失准</p><p>　　3）最后确定函数——选<strong>lower_bound</strong>函数。</p><p>　　upper_bound函数在降序或不上升序列的前提下，如果填greater，返回的是小于目标的第一个数；如果填greater_equal，返回的是小于等于目标值的第一个数。这……有点反人类了。而lower_bound函数则表现稳定，没有这类问题。为减少同学们的记忆量，自己写代码的时候，请直接用lower_bound函数就好了。</p><p>　　（七）AC代码</p><p>　　本题AC代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 201</span><br><span class="hljs-type">int</span> data[N];<span class="hljs-comment">// 原始数据序列，长度是[1..n]</span><br><span class="hljs-comment">// seqval[5]=20：子序列的第5个数值为20 </span><br><span class="hljs-comment">// 存放子序列的每个元素的值，个数是准确的，但是值不一定准确。[1..len]</span><br><span class="hljs-type">int</span> seqval[N];  <br><span class="hljs-comment">// 下面2个数组maxlen[]和seqpos[]主要是为了求子序列的所有元素。如果不求，可不需要maxlen[]和seqppos[]</span><br><span class="hljs-comment">// maxlen[i]：以第i个数为最后一个数的非下降子序列的最大长度值 [1..n]</span><br><span class="hljs-type">int</span> maxlen[N];<span class="hljs-comment">// maxlen[8] = 5，这表示以data[8]为子序列末结点的最长子序列的序列长度是 5   </span><br><span class="hljs-comment">// 最大非下降子序列在原始数据序列中的下标值[1..len]</span><br><span class="hljs-type">int</span> seqpos[N];<span class="hljs-comment">// seqpos[4] = 7，这表示整个数组的最长非下降子序列中的第4个结点是data[7] </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i, j, n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-comment">// 先把异常情况处理了 </span><br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max=-1\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data[i]);<br><br>seqval[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 为了让下面的for比较顺</span><br><span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> mlen = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// data[] ----------&gt; seqval[], maxlen[] </span><br><span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++ )&#123;<br>   <span class="hljs-keyword">if</span>( data[i] &gt;= seqval[len] )&#123;<br>   seqval[++len] = data[i]; <span class="hljs-comment">// 要么就用来延长seqval数组，给曲线右侧增加新的点 </span><br>   maxlen[i] = len;         <span class="hljs-comment">// 求子序列元素值需要维护maxlen[]</span><br>   &#125;<br>   <span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 贪心思想，压低（采用替换的方法）seqval数组曲线的上升速度，以方便后续能够延得更长！</span><br><span class="hljs-comment">// 子序列顺序是&lt;=, 故第四个参数用less_equal，无论lower或upper都行</span><br>        j = <span class="hljs-built_in">lower_bound</span>(seqval+<span class="hljs-number">1</span>, seqval+len+<span class="hljs-number">1</span>, data[i], <span class="hljs-built_in">less_equal</span>&lt;<span class="hljs-type">int</span>&gt;() ) - seqval; <br>        <span class="hljs-comment">//j = upper_bound(seqval+1, seqval+len+1, data[i], less_equal&lt;int&gt;() ) - seqval; //和上一行代码等效。其实只要指定了less_equal，那么用lower或者upper都没区别</span><br>        <span class="hljs-comment">//j = upper_bound(seqval+1, seqval+len+1, data[i]) - seqval; //和上一行代码等效，upper默认就是less_equal规则，所以可不填</span><br>       seqval[j] = data[i];<br>       maxlen[i] = j;<br>   &#125;<br>&#125;  <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max=%d\n&quot;</span>, len);<br><span class="hljs-comment">// 根据maxlen[]，找出最长子序列的各个元素。如果不需找，则下面这片代码不必写 </span><br><span class="hljs-comment">// maxlen[] ------------&gt; seqpos[]</span><br><span class="hljs-type">int</span> maxx = <span class="hljs-number">0x7f7f7f7f</span>;<br>mlen = len;<br><span class="hljs-keyword">for</span>(i = n; i &gt;= <span class="hljs-number">1</span>; i--)&#123;<br><span class="hljs-comment">// 注意这里有等号，相等的数值也会纳入，这样才算是“不下降” </span><br>    <span class="hljs-keyword">if</span>( maxlen[i] == len &amp;&amp; data[i] &lt;= maxx ) &#123;<br>        seqpos[len] = i;<span class="hljs-comment">// 子序列纳入第i个数，注意这里记录的i是data[]中的下标值 </span><br>        len--;            <span class="hljs-comment">// 减一，往左找下一个 </span><br>        maxx = data[i];<span class="hljs-comment">// 及时调整，为了方便找子序列的前一个元素 </span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 当退出for循环时，seqval数组里面的递增序列，并不是所求的最长子序列，但其长度值确是正确的！ </span><br><span class="hljs-comment">// seqpos[] -------------&gt; 子序列 </span><br><span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=mlen; i++)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, data[ seqpos[i] ]);      <span class="hljs-comment">// data[ seqpos[i] ] ————最长子序列的第i个元素 </span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　如果想巩固上述算法的练习，可以看2.4节。</p><p>　　因为multiset这种STL类可以存储重复数据，且内带lower_bound和upper_bound成员函数，所以我们还可以multiset来实现“贪心+二分”。要求同学对multiset类的erase(x)、insert(x)、lower_bound(x)等成员函数比较熟悉。</p><h2 id="最长上升子序列">2.2 1281 最长上升子序列</h2><p>　　原题链接：<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1281">1281：最长上升子序列</a></p><p>　　分析：</p><p>　　本题和2.1节的1259是高度相似的，只是子序列的筛选条件不同而已。“上升”，意味着后面的元素值一定会大于前面的元素值（1259是“大于等于”，本题是“大于”，即不允许出现“等于”的情况）。</p><p>　　如果原始数组中存在重复数据，则很有可能最长上升子序列是有多种答案的。比如{4,1,2,2,3}的最长上升子序列是{1,2,3}，其中的2可以说第2个数2，也可以是第3个数2。</p><p>　　本题的AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">最长上升子序列问题 ，平方级，朴素做法 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> data[<span class="hljs-number">1001</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">1001</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i, pre, n;<br>cin &gt;&gt;n;<br><span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data[i]);<br>dp[i] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br><span class="hljs-keyword">for</span>( pre=<span class="hljs-number">1</span>; pre &lt; i; pre++)<br><span class="hljs-keyword">if</span> (data[pre] &lt; data[i])<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[pre] + <span class="hljs-number">1</span>);<br><br><span class="hljs-type">int</span> mmax= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i= <span class="hljs-number">1</span>; i&lt;=n; i++)<br><span class="hljs-keyword">if</span> (mmax &lt; dp[i])<br>mmax = dp[i];<br><br>cout &lt;&lt;mmax &lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="友好城市">2.3 1263 友好城市</h2><p>　　（一）视频链接：</p><p>　　　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1263">1263：【例9.7】友好城市</a></p><p>　　（二）分析：</p><p>　　对于这样的题，首先应该做的事是看懂样例。下面是本题样例数据及选择。其选择结果有如下几种方案：</p><p>　　1）<font color="yellow">黄</font>，<font color="DodgerBlue">蓝</font>，<font color="green">绿</font>，<font color="green">绿</font></p><p>　　2）<font color="yellow">黄</font>，<font color="orange">橙</font>，<font color="green">绿</font>，<font color="green">绿</font></p><p>　　3）<font color="red">红</font>，<font color="orange">橙</font>，<font color="green">绿</font>，<font color="green">绿</font></p><p>　　上述三个方案，是可以通过肉眼直观地看出来（<strong>希望同学们此时一定要耐心，拿出草稿纸，仔细在纸上勾画，不要图懒而就这么盯着屏幕空想。这是总结很多算法题的重要前提！</strong>）。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240428113006277.png"alt="image-20240428113006277" /><figcaption aria-hidden="true">image-20240428113006277</figcaption></figure><p>　　现在我们需要进一步总结归纳解法方案的特征。因所有线段都有两个端点，为避免重复或遗漏，可以以南岸（以北岸也行，本无差别）端点的增序为序，对每条线段进行筛选。</p><p>　　1）黄线：没什么可说的，第一条，肯定无冲突，暂且选，方案改成{黄}；</p><p>　　2）蓝线：无冲突，暂且选，方案改成{黄，蓝}；</p><p>　　3）黑线：无冲突，暂且选，方案改成{黄，蓝，黑}；</p><p>　　4）红线：和左侧三条线都冲突，放弃；</p><p>　　5）橙线：和蓝线、黑线冲突，放弃；</p><p>　　6）绿线1：和黑线冲突，<strong>但因其北端点值15&lt;黑线北端点值22，15比22更靠左，理论上来说，可使得后续线段在跨线时更不容易产生交点。所以绿线1比黑线更优</strong>，方案改成{黄，蓝，绿1}</p><p>　　7）绿线2：因为有步骤6）的优化，现在可以在方案中加入绿线2而不冲突了。方案改为{黄，蓝，绿1，绿线2}</p><p>　　（三）模型总结：</p><p>　　根据上面我们模拟的七条线段的选择，我们可以把该模型改为对{4,10,22,2,9,15,17}这7个数（因为不可能一个城市同时和多个其他城市连接，所以该序列肯定是不重复的）当中选一个上升子序列，而且希望子序列尽量长。上述的方案结果可以理解为{4,10,15,17}这个子序列。在选择每个数的时候，不仅要兼顾“上升”的要求，而且还要尽量增长得慢，这样才能有利于后续选出更多符合要求（上升）的数。</p><p>　　可能有些同学已经看出来了，绕了这么一大圈，这题不就是“在南岸值递归排序的情况下，对北岸点值进行‘最长上升子序列’算法”吗？</p><p>　　（四）AC代码</p><p>　　剩下的事情就很简单了，AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  <span class="hljs-comment">// sort函数用 </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> M 1000100</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">最长上升子序列问题，朴素做法。</span><br><span class="hljs-comment">n&lt;=5000，这个数据规模，平方级的朴素算法没问题 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 原始数据 </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> N, S;<br>&#125;city[M];<br><br><span class="hljs-comment">// dp[5]=3 表示前5个点中最长上升子序列的长度是3（这个子序列中不一定包含当前点哦） </span><br><span class="hljs-type">int</span> dp[M], n, ans;<br><br><span class="hljs-comment">// 把友好城市对，按北岸城市的坐标进行增序排列</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a, node b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.N &lt; b.N;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;city[i].N, &amp;city[i].S);<br>dp[i] = <span class="hljs-number">1</span>;    <br>&#125;<br><br><span class="hljs-comment">// 把友好城市对，按北岸城市的坐标进行增序排列，从第1个元素开始排</span><br>    <span class="hljs-built_in">sort</span>(city+<span class="hljs-number">1</span>, city+<span class="hljs-number">1</span>+n, cmp);<br>    <br>    <span class="hljs-comment">// 然后求当前顺序下，南岸城市坐标序列的最长上升子序列 </span><br>    <span class="hljs-comment">// 针对每一个点i，根据其pre边每一个点pre的状态值，来刷新点i的状态值</span><br><span class="hljs-comment">// 状态转换方程： dp[现] = max(dp[现], dp[pre] + 1) </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> pre = <span class="hljs-number">1</span>; pre &lt;i; pre++) &#123;<br><span class="hljs-comment">// 如果pre边的点比当前点坐标小，则参与比较和刷新当前点的状态值 </span><br><span class="hljs-comment">// 这个方法有个缺憾，即没有标注记录出这个上升子序列包含哪些点 </span><br>            <span class="hljs-keyword">if</span> (city[pre].S &lt; city[i].S) <br>dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[pre]+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 求出所有点的状态值的最大值，即本题答案 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <br>ans = <span class="hljs-built_in">max</span>(ans, dp[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p2782-友好城市1263的数据加强版">2.4 P2782友好城市（1263的数据加强版）</h2><p>　　（一）原题链接：</p><p>　　　　<a href="https://www.luogu.com.cn/problem/P2782">P2782友好城市</a></p><p>　　（二）分析：</p><p>　　　　最长上升子序列，n达到了2e5，朴素做法只能得50分，必须上nlogn的做法才能得100分。如果不会的同学，请先看2.1.2节的内容。</p><p>​本题因为原始序列不存在重复，所以按照“不下降子序列”的方式来做也能AC，兼容的。此处就不再展示其做法了，只展示最长上升子序列的做法。</p><p>　　（三）AC代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">最长上升子序列，n达到了2e5，朴素做法只能得50分，必须上nlogn的做法才能得100分</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>  N =<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-comment">// 存放子序列的每个元素的值，个数是准确的，但是值不一定准确。[1..len]</span><br><span class="hljs-type">int</span> seqval[N];  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> N, S;<br>&#125;city[N];<br><span class="hljs-comment">// dp[5]=3 表示前5个点中最长上升子序列的长度是3（这个子序列中不一定包含当前点哦） </span><br><span class="hljs-type">int</span> dp[N], n, ans;<br><span class="hljs-comment">// 把友好城市对，按北岸城市的坐标进行增序排列</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a, node b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.N &lt; b.N;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;city[i].N, &amp;city[i].S);<br><span class="hljs-comment">// 状态初始值设定为1，即假设每个点所处的最长子序列只有自己一个点 </span><br>dp[i] = <span class="hljs-number">1</span>;    <br>&#125;<br><span class="hljs-comment">// 把友好城市对，按北岸城市的坐标进行增序排列，从第1个元素开始排</span><br>    <span class="hljs-built_in">sort</span>(city+<span class="hljs-number">1</span>, city+<span class="hljs-number">1</span>+n, cmp);<br><br>seqval[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 为了让下面的for比较顺</span><br><span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> mlen = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++ )&#123;<br>   <span class="hljs-keyword">if</span>( city[i].S &gt;= seqval[len] )<br>   seqval[++len] = city[i].S; <span class="hljs-comment">// 要么就用来延长seqval数组，给曲线右侧增加新的点 </span><br>   <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 贪心思想，压低（采用替换的方法）seqval数组曲线的上升速度，以方便后续能够延得更长！</span><br><span class="hljs-comment">// seqval[]是上升（&lt;）子序列，所以第四个参数应填less&lt;int&gt;()。和lower的默认参数吻合，故可不填 </span><br>        <span class="hljs-type">int</span> j = <span class="hljs-built_in">lower_bound</span>(seqval+<span class="hljs-number">1</span>, seqval+len+<span class="hljs-number">1</span>, city[i].S, <span class="hljs-built_in">less</span>&lt;<span class="hljs-type">int</span>&gt;() ) - seqval; <br>       seqval[j] = city[i].S;<br>   &#125;<br>&#125;  <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, len);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>　</p><h2 id="例9.4拦截导弹noip1999">2.5 1260【例9.4】拦截导弹(Noip1999)</h2><p>　　原题链接：</p><p>　　　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1260">1260：【例9.4】拦截导弹(Noip1999)</a>/<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1289">1289：拦截导弹</a></p><p>　　分析：</p><p>　　本题的第一个问并不难，就是普通的最长“不上升”子序列的问题，n&lt;=1000，用朴素算法可搞定。但本题的第二个问，有难度，需要用到1.3节所讲的Dilworth定理。本题的一个划分是“不上升”子序列，<strong>正链是“不上升”</strong>，所以其<strong>反链就是“上升”</strong>。进而，“拦截所有导弹最少要配备的系统数”=“最少的划分数”=“<strong>最长‘上升’子序列</strong>的长度值”。所以要搞定第二个问，就需要求出该原始序列的最长上升子序列的长度值即可。</p><p>　　（一）朴素算法，AC代码</p><p>　　本题不需要求子序列的所有元素的值，所以不需要定义ppre[]了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> M 1010</span><br><span class="hljs-type">int</span>  a[M], n;<br><span class="hljs-type">int</span> f_down[M], f_up[M];  <span class="hljs-comment">// 两个状态数组</span><br><span class="hljs-type">int</span> ans_down, ans_up;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; a[++n])<br>f_down[n] = f_up[n] = <span class="hljs-number">1</span>;<br><br>n--;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> cur = <span class="hljs-number">2</span>; cur &lt;= n; cur++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> pre = <span class="hljs-number">1</span>; pre &lt; cur; pre++)&#123;<br>            <span class="hljs-keyword">if</span>(a[cur] &lt;= a[pre])<br>f_down[cur] = <span class="hljs-built_in">max</span>(f_down[cur], f_down[pre]+<span class="hljs-number">1</span>);<br><br>            <span class="hljs-keyword">if</span>(a[cur] &gt; a[pre])<br>f_up[cur] = <span class="hljs-built_in">max</span>(f_up[cur], f_up[pre]+<span class="hljs-number">1</span>);<br>        &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        ans_down = <span class="hljs-built_in">max</span>(ans_down, f_down[i]);<br>        ans_up = <span class="hljs-built_in">max</span>(ans_up, f_up[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n%d&quot;</span>, ans_down, ans_up);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　（二）<spanclass="math inline">\(n*log_xn\)</span>算法，AC代码</p><p>　　算法和2.1.2节算法相似，但因本题不需要求子序列的所有元素的值，所以不需要定义maxlen[]和seqpos[]了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 最长不下降子序列的序列个数  =  最长的上升子序列的元素个数</span><br><span class="hljs-comment">// 该版本可以很好地训练学生对lower_bound和upper_bound的使用，应该练习和掌握！ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span>   <span class="hljs-comment">// greater_equal&lt;int&gt;() 需要 </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span><span class="hljs-comment">// lower_bound 函数需要 </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span>           <span class="hljs-comment">// memset需要</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x7f7f7f7f</span>;  <span class="hljs-comment">// int的无穷大</span><br><span class="hljs-type">int</span> data[maxn];<span class="hljs-comment">// 原始数组</span><br><span class="hljs-type">int</span> seqval[maxn];  <span class="hljs-comment">// &quot;seqval[5]=20&quot;表示&quot;子序列的第5个元素的值是20&quot;。</span><br><span class="hljs-type">int</span> N;<br><span class="hljs-comment">//返回最长不上升子序列的长度值   （ 子序列数据的关系：左 &gt;= 右  ）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Not_increase</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i, Len = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(seqval, INF, <span class="hljs-built_in">sizeof</span>(seqval));<br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=N; i++)&#123;<br>        <span class="hljs-keyword">if</span> ( data[i] &lt;= seqval[Len] )<br>seqval[++Len] = data[i];<br>        <span class="hljs-keyword">else</span>&#123;<br>             <span class="hljs-comment">// 因为seqval[]是“不上升”（&gt;=）序列，所以第四个参数应填greater_equal，</span><br>            <span class="hljs-comment">// 无论lower或upper都行，且第四个参数都必填</span><br>            <span class="hljs-type">int</span> idx = <span class="hljs-built_in">lower_bound</span>(seqval+<span class="hljs-number">1</span>, seqval+<span class="hljs-number">1</span>+Len, data[i], <span class="hljs-built_in">greater_equal</span>&lt;<span class="hljs-type">int</span>&gt;() ) - seqval;<br>            seqval[idx] = data[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Len;<br>&#125;<br><span class="hljs-comment">//返回最长上升子序列的长度值   （ 子序列数据的关系：左 &lt; 右  ）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i, Len = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(seqval, -INF, <span class="hljs-built_in">sizeof</span>(seqval));<br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=N; i++)&#123;<br>        <span class="hljs-keyword">if</span> ( data[i] &gt; seqval[Len] )<br>seqval[++Len] = data[i];<br>        <span class="hljs-keyword">else</span>&#123;<br>             <span class="hljs-comment">// 因为seqval[]是“上升”（&lt;）序列，，所以第四个参数应填less</span><br>            <span class="hljs-comment">// 但因其和lower函数的第四个参数的默认规则less相吻合，所以第四个参数可不填。</span><br>            <span class="hljs-type">int</span> idx = <span class="hljs-built_in">lower_bound</span>(seqval+<span class="hljs-number">1</span>, seqval+<span class="hljs-number">1</span>+Len, data[i]) - seqval;<br>            seqval[idx] = data[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Len;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>    N = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>( <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data[++N])  != EOF) <span class="hljs-comment">// 从data[1]开始存储原始数组</span><br>;<br>N--;<br><span class="hljs-type">int</span> len1 = <span class="hljs-built_in">Not_increase</span>();<br><span class="hljs-type">int</span> len2 = <span class="hljs-built_in">increase</span>();<br>    <span class="hljs-keyword">return</span> !<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n%d&quot;</span>, len1, len2);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p1020-noip1999-提高组-导弹拦截1260的数据加强版">2.6 P1020[NOIP1999 提高组] 导弹拦截（1260的数据加强版）</h2><p>　　原题链接：</p><p>　　<a href="https://www.luogu.com.cn/problem/P1020">P1020 [NOIP1999提高组] 导弹拦截</a></p><p>　　分析：</p><p>　　有50%的数据是达到了1e5的规模，所以必须要采用<spanclass="math inline">\(n*log_2n\)</span>的算法才行。这里可以直接采用2.5节中的第（二）种算法即可。此题不再专门展示代码了。</p><h1 id="三.-关于lower_bound和upper_bound函数的说明">三.关于lower_bound和upper_bound函数的说明</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 此处的cmp可以拓展为结构体的成员比较,以及&lt;, &lt;=, &gt;, &gt;= </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a&gt;=b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v=&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>&#125;;   <span class="hljs-comment">// 下标在[0..10] </span><br>    <span class="hljs-type">int</span> pos;<br>    <span class="hljs-comment">// 返回违背less(&lt;),即&gt;=5的第一个数6的下标8 </span><br>    pos = <span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">5</span>, <span class="hljs-built_in">less</span>&lt;<span class="hljs-type">int</span>&gt;()) - v.<span class="hljs-built_in">begin</span>(); <br>    cout &lt;&lt;pos &lt;&lt;endl; <br>    <span class="hljs-comment">// 返回违背less(&lt;),即&gt;=5的第一个数6的下标8 </span><br>    pos = <span class="hljs-built_in">upper_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">5</span>, <span class="hljs-built_in">less</span>&lt;<span class="hljs-type">int</span>&gt;()) - v.<span class="hljs-built_in">begin</span>(); <br>    cout &lt;&lt;pos &lt;&lt;endl; <br>    <span class="hljs-comment">// 返回违背less(&lt;),即&gt;4的第一个数6的下标8 </span><br>    pos = <span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">4</span>, <span class="hljs-built_in">less_equal</span>&lt;<span class="hljs-type">int</span>&gt;()) - v.<span class="hljs-built_in">begin</span>(); <br>    cout &lt;&lt;pos &lt;&lt;endl; <br>    <span class="hljs-comment">// 返回违背upper_bound的默认规则less_equal(&lt;=),即&gt;4的第一个数6的下标8 </span><br>    pos = <span class="hljs-built_in">upper_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">4</span>) - v.<span class="hljs-built_in">begin</span>(); <br>    cout &lt;&lt;pos &lt;&lt;endl; <br>    <span class="hljs-comment">// 返回违背less(&lt;),即&gt;=4的第一个数4的下标4 </span><br>    pos = <span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">4</span>, <span class="hljs-built_in">less</span>&lt;<span class="hljs-type">int</span>&gt;()) - v.<span class="hljs-built_in">begin</span>(); <br>    cout &lt;&lt;pos &lt;&lt;endl; <br>    <span class="hljs-comment">// less是递增序列中使用lower_bound的默认规则，故结果同上=4 </span><br>    pos = <span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">4</span>) - v.<span class="hljs-built_in">begin</span>(); <br>    cout &lt;&lt;pos &lt;&lt;endl; <br><span class="hljs-comment">//    // 在升序序列中对lower_bound使用greater或greater_equal，其结果是不准确的，禁用！ </span><br><span class="hljs-comment">//    pos = lower_bound(v.begin(), v.end(), 2, greater&lt;int&gt;()) - v.begin(); </span><br><span class="hljs-comment">//    cout &lt;&lt;pos &lt;&lt;endl; </span><br><span class="hljs-comment">//    // 在升序序列中对lower_bound使用greater或greater_equal，其结果是不准确的，禁用！ </span><br><span class="hljs-comment">//    pos = upper_bound(v.begin(), v.end(), 2, greater&lt;int&gt;()) - v.begin(); </span><br><span class="hljs-comment">//    cout &lt;&lt;pos &lt;&lt;endl; </span><br><br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), cmp);  <span class="hljs-comment">// 如果不排序的情况下去lower_bound,得到的是完全错误的答案 </span><br>    cout&lt;&lt;<span class="hljs-string">&quot;&gt;=，降序排列后：&quot;</span>; <br>    <span class="hljs-comment">//  v=&#123; 9, 7, 6, 4, 4, 4, 4, 3, 2, 2, 1 &#125;;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> val: v)<br>        cout &lt;&lt;val &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt;endl;<br>    <span class="hljs-comment">// 返回违背greater(&gt;),即&lt;=5的第一个数4的下标3 </span><br>    pos = <span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">5</span>, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;()) - v.<span class="hljs-built_in">begin</span>(); <br>    cout &lt;&lt;pos &lt;&lt;endl; <br>    <span class="hljs-comment">// 返回违背greater(&gt;),即&lt;=4的第一个数4的下标3 </span><br>    pos = <span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">4</span>, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;()) - v.<span class="hljs-built_in">begin</span>(); <br>    cout &lt;&lt;pos &lt;&lt;endl; <br>    <span class="hljs-comment">// 降序 + upper + greater(&gt;),返回&lt;4的第一个数3的下标7 ！！！！ </span><br>    pos = <span class="hljs-built_in">upper_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">4</span>, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;()) - v.<span class="hljs-built_in">begin</span>(); <br>    cout &lt;&lt;pos &lt;&lt;endl; <br>    <span class="hljs-comment">// 降序 + upper + greater_equal(&gt;=),返回&lt;=4的第一个数4的下标3 ！！！！ </span><br>    pos = <span class="hljs-built_in">upper_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">4</span>, <span class="hljs-built_in">greater_equal</span>&lt;<span class="hljs-type">int</span>&gt;()) - v.<span class="hljs-built_in">begin</span>(); <br>    cout &lt;&lt;pos &lt;&lt;endl; <br>    <span class="hljs-comment">// 返回违背greater_equal(&gt;=),即&lt;4的第一个数3的下标7 </span><br>    pos = <span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">4</span>, <span class="hljs-built_in">greater_equal</span>&lt;<span class="hljs-type">int</span>&gt;()) - v.<span class="hljs-built_in">begin</span>(); <br>    cout &lt;&lt;pos &lt;&lt;endl; <br>    <span class="hljs-comment">// 返回违背greater(&gt;),即&lt;=3的第一个数3的下标7 </span><br>    pos = <span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;()) - v.<span class="hljs-built_in">begin</span>(); <br>    cout &lt;&lt;pos &lt;&lt;endl; <br>    <span class="hljs-comment">//  在降序序列中对lower_bound函数使用less或less_equal规则，结果是不准确的！不是0就是11 </span><br>    <span class="hljs-comment">//pos = lower_bound(v.begin(), v.end(), 4, less_equal&lt;int&gt;()) - v.begin(); </span><br>    <span class="hljs-comment">// less是用lower_bound在任何顺序序列中的默认规则，但在降序序列中会不准！ </span><br>    <span class="hljs-comment">//pos = lower_bound(v.begin(), v.end(), 5) - v.begin(); </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>$$</p><p>$$</p>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 线性DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划入门</title>
      <link href="/2024/04/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/"/>
      <url>/2024/04/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="视频教学链接">1.1 视频教学链接</h2><p><ahref="https://www.bilibili.com/video/BV1Rk4y1173p/">数字三角形</a></p><h2 id="动态规划的基本概念和步骤">1.2 动态规划的基本概念和步骤</h2><p>本帖不光是讲线性DP，同时也为所有各种DP的学习奠定理论基础和学习方法。</p><h3 id="什么是动态规划">1.2.1 什么是动态规划</h3><p>动态规划（英语：Dynamic programming，简称DP）的算法本质实际上就是递推，以递推的方式对某1个或者多个状态数组进行依序填值，并根据其填写结果中的某1个或者某个区域内的值来返回问题答案。所以在动态规划中，一定是存在递推方程的。</p><h3 id="什么情况下能使用动态规划">1.2.2 什么情况下能使用动态规划</h3><p>动态规划（Dynamic Programming）需要有2个重要的前提：</p><ol type="1"><li><p><strong>局部最优化原理</strong>：</p><p>　　模型的求解过程能够被分成多个阶段；局部最优解不受后续其他阶段各种信息的影响。<strong>局部最优解一定是全局最优解的子集。</strong>所有局部最优解将会促成全局最优解。</p><p>　　下面分别举正反两个例子来加以说明：</p><p>1）<strong>正例</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240509152610044.png" style="zoom: 40%;" /></p><p>　　如上图所示，全局问题为“求从A点到E点的最短路径”。B为其最短路径上的某一个点，局部子问题为“求从A点到B点的最短路径”，其局部最优解路径可以标注为<spanclass="math inline">\(\overrightarrow {AB}\)</span>。根据局部最优化原理，<spanclass="math inline">\(\overrightarrow {AB}\)</span>一定是全局最优解<span class="math inline">\(\overrightarrow{A E}\)</span>的子集。</p><p>　　如何证明这一点呢？用反证法。</p><p>　　假设现在存在从A到B的另一条路径<spanclass="math inline">\(\overset{\frown}{AB}\)</span>，该路径的长度比<span class="math inline">\(\overrightarrow{A B}\)</span>更短，即有<span class="math inline">\(\overset{\frown}{AB} &lt; \overrightarrow {A B}\)</span>，那么不等式两边同时加上<spanclass="math inline">\(\overrightarrow {B E}\)</span>，得到:<spanclass="math inline">\(\overset{\frown} {AB} +\overrightarrow {B E} &lt;\overrightarrow {A B}+ \overrightarrow {B E}=\overrightarrow {AE}\)</span>。这样就和“<span class="math inline">\(\overset{\frown}{AE}\)</span>是从A点到E点的最短路径”产生矛盾，因为找到了一条不同的更短路径。故原假设不成立，而<spanclass="math inline">\(\overrightarrow {AB}\)</span>一定是全局最优解<span class="math inline">\(\overrightarrow{A E}\)</span>的子集。</p><p>2)<strong>反例</strong>：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240509160154842.png"alt="image-20240509160154842" /><figcaption aria-hidden="true">image-20240509160154842</figcaption></figure><p>　　图中有四个点，A、B、C、D，相邻两点有两条连线，代表两条通道，d1,d2, d3, d4, d5,d6代表的是道路的长度，求A到D的所有通道中，总长度除以4得到的余数最小的路径为最优路径，求一条最优路径。</p><p>　　这里如果还是按照上面的思路去求解，就会误入歧途了。按照之前的思路，<spanclass="math inline">\(\overset{\frown}{AD}\)</span>的最优路径应该包含了<spanclass="math inline">\(\overset{\frown} {BD}\)</span>的最优路径，而<spanclass="math inline">\(\overset{\frown}{BD}\)</span>的最优路径决策为（3+5）mod 4 =0，即应该选d2和d6这两条道路。而实际上，全局最优解是d4+d5+d6或者d1+d5+d3。所以<strong>这里局部最优解并不是全局最优解的子集，即不满足最优化原理。所以就不适合使用动态规划来求解了</strong>。</p></li><li><p><strong>无后效性原理</strong>：</p><p>　　前i个阶段的所有决策及操作，对后续阶段的决策及操作，不构成任何的干扰或影响。换句话说，未来与过去无关，当前状态是此前历史状态的完整总结，此前历史决策只能通过影响当前的状态来影响未来的演变。</p><p>　　下面分别举正反两个例子来加以说明：</p><p>1）正例</p><p>　　我们可以仍然看这张图。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240509152610044.png" style="zoom: 40%;" /></p><p>　　如果规定“行走路线只能在AB这个小矩形范围内，不能越界”，那么不管从A到B点的路线如何行走，都不会影响到从B点到E点的路线选择。这就满足了“无后效性”。从A到B的所有选择，都最终反映在从A到B的路径长度这个数值上，其路径决策不会对后续的从B到E的决策产生任何影响。</p><p>2）反例</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240509162006688.png" style="zoom: 50%;" /></p><p>　　如果在原来的基础上加上一个限制条件：“同一个格子只能通过一次”，且允许超过AB的矩形范围。那么，这个题就不符合无后效性了，因为前一个子问题的解会对后面子问题的选择策略有影响，比如说，如果从A到B选择了一条如上图中绿色表示的路线，那么从B点出发到达E点的路线就只有一条了。也就是说从A点到B点的路径选择会影响B点到E点的路径选择。</p></li></ol><p>　　综上1、2两点，如果满足这两个条件，才能考虑用dp法来做。否则是不能用动态规划来做的。</p><p>　　关于这两个原理，空说太抽象，会在本帖的后续案例中进一步来具体说明。</p><h3 id="具体步骤">1.2.3 具体步骤</h3><p>因为动态规划具有较强的模板性，所以强烈建议同学们在学习dp这个板块时，能够有较为固定的命名规则。每个题，因为出题人对所有变量的命名较为随意，甚至是混乱的，如果按照题目中的命名来写代码，日后复习时会引起很多混乱（例如有些题目把总行数命名为n，总列数命名为m，而另外有些题是把总行数命名为m，总列数命名为n），这些混乱会导致很多小朋友调试很久都找不到错误。</p><p>所以，建议在命名时不要理会题目内的命名，按照自己的命名规则来写代码即可，这样以后在看代码时能够快速看懂。<strong><font color="red">在本站中，总个数为n或者N或者maxn，总行数R或者Row（英文中的“行”），总列数C或者Col（column，英文中的“列”），for循环中的当前行r，当前列c，状态数组名称dp[]或者dp[][]，原始数据数组data[]或者data[][]，当前值cur，上一个值pre，下一个值nxt，总和sum，个数cnt或count</font></strong>。</p><p>一共分为5个步骤，下面分小节具体阐述。<strong>初学动态规划的同学，严重推荐在每个题的代码前面用块注释的方式写清楚5个步骤的具体内容，提前做好分析。很多同学不愿意打一点点注释，这个习惯可不太好哟！～</strong></p><h4 id="阶段划分确定状态数组的精准-含义">1.2.3.1阶段划分，确定状态数组的<font color="red" ><strong>精准</strong></font>含义</h4><p>首先应该根据问题的描述，首先应确定每个状态由几个维度来共同决定？每个维度分别是什么含义？给定i或者给定i和j之后，dp[i]或者dp[i][j]究竟代表什么含义？（此处含义务必精准描述）</p><p>常用的一些含义如下，供抛砖引玉地参考：</p><p>1）dp[i]：序列前i个数的XXXXXX的值；</p><p>2）dp[i]：序列前i个数中，以第i个数结尾的字序列的XXXXXX的值；</p><p>3）dp[i]：在成本不超过i个单位的前提下的最优成本值；</p><p>4）dp[i][j]：从出发点走到第i行第j列时所经历的XXXXX的值；</p><p>5）dp[i][j]：从第i个到第j个数之间的XXXXX的值；</p><p>6）dp[i][j]：前i个数对k取余后余数是否为j；</p><p>同学们在定义好状态数组后，不妨可以自己写一个“dp[3]=5;”或者“dp[3][4]=5;”或者“dp[3][5]=true;”，然后自己尝试着去解释这句代码的精确含义。在解释的过程中，注意自己的语文描述，不要模棱两可、含混不清。</p><p>大多数情况下，“确定状态数组”这一步都没什么难度，但也会偶尔遇到有难度的情况，后面会有相关题来说明。</p><h4 id="所求目标">1.2.3.2 所求目标</h4><p>在dp数组的含义确定后，我们就能确定出所求目标了。所求目标基本上就是下面几种类型：</p><ol type="1"><li>dp[N]——一维数组，特定位置</li><li>max(dp[1..N]) （或者min）——一维数组，全范围求最值</li><li>dp[Row][Col]——二维数组，特定位置</li><li>max(dp[Row][1..Col]) （或者min）——二维数组，最末行求最值</li><li>max(dp[Row..Row+a][Col..Col+b])（或者min）——二维数组，特定的下标范围内求最值</li><li>min(dp[1..N]) (dp[i]&gt;=K)——一维数组，特定的值范围求最值</li></ol><h4 id="确定状态转移方程">1.2.3.3 确定状态转移方程</h4><p>如果直接讨论“状态转移”，听起来挺抽象的。我们这里就用最简单通俗的方式吧。那就是“如何填数组”？填数组，一定是“根据已知的值来填未知位置上的值”。对于一个普通位置上的值，它一定是来自于数组其他位置上的值，经过某种运算而得来。状态转移方程，就是递推方程或者递归方程。</p><p>在拟定状态转移方程时，我们重点会去研究当前位置的值，来自于哪些其他位置的值？一般来说，常用的主要有如下几个方向：</p><p>1）一维数组，dp[i]根据左侧的值，例如dp[i-1]或dp[i-2]、dp[i-3]等值来填</p><p>2）一维数组，dp[i]根据右侧的值，例如dp[i+1]或dp[i+2]、dp[i+3]等值来填</p><p>3）二维数组，dp[i][j]根据其左/右侧、上/下侧或者组合的值来填</p><p>因为我们一定是根据已知来填写未知，所以在上述三种情况中，不可能出现“当前位置的值依赖于左侧及右侧的值（例如dp[i]=dp[i-1]+dp[i+1]这种状态转移方程，这种是无法下手填的）”，也不可能出现“当前位置的值依赖于左上侧及右下侧的值”，总之，在填写当前位置之前，它所依赖的值一定是已知、已填的。</p><h4 id="循环顺序和边界">1.2.3.4 循环顺序和边界</h4><p>根据上一小节的分析，我们必须要根据已知来填写未知，所以这其实就决定了我们在写一重for或者二重for循环时的循环顺序。能不能先列后行？在处理行的时候，只能从上往下吗？能不能从下往上也可以？在处理列的时候，能不能从右往左呢？这些问题都需要我们想清楚，然后做出选择。</p><p>例如：<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=2043">杨辉三角</a>的标准状态转移方程是dp[i][j]=dp[i-1][j-1]+dp[i-1][j]，我们都知道填写数组时需要从上往下，从左往右填写。那请问：</p><ol type="1"><li>能否“从上往下，从右往左”呢？——能，为什么？</li><li>能否“从下往上，从左往右”呢？——不能，为什么？</li></ol><p>需要注意的是，上例的滚动状态转移方程是dp[j]=dp[j-1]+dp[j]，此时填写数组要求只能从右往左填写，不能从左往右填写。请问为什么呢？</p><p>这里涉及到一个时间差的问题。赋值号左侧是新值，右侧是旧值，所以有dp[j]（新）=dp[j-1]（旧）+dp[j]（旧）。然后我们可以看到，当产生dp[j]（新）后，dp[j-1]（旧）此刻是依旧存在的。而dp[j]肯定在dp[j-1]的右侧，所以说，右侧的数据先更新，即需要从右往左更新dp[]。</p><p>我们在处理滚动数组时，尤其需要注意循环顺序的处理。顺序不同，含义不同，结果也会很不相同。比较常见的情况如背包问题中，采用滚动数组时，从右往左更新是01背包，从左往右更新是重复背包。</p><p>关于循环边界的问题，涉及到需要填写dp数组的哪些部分。绝大多数情况下，我们调用一次转移方程就填好一个元素的值，程序循环到dp[R][C]或者dp[N]之类的就结束。但有时候也有可能会需要多调用一些次数，多计算一些扩展区域，并从中筛选。这涉及到“所求目标”的问题。可以以“<strong><ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1271">1271：【例9.15】潜水员</a></strong>”为例学习（要求学生已掌握到多重背包为佳）。</p><h4 id="确定转移方程的特例">1.2.3.5 确定转移方程的特例</h4><p>上一节我们反复强调，转移方程是“根据已知填写未知”，那整个状态转移方程中，哪个位置的值从一开始就是已知的呢？这些位置上的值，一定不是根据转移方程而得来的。我们都知道“女娲造人”的传说，那女娲是怎么来的呢？我们知道非波拉契数列的转移方程是f[i]=f[i-1]+f[i-2]，而“f[1]=1、f[2]=1”就是非波拉契数列的转移方程的“2个特例”。</p><p>特例的个数和位置，取决于状态转移方程中的公式内容。假设dp数组的有效数据的下标范围是[1..n]或者[1..R][1..C]。以几个例子来说明：</p><ol type="1"><li>dp[i]=5*dp[i-2]：i-2是数组的下标，它必然只能在规定的范围内，即i-2&gt;=1，所以该公式只能在i&gt;=3的情况下有效。所以i=1和i=2属于特例，需要单独解决。</li><li>dp[i][j]=dp[i-2][j] + dp[i][j-1];：公式里出现了i-2和j-1，是数组下标，所以该公式只能在i-2&gt;=1（要满足有效数据的行下标范围，故i&gt;=3）且j-1&gt;=1（即j&gt;=2）的情况下有效。所以i=1、i=2、j=1都属于特例，也就是说，这个二维数组的第1、2行全体数据和第1列的全体数据，需要单独解决。</li></ol><p>对于这些特例，该取什么值呢？如果题上已经明说了其取值，直接填入即可。如果题上没有明说，就需要同学们结合dp数组的基本含义，自己去推算。</p><p>例如：在“摘花生”一题中，假设dp[i][j]表示从（1，1）这个位置走到第i行第j列位置的不同走法数，那么dp[1][j]（即第一行所有元素）该如何填特例值呢？很明显，从（1，1）走到（1，j）位置只能有一种走法，那就是“一直向右”这种走法。</p><h4 id="状态数组普通位置上的初值">1.2.3.6 状态数组普通位置上的初值</h4><p>dp数组的特例该如何处理，我们在上一节刚讲过。对于普通位置上的初值，该如何处理呢？</p><p>在定义dp数组时，建议定义为全局变量（默认初始化为全0），这样方便后续多个函数共同使用。如果需要反复多次进行dp，则需要在每次dp之前先对状态数组清零，建议使用多重for循环来清零，避免使用memset函数。因为如果你的dp数组长度达到1e6，但实际数据如果只使用了1e4，那么多重for循环赋值会判定程序的空间使用量为1e4，而memset会判定使用量是1e6，且实测其运行效率不比memset差。</p><p>需要提醒注意的是，全局数组初始化为全0，这虽然对绝大多数题都有效，<strong>但对少部分题目是不行的</strong>。当dp数组代表个数、条数、总和、价值、最大值等情况时，极大概率其结果是非负的，所以用0作为初值没任何问题。但如果dp[]代表的是“最小值”（例如图的“最短路径”问题，或者求“装满或恰好装满背包时的最小价值”），则应将其初值设为一个极大值，以方便后续在书写转移方程时进行迭代更新。关于“极大值”该如何选择和表示，请参看本站的相关专题。此处不再详述。</p><p>普通位置和特例是互不冲突的两件事情，不要混在了一起，更不要覆盖了特例位置。</p><h1 id="二.-实战训练">二. 实战训练</h1><p>希望能够尽量按照第一节所述的六点要求去分析，尽可能多写清楚注释文字。虽然这两个题之前同学们可能已经做过，但当时是否考虑周全了？</p><h2 id="数字金字塔">2.1 数字金字塔</h2><p>　　原题链接：<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1258">1258：【例9.2】数字金字塔</a>/<ahref="https://www.luogu.com.cn/problem/P1216">P1216 [USACO1.5][IOI1994]数字三角形 Number Triangles</a></p><p>　　分析：</p><p>　　固定动作：数组下标从1开始，尽量不要从0开始，免得后续很多麻烦。行列用r和c表示，不要用x和y来表示！！</p><p>　　先看看本题是否满足动态规划的两个基本前提？</p><p>　　<strong>局部最优化原理</strong>——模型的求解过程能够被分成多个阶段；<strong>第i个阶段的决策方案</strong>，是该问题前i个阶段范围内的最优解，<strong>它不受后续其他阶段各种信息的影响</strong>。本题从上往下求解，每一层是一个阶段。从塔顶走到第５层的每个数，其决策方案不受下面第６、７、８等层数值变化的影响。满足“局部最优化原理”。</p><p>　　<strong>无后效性原理</strong>——<strong>前i个阶段的所有决策及操作，对后续阶段的决策及操作，不构成任何的干扰或影响</strong>。假设第６层第１列的节点与第５层第１列和第２列的两个点相连，则在求解dp[6][1]时，不需要去关心dp[5][1]和dp[5][2]选择了路上的哪些点，只要这两个dp值分别都肯定是最大值就能去往第６层推算了。满足“无后效性原理”。</p><p>　　综上两点，本题可以用“动态规划”来解决。下面开始６点分析。</p><p>　　1).状态数组：dp[r][c]：从data[1][1]走到data[r][c]所经历的不同路径上数据之和的最大值</p><p>　　2).所求目标：max(dp[R][1..C])（R为最下一行）</p><p>　　3).状态转换方程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">dp[r][c] = <span class="hljs-built_in">max</span>( data[r][c] + dp[r<span class="hljs-number">-1</span>][c<span class="hljs-number">-1</span>],   data[r][c] + dp[r<span class="hljs-number">-1</span>][c] ) <br></code></pre></td></tr></table></figure><p>　　或者为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">dp[r][c] = data[r][c] + <span class="hljs-built_in">max</span>( dp[r<span class="hljs-number">-1</span>][c<span class="hljs-number">-1</span>],  dp[r<span class="hljs-number">-1</span>][c] ) <br></code></pre></td></tr></table></figure><p>　　4).循环边界和循环顺序</p><p>　　　r: [2..R] 2 --&gt; R 增序</p><p>​ 　　c: [2..r] 2 &lt;--&gt; r 增减均可</p><p>　　5).状态初始化值</p><p>　　因为data[][]都在[0,100]内，dp[][]是最大值，max(dp[R][])也要计算最大值，dp[][]不可能为负数。所以dp[][] 初始化为 0即可（为了和下面第6点中的特例兼容）。如果data[][]的值范围允许为负数，则dp[][]应初始化为极小值。</p><p>　　6).特例</p><p>　　根据状态转移方程中出现的r-1和c-1，可以知道r=1和c=1(即第1行和第1列的全体dp数据)需要单独处理。因为第一行只有dp[1][1]这一个数据，所以整理下来只有dp[1..R][1]需要单独处理，值为data[1..R][1]。碰巧的是，因为dp[0][]和dp[][0]的初值是0，所以碰巧和状态转移方程吻合。所以，本题直接从1行或1列开始即可。不需要单独处理特例了。</p><p>　　AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">方法1： 二维标准状态数组</span><br><span class="hljs-comment">这个题，是比较典型的动态规划的案例。1258和P1216是同一个题 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1001</span><br><span class="hljs-comment">// 注意取名习惯，建议尽量固定化 </span><br><span class="hljs-type">int</span> data[N][N];  <span class="hljs-comment">// 原始数据， 全局，默认均为 0 </span><br><span class="hljs-type">int</span> dp[N][N];    <span class="hljs-comment">// 状态数组， 全局，默认均为 0 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> r, c, R, mmax=<span class="hljs-number">0</span>;<br>cin &gt;&gt;R;<br><span class="hljs-keyword">for</span> (r=<span class="hljs-number">1</span>; r&lt;=R; r++)<br><span class="hljs-keyword">for</span> (c=<span class="hljs-number">1</span>; c&lt;=r; c++)<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data[r][c]);<br>    <br><span class="hljs-keyword">for</span> (r=<span class="hljs-number">1</span>; r&lt;=R; r++)<br><span class="hljs-keyword">for</span> (c=<span class="hljs-number">1</span>; c&lt;=r; c++)   <span class="hljs-comment">// 增减均可 </span><br>dp[r][c] = <span class="hljs-built_in">max</span>(data[r][c] + dp[r<span class="hljs-number">-1</span>][c<span class="hljs-number">-1</span>], data[r][c] + dp[r<span class="hljs-number">-1</span>][c]); <br><span class="hljs-comment">//if (dp[r-1][c-1] &gt; dp[r-1][c])   // 这样写也可以，看似繁琐，但更具有可扩充性，如可记录路径</span><br><span class="hljs-comment">//dp[r][c] = data[r][c] + dp[r-1][c-1];    // 选择左上方数据</span><br><span class="hljs-comment">//else</span><br><span class="hljs-comment">//dp[r][c] = data[r][c] + dp[r-1][c];     // 选择正上方数据</span><br><br><span class="hljs-comment">// 因为data[][] &gt;= 0，所以dp数组是递增的，</span><br><span class="hljs-comment">// 要找所有路径中最大的路径和，应找最底层第R行的状态值来找最大值就行了</span><br><span class="hljs-comment">// 如果data数组的值允许为负数呢？那就需要在上面的2重循环中去及时比对和刷新mmax了 </span><br><span class="hljs-keyword">for</span> (c=<span class="hljs-number">1</span>; c&lt;=R; c++)    <span class="hljs-comment">// 末行每列</span><br>mmax = <span class="hljs-built_in">max</span>(mmax, dp[R][c]);<br>cout &lt;&lt;mmax;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p>　　注意，上面的代码是标准状态数组的解法。在学完滚动数组之后，同学们可自行思考本题的滚动数组解法。</p><p>　　另外，<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1284">1284</a>这个题和本题很相似，也可以一并刷过。</p><h2 id="移动路线">2.2 移动路线</h2><p>　　原题链接：<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1194">1194：移动路线</a></p><p>　　分析：</p><p>　　老规矩，所有数组的下标从1开始编号。行列用r和c表示，不要用x和y来表示！！</p><p>　　先看看本题是否满足动态规划的两个基本前提？</p><p>　　<strong>局部最优化原理</strong>——模型的求解过程能够被分成多个阶段；<strong>第i个阶段的决策方案</strong>，是该问题前i个阶段范围内的最优解，<strong>它不受后续其他阶段各种信息的影响</strong>。本题从左上往右下求解，每一行是一个阶段。从（０，０）走到（３，４）的每个格子，他们的决策方案不受后续的（３，５）、（５，８）、（６，２）等格子上数值变化的影响（因为只能往右走或者往下走）。满足“局部最优化原理”。</p><p>　　<strong>无后效性原理</strong>——<strong>前i个阶段的所有决策及操作，对后续阶段的决策及操作，不构成任何的干扰或影响</strong>。在求解dp[3][5]时，不需要去关心dp[3][4]和dp[2][5]的路径条数是如何统计出来的，也不需要去关心路径具体怎么走，这些路径的选择和计算过程对后续其他点的推算结果无任何影响，只要条数值无误就行，就可以拿着这两个值去推dp[3][5]的值。满足“无后效性原理”。</p><p>　　综上两点，本题可以用“动态规划”来解决。下面开始６点分析。</p><p>　　1. 状态数组：dp[r][c]：从(1,1)A点走到坐标为(r,c)的点的路径的条数</p><p>　　2. 所求目标：dp[R][C]:从(1,1)A点走到坐标为(R,C)的点的路径的条数</p><p>　　3. 状态转换方程：</p><pre><code> &lt;img src=&quot;https://cspcoding.gitee.io/pic/img/image-20240423131732427.png&quot; style=&quot;zoom:67%;&quot; /&gt; 　　从上图中可以看出，从点O走到点X的路线，只能经过A点或者B点。 　　所以，根据组合数学的乘法原理和加法原理可得： O-&gt;X的路线总数 = O-&gt;A的路线总数 * A-&gt;X的路线总数 **+** O-&gt;B的路线总数 * B-&gt;X的路线总数 　　而“A-&gt;X的路线总数”和“B-&gt;X的路线总数”都只有唯一的1种走法（就是“直接一步走过去”这一种走法）， 　　所以： 　　　　　O-&gt;X的路线总数 = O-&gt;A的路线总数 * 1 + O-&gt;B的路线总数 * 1 　　　　　　　　　　　　　= O-&gt;A的路线总数 + O-&gt;B的路线总数 　　　　　　即：dp\[r][c]= dp\[r-1][c] + dp\[r][c-1]                  　　　　　　　　　　　　　　　　　　　　　　　　(1&lt;=r&lt;=R, 1&lt;=c&lt;=C ,从左往右，从上往下遍历)</code></pre><ol start="4" type="1"><li><p>循环边界和循环顺序</p><p>r: [2..R] 2 --&gt; R 增序</p><p>c: [2..C] 2 --&gt; C 增序（不能降序）</p></li><li><p>状态初始化值</p><p>　　状态转移方程是赋值形式，可不给初值而直接覆盖即可。但为了和第6点的特例尽量兼容，此处初始化为0，寓意“从（1，1）到当前点的路径条数为0条”。</p></li><li><p>特例</p><p>　　因为状态转移方程中出现了r-1和c-1，所以dp数组的第1行和第1列需要单独处理。根据dp数组的基本含义可知，从左上角走到第一行的每个点只有一条路，走到第一列的每个点也只有一条路，故而dp[1][]和dp[][1]均为1。</p><p>　　实际上此处只需要将dp[1][1]设置为1，其他全设置为0即可，经过转移方程推算之后，正好是全1。</p><p>　　AC代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> F[<span class="hljs-number">21</span>][<span class="hljs-number">21</span>]; <span class="hljs-comment">// 坐标点是(1, 1)，0行和0列元素全部弃用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> m, n, i, j;<br><span class="hljs-comment">// 1. 先处理状态数组F的一些边界情况，为后面的二重循环填表做数据上的准备工作</span><br><span class="hljs-comment">// 坐标轴上的点只能有1种走法</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;<span class="hljs-number">21</span>; i++)  <span class="hljs-comment">// 纵向坐标轴</span><br>F[i][<span class="hljs-number">1</span>]= <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;<span class="hljs-number">21</span>; i++)  <span class="hljs-comment">// 横向坐标轴</span><br>F[<span class="hljs-number">1</span>][i]= <span class="hljs-number">1</span>; <br><span class="hljs-comment">// 2. 然后才开始递推</span><br><span class="hljs-comment">// 从出发点走到当前点的走法数 = 来自于下面点的走法个数 +  来自于左边点的走法个数</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>; i&lt;<span class="hljs-number">21</span>; i++)<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">2</span>; j&lt;<span class="hljs-number">21</span>; j++)<br>F[i][j]= F[i<span class="hljs-number">-1</span>][j] + F[i][j<span class="hljs-number">-1</span>];  <br><span class="hljs-comment">// 接纳输入</span><br>cin &gt;&gt; m &gt;&gt;n;<br>cout &lt;&lt;F[m][n] &lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p></li></ol><h2 id="过河卒">2.3 过河卒</h2><p>　　原题链接：<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1314">1314：【例3.6】过河卒(Noip2002)</a>/<ahref="https://www.luogu.com.cn/problem/P1002">P1002 [NOIP2002 普及组]过河卒</a></p><p>　　分析：</p><p>　　本题是在上一小节的基础上，略微增加了一点东西。</p><p>　　１）本题根据题意，下标都从０开始编号。</p><p>　　２）程序在对dp[][]的第０行或第０列进行特例处理之后，需要再对棋盘中可能出现的８个鞍点及１个马点（合计一共９个点）进行预先单独处理（这９个点的位置不可达，其对应的路线条数为０）。</p><p>　　３）如果这９个点有任何一个点如果落在第０行或者第０列的位置上，则其之下或者之右的所有点的dp值从１改为０。</p><p>　　４）我们需要把普通位置（第１行及以下、第１列及以右的除了这９个点之外的其他位置）和这９个点位置进行区别，９点不可执行转移方程，而普通位置应执行方程。为了方便区分，我们可以预先把普通位置的dp[][]值设置为－１，９点位置的dp[][]值设置为０，以示区分。</p><p>　　需要注意的是，在做递推之前的各项准备工作，不要出现前后覆盖。应先初始化第０行和第０列为全１，其他位置为－１；然后计算９个点的位置，给对应位置标记为０；最后核查第０行和第０列的每个点，一旦出现有值为０，其下或其右的所有值均应改为０。</p><p>　　本题AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 21 </span><br><span class="hljs-comment">// 从出发点A到B点坐标的路径条数 </span><br><span class="hljs-comment">// 有可能数字很大，所以需要long long才行哦！～不然会错2个案例</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[N][N];<br><span class="hljs-comment">// 坐标调整数组，方向从0到7 </span><br><span class="hljs-type">int</span> dr[<span class="hljs-number">8</span>] = &#123; <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">2</span>,  <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span> &#125;;<br><span class="hljs-type">int</span> dc[<span class="hljs-number">8</span>] = &#123; <span class="hljs-number">2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>,  <span class="hljs-number">2</span>, <span class="hljs-number">-2</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">-1</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> R,C, hR,hC, nr,nc;<br>    cin &gt;&gt;R &gt;&gt;C &gt;&gt;hR &gt;&gt;hC;<br>    <span class="hljs-comment">// 特例区赋值，从(0,0)到第0行的所有其他点的走法只有1种，第0行元素全部先设置为1 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=C;k++)<br>    dp[<span class="hljs-number">0</span>][k] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 特例区赋值，从(0,0)到第0列的所有其他点的走法也只有1种，第0列元素全部先设置为1 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=R;k++)<br>    dp[k][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br> <br><span class="hljs-comment">// 把普通区的dp[][]设置为-1，以方便区别0（不可达的点） </span><br><span class="hljs-comment">//    memset(dp, -1, sizeof(dp));   // 最好不用memset，其效率和二重for其实差不多，但易多占内存 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r=<span class="hljs-number">1</span>;r&lt;=R;r++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;c&lt;=C;c++)<br>            dp[r][c]= <span class="hljs-number">-1</span>;<br>            <br>    dp[hR][hC]=<span class="hljs-number">0</span>;   <span class="hljs-comment">// C点不可达，dp值设置为0 </span><br>  <span class="hljs-comment">// 把最多8个方向的点设置为不可达 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r=<span class="hljs-number">0</span>;r&lt;<span class="hljs-number">8</span>;r++)<br>    &#123;<br>        nr = hR + dr[r];<br>        nc = hC + dc[r];<br>        <span class="hljs-keyword">if</span>( nr&gt;=<span class="hljs-number">0</span> &amp;&amp; nr&lt;=R &amp;&amp; nc&gt;=<span class="hljs-number">0</span> &amp;&amp; nc&lt;=C )<br>            dp[nr][nc]=<span class="hljs-number">0</span>;    <span class="hljs-comment">// 多个控制点不可达，dp值设为0 </span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 第0行如果有控制点，在其右边所有的点都不可达，其dp值都是0 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=C;k++)<br>        <span class="hljs-keyword">if</span>(dp[<span class="hljs-number">0</span>][k]==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b=k+<span class="hljs-number">1</span>;b&lt;=C;b++)<br>                dp[<span class="hljs-number">0</span>][b]=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    <span class="hljs-comment">// 第0列如果有控制点，在其下面所有的点都不可达，其dp值都是0 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=R; k++)<br>        <span class="hljs-keyword">if</span> ( dp[k][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> )<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b=k+<span class="hljs-number">1</span>; b&lt;=R; b++)<br>                dp[b][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    <br><span class="hljs-comment">// 普通区开始填表，从(1,1)填到(R,C)。   </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r=<span class="hljs-number">1</span>;r&lt;=R;r++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;c&lt;=C;c++)<br>        <span class="hljs-comment">// 只填dp值为-1的元素（dp值为0的点表示控制点，不能对其进行计算）  </span><br><span class="hljs-keyword">if</span> (dp[r][c]== <span class="hljs-number">-1</span> )<br>dp[r][c]=dp[r][c<span class="hljs-number">-1</span>]+dp[r<span class="hljs-number">-1</span>][c];<br><br>    cout&lt;&lt;dp[R][C];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">8 6 0 4</span><br><span class="hljs-comment">1617</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 线性DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记忆化搜索</title>
      <link href="/2024/04/02/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
      <url>/2024/04/02/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="视频教学链接">1.1 视频教学链接</h2><p><ahref="https://www.bilibili.com/video/BV16V411U7Gc">记忆化搜索</a></p><h2 id="相关概念">1.2 相关概念</h2><h3 id="基本思想">1.2.1 基本思想</h3><p><strong>记忆化搜索</strong>是一种编程技巧，其主要思想是当需要用递归函数<spanclass="math inline">\(f(x)\)</span>（或者深搜函数）来计算或填写某个数组<spanclass="math inline">\(a[1..n]\)</span>（假设状态是一维的。多维是类似的道理）内每个元素值时，为了避免过多地重复调用<spanclass="math inline">\(f(i)\)</span>，而在首次调用完<spanclass="math inline">\(f(i)\)</span>后，用<spanclass="math inline">\(a[i]\)</span>记录下其对应值，当以后再次如果再次调用<spanclass="math inline">\(f(i)\)</span>时，如果发现<spanclass="math inline">\(a[i]\)</span>已经有值，则直接使用而不再做递归调用，从而提高效率。</p><p>记忆化dfs的核心是在朴素dfs的基础上新增了一个记录递归中间状态和数据的容器（数组a[]），当再次递归到相同的状态时，直接使用容器的缓存结果a[i]即可，从而实现剪枝的效果，这也是一种空间换时间的策略。</p><h3 id="什么时候适用">1.2.2 什么时候适用</h3><p>如果在求解一个问题时需要求解很多重复（完全相同）的子问题，则可以使用。但如果没有很多重复的子问题，换句话说，递归展开图只是一棵单分支树，就没必要用记忆化搜索了。</p><p>例如：</p><ol type="1"><li><spanclass="math inline">\(f(n)=f(n-1)+f(n-2)\)</span>，函数调用关系图画出来是一棵矮胖型的二叉树，内含大量的重复子问题，可以用。</li><li><spanclass="math inline">\(f(n)=f(n-1)*n\)</span>，函数调用关系图画出来是一棵单分支树，没有重复子问题，没必要用记忆化dfs。</li><li><spanclass="math inline">\(f(i,j)=f(i-1,j)+f(i,j-1)\)</span>，函数调用关系图画出来是一棵矮胖型二叉树，内含大量的重复子问题，可以用。</li></ol><h3 id="复杂度分析">1.2.3 复杂度分析</h3><p>1)时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>　　根据其基本思想，每次调用完一个<spanclass="math inline">\(f(i)\)</span>之后就会填写好一个<spanclass="math inline">\(a[i]\)</span>，且该节点不会再被调用而是直接取<spanclass="math inline">\(a[i]\)</span>来返回即可，所以记忆化搜索的时间复杂度不再是恐怖的<spanclass="math inline">\(2^n\)</span>或者<spanclass="math inline">\(3^n\)</span>，而变成线性阶。其反复地调用函数和返回函数有一定的开销（保存现场、恢复现场等），但总体时间复杂度变成了<spanclass="math inline">\(O(n)\)</span>，高度接近一维递推的复杂度。</p><p>2）空间复杂度：<span class="math inline">\(O(n)\)</span></p><p>　　记忆化搜索必须要定义一个数组，用来记录对每个状态情况下对应的值。对于只有一个状态参数的递归来说，数组是一维的；对于有两个状态参数的递归来说，数组是二维的，空间复杂度为<spanclass="math inline">\(O(R*C)\)</span>。</p><p>　　不能忽视的一点是，当产生大量（虽然没有<spanclass="math inline">\(2^n\)</span>这么多，但即使是线性阶，当n上万时也要当心）递归调用时，因为每次递归调用在还没有返回之前，都会占用着系统栈区的部分空间。当层层递归到足够深处时，可能会引起系统栈区被大量的“保存现场”操作给撑满，从而引起爆栈，程序直接崩溃。</p><h3 id="记忆化搜索和深搜递归的关系">1.2.4记忆化搜索和深搜/递归的关系</h3><p>　　记忆化搜索只适用于能够用递推的方式做数值计算的递归改造。它只能在<strong>数值类递归</strong>的过程中加入数组来存结果。也就是说，如果是针对<strong>操作类的递归</strong>，比如dfs函数的返回类型是void，且无法用数值来记录每个状态的值的话，<strong>是无法用记忆化搜索的，因为没有任何数值需要被记忆</strong>。比如“用递归的方式实现反序打印字符串”，或者“八皇后问题”。</p><h3 id="记忆化搜索和递推动态规划的关系">1.2.5记忆化搜索和递推/动态规划的关系</h3><p>　　动态规划本质上是递推，而递推和数值类递归都有状态转移方程，只不过递推是根据“已知特例”推导（填写）出“未知”，是“自下而上”的；而记忆化搜索是从“未知”开拓到“已知的特例或完成值”，然后回填“未知”，是“自上而下”的。实现方式不同，但都需要先搞定递推方程，</p><p>　　否则无法着手。时间复杂度都是接近<spanclass="math inline">\(O(n)\)</span>。</p><p>　　递推（或dp）和记忆化搜索并不能完全划等号。</p><p>　　递推是根据已知值来填写未知的值，其特点是“<strong>不爆栈，时空可优化，顺序讲究</strong>”。</p><p>　　这三个特点中，“不爆栈”和“时空可优化”是递推的优点，这是记忆化搜索可能不具备的。当题目刻意卡系统栈（递归层数太深），或者卡时空（时间要求比如单调队列优化DP、斜率优化DP，空间要求比如滚动数组优化），则只能使用dp来做，而不能用记忆化搜索取代。记忆化搜索需要针对每个状态的多维度，定义好对应的状态数组，看上去好像和dp很相似，但dp是可以用滚动的方式来对状态数组进行有效率的压缩的。当标准状态数组很大时，用记忆化搜素可能会造成MLE错误。</p><p>　　而第3个特点“顺序讲究”是递推的缺点。如果递推顺序比较难以推导，或者难以代码实现，则应该改用记忆化搜素。记忆化搜索不存在填写顺序的问题，有现成的值就直接返回现成值，如果没有就马上去递归求出，“逢山开路，逢水架桥”，“车到山前必有路”。</p><p>　　例如：</p><p>　　1） 记忆化搜索不会爆MLE，但会爆栈，只能用递推的：“<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1202">1202：Pell数列</a>”</p><p>　　2）所有只能用滚动状态数组才能完成的dp题，例如n和YS1较大的01背包问题</p><p>　　3） 递推顺序比较难搞的："<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1280">1280：【例9.24】滑雪</a>"</p><h3 id="代码框架">1.2.6 代码框架</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[maxn];    <span class="hljs-comment">// 设置数组的初始值，默认未填的值为0，或者在main()中全设置为 -1，表示未填过</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123; <span class="hljs-comment">// dfs函数是一个能返回数值的函数</span><br>    <span class="hljs-keyword">if</span> (x已经使数组a越界) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span> (x==特例) <br>        a[x]=特例值, <span class="hljs-keyword">return</span> a[x];  <span class="hljs-comment">// 先填数组，再直接返回</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[x] != 数组初始值)   <span class="hljs-comment">// 表示dfs(x)已经被调用过，已有现成的结果在a[x]</span><br>        <span class="hljs-keyword">return</span> a[x];              <span class="hljs-comment">// 那用记忆的值a[x]直接返回，不必再去递归求解</span><br>    <span class="hljs-keyword">else</span>  <span class="hljs-comment">// dfs(x)还没被调用过，a[x]未填过，应递归去求</span><br>        a[x] = “和<span class="hljs-built_in">dfs</span>(x<span class="hljs-number">-1</span>)或<span class="hljs-built_in">dfs</span>(x<span class="hljs-number">-2</span>)等有关的递归方程” , <span class="hljs-keyword">return</span> a[x];  <span class="hljs-comment">// 先填数组（做记忆），再直接返回（别忘了返回） </span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二实战练习">二、实战练习</h1><h2 id="一元的记忆化dfs">2.1 一元的记忆化dfs</h2><h3 id="菲波那契数列">2.1.1 1201 菲波那契数列</h3><p>原题链接：<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1201">1201：菲波那契数列</a></p><p><strong>分析</strong>：这个题是一个典型的递归题，<strong>因为其规模不大</strong>，所以也可以作为一个典型的一维记忆化搜索的模板题。</p><p>根据1.2.6节的代码框架，本题采用“记忆化搜索”思想实现的AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br>LL a[<span class="hljs-number">22</span>];  <span class="hljs-comment">// 十年OI一场空，不开long long见祖宗。养成良好习惯，只要数组不大，抬手就写long long，别去冒险</span><br><span class="hljs-function">LL <span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span> || n==<span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[n]!=<span class="hljs-number">0</span>)  <span class="hljs-comment">// 如果第n个数已算出填好，直接调用，不必再去递归求它了</span><br>    <span class="hljs-keyword">return</span> a[n];<br><span class="hljs-keyword">else</span>               <span class="hljs-comment">// 没算过的就去递归求解。注意，求出来之后先填数组a[n]，再函数返回。</span><br><span class="hljs-keyword">return</span> a[n] = <span class="hljs-built_in">F</span>(n<span class="hljs-number">-1</span>) + <span class="hljs-built_in">F</span>(n<span class="hljs-number">-2</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n, a, i;<br>cin &gt;&gt;n;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>cin &gt;&gt;a;<br>cout &lt;&lt;<span class="hljs-built_in">F</span>(a) &lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，因为菲波那契数列数列增长很快，所以需要考虑数据是否爆int或者爆longlong的问题。菲波那契数列的第47个数会爆int（10位），第93个数会爆longlong（18位）。如果要求第93个及以上的数值，只能上高精度加法来实现。</p><h3 id="pell数列">2.1.2 1202 Pell数列</h3><p>原题链接：<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1202">1202：Pell数列</a></p><p><strong>分析</strong>：这个题要求pell数列的第100万项模32767后的结果。pell数列的第100万项，如果不取模的话，早就爆任何数据类型了，非常大。但是通过每次取模运算，利用模运算的分配率，可以解决这个问题。本题咋一看似乎可以用记忆化搜索来对递归进行剪枝，提升其运行速度，但实际上是通不过AC的。第100万项，其最大问题是递归深度太深，爆系统栈了。本题是想提醒学生，在使用记忆化搜索之前，一定要当心留意其递归深度。如果太深了（本题超过1万左右，就会爆系统栈），则不能使用。</p><p>本题想要AC，只能采用递推的方式。</p><h3 id="p3183-haoi2016-食物链">2.1.3 P3183 [HAOI2016] 食物链</h3><p>看本小节内容需要先掌握链式前向星和top排序最佳，否则建议先跳过本节。</p><p>原题链接：<a href="https://www.luogu.com.cn/problem/P3183">P3183[HAOI2016] 食物链</a></p><p>分析：这个题涉及到了对有向图的处理，需要用链式前向星、邻接表或者逆邻接表来处理图结构均可。</p><p>如果是采用链式前向星或者邻接表，可以很方便地根据某一个点找到其所有邻接点。<strong>dp[]数组存放从当前点到所有汇点的路径条数</strong>。</p><p>1）一种遍历方案是直接用top排序的方式。所有源点的dp[]值为1。然后从所有源点出发，遍历所有节点，并将所有的路径条数值累加到所有的汇点上，一旦遇到汇点，就累加其dp[]值到ans。这种思想类似于递推，但采用了Top排序来规定了特殊的递推顺序，这种递推顺序是非线性的。</p><p>2）如果学生尚未学过top排序或者忘记，那么可以使用第二种遍历方案，即采用记忆化搜素来实现对dp[]的填写。汇点是递归特例，dp[]值为1，表示汇点到汇点的路径只有1条。<strong>当前点到汇点的路径总条数=该点所有邻接点到汇点的总条数之和</strong>，这是递归方程。算法对所有源点做初始的递归调用，由它们去进一步调用邻接点，层层推进，直到遇到汇点，再层层回溯。所有源点的dp[]值即得到答案ans。</p><p>注意，这里<strong>dp[]数组不能存放从所有源点到当前点的路径条数。因为如果这么定义，那必定就需要算法对所有汇点做初始的递归调用</strong>，由它们去进一步调用这些汇点的“<strong>逆邻接点</strong>”，直到遇到源点。但根据当前点去访问其逆邻接点，该操作若采用邻接表或者链式前向星都非常不方便，此时应采用逆邻接表才行。</p><p>本题采用“链式前向星+记忆化搜索”来实现的AC代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 方法1： 记忆化搜素</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxe=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br><span class="hljs-type">int</span> from,to,next;<br>&#125; edges[maxe];<br><span class="hljs-type">int</span> head[maxn];<br><br><span class="hljs-type">int</span> out[maxn], ind[maxn];<br><span class="hljs-type">int</span> f[maxn];  <span class="hljs-comment">// f[5] = 3: 从 5 号点出发，走到不能走为止的路径有 3 条</span><br><span class="hljs-type">int</span> n,m,ans,ecnt;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> from,<span class="hljs-type">int</span> to)</span> </span>&#123;<br>edges[++ecnt].from=from;<br>edges[ecnt].to=to;<br>edges[ecnt].next=head[from];<br>head[from]=ecnt;<br>&#125;<br><span class="hljs-comment">// 递归求从from号出发，走到所有汇点的路径有多少条（以from为出发点） </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> from)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (f[from])<br><span class="hljs-keyword">return</span> f[from];<span class="hljs-comment">// 记忆化，已经填过的就别再去递归了</span><br><span class="hljs-keyword">if</span> (out[from]==<span class="hljs-number">0</span>)      <span class="hljs-comment">// 如果from是汇点之一，则直接返回 1，汇点无法再前行，只能走到自己，即1条路 </span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 该from点所有孩子节点到汇点的路径条数之和，就是from点到汇点的路径条数之和 </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=head[from]; i; i=edges[i].next) &#123;<br>f[from] += <span class="hljs-built_in">dfs</span>(edges[i].to);<br>&#125;<br><span class="hljs-comment">// 记录好之后，返回 </span><br><span class="hljs-keyword">return</span> f[from];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-type">int</span> from, to;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;from, &amp;to);<br><span class="hljs-built_in">addedge</span>(from, to);<br>out[from]++;<br>ind[to]++;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br><span class="hljs-keyword">if</span> (ind[i]==<span class="hljs-number">0</span> &amp;&amp; out[i]!=<span class="hljs-number">0</span>) <span class="hljs-comment">////数据已经累加到所有源点上了，累加起来即OK。孤立点不纳入统计 </span><br>ans+=<span class="hljs-built_in">dfs</span>(i);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多元的记忆化搜索">2.2 多元的记忆化搜索</h2><h3 id="p1464-function">2.2.1 P1464 Function</h3><p>原题链接：<a href="https://www.luogu.com.cn/problem/P1464">P1464Function</a></p><p>分析：这是一个多元的记忆化搜索的模板题。需要注意的是本题录入的a、b、c可能会在[0,20]这个范围之外，所以需要处理一下，以防越界。<strong>“如果 a&gt;20 或b&gt;20 或 c&gt;20 就返回w(20,20,20)”这句话确保了状态数组的规模不会超过20×20×20=8000个单元，也确保了递归深度不会太大，不会爆栈。</strong>所以本题可以用记忆化搜索来搞定。请同学们也注意一下这些分析过程，明确“记忆化搜索”的使用场合。</p><p>本题的AC代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long   <span class="hljs-comment">// 虽然本题规模小，不需开long long，但建议最好还是都写吧，反正不会MLE</span></span><br>LL  d[<span class="hljs-number">21</span>][<span class="hljs-number">21</span>][<span class="hljs-number">21</span>];<br><br><span class="hljs-function">LL  <span class="hljs-title">w</span><span class="hljs-params">(LL a, LL b, LL c)</span></span>&#123;<br>    <span class="hljs-comment">// 首先应该先判特例，或者检查a、b、c是否有数组越界</span><br>    <span class="hljs-comment">// 一旦越a、b、c界，是不能写d[a][b][c]这样的代码的，不管用它来做什么 </span><br><span class="hljs-keyword">if</span> (a&lt;=<span class="hljs-number">0</span> || b &lt;=<span class="hljs-number">0</span> || c&lt;=<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (a&gt;<span class="hljs-number">20</span> || b &gt;<span class="hljs-number">20</span> || c&gt;<span class="hljs-number">20</span>)&#123;<br>LL  t = <span class="hljs-built_in">w</span>(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>);<br>d[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>][<span class="hljs-number">20</span>] = t;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br><span class="hljs-comment">// 这个不能写在前面，因为abc可能超过了数组下标范围，所以应该等上面2个if先判断了之后再做下面的</span><br><span class="hljs-comment">// 如果已经计算过值，就不要再递归了。即递归特例! 这就是记忆化搜索的含义！！ </span><br><span class="hljs-keyword">if</span> (d[a][b][c] != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> d[a][b][c];<br><br><span class="hljs-keyword">if</span> (a&lt;b &amp;&amp; b &lt; c )&#123;<br>LL  t = <span class="hljs-built_in">w</span>(a,b,c<span class="hljs-number">-1</span>) + <span class="hljs-built_in">w</span>(a,b<span class="hljs-number">-1</span>,c<span class="hljs-number">-1</span>) - <span class="hljs-built_in">w</span>(a,b<span class="hljs-number">-1</span>,c);<br><span class="hljs-comment">// 算出结果之后一定要填写数组，避免下次重复计算。 这也是记忆化搜索的含义！ </span><br>d[a][b][c] = t;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>LL  t= <span class="hljs-built_in">w</span>(a<span class="hljs-number">-1</span>,b,c) + <span class="hljs-built_in">w</span>(a<span class="hljs-number">-1</span>, b<span class="hljs-number">-1</span>,c) +<span class="hljs-built_in">w</span>(a<span class="hljs-number">-1</span>,b,c<span class="hljs-number">-1</span>)-<span class="hljs-built_in">w</span>(a<span class="hljs-number">-1</span>,b<span class="hljs-number">-1</span>,c<span class="hljs-number">-1</span>);<br>d[a][b][c] = t;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>LL aa, bb, cc;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;aa, &amp;bb, &amp;cc), !(aa==<span class="hljs-number">-1</span>&amp;&amp;bb==<span class="hljs-number">-1</span>&amp;&amp;cc==<span class="hljs-number">-1</span>))&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;w(%lld, %lld, %lld) = %lld\n&quot;</span>, aa, bb, cc, <span class="hljs-built_in">w</span>(aa,bb,cc));<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">200 20 20</span><br><span class="hljs-comment">18 250 20</span><br><span class="hljs-comment">-1 -1 -1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="p5635">2.2.2 P5635</h3><p>　　原题链接：<ahref="https://www.luogu.com.cn/problem/P5635">【CSGRound1】天下第一</a></p><p>　　<strong>分析</strong>：根据题意，</p><p>$$ <span class="math display">\[\begin{align}第一个回合：x_2&amp;=(x_1+y_1) \ mod \ p \tag{1}\\第二个回合：y_2&amp;=(x_2+y_1) \ mod \ p =((x_1+y_1) \ mod \ p + y_1)\mod \ p \tag{2}\\第三个回合：x_3&amp;=(x_2+y_2) \ mod \ p  \tag{3}\\第四个回合：y_3&amp;=(x_3+y_2) \ mod \ p \tag{4}\\...&amp;=......\tag{}\end{align}\]</span> $$</p><p>　　首先，我们需要确定在本题中，一个状态如何形容？可以看出，一个回合，就是一个状态。在每个回合中，要算出一个x或者y，需要预先确定x和y的值。所以，一个状态是由x和y同时来确定的。也就是说，这是一个二元递归。根据上面公式中的（1）和（2）可以得知递归方程如下：<span class="math display">\[\begin{cases}x_n=(x_{n-1}+y_{n-1})\ mod \ p \\y_n=((x_{n-1}+y_{n-1})\ mod \ p \quad + \quad y_{n-1}\ ) \ mod \ p\end{cases}\]</span></p><p>　　需要注意的是，在这个递归方程中，需要先计算x，判断其是否为0，否则再计算并判断y。</p><p>本题的递归过程有三种特例：x为0、y为0、x和y一直都不为0。如何理解并把这三种情况以特例的代码形式写入递归函数中呢？<strong>假设用f[x][y]存储cbw拥有数x，zhouwc拥有数y时的获胜情况，f[x][y]=1表示cbw获胜，f[x][y]=2表示zhouwc获胜，f[x][y]=-1表示双方平局。</strong></p><p>1）第一种情况x=0很好做，if (x==0) return f[x][y]=1;</p><p>2）第二种情况y=0也好做，if (y==0) return f[x][y]=2;</p><p>3）第三种情况“双方平局”，在代码中如何体现呢？这种思考起来比较复杂，但代码做起来其实也简单。如何体现x和y都不会为0呢？x和y每次经过运算后会得到新的数值，而且数值一定是在[0,p-1]之间，这是一个数的个数有限的区间，也就是说x和y的取值范围是有限的。要想其永远都不可能等于0，这意味着x和y的取值序列一定会有周期循环。从函数调用关系图的角度来说，就是图中一定会存在一个有向环路，类似于“状态A--&gt;状态B--&gt;状态C--&gt;状态D--&gt;状态A”这种。好，现在的问题演变为“如何在记忆化搜索里侦测到调用关系的环路？”其实我们只需要在每次调用时，把当前的状态做一个标记，一路标记下去，如果在当前状态中发现其值已经是我们做好的标记，那该状态已经在之前已经被调用过，产生环路了。具体做法是“在当前递归时，将f[x][y]=-1，然后去递归。在下一步递归时，如果发现f[新x][新y]==-1，则返回3”，具体见下面的AC代码。</p><p>需要注意的是，递归函数中的“判环路”和“判已填过”这两种情况是有区别的。两者在(x,y)位置上的f[x][y]值虽然都不等于数组的初值0，但“判环路”情况下其f[x][y]值是程序预先手工填写的一个假值，是个标记值，此时它仍然属于一种“没有实际填入”的状态，而对应的递归调用属于尚未返回，正在运行的状态。而“判已填过”情况下的f[x][y]值是程序在之前的递归调用中已经结束并回填好了，只不过现在通过其他调用关系路径走到该状态点而已，此时不需要再往下递归，直接取值返回即可。</p><p>本题的AC代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> t,x,y,p;<br><span class="hljs-type">short</span> f[<span class="hljs-number">10010</span>][<span class="hljs-number">10010</span>];     <span class="hljs-comment">// 1e10的空间量，要注意防止MLE，此处只能用short来存1、2、3这些值 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(f[x][y]==<span class="hljs-number">-1</span>)        <span class="hljs-comment">// “判环路”和“判已填过”这两步之间可以不分先后 </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">if</span>(f[x][y]&gt;<span class="hljs-number">0</span>)          <span class="hljs-comment">// 判已填过 </span><br>        <span class="hljs-keyword">return</span> f[x][y];<br>        <br>    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> f[x][y]=<span class="hljs-number">1</span>;  <span class="hljs-comment">// 递归特例 </span><br>    <span class="hljs-keyword">if</span>(y==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> f[x][y]=<span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 一路上都埋入“环路侦测的标记值-1” </span><br>    f[x][y]= <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> f[x][y] = <span class="hljs-built_in">cal</span>( (x+y)%p, ((x+y)%p+y)%p );    <span class="hljs-comment">// 递归方程 </span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt;t &gt;&gt;p;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=t; i++)&#123;<br>        cin &gt;&gt;x &gt;&gt;y;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-built_in">cal</span>(x, y);<br>        <span class="hljs-keyword">if</span>(ans==<span class="hljs-number">3</span>)<br>            cout&lt;&lt;<span class="hljs-string">&quot;error&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ans==<span class="hljs-number">2</span>)<br>            cout&lt;&lt;<span class="hljs-string">&quot;2&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span><br>            cout&lt;&lt;<span class="hljs-string">&quot;1&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题的难点在于对平局的处理，用记忆化搜索的方法，在数组中预填标记量，从而侦测出递归调用关系图中的环路。</p><h3 id="p1434-shoi2002-滑雪">2.2.3 P1434 [SHOI2002] 滑雪</h3><p>原题链接：<a href="https://www.luogu.com.cn/problem/P1434">P1434[SHOI2002] 滑雪</a>或者<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1280">1280：【例9.24】滑雪</a></p><p>分析：这个题可以用“广搜+dp”的方法来做，也可以用“记忆化搜索”的方法来做。因为本题对dp的推导顺序做了较为严格的规定，如果任选一个点开始的话，并不知道是否是最低点或者最高点，所以如果用dp的方式来做的话，需要先对所有状态点进行高度增序的排序，然后从最低点开始往附近的高处递推。</p><p>本题如果采用“记忆化搜索”来做的话，就不必考虑去排序和找初始点了，递归函数规定好只能往比当前点更低的低点进行状态的递归，同时设置到最低点的状态值为1即可。如果当前点是最低点，返回1；如果当前点是半山腰的某点，在求解时会把从当前点到最低点的所有临近点都搞定（注意，此时当前点的状态值并不是最终答案）。所以只需要把所有点都做一次记忆化搜索，全都调一次，填过的就不填了，没填过的就去填，自然能找出其中的最大值，即本题答案。</p><p>方法一：“广搜+dp”，AC代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">关于priority_queue，最主要是搞清楚按照不同字段进行增序或者降序的规则怎么书写 </span><br><span class="hljs-comment">https://www.cnblogs.com/huashanqingzhu/p/11040390.html</span><br><span class="hljs-comment">https://blog.csdn.net/idiot5lie/article/details/115374392</span><br><span class="hljs-comment">*/</span> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br><span class="hljs-type">int</span> r, c, hi;<br>&#125;;<br><br><span class="hljs-comment">// 优先队列，按照hi值递增的顺序出队，即“从矮到高”的顺序</span><br><span class="hljs-comment">// 注意在priority_queue中的排序规则的写法，和sort函数的排序规则写法是反的 ！ </span><br><span class="hljs-comment">// 注意：此处是 &#x27;&gt;&#x27; ，是小顶堆，先出队较小的值 </span><br><span class="hljs-comment">//struct cmp1 &#123;</span><br><span class="hljs-comment">//bool operator()(node x, node y) &#123;</span><br><span class="hljs-comment">//return x.hi &gt; y.hi;   // 严格递增排序</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//&#125;;</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (node x, node y)&#123; <span class="hljs-comment">// 重载&#x27;&lt;&#x27;号操作。 </span><br>    <span class="hljs-keyword">return</span> x.hi &gt; y.hi;           <span class="hljs-comment">// 递增顺序，先出队最矮小的，后出队最大的！和sort函数的cmp是反的哟！～ </span><br>&#125;<br><br>priority_queue&lt;node, vector&lt;node&gt;&gt; q;   <span class="hljs-comment">// 这里就不需要填写第三个参数了 </span><br><span class="hljs-comment">//priority_queue&lt;node, vector&lt;node&gt;, cmp1&gt; q;   // 如果用struct cmp1的写法，此处就应这样写 </span><br><br><span class="hljs-type">int</span> R, C, maxlen;<br><span class="hljs-type">int</span> high[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>], dp[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> dr[<span class="hljs-number">4</span>]= &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> dc[<span class="hljs-number">4</span>]= &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin &gt;&gt;R &gt;&gt;C;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r=<span class="hljs-number">1</span>; r&lt;=R; r++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>; c&lt;=C; c++) &#123;<br>dp[r][c]=<span class="hljs-number">1</span>;<span class="hljs-comment">// 长度最开始为1，它自己</span><br>cin&gt;&gt;high[r][c];<br><span class="hljs-comment">// 将R*C个结点按照行列顺序都入队，但入队后会按照high值递增顺序出队</span><br>q.<span class="hljs-built_in">push</span>( node&#123;r,c,high[r][c]&#125; );<br>&#125;<br>&#125;<br><span class="hljs-comment">// 不管如何，至少有一个点吧！～所以maxlen至少为 1  </span><br>maxlen = <span class="hljs-number">1</span>; <br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-comment">// 因为是按照cmp1规则定义的优先队列，所以会按照high值递增的顺序出队 </span><br>node cur = q.<span class="hljs-built_in">top</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++) &#123;<br><span class="hljs-type">int</span> nr = cur.r + dr[i], nc = cur.c + dc[i];<br><span class="hljs-comment">// 根据当前点的路径长度值，更新合法的附近高点的长度值 </span><br><span class="hljs-keyword">if</span>( nr&gt;=<span class="hljs-number">1</span> &amp;&amp; nr&lt;=R &amp;&amp; nc&gt;=<span class="hljs-number">1</span> &amp;&amp; nc&lt;=C &amp;&amp; high[nr][nc] &gt; high[cur.r][cur.c] ) &#123;<br>dp[nr][nc] = <span class="hljs-built_in">max</span>( dp[nr][nc], dp[cur.r][cur.c] + <span class="hljs-number">1</span>);<br><span class="hljs-comment">//取最大值</span><br>maxlen=<span class="hljs-built_in">max</span>(maxlen, dp[nr][nc]);<br>&#125;<br>&#125;<br>&#125;<br>cout &lt;&lt;maxlen;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：“记忆化搜索”，AC代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 201</span><br><span class="hljs-type">int</span> R, C, high[N][N];<br><span class="hljs-type">int</span> dp[N][N], ans;<br><br><span class="hljs-type">int</span> dr[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> dc[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span></span>&#123;<br><span class="hljs-comment">// 如果这个位置已经dfs过，算过值，那此时就不必再重复计算了，体现了记忆化搜索！</span><br><span class="hljs-comment">// 把这个情况作为递归函数的特例</span><br>    <span class="hljs-keyword">if</span>( dp[r][c] )<br><span class="hljs-keyword">return</span> dp[r][c];<br><br><span class="hljs-comment">// 出发点也要算在路径中，路径中至少有1个点（出发点）</span><br>    dp[r][c] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 然后根据出发点周围的四个点的dp[][]值，来更新dp[r][c]的值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++)&#123;<br><span class="hljs-type">int</span> nr = dr[i] + r;<br>       <span class="hljs-type">int</span> nc = dc[i] + c;<br><span class="hljs-comment">// 如果当前点high值最低，则if内部 一次都不会进入，空转4次后收场，dp[r][c] = 1</span><br>       <span class="hljs-keyword">if</span>( nr &gt;= <span class="hljs-number">1</span> &amp;&amp; nr &lt;= R &amp;&amp; nc &gt;= <span class="hljs-number">1</span> &amp;&amp; nc &lt;= C &amp;&amp;  high[r][c] &gt; high[nr][nc] )&#123;<br>         <span class="hljs-built_in">dfs</span>(nr, nc);   <span class="hljs-comment">// 调用递归函数，填入dp[nr][nc]的值</span><br>         <span class="hljs-comment">// 把四个方向的路径长度值+1之后和当前值比较，取最大的，作为当前值</span><br>          dp[r][c] = <span class="hljs-built_in">max</span>(dp[r][c] , dp[nr][nc] + <span class="hljs-number">1</span>);<br>       &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[r][c];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;R, &amp;C);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=R; i++)<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=C; j++)<br>       <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;high[i][j]);<br><br><span class="hljs-comment">// 既然不知道该从哪个点开始遍历，索性就自己定个顺序开始，每个点都要调用一遍。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=R; i++)<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=C; j++)<br>        ans = <span class="hljs-built_in">max</span>(ans , <span class="hljs-built_in">dfs</span>(i,j) ); <span class="hljs-comment">// 遍历并取最大值</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度优先搜索 </category>
          
          <category> 剪枝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差分 二维差分</title>
      <link href="/2024/03/20/%E5%B7%AE%E5%88%86%20%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86/"/>
      <url>/2024/03/20/%E5%B7%AE%E5%88%86%20%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="视频教学链接">1.1 视频教学链接</h2><p><a href="https://www.bilibili.com/video/BV12u411L7ii">差分二维差分</a></p><h2 id="相关概念">1.2 相关概念</h2><h3 id="基本思想">1.2.1 基本思想</h3><p><strong>差分</strong>是一种处理数据的巧妙而简单的方法，它应用于<strong>区间的修改和区间查询</strong>问题。把给定的数据元素集a数组分成很多区间，对这些区间做很多次操作，<strong>每次操作是对某个区间内的所有元素做相同的加减操作</strong>，若一个个地修改这个区间内的每个元素，非常耗时。引入差分数组D，当修改某个区间时，只需要修改这个区间的“两个端点”，就能记录整个区间的修改，而对端点的修改非常容易，是<spanclass="math inline">\(O(1)\)</span>复杂度的。当所有的修改操作结束后，再根据当前差分数组的值恢复出新的a数组。  a数组可以是一维的线性数组a[]、二维矩阵a[][]、三维立体a[][][]。相应地，定义差分数组D[]、D[][]、D[][][]。一维差分很容易理解，二维和三维需要一点想象力。本节后续内容如无特别说明，指的都是一维数组或序列。</p><h3 id="差分和前缀和的关系及互换">1.2.2 差分和前缀和的关系及互换</h3><p>对于一个给定的序列a[1..n]，它的差分序列D[1..n]定义为： <spanclass="math display">\[D[1]=a[1], \qquad D[i]=a[i]-a[i-1],\qquad (2 \leq i \leq n)\]</span>D[]是a[]的<font color="red" >差分</font>序列，反过来，a[]是D[]的<font color=#ADFF2F>前缀和</font>序列。差分操作和前缀和操作是一对互逆运算。对任何序列a[]求差分D[]，再对D[]求其前缀和序列，就能得到原来的序列a[]。</p><p>关于上述这一点的证明如下： <span class="math display">\[\begin{align}a[1]&amp;=D[1] \\a[2]&amp;=D[2]+a[1]=D[2]+D[1]\\a[3]&amp;=D[3]+a[2]=D[3]+D[2]+D[1]\\......\end{align}\]</span></p><p>二维、三维形式的差分数组，在还原数组时，需要用到多维数组求前缀和的计算方法。具体见本站关于“前缀和”的帖子。</p><h2 id="一维差分">1.3 一维差分</h2><h3 id="问题假设">1.3.1 问题假设</h3><p>讨论这样一个场景：</p><p>（1）给定一个长度为n的一维数组<spanclass="math inline">\(a[1..n]\)</span>，数组内每个元素有初始值。</p><p>（2）<strong>区间修改</strong>操作：做m次区间修改，<strong>每次修改对区间内所有元素做相同的加减操作</strong>。例如第i次修改，把区间<spanclass="math inline">\([L_i,\ R_i]\)</span>内所有元素加上<spanclass="math inline">\(d_i\)</span>。</p><p>（3）<strong>单点查询</strong>操作：询问一个元素的新值是多少。</p><p>如果简单地用暴力法编码，那么每次区间修改的复杂度是<spanclass="math inline">\(O(n)\)</span>的，m次修改共<spanclass="math inline">\(O(m*n)\)</span>，总复杂度<spanclass="math inline">\(O(m*n)\)</span>，效率很差。利用差分法，可以把复杂度减少到<spanclass="math inline">\(O(m+n)\)</span>。模板题可见<ahref="http://acm.hdu.edu.cn/showproblem.php?pid=1556">hdu1556</a>，解法见2.1节。</p><h3 id="相关操作和解法">1.3.2 相关操作和解法</h3><h4 id="批量m次区间修改操作">1.3.2.1“<strong>批量（m次）区间修改</strong>”操作</h4><p>假设a[1..n]是原始数组，D[1..n]是该数组对应的差分数组。m次区间修改，把区间<spanclass="math inline">\([L_i,\ R_i]\)</span>内每个元素（在a[]中从第<spanclass="math inline">\(L_i\)</span>个元素到第<spanclass="math inline">\(R_i\)</span>个元素在内）全都加上<spanclass="math inline">\(d_i\)</span>，<span class="math inline">\((1\leq i\leq m)\)</span>。则区间修改的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)&#123;<br>D[ L[i] ] += d[i];<br>D[ R[i]+<span class="hljs-number">1</span> ] -= d[i];     <span class="hljs-comment">// 注意不要写成了R[i+1]了。做当前这个区间的修改，关下一个区间什么事？</span><br>&#125;<br></code></pre></td></tr></table></figure><p>for循环里的这两句代码如何理解呢？</p><p>举个例子：现在需要将a[]中第3个元素到第7个元素（共计7-3+1=5个）全都加上20，则代码应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">D[3] += 20;<br>D[8] -= 20;    <br></code></pre></td></tr></table></figure><p>注意，上述代码中不是D[7]!为什么呢？请看下图的例子：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240321112724482.png" alt="image-20240321112724482" style="zoom:67%;" /></p><p>我们可以把上面的代码整合一下，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> le, <span class="hljs-type">int</span> ri, <span class="hljs-type">int</span> v)</span></span>&#123;<br>D[le]+=v, D[ri+<span class="hljs-number">1</span>]-=v;            <span class="hljs-comment">// 注意 ri+1</span><br>&#125;<br><span class="hljs-built_in">main</span>()&#123;<br>    ......<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)          <span class="hljs-comment">// m次区间修改  </span><br>    <span class="hljs-built_in">change</span>(L[i], R[i], val[i]);  <span class="hljs-comment">// 每次把a[]从第L[i]到第R[i]个元素全都加上val[i]</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述的change函数是<spanclass="math inline">\(O(1)\)</span>的，for循环是<spanclass="math inline">\(O(m)\)</span>的。我们成功地将“m次<strong>区间</strong>操作”的<spanclass="math inline">\(O(m*n)\)</span>操作变成了“m次<strong>单点</strong>修改”的<spanclass="math inline">\(O(m)\)</span>，大大提高了效率。</p><h4 id="单点查询操作">1.3.2.2 “<strong>单点查询</strong>"操作</h4><p>这里说的单点查询，是指读取最终a[]数组中某一个元素的值。</p><p>当我们使用D[]数组做了m次<spanclass="math inline">\(O(1)\)</span>修改操作后，D[]已经面目全非了。现在要查询a[]中的第k个元素的值，该如何做呢？当然需要先通过D[1..n]还原出a[1..n]，然后提取a[k]。<strong>还原过程就是对D[]做“前缀和”操作</strong>，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;    <span class="hljs-comment">// 因为是对a[]做遍历，i要到n，这里和m没任何关系了</span><br>a[i] = a[i<span class="hljs-number">-1</span>] + D[i];   <span class="hljs-comment">// 谁加谁的值赋给谁，别晕哦！～下标别乱写～</span><br>&#125;<br>cout &lt;&lt;a[k];<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240321113343953.png" alt="image-20240321113343953" style="zoom:67%;" /></p><p>上述的操作，时间复杂度是<spanclass="math inline">\(O(n)\)</span>的，而不是<spanclass="math inline">\(O(1)\)</span>，因为需要先还原。当查询次数很少时，是可以接受的。</p><h3 id="局限性">1.3.3 局限性</h3><p>局限主要出现在“查询”上。如果查询不是发生了1次，而是这样：有m次修改，有k次查询，且修改和查询的顺序是随机的。此时总复杂度是：m次修改复杂度<spanclass="math inline">\(O(m)\)</span>，k次查询复杂度<spanclass="math inline">\(O(k*n)\)</span>，总复杂度<spanclass="math inline">\(O(m+k*n)\)</span>。当查询次数远大于修改次数时，还不如直接用暴力法（总复杂度<spanclass="math inline">\(O(m*n+k)\)</span>）。</p><p>对于“区间修改+<strong>多次</strong>单点查询”这种题型来说，用差分数组往往不够用。因为差分数组对“区间修改”很高效，但是对“<strong>多次</strong>单点查询”并不高效。此时需要用树状数组和线段树来求解。</p><p>树状数组常常结合差分数组来解决更复杂的问题，具体需要查阅“树状数组”专题中的<ahref="http://acm.hdu.edu.cn/showproblem.php?pid=1556">hdu1556</a>；差分数组也常用于“树上差分”，见本博客<strong>LCA</strong>专题的“树上差分”。</p><h2 id="二维差分">1.4 二维差分</h2><p>从一维差分容易扩展到二维差分。一维是线性数组，一个区间[L,R]有两个端点；<strong>二维则是矩阵，一个区间由四个端点围成</strong>。</p><h3 id="问题假设-1">1.4.1 问题假设</h3><p><a href="https://www.luogu.com.cn/problem/P3397">P3397地毯</a>是一个非常典型的二维差分的模板题。我们可以不妨以该题作为二维差分的问题假设。</p><h3 id="原始数组a和二维差分d之间的互换">1.4.2原始数组a[][]和二维差分D[][]之间的互换</h3><p>假设原始数组为a[1..R][1..C],二维差分数组D[1..R][1..C]。这里并不存在专门的前缀和数组，对D[][]进行前缀和运算，就能得到原始数组a[][]。“前缀和”只是从差分还原为原始数组时需要用到的计算方法。</p><h4 id="差分drightarrow原始数组a">1.4.2.1 差分D[][]<spanclass="math inline">\(\Rightarrow\)</span>原始数组a[][]</h4><p>在一维差分中，原数组a[1..n]是从第1个元素(即D[1])开始的差分数组D[1..n]的前缀和：<span class="math display">\[a[k]=D[1]+D[2]+...+D[k]\]</span>在二维差分中，a[i][j]实际上就是差分数组D[1..i][1..j]的前缀和运算结果，即<strong>由原点坐标(1,1)和坐标(i,j)围成的矩阵中，所有的D[][]相加等于a[i][j]</strong>，用数学公式来表示就是：<spanclass="math inline">\(a[i][j]=\sum_{r=1}^{i}(\sum_{c=1}^{j}D[r][c])\)</span>。所以，“根据D[][]求a[][]”的这个问题，其实就是如何求一个二维数组D的前缀和数组a的问题。可以参看本站“前缀和二维前缀和”的帖子第3节“高维前缀和”，有更加清晰和完整的阐述。</p><h5 id="一按维做前缀和操作-更优">（一）按维做“前缀和”操作（ 更优 ）</h5><p>如下图，每个小正圆形代表了一个D[][]值，每个小正方形代表了一个a[][]。在坐标(1,1)和(i,j)所围成的矩形范围内所有小圆形内的数值之和等于a[i][j]。注意，a[0][]和a[][0]值全0，需单独处理，以便后续的二重递推能顺利进行。填写过程的二重for循环都应从1开始。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240322114928462.png" style="zoom:67%;" /></p><p>相关代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 也可以“for C for R”，只是影响填写顺序，第4行代码决定了先累加横向数据，同学们可以试试。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r=<span class="hljs-number">1</span>; r&lt;=R; r++)               <span class="hljs-comment">// 每行都要做如下的事情：</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>; c&lt;=C; c++)&#123;          <span class="hljs-comment">// 对于指定的某一行，从左往右做前缀和并存于a[][]</span><br>    a[r][c]=a[r][c<span class="hljs-number">-1</span>] + D[r][c];   <span class="hljs-comment">// 该行当前列的累加和=该行左侧列的累加和 + 当前数</span><br>    &#125;<br><span class="hljs-comment">// for R for C和for C for R都可以，但第9行一定只能纵向累加，区别于第4行的横向累加</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>; r&lt;=C; c++)               <span class="hljs-comment">// 每列都要做如下的事情：</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r=<span class="hljs-number">1</span>; r&lt;=R; r++)&#123;          <span class="hljs-comment">// 对于指定的某一列，从下往上，继续做前缀和</span><br>    a[r][c]=a[r<span class="hljs-number">-1</span>][c] + a[r][c];   <span class="hljs-comment">// a[r][c]已经是一个横向的前缀和数值了，现在按纵向来累加</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>对于d维数组，则这种算法的时间复杂度为<spanclass="math inline">\(O(R*C*d)\)</span>，表现优异。</p><h5 id="二递推做法">(二)递推做法</h5><p>我们可以用二维的容斥原理来得到递推公式。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240322120812891.png" style="zoom:67%;" /></p><p>总结为公式就是如下： <span class="math display">\[\begin{cases}a[i][0]=0 \qquad (0 \leq i \leq R) \\a[0][j]=0 \qquad (0 \leq j \leq C) \\a[i][j]=a[i-1][j]\ +\ a[i][j-1]\ -\ a[i-1][j-1]\ +\ D[i][j] \qquad(1\leq i \leq R, \ 1\leq j \leq C) \tag {1}\end{cases}\]</span> 这种优化后的递推方法，复杂度为<spanclass="math inline">\(O(R*C)\)</span>。但是对于d维数组求前缀和来说，多维下的容斥原理，上面公式（1）中的第3个公式右边的数据项数不再是4项，而是有<spanclass="math inline">\(2^d\)</span>项。所以其时间复杂度准确地说，应该是<spanclass="math inline">\(O(R*C*2^d)\)</span>，看上去似乎没有第一种方法那么好了，而且公式复杂，书写易错，不推荐本方法。</p><h4 id="原始数组arightarrow差分数组d">1.4.2.2 原始数组a[][]<spanclass="math inline">\(\Rightarrow\)</span>差分数组D[][]</h4><p>在一维情况下，<spanclass="math inline">\(D[i]=a[i]−a[i−1]\)</span>。</p><p>在二维情况下，根据上面总结出来的公式(1)，可以很容易得到： <spanclass="math display">\[\begin{cases}D[i][0]=0 \qquad (0 \leq i \leq R) \\D[0][j]=0 \qquad (0 \leq j \leq C) \\D[i][j]=a[i][j]\quad\textcolor[RGB]{225,0,0}{–}a[i−1][j]\quad\textcolor[RGB]{225,0,0}{–}a[i][j−1]\quad\textcolor[RGB]{0,225,0}{+}a[i−1][j−1]\qquad(1\leq i \leq R,\ 1\leq j \leq C) \tag{2}\end{cases}\]</span> 这个公式的计算复杂度是<spanclass="math inline">\(O(4)\)</span>的。这个公式可以通过下图进一步，采用集合的容斥原理来分析。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240322143341699.png" style="zoom: 67%;" /></p><p>同学们可以想一下，如果这里是<spanclass="math inline">\(d=3\)</span>维数组，那采用容斥原理来分析，其复杂度是多少呢？<spanclass="math inline">\(O(2^d)\)</span></p><h3 id="相关操作和解法-1">1.4.3 相关操作和解法</h3><h4 id="批量m次区间修改操作-1">1.4.3.1“<strong>批量（m次）区间修改</strong>”操作</h4><p>在一维情况下，做区间修改只需要修改区间的两个端点的D[]值。在二维情况下，一个区间代表了一个小矩阵，有4个角点，只需要修改这4个角点的D[][]值。例如以两个坐标点<spanclass="math inline">\((r1,c1)\)</span>和<spanclass="math inline">\((r2,c2)\)</span>为对角点而定义的矩形区间，其修改方法如下代码所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">D[r1][c1]     += d;     <span class="hljs-comment">// 二维区间的起点，累加</span><br>D[r1][c2+<span class="hljs-number">1</span>]   -= d;     <span class="hljs-comment">// 横向看，原始数组的修改范围是列从c1到c2+1。累减</span><br>D[r2+<span class="hljs-number">1</span>][c1]   -= d;     <span class="hljs-comment">// 纵向看，原始数组的修改范围是行从r1到r2+1。累减</span><br>D[r2+<span class="hljs-number">1</span>][c2+<span class="hljs-number">1</span>] += d;     <span class="hljs-comment">// 由于前两式把d减了2次，多减了1次，这里加1次回来</span><br></code></pre></td></tr></table></figure><p>举个例子：现在有a[0..7][0..7]及其对应的差分数组D[0..7][0..7]的数据如下图所示，a[][]的每个元素值都是10的整倍数。现在需要在以(2，3)和（5，5）为对角点的矩形范围内把每个a[][]的值都累加上5。如果用差分数组来处理，该如何实现这个操作呢？我们需要在D[][]中找到4个坐标点，他们分别是（2，3）、（2，6）、（6，3）、（6，6），如下图左中黄色圆圈所示。然后对这四个D[][]做上面代码块中的相关操作就可以啦！注意，是<strong>累加</strong>，不是直接赋值。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240322152409516.png"alt="image-20240322152409516" /><figcaption aria-hidden="true">image-20240322152409516</figcaption></figure><p>修改后的D数组和其对应代表的a数组如上图右所示。同学们可以仔细体会。</p><h4 id="单点查询操作-1">1.4.3.2 “单点查询”操作</h4><p>当我们对D[][]数组做了m次<spanclass="math inline">\(O(4)\)</span>修改操作后，假如现在要查询其对应的a[][]中的第r行第c列的元素值，这就是所谓的“单点查询”操作。解决方法就是先通过D[1..R][1..C]还原出a[1..R][1..C]，然后提取a[r][c]。<strong>还原过程就是对D[][]做“前缀和”操作</strong>，从而还原得到a[][]。该操作过程请参看1.4.2.1节内容，此处不再赘述。算法复杂度为<spanclass="math inline">\(O(R*C)\)</span>。</p><h2 id="三维差分">1.5 三维差分</h2><h3 id="问题假设-2">1.5.1 问题假设</h3><p>元素值用三维数组a[][][]来定义，差分数组b[][][]也是三维的。与之前低维度的差分类似，把三维差分想象成立体空间的操作。与之对应的小立方块有8个顶点，所以三维的区间需要修改8个b[][][]的值。</p><h3 id="原始数组a和差分数组d之间的相互关系">1.5.2原始数组a[][][]和差分数组D[][][]之间的相互关系</h3><p>在二维差分中，a[][] 是差分数组 b[][]的前缀和，即原点坐标(1，1)和坐标(i，j)围成的矩阵面积。</p><p>在三维差分中，a[][][] 是差分数组b[][][]的前缀和，即原点坐标(1,1,1)和坐标(r,c,h)围成的立方体体积。同样地，我们把每个b[][][]看成一个小正方体，在坐标(1，1，1)~(i，j，k)所围成的三维空间中，所有小正方体加起来的总体积即为a[r][c][h]。如下图所示，每个小立方体由8个角点定义。坐标点(i，j，k)的值是a[r][c][h]; 图中正方体的体积是差分数组 b[i][j][k]的值。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240322215017626.png" style="zoom:67%;" /></p><p>类似的，在三维情况下，差分就变成了相邻的<code>a[][][]</code>的”体积差“。那么如何来写出差分的<strong>递推</strong>计算公式呢？</p><p>观察前面一、二维的前缀和我们可以发现，其前缀和规律十分吻合容斥原理:</p><ol type="1"><li><p>一维：</p><p>A)原始a <span class="math display">\[\begin{align} a_i = a^{i-1} + D_i \tag{3}\end{align}\]</span> B)差分D <span class="math display">\[\begin{align}D_i=a_i - a_{i-1}\end{align} \tag{4}\]</span></p></li><li><p>二维：</p><ol type="A"><li>原始a <span class="math display">\[\begin{align}a_{r,c} = &amp;\ \ \ \ \ \ D_{r,c}  \tag{5}\\&amp;+\a_{r-1,c} \ \ \ + \ \ a_{r,c-1}\quad\quad\quad(奇数个维度(1)要-1，加)\notag \\&amp;-\ a_{r-1,c-1}\quad\quad\quad\quad\quad\quad\quad(偶数个维度(2)要-1，减)\notag \\\end{align}\]</span></li><li>差分D <span class="math display">\[\begin{align}D_{r,c} = &amp;\ \ \ \ \ \ a_{r,c} \tag{6}\\&amp;-\a_{r-1,c} \ \ \ - \ \ a_{r,c-1}\quad\quad\quad(奇数个维度(1)要-1，减)\notag \\&amp;+\ a_{r-1,c-1}\quad\quad\quad\quad\quad\quad\quad(偶数个维度(2)要-1，加)\notag \\\end{align}\]</span></li></ol></li><li><p>三维：</p><ol type="A"><li>原始a <span class="math display">\[\begin{align}a_{r,c,h} = &amp;\ \ \ \ \ \ D_{r,c,h} \tag{7}\\&amp;+\a_{r-1,c,h} \ \ \ + \ \ a_{r,c-1,h}\ \ \ + \a_{r,c,h-1}\quad\quad\quad(奇数个维度(1)要-1，加) \notag \\&amp;-\ a_{r-1,c-1,h}-\ a_{r,c-1,h-1}-\ a_{r-1,c,h-1}\quad\quad(偶数个维度(2)要-1，减)\notag \\&amp;+\a_{r-1,c-1,h-1}\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\\ \ (奇数个维度(3)要-1，加)\notag\end{align}\]</span> B)差分D <span class="math display">\[\begin{align}D_{r,c,h} = &amp;\ \ \ \ \ \ a_{r,c,h}\tag{8}\\&amp;−\a_{r-1,c,h} \ \ \ − \ \ a_{r,c-1,h}\ \ \ − \a_{r,c,h-1}\quad\quad\quad(奇数个维度(1)要-1，减) \notag \\&amp;+\ a_{r-1,c-1,h}+\ a_{r,c-1,h-1}+\ a_{r-1,c,h-1}\quad\quad(偶数个维度(2)要-1，减减得加)\notag \\&amp;−\a_{r-1,c-1,h-1}\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\\ \ (奇数个维度(3)要-1，减)\notag\end{align}\]</span>上述A)和B)两个公式，其实是同一个公式。建议选一个来记住即可，临场现推另外一个，不必全记。</li></ol></li></ol><h3 id="相关操作和解法-2">1.5.3 相关操作和解法</h3><h4 id="批量m次区间修改操作-2">1.5.3.1“<strong>批量（m次）区间修改</strong>”操作</h4><p>在三维情况下，我们修改的是一个立方体，有8个顶点，故我们只需要修改这8个顶点的差分数组b[][][]的值即可。给出坐标点$$定义的区间，如下图所示:</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240325114915696.png" style="zoom: 50%;" /></p><p>那么对应的8个 D[][][]的修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 左侧</span><br>D[r1][c1][h1] += d;     <span class="hljs-comment">// 红点，左前下</span><br>D[r1][c1][h2 + <span class="hljs-number">1</span>] -= d;      <span class="hljs-comment">// 左前上</span><br>D[r1][c2 + <span class="hljs-number">1</span>][h1] -= d;      <span class="hljs-comment">// 左后下</span><br>D[r1][c2 + <span class="hljs-number">1</span>][h2 + <span class="hljs-number">1</span>] += d;  <span class="hljs-comment">// 左后上 </span><br><br><span class="hljs-comment">// 右侧</span><br>D[r2 + <span class="hljs-number">1</span>][c1][h1] -= d;      <span class="hljs-comment">// 右前下</span><br>D[r2 + <span class="hljs-number">1</span>][c1][h2 + <span class="hljs-number">1</span>] += d;  <span class="hljs-comment">// 右前上</span><br>D[r2 + <span class="hljs-number">1</span>][c2 + <span class="hljs-number">1</span>][h1] += d;  <span class="hljs-comment">// 右后下</span><br>D[r2 + <span class="hljs-number">1</span>][c2 + <span class="hljs-number">1</span>][h2 + <span class="hljs-number">1</span>] -= d; <span class="hljs-comment">// 绿点，右后上</span><br></code></pre></td></tr></table></figure><p>为了方便记忆，我们可以把它按照二进制的排列来写，若二进制中出现偶数个"正1"为正，奇数个"正1"为负，与前缀和恰好相反（前缀和是偶数个"-1"为负，奇数个"-1"为正）:$$ <span class="math display">\[\begin{align}{0, 0, 0}\quad&amp;\Rightarrow{r1, c1,h1}&amp;\Rightarrow&amp;D[][][]+=d; \notag \\{0, 0, \textcolor[RGB]{225,0,0}{1}}\quad&amp;\Rightarrow{r1, c1,h2+1}&amp;\Rightarrow&amp;D[][][]\textcolor[RGB]{225,0,0}{-}=d; \notag\\{0, \textcolor[RGB]{225,0,0}{1}, 0}\quad&amp;\Rightarrow{r1, c2+1,h1}&amp;\Rightarrow&amp;D[][][]\textcolor[RGB]{225,0,0}{-}=d; \notag \\{0, 1, 1}\quad&amp;\Rightarrow{r1, c2+1,h2+1}&amp;\Rightarrow&amp;D[][][]+=d; \notag \\{\textcolor[RGB]{225,0,0}{1}, 0, 0}\quad&amp;\Rightarrow{r2+1, c1,h1}&amp;\Rightarrow&amp;D[][][]\textcolor[RGB]{225,0,0}{-}=d; \notag \\{1, 0, 1}\quad&amp;\Rightarrow{r2+1, c1,h2+1}&amp;\Rightarrow&amp;D[][][]+=d; \notag \\{1, 1, 0}\quad&amp;\Rightarrow{r2+1, c2+1,h1}&amp;\Rightarrow&amp;D[][][]+=d; \notag \\  {\textcolor[RGB]{225,0,0}{1}, \textcolor[RGB]{225,0,0}{1},\textcolor[RGB]{225,0,0}{1}}\quad&amp;\Rightarrow{r2+1, c2+1,h2+1}&amp;\Rightarrow&amp;D[][][]\textcolor[RGB]{225,0,0}{-}=d; \notag\\\end{align}\]</span> $$</p><h1 id="二实战训练">二、实战训练</h1><h2 id="hdu-1556一维差分模板题">2.1 HDU 1556（一维差分模板题）</h2><p><strong>原题链接</strong>：<ahref="http://acm.hdu.edu.cn/showproblem.php?pid=1556">HDU 1556 Color theball</a></p><p><strong>问题描述</strong>：N个气球排成一排，从左到右依次编号为1,2,3....N。每次给定2个整数L,R(L&lt;=R)，lele从气球L开始到气球R依次给每个气球涂一次颜色。但是N次以后lele已经忘记了每个气球已经涂过几次颜色了，你能帮他算出每个气球被涂过几次颜色吗？<strong>输入</strong>：每个测试实例第一行为一个整数N，(N&lt;=100000)。接下来的N行，每行包括2个整数L,R(1&lt;=L&lt;=R&lt;=N)。当N=0，输入结束。<strong>输出</strong>：每个测试实例输出一行，包括N个整数，第I个数代表第I个气球总共被涂色的次数。</p><p><strong>分析</strong>：</p><p>这个例题是简单差分法的直接应用，下面给出代码。代码第13、14行是区间修改，第17行的a[i]=a[i−1]+D[i]，即利用D[]求得了最后的a[]。这个式子就是a[i]−a[i−1]=D[i]，它是差分数组的定义。</p><p>注意a[]的计算方法。a[i]=a[i−1]+D[i]是一个递推公式，通过它能在一个i循环中求得所有的a[]。如果不用递推，而是直接用前缀和a[k]=D[1]+D[2]+...+D[k]来求所有的a[]，就需要用两个循环i、k。</p><p>本题AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//hdu 1556用差分数组求解</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Maxn = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> a[Maxn],D[Maxn];               <span class="hljs-comment">//a是气球，D是差分数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)) &#123; <br>        <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a)); <span class="hljs-built_in">memset</span>(D,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(D));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> L,R; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;L,&amp;R);<br>            D[L]++;                 <span class="hljs-comment">//区间修改，这里d=1</span><br>            D[R+<span class="hljs-number">1</span>]--;<br>        &#125;<br>        <span class="hljs-comment">//小技巧：17行到20行，把a[]改成D[]也行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;              <span class="hljs-comment">//求原数组</span><br>            a[i] = a[i<span class="hljs-number">-1</span>] + D[i];           <span class="hljs-comment">//差分。求前缀和a[]，a[i]就是气球i的值</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);     <span class="hljs-comment">//逐个打印结果</span><br>        &#125;        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码可以把第17~20行的a[]改为D[]（即不使用专门的a数组）也能通过。这个技巧在后面的二维差分、三维差分中也能用，节省一倍的空间。</p><h2 id="p2367-一维差分模板题">2.2 P2367 （一维差分模板题）</h2><p>原题链接：<a href="https://www.luogu.com.cn/problem/P2367">P2367语文成绩</a></p><p>这个题和2.1节一样，是第二个裸的一维差分入门模板题。n=5e6，要求1秒完成，所以只能采用<spanclass="math inline">\(O(n)\)</span>的算法才能过。</p><p>AC代码如下。本题代码只用了一个数组，同学们也可以试试看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//P2367用差分数组求解</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Maxn = <span class="hljs-number">5e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> D[Maxn];            <span class="hljs-comment">//差分数组（初始也用来存原始数据）</span><br><span class="hljs-comment">// 本题也可以只定义a[]而不定义D[]，其实代码形式都一样，从内存的角度来说很容易看出来。 </span><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, p;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n, &amp;p);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;D[i]);  <span class="hljs-comment">// 先用差分数组D[]暂存a[] </span><br>    <span class="hljs-comment">// 注意循环顺序只能倒序，不能正序哦！递推公式决定的。 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n; i&gt;=<span class="hljs-number">1</span>; i--) D[i]=D[i]-D[i<span class="hljs-number">-1</span>];     <span class="hljs-comment">// 等效于D[i]=a[i]-a[i-1]，得到真正的差分数组D[] </span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=p; i++) &#123;<br>        <span class="hljs-type">int</span> L,R,s;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;L,&amp;R,&amp;s);<br>        D[L]+=s;                 <span class="hljs-comment">//区间修改的固定套路 </span><br>        D[R+<span class="hljs-number">1</span>]-=s;<br>    &#125;<br>    <span class="hljs-type">int</span> minn = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;            <br>        D[i] = D[i<span class="hljs-number">-1</span>] + D[i];    <span class="hljs-comment">//以前缀和的方法，恢复出原始数组a[i]，仍存于D[i]</span><br>        <span class="hljs-keyword">if</span> (D[i]&lt;minn)<br>            minn= D[i];<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, minn);   <span class="hljs-comment">//逐个打印结果</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p4552多少次多少种">2.3 P4552（多少次，多少种）</h2><p>原题链接：<a href="https://www.luogu.com.cn/problem/P4552">P4552[Poetize6] IncDec Sequence</a></p><p>视频讲解链接：<ahref="https://www.bilibili.com/video/BV12u411L7ii">差分二维差分</a>（04:53处）</p><p><strong>分析：</strong></p><p><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230705121209012-1332416451.png" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230705121209018-1370204910.png" /></p><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[maxn], D[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);<br>        D[i] = a[i] - a[i<span class="hljs-number">-1</span>];<br>    &#125;<br><br>LL p=<span class="hljs-number">0</span>, q=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++)<br><span class="hljs-keyword">if</span>(D[i]&gt;<span class="hljs-number">0</span>) <br>            p += D[i];<br><span class="hljs-keyword">else</span> <br>            q += <span class="hljs-built_in">abs</span>(D[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n%lld&quot;</span>, <span class="hljs-built_in">max</span>(p,q), <span class="hljs-built_in">abs</span>(p-q)+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p9011深搜为主一维差分可有">2.4P9011（深搜为主，一维差分可有）</h2><p>原题链接：<a href="https://www.luogu.com.cn/problem/P9011">P9011[USACO23JAN] Air Cownditioning II B</a></p><p>题目简意：要求从M(<span class="math inline">\(1\leqM\leq10\)</span>)个区间修改中选择若干个（次数不定）修改，对一个数组a[1..100]（初始全0）进行区间修改，每次修改的成本代价已知且不同，求将数组改造成指定要求的内容最少需要的代价之和。</p><p><strong>分析</strong>：</p><p>题意中说“从M个中选择若干个……”，且M如此之小，第一反应就是用深搜来暴力尝试。针对每个区间修改，我们有“选择它”和“不选择它”这两种选择方案。两种方案都要尝试，都要执行。</p><p>1）如果选择做第i个修改，则对a数组中第le[i]..ri[i]个之间的数据进行区间修改，可以采用差分数组将其降为<spanclass="math inline">\(O(1)\)</span>的复杂度（也可以直接开for循环来做，<spanclass="math inline">\(O(N=20)\)</span>变成<spanclass="math inline">\(O(N*100=2e4)\)</span>，也不大），累计成本，对下一个修改做选择；</p><p>2）如果选择不做该修改，成本不变，对下一个修改做选择；</p><p>以上的操作一直进行到M个区间修改全都完毕，可以视为一个方案。此时的成本即为该方案的成本。当前需要求最小成本，所以在深搜的过程中可以剪枝（若当前成本已经大于曾经的最小成本，则没必要继续深搜下去了，不可能优）</p><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> N,M,k,minmoney=<span class="hljs-number">1e9</span>;<br><span class="hljs-type">int</span> wendu[<span class="hljs-number">105</span>];   <span class="hljs-comment">// 100个围栏的温度 </span><br><span class="hljs-type">int</span> s[<span class="hljs-number">25</span>],t[<span class="hljs-number">25</span>],c[<span class="hljs-number">25</span>];  <span class="hljs-comment">// 最多20个奶牛，占据从s[]到t[]的围栏，要求温度要下降c[]度 </span><br><span class="hljs-type">int</span> a[<span class="hljs-number">25</span>],b[<span class="hljs-number">25</span>],p[<span class="hljs-number">25</span>],m[<span class="hljs-number">25</span>];  <span class="hljs-comment">// 最多10个空调，从a[]到b[]的围栏温度都能下降m[]度  </span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//是否满足</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=k; i++)&#123;<br>        <span class="hljs-keyword">if</span>(wendu[i]&gt;<span class="hljs-number">0</span>)   <span class="hljs-comment">// 如果还存在某个围栏的预设温度没有降到0及以下，说明降温不够要求 </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> dep,<span class="hljs-type">int</span> money)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (money &gt; minmoney)  <span class="hljs-comment">// 剪枝，如果继续下去，不可能再小于minnoney，放弃这个分支 </span><br>        <span class="hljs-keyword">return</span>; <br>    <span class="hljs-keyword">if</span>(dep&gt;M)&#123;     <span class="hljs-comment">// 已经处理完M个空调的选择 </span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>()) <br>            minmoney=<span class="hljs-built_in">min</span>(minmoney,money);<span class="hljs-comment">//合法就更新答案</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(dep+<span class="hljs-number">1</span>,money); <span class="hljs-comment">//不选，前进 </span><br><br>    <span class="hljs-comment">// 做完“不选第dep个修改”的尝试之后，再做“做第dep个修改”的尝试    </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a[dep]; i&lt;=b[dep]; i++) wendu[i]-=p[dep]; <span class="hljs-comment">//选，既然选，就要降温 </span><br>    <span class="hljs-built_in">dfs</span>(dep+<span class="hljs-number">1</span>,money+m[dep]);   <span class="hljs-comment">// 前进 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a[dep]; i&lt;=b[dep]; i++) wendu[i]+=p[dep]; <span class="hljs-comment">//回溯，抹掉对应的修改 </span><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt;N &gt;&gt;M;    <span class="hljs-comment">// 奶牛数N，空调数M </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=N; i++)&#123;<br>        cin &gt;&gt;s[i] &gt;&gt;t[i] &gt;&gt;c[i];<br>        k=<span class="hljs-built_in">max</span>(k,t[i]);<br>        wendu[s[i]]+=c[i];   <span class="hljs-comment">//差分的处理方式 </span><br>        wendu[t[i]+<span class="hljs-number">1</span>]-=c[i]; <span class="hljs-comment">// </span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">100</span>; i++)<br>        wendu[i]+=wendu[i<span class="hljs-number">-1</span>]; <span class="hljs-comment">//将差分数组还原成原始数组 </span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=M; i++) cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;p[i]&gt;&gt;m[i];<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);      <span class="hljs-comment">// 考虑第1个修改，已付成本为0 </span><br>    cout&lt;&lt;minmoney;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他简单的一维差分题训练">2.5 其他简单的一维差分题训练</h2><p>1）<a href="https://www.luogu.com.cn/problem/CF44C">CF44CHolidays</a>,原题链接点<ahref="https://codeforces.com/problemset/problem/44/C"><strong>这里</strong></a></p><p>2）<a href="https://www.luogu.com.cn/problem/P1672">P1672[USACO05FEB] Feed Accounting S</a></p><p>3)<a href="https://www.luogu.com.cn/problem/P4623">P4623[COCI2012-2013#6] BUREK</a></p><h2 id="p3397二维差分模板题">2.6 P3397（二维差分模板题）</h2><p><strong>原题链接</strong>：<ahref="https://www.luogu.com.cn/problem/P3397">P3397 地毯</a></p><p><strong>分析</strong>：</p><p>这一题是2.1节的hdu1556的二维扩展，其修改操作和查询操作完全一样。m=1000次修改，n*n的网格范围。</p><p>在用差分之前，先考虑能不能用暴力法。每次修改复杂度是<spanclass="math inline">\(O(n^2)\)</span>，共m次，总复杂度<spanclass="math inline">\(O(m*n^2=1e9)\)</span>，超时。</p><p>二维差分的复杂度是多少？一维差分的一次修改是<spanclass="math inline">\(O(1)\)</span>的，二维差分的修改是O(4)的；一维差分的一次查询是<spanclass="math inline">\(O(n)\)</span>的，二维差分是<spanclass="math inline">\(O(n^2)\)</span>的，所以二维差分的总复杂度是<spanclass="math inline">\(O(4*m+n^2)\)</span>。由于计算一次二维矩阵的值需要<spanclass="math inline">\(O(n^2)\)</span>的计算量，所以二维差分已经达到了最好的复杂度。</p><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> D[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>];     <span class="hljs-comment">//差分数组</span><br><span class="hljs-comment">//int a[1010][1010];   //原数组，不定义也行</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);<br>        D[x1][y1]     += <span class="hljs-number">1</span>;        <span class="hljs-comment">//计算差分数组</span><br>        D[x2+<span class="hljs-number">1</span>][y1]   -= <span class="hljs-number">1</span>;<br>        D[x1][y2+<span class="hljs-number">1</span>]   -= <span class="hljs-number">1</span>;<br>        D[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>] += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 还原的方法1：前缀和方式 O(d * n^2)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i)           <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;n; ++j)        <span class="hljs-comment">//注意这里是j&lt;n</span><br>            D[i][j+<span class="hljs-number">1</span>] += D[i][j];     <span class="hljs-comment">//把i看成定值，先累加计算j方向</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; ++j)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; ++i)        <span class="hljs-comment">//注意这里是i&lt;n</span><br>            D[i+<span class="hljs-number">1</span>][j] += D[i][j];     <span class="hljs-comment">//把j看成定值，再累加计算i方向</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) &#123;         <span class="hljs-comment">//打印</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; ++j)<br>             <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,D[i][j]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);                 <span class="hljs-comment">//换行</span><br>    &#125;<br>     <br><span class="hljs-comment">//    // 还原的方法2：递推方式   O(2^d * n^2) </span><br><span class="hljs-comment">//    for(int i=1;i&lt;=n;++i)&#123;   //根据差分数组计算原矩阵的值（想象成求小格子的面积和）</span><br><span class="hljs-comment">//        for(int j=1;j&lt;=n;++j)&#123;      //把用过的D[][]看成a[][]，就不用再定义a[][]了</span><br><span class="hljs-comment">//            //a[i][j] = D[i][j] + a[i-1][j] + a[i][j-1] - a[i-1][j-1];</span><br><span class="hljs-comment">//            //printf(&quot;%d &quot;,a[i][j]);  //这两行和下面两行的效果一样</span><br><span class="hljs-comment">//            D[i][j] += D[i-1][j]+D[i][j-1]-D[i-1][j-1];</span><br><span class="hljs-comment">//            printf(&quot;%d &quot;,D[i][j]);</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        printf(&quot;\n&quot;);//换行</span><br><span class="hljs-comment">//    &#125;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三体攻击三维差分模板题">2.7 三体攻击（三维差分模板题）</h2><p><strong>原题链接</strong>：<ahref="https://www.lanqiao.cn/problems/180/learning/">三体攻击（蓝桥杯2018年省赛A组）</a></p><p><strong>问题简述</strong>：</p><p>三体人将对地球发起攻击。为了抵御攻击，地球人派出了<spanclass="math inline">\(n = A × B × C\)</span> 艘战舰，在太空中排成一个 A层 B 行 C 列的立方体。其中，第 i 层第 j 行第 k 列的战舰（记为战舰 <spanclass="math inline">\((i, j, k)\)</span>）的生命值为 <spanclass="math inline">\(s(i, j, k)\)</span>。</p><p>三体人将会对地球发起 m轮“立方体攻击”，每次攻击会对一个小立方体中的所有战舰都造成相同的伤害。具体地，第t轮攻击用7个参数x1, x2, y1, y2, z1, z2, d 来描述；</p><p>所有满足<span class="math inline">\(i∈[x1, x2], j∈[y1, y2],k∈[z1, z2]\)</span> 的战舰 <spanclass="math inline">\((i, j, k)\)</span>会受到值为d的伤害。如果一个战舰累计受到的总伤害超过其防御力，那么这个战舰会爆炸。</p><p>地球指挥官希望你能告诉他，第一艘爆炸的战舰是在哪一轮攻击后爆炸的。</p><p>输入：第一行包括 4 个正整数 A, B, C, m；</p><p>第二行包含<span class="math inline">\(A × B ×C\)</span>个整数，其中第<span class="math inline">\(((i − 1)×B + (j −1)) × C + (k − 1)+1\)</span> 个数为<spanclass="math inline">\(s(i, j, k)\)</span>；</p><p>第 3 到第 m + 2 行中，第 (t − 2) 行包含 7 个正整数 x1,x2, y1, y2, z1, z2, d。</p><p><span class="math inline">\(A × B ×C ≤ 10^6, m ≤ 10^6, 0 ≤ s(i, j, k), d ≤ 10^9\)</span>。</p><p>输出：输出第一个爆炸的战舰是在哪一轮攻击后爆炸的。保证一定存在这样的战舰。</p><p><strong>分析</strong>：</p><p>首先看数据规模，有<span class="math inline">\(n=10^6\)</span>个点，<spanclass="math inline">\(m=10^6\)</span>次攻击，如果用暴力法，统计每次攻击后每个点的生命值，那么复杂度是<spanclass="math inline">\(O(m*n)\)</span>的，超时。</p><p>本题适合用三维差分，每次攻击只修改差分数组D[][][]，一次修改的复杂度是<spanclass="math inline">\(O(1)\)</span>，m次修改的总复杂度只有<spanclass="math inline">\(O(m)\)</span>。</p><p>但是光用差分数组并不能解决问题。因为在差分数组上查询区间内的原始数组中每个元素是否小于0，需要用差分数组来计算前缀和数组（即原始数组a）的值，复杂度是<spanclass="math inline">\(O(n)\)</span>的。合起来的总复杂度还是<spanclass="math inline">\(O(m*n)\)</span>的，跟暴力法的复杂度一样。</p><p>分析到这里，可以发现，本题和P1083是非常相似的（P1083的分析过程请见本站“二分查找和二分答案”帖），是存在单调性的。本题需要结合第二个算法：二分法。从第1次修改到第m次修改，肯定有一次修改是临界点。在临界点前，没有负值（战舰爆炸）；在临界点后，出现了负值，且后面一直有负值。这就是单调性。那么对m进行二分，就能在<spanclass="math inline">\(O(logm)\)</span>次内找到这个临界点，这就是答案。总复杂度<spanclass="math inline">\(O(n*logm)\)</span>。</p><p>下面给出代码。其中<code>check()</code>函数包含了三维差分的全部内容。代码有几个关键点：</p><p>（1）没有定义a[][][]，而是用D[][][]来代替。</p><p>（2）<strong>压维</strong>。直接定义三维差分数组D[][][]不太方便。虽然坐标点总数量<spanclass="math inline">\(n=A×B×C=10^6\)</span>比较小，但是本题并没有明确告知每一维的最大长度，所以如果定义成三维数组，那么每一维都需要定义到<spanclass="math inline">\(10^6\)</span>，那么总空间就是<spanclass="math inline">\(10^{18}\)</span>。为避免这一问题，可以把三维坐标压维成一维数组D[]，总长度仍然是<spanclass="math inline">\(10^6\)</span>的。这个技巧很有用。实现函数是<code>num()</code>，它把三维坐标(x,y,z)变换为一维坐标<spanclass="math inline">\(h=(x−1)∗B∗C+(y−1)∗C+(z−1)+1\)</span>，当x、y、z的取值范围分别是<spanclass="math inline">\([1,\ A]、[1,\ B]、[1,\C]\)</span>时，h的范围是<span class="math inline">\([1,\  A × B ×C]\)</span>。</p><p>如果希望按C语言的习惯从0开始，x、y、z的取值范围分别是<spanclass="math inline">\([0,\ A-1]、[0,\ B-1]、[0,\ C-1]\)</span>，h范围是0~ A × B × C-1，就把式子改为：<spanclass="math inline">\(h=x∗B∗C+y∗C+z\)</span>。</p><p>同理，二维坐标(x,y)也可以压维成一维<spanclass="math inline">\(h=(x−1)∗B+(y−1)+1\)</span>，当x、y的取值范围分别是<spanclass="math inline">\([1,\ A]、[1,\ B]\)</span>时，hℎ的范围是<spanclass="math inline">\([1,\  A × B]\)</span>。</p><p>（3）<code>check()</code>中19-26行，在D[1..n]上记录区间修改。</p><p>（4）<code>check()</code>中29-40行的3个<code>for</code>循环计算前缀和。分别从x、y、z三个方向累加小立方体的体积，计算出所有的前缀和。</p><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> A,B,C,n,m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Maxn = <span class="hljs-number">1000005</span>;<br><span class="hljs-type">int</span> s[Maxn];   <span class="hljs-comment">//存储舰队生命值</span><br><span class="hljs-type">int</span> D[Maxn];   <span class="hljs-comment">//三维差分数组（压维）；同时也用来计算每个点的攻击值</span><br><span class="hljs-type">int</span> x2[Maxn], y2[Maxn], z2[Maxn]; <span class="hljs-comment">//存储区间修改的范围，即攻击的范围</span><br><span class="hljs-type">int</span> x1[Maxn], y1[Maxn], z1[Maxn]; <br><br><span class="hljs-type">int</span> d[Maxn];                    <span class="hljs-comment">//记录伤害，就是区间修改</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;  <br><span class="hljs-comment">//小技巧：压维，把三维坐标[(x,y,z)转为一维的((x-1)*B+(y-1))*C+(z-1)+1</span><br>    <span class="hljs-keyword">if</span> (x&gt;A || y&gt;B || z&gt;C) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> ((x<span class="hljs-number">-1</span>)*B+(y<span class="hljs-number">-1</span>))*C+(z<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;              <span class="hljs-comment">//做x次区间修改。即检查经过x次攻击后是否有战舰爆炸</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)  D[i]=<span class="hljs-number">0</span>;  <span class="hljs-comment">//差分数组的初值，本题是0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=x; i++) &#123;         <span class="hljs-comment">//用三维差分数组记录区间修改：有8个区间端点</span><br>        D[<span class="hljs-built_in">num</span>(x1[i],  y1[i],  z1[i])]   += d[i];<br>        D[<span class="hljs-built_in">num</span>(x2[i]+<span class="hljs-number">1</span>,y1[i],  z1[i])]   -= d[i];<br>        D[<span class="hljs-built_in">num</span>(x1[i],  y1[i],  z2[i]+<span class="hljs-number">1</span>)] -= d[i];<br>        D[<span class="hljs-built_in">num</span>(x2[i]+<span class="hljs-number">1</span>,y1[i],  z2[i]+<span class="hljs-number">1</span>)] += d[i];<br>        D[<span class="hljs-built_in">num</span>(x1[i],  y2[i]+<span class="hljs-number">1</span>,z1[i])]   -= d[i];<br>        D[<span class="hljs-built_in">num</span>(x2[i]+<span class="hljs-number">1</span>,y2[i]+<span class="hljs-number">1</span>,z1[i])]   += d[i];<br>        D[<span class="hljs-built_in">num</span>(x1[i],  y2[i]+<span class="hljs-number">1</span>,z2[i]+<span class="hljs-number">1</span>)] += d[i];<br>        D[<span class="hljs-built_in">num</span>(x2[i]+<span class="hljs-number">1</span>,y2[i]+<span class="hljs-number">1</span>,z2[i]+<span class="hljs-number">1</span>)] -= d[i];<br>    &#125;<br>    <span class="hljs-comment">//下面从x、y、z三个方向计算前缀和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=A; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=B; j++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;C; k++)        <span class="hljs-comment">//把x、y看成定值，累加z方向</span><br>                D[<span class="hljs-built_in">num</span>(i,j,k+<span class="hljs-number">1</span>)] += D[<span class="hljs-built_in">num</span>(i,j,k)];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=A; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=C; k++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;B; j++)        <span class="hljs-comment">//把x、z看成定值，累加y方向</span><br>                D[<span class="hljs-built_in">num</span>(i,j+<span class="hljs-number">1</span>,k)] += D[<span class="hljs-built_in">num</span>(i,j,k)];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=B; j++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=C; k++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;A; i++)        <span class="hljs-comment">//把y、z看成定值，累加x方向</span><br>                D[<span class="hljs-built_in">num</span>(i+<span class="hljs-number">1</span>,j,k)] += D[<span class="hljs-built_in">num</span>(i,j,k)];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)    <span class="hljs-comment">//最后判断是否攻击值大于生命值</span><br>        <span class="hljs-keyword">if</span> (D[i]&gt;s[i])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;A, &amp;B, &amp;C, &amp;m);<br>    n = A*B*C;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;s[i]);  <span class="hljs-comment">//读生命值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)                      <span class="hljs-comment">//读每次攻击的范围，用坐标表示</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d%d%d%d&quot;</span>,&amp;x1[i],&amp;x2[i],&amp;y1[i],&amp;y2[i],&amp;z1[i],&amp;z2[i],&amp;d[i]);<br><br>    <span class="hljs-type">int</span> L = <span class="hljs-number">1</span>,R = m;      <span class="hljs-comment">//经典的二分写法</span><br>    <span class="hljs-keyword">while</span> (L&lt;R) &#123;     <span class="hljs-comment">//对m进行二分，找到临界值。总共只循环了log(m)次</span><br>        <span class="hljs-type">int</span> mid = (L+R)&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) R = mid;<br>        <span class="hljs-keyword">else</span> L = mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, R);  <span class="hljs-comment">//打印临界值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 前缀和/差分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找和二分答案</title>
      <link href="/2024/03/06/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
      <url>/2024/03/06/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="一.-题型分类">一. 题型分类</h1><p>信竞中有一个比较重要的知识点，就是二分查找与二分答案。下面说一下其中的题型和考法。</p><ul><li><p>题型A.在数组nums[]中查找是否有某个值key，如果找到有key就返回其下标值，如果没有找到key则返回-1。题目确保<strong>nums[]内的每个元素都是唯一的，离散可数的</strong>。这种题是二分查找最原始的题型，各大教材上均有介绍。</p></li><li></li><li><p>题型B.在数组nums[]中（<strong>数据不唯一，可存在多个相同的值</strong>），给定值key，按照如下要求进行查找：</p><ul><li>B1. 满足nums[i]&gt;=key的最小下标值 i</li><li>B2. 满足nums[i]&lt;=key的最大下标值 i</li><li>B3. 满足nums[i] &gt; key的最小下标值 i</li><li>B4. 满足nums[i] &lt; key的最大下标值 i</li><li></li></ul></li><li><p>题型C.并不存在所谓的nums[]数组，但需要在确定最小精度jd的情况下，在连续型区间[le,ri]中去找到符合题意要求的一个数值。如果用二分的方式来做，这种就叫做“二分答案”。le的下一个数是le+jd，再下一个数是le+2*jd，以此类推。</p></li><li><p>上面的这三种题型，并不存在严格的界限。例如在题型A中，如果要求在没有找到key值的情况下，返回nums[]中&gt;key的最接近的数，则这种与题型B1就非常接近了。但题型B1可适用于数据不唯一的情况，这一点是题型A不允许的。</p><p>题型A和B都具有离散型的数组nums[]，算法无非就是去找个下标。而题型C是要求在一个连续区间里找某个值，并不存在任何现成的数组。但其实，在已知精度jd值的情况下，我们是可以把一个原本可以无限分割的连续区间视为一个具有有限数据个数的离散数据区间的。</p><p>这三种题型，能不能整合成一份代码模板呢？当然是可以的。</p><p>题型A和B，我们可以视为精度值jd=1。</p><p><span id="jump1">假设</span>现在需要在区间[a,b]中找出符合条件f(x)&lt;=key的最大值x，精度jd=0.01</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span>&#123;<br>    <span class="hljs-comment">// 这是一个单调递增函数，x越大，f(x)越大。不同的题，这个映射关系会不同，但必须是单调递增关系。</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">3</span>*x*x*x + <span class="hljs-number">4</span>*x - <span class="hljs-number">2</span>;   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(x) &lt;= key;   <span class="hljs-comment">// 根据题意会不同</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">double</span> le, ri)</span></span>&#123;<br><span class="hljs-type">double</span> le=a-jd, ri=b+jd;  <span class="hljs-comment">// 开区间 </span><br><span class="hljs-keyword">while</span> (le + jd &lt; ri) &#123;  <span class="hljs-comment">// 注意，是小于，+1是离散数组查找的标准写法 </span><br><span class="hljs-type">double</span> mid = le + (ri-le&gt;&gt;<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid))  <span class="hljs-comment">// 因为本题要查找第一个出现key的下标值，所以是&gt;=key， </span><br>A = mid;     <span class="hljs-comment">// 此处的 A 是re或是le，因题而已。关键看是砍掉左半或者右半。 </span><br><span class="hljs-keyword">else</span><br>B = mid;     <br>&#125;<br>    <span class="hljs-keyword">return</span> A;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>首先，在这个模板中，最关键的就是这个check函数的书写。往往我们需要根据提供的x来计算出y值，计算方法就是通过模拟题目中给出的过程描述来计算，这个y值往往会是计数型、求和型、是否型等。在计算时往往会和“前缀和、贪心、DP、搜索”等其他专门的算法进行搭配，从而加深题目难度。</p><p>其次，我们需要根据y与x之间的变化关系，在二维坐标系上画出其对应的曲线或者图像，然后根据题意标注出可行解的范围（即可行区域）。那如何确定出最优解的位置呢？如果可行区域是往右拓展的(&gt;=...)，那么此时一定是取最小值（取&gt;=...的最小值）；反之，如果可行区域是往左拓展的，那一定是取最大值（取&lt;=...的最大值）。</p></li></ul><h1 id="二.-案例练习">二. 案例练习</h1><h2 id="p2249-深基13.例1查找">2.1 P2249 【深基13.例1】查找</h2><p>原题链接：<a href="https://www.luogu.com.cn/problem/P2249">P2249【深基13.例1】查找</a></p><p>这个题不属于题型A，也不属于题型B。允许数据重复，但又要求精确相等，所以在不相等（没找到）时，要求返回-1。也就是说，存在查找失败的情况。但是可以用上述模板来套。因为是给定数组，离散，所以jd=1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> d[<span class="hljs-number">1000001</span>], key, jd=<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> n, t;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> d[x] &gt;= key;    <span class="hljs-comment">// 要查找最小(第一个，最左)的下标值，所以只能是&gt;=key。不能写成==key！要二分</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br><span class="hljs-type">int</span> i;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;t);<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++) <br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;d[i]);<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=t; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;key);<br><span class="hljs-type">int</span> le=<span class="hljs-number">1</span>-jd, ri=n+jd;  <span class="hljs-comment">// le和ri设定在[1,n]之外，开区间 </span><br><span class="hljs-keyword">while</span> (le + jd &lt; ri) &#123;  <span class="hljs-comment">// 注意，是小于，+1是离散数组查找的标准写法 </span><br><span class="hljs-type">int</span> mid = le+ (ri-le&gt;&gt;<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> ( <span class="hljs-built_in">check</span>(mid) ) <span class="hljs-comment">// 如果mid是合法的   </span><br>ri = mid;  <span class="hljs-comment">// 就继续找第一个（最左,最小）解，下标尽量缩小，应ri=mid（砍右半段） </span><br>                            <span class="hljs-comment">// 此处可以看出，本题中，ri存解</span><br><span class="hljs-keyword">else</span> le = mid;     <br>&#125;<br><span class="hljs-comment">//  本题要查找第一个&gt;=key的下标值，有两种情况可能出现“找不到”</span><br><span class="hljs-comment">// 1.  所有数都&lt;key，此时ri仍=n+1，但经过整个while后，le不断右移到n，而ri一步都没左移过</span><br><span class="hljs-keyword">if</span> (ri ==n+jd)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1 &quot;</span>);  <br><span class="hljs-comment">// 2.  &gt;=key的左侧第一个数存在，但并不是key，这种情况下，意味着数组中并没有key这个数</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d[ri] != key)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1 &quot;</span>);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, ri); <span class="hljs-comment">// check(mid)若成立，表示mid合法，ri=mid，所以最终解存于ri中！ </span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分法求函数的零点">2.2 1241：二分法求函数的零点</h2><p>原题链接：<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1241">1241：二分法求函数的零点</a></p><p>有函数：<spanclass="math inline">\(f(x)=x^5-15x^4+85x^3-225x^2+274x-121\)</span></p><p>已知<spanclass="math inline">\(f(1.5)&gt;0,f(2.5)&lt;0\)</span>，且方程<spanclass="math inline">\(f(x)=0\)</span>在区间[1.5,2.5]有且只有一个根，请用二分法求出该根，要求四舍五入到小数点后6位。</p><p>分析：</p><p>这是在实数区间进行二分查找的一个典型入门题。可以看出<spanclass="math inline">\(f(x)\)</span>是一个<strong>连续</strong>的函数。也就是说，随着<spanclass="math inline">\(x\)</span>值的微调，<spanclass="math inline">\(f(x)\)</span>的值只是微微变化一点点，不存在函数值骤变的情况（比如分段函数）。再根据题意，方程<spanclass="math inline">\(f(x)=0\)</span>在区间[1.5,2.5]有且只有一个根，也就是说，随着<spanclass="math inline">\(x\)</span>从1.5慢慢往2.5增大，<spanclass="math inline">\(f(x)\)</span>的值会逐渐变小，直到当x等于某个实数时，<spanclass="math inline">\(f(x)\)</span>的值恰好等于0（在保留6位有效小数的精度要求下）。所以，可以看出，<spanclass="math inline">\(f(x)\)</span>在[1.5,2.5]这个区间内是单调递减的，是可以用二分查找来搞定的。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240309170306887.png" style="zoom: 67%;" /></p><ul><li>如果出现图（1）f(le)*f(mid)&lt; 0的情况，说明曲线与x轴的交点必然在mid点的左侧，此时应放弃区间右半段，即应做ri=mid;</li><li>如果出现图（2）f(le)*f(mid)&gt; 0的情况，说明曲线与x轴的交点必然在mid点的右侧，此时应放弃区间左半段，即应做le=mid;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1238-1241-1246 三个题合在一起看！</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x*x*x*x*x - <span class="hljs-number">15</span>*x*x*x*x + <span class="hljs-number">85</span>*x*x*x - <span class="hljs-number">225</span>*x*x + <span class="hljs-number">274</span>*x - <span class="hljs-number">121</span>;<br>&#125;<br><span class="hljs-comment">// 此处用ri和mid来做也可以，传参和while内砍掉需要调整</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> le, <span class="hljs-type">double</span> mid)</span></span>&#123;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-built_in">f</span>(le) * <span class="hljs-built_in">f</span>(mid)  &lt; <span class="hljs-number">0</span> ; <span class="hljs-comment">// 如果二分后左半段有解，</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> jd=<span class="hljs-number">1e-8</span>;    <span class="hljs-comment">// 要求精度是1e-6，计算时建议降低2个数量级，取对数后不会耗太多，可更精准 </span><br>                       <span class="hljs-comment">// 这里多做几轮，没关系。填1e-9, 1e-10都影响不太大。 </span><br>    <span class="hljs-type">double</span> mid, le = <span class="hljs-number">1.5</span>-jd, ri = <span class="hljs-number">2.5</span>+jd;<br>    <span class="hljs-keyword">while</span>( le + jd &lt; ri)  <br>    &#123;<br>        mid = ( ri + le ) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 实数折半不适合位操作，只好硬除2</span><br>        <span class="hljs-keyword">if</span>( <span class="hljs-built_in">check</span>(le, mid)  ) <br>ri = mid;   <span class="hljs-comment">// 如果左半段有解，砍掉右半部份 </span><br>        <span class="hljs-keyword">else</span> <br>le = mid;   <span class="hljs-comment">// 说明解在右半部份区间，应该收敛左端点 </span><br>    &#125;<br>    <span class="hljs-comment">// 对实数做二分时，当le和ri的差异小于jd时，实际上就不分彼此,视为同一个数了 </span><br>    <span class="hljs-comment">// 本题的取值范围是[1.5, 2.5],不会输出&quot;-0.000000&quot;这种答案,按格式要求打印le或ri即可  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6lf&quot;</span>, ri ); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p1024-noip2001-提高组-一元三次方程求解">2.3 P1024 [NOIP2001提高组] 一元三次方程求解</h2><p>原题链接：<a href="https://www.luogu.com.cn/problem/P1024">P1024[NOIP2001 提高组] 一元三次方程求解</a></p><p>分析：根据题意可以得知以下几点：</p><p>1）函数是一个连续函数；</p><p>2）函数在[-100.0,100.0]范围内有3个实数根，且根相互之间间隔至少1.0，不存在两根靠太近的情况；</p><p>3）要求精度jd=1e-2，故计算精度可以设为1e-4。</p><p>根据2）的分析，我们可以把[-100.0， 100.0]分为[-100.0， -99.0],[-99.0，-98.0]，……等200个宽度为1的实数区间，然后依次判断这200个区间是否存在解点。（f(le)*f(ri)&lt;0），如果存在解点，则本题演变为2.2节的内容，可再按照精度jd=1e-4来套入1241题的算法即可。</p><p>需要注意一点，假设f(3)=0，那么x=3这个点在区间[2,3]和[3,4]中都会被判为有解，从而计算重复。要解决这个问题，可以先对200个区间的左端点（或右端点）进行单判，对剩余的双开区间，即(-100,-99)，(-99,-98),……，进行筛选。二分查找时每个区间为[i+jd,i+1-jd]。最后再单判x=-100和x=100。</p><p>需要注意的是，我们的这个模板要求le和ri的初值设定为区间左右端之外，所以应该是le=i+jd-jd=i,ri=i+1-jd+jd=i+1;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-type">double</span> a,b,c,d;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a*x*x*x+b*x*x+c*x+d;<br>&#125;<br><span class="hljs-comment">// 已经过筛选，le和mid不会是零解，所以不需要&lt;=0 </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> le, <span class="hljs-type">double</span> mid)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(le) * <span class="hljs-built_in">f</span>(mid)&lt; <span class="hljs-number">0</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">double</span> le, ri, mid, y1, y2, jd=<span class="hljs-number">1e-4</span>;<br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>, i;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf%lf%lf&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);  <span class="hljs-comment">//输入</span><br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">-100</span>; i&lt;=<span class="hljs-number">99</span>; i++) &#123;<br>le = i;  <br>ri = i + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>( <span class="hljs-built_in">fabs</span>(<span class="hljs-built_in">f</span>(le) ) &lt; <span class="hljs-number">1e-20</span> ) &#123; <span class="hljs-comment">// 先单独判断左端点/或者右端点 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf &quot;</span>, le);    <span class="hljs-comment">// 若是解，直接输出。</span><br>cnt++;<br><span class="hljs-keyword">continue</span>;<br>&#125;      <br><span class="hljs-keyword">if</span>( <span class="hljs-built_in">check</span>(le, ri) ) &#123;      <span class="hljs-comment">// (le, ri)开区间内有根。</span><br><span class="hljs-comment">// 既然肯定有解，肯定能找到，当while跳出来时就是找到解之时 </span><br><span class="hljs-keyword">while</span>( le + jd &lt; ri) &#123;       <br>mid = ( le + ri ) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>( <span class="hljs-built_in">check</span>(le, mid) )  <span class="hljs-comment">// 如果解在(le, mid)之间(=0的情况已经筛过，不需要再写) </span><br>ri = mid;    <span class="hljs-comment">// 砍掉右半 </span><br><span class="hljs-keyword">else</span>                    <br>le = mid;   <br>&#125;<br><span class="hljs-comment">// 当le和ri差值小于jd时，视为相等，方程解就是le或ri。本题不存在查找失败的情况 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf &quot;</span>, ri);     <br>cnt++;<br>&#125;<br><span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">3</span>)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">//找到三个就退出大概会省一点时间</span><br>&#125;<br><span class="hljs-keyword">if</span> ( <span class="hljs-built_in">fabs</span>(<span class="hljs-built_in">f</span>(<span class="hljs-number">100</span>)) &lt; <span class="hljs-number">1e-20</span> )<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf &quot;</span>, <span class="hljs-number">100.0</span>); <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p1163-银行贷款">2.4 P1163 银行贷款</h2><p>原题链接：<a href="https://www.luogu.com.cn/problem/P1163">P1163银行贷款</a></p><p>分析：</p><p>(1): 每个月还款的现值为如下:</p><p><span class="math display">\[\frac{w}{1+p}  +  \frac{w}{(1+p)^2}  +  +  \frac{w}{(1+p)^3}  + ...+  \frac{w}{(1+p)^m} \tag{1}\]</span></p><p>​ 如果p太大，(1)式会变小，是逆相关，单调递减。</p><p>(2): <strong>(1)式须要 &gt;=W。多还了钱没问题，少还了钱是不行的！</strong>……</p><p>分析的结论： <strong>本题是求满足 (1) &gt;= W的最大p值</strong>。(1)式是连续的且单调递减，所以可以用“二分答案”来暴力解决。</p><p>二分的范围是[0..3]，可以写成[0,5]都行，反正能lg(W)的速度快速收敛。本题没有说利率是否能为负数。实际上本题的测试样例都没有考虑负利率的问题，也就是说，测试样例全都满足<span class="math inline">\(w*m&gt;=w_0\)</span> 。</p><p>精度控制：题目要求精确到1e-3，计算时，jd取再低的两个数量级，即1e-5</p><p>本题的le初值&lt;0，使得终值可能也会&lt;0。所以需要处理-0.0的问题，应输出0.0才对</p><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> W, w, m;<br><span class="hljs-type">int</span> Left=<span class="hljs-number">0</span>, Right=<span class="hljs-number">3</span>; <span class="hljs-comment">//本题利率不可能为负数，且明说了最多可达300%，即3 </span><br><span class="hljs-type">double</span> jd = <span class="hljs-number">1e-5</span>;    <span class="hljs-comment">//题目要求精确到1e-3，计算时，jd取再低的两个数量级，即1e-5</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> p)</span> </span>&#123;<br>    <span class="hljs-type">double</span> money=<span class="hljs-number">0</span>, term= w;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++) &#123;<br>        term = term / (<span class="hljs-number">1</span>+p);<br>        money = money + term;<br>    &#125;<br>    <span class="hljs-keyword">return</span> money &gt;= W;     <span class="hljs-comment">// 还了钱没问题，少还了钱是不行的！</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>    <span class="hljs-type">double</span> le, ri, mid;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;W, &amp;w, &amp;m);<br><br>    le = Left-jd, ri = Right+jd;   <span class="hljs-comment">// 本题的利率可以大于1，是个坑点</span><br>    <span class="hljs-keyword">while</span> (le + jd  &lt; ri) &#123;<br>        mid = (le+ri)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">check</span>(mid) )  <span class="hljs-comment">// 模板，如果mid满足条件，</span><br>            le = mid;    <span class="hljs-comment">// 既然是求最大解，当可行时，砍掉左半段 </span><br>        <span class="hljs-keyword">else</span><br>            ri = mid;   <br>    &#125;<br>    <span class="hljs-comment">// le的初值&lt;0，使得终值可能也会&lt;0。所以此处需要处理-0.0的问题，应输出0.0才对 </span><br>    <span class="hljs-comment">// printf(&quot;%.1lf&quot;, -4.27791595e-06) 打印出来是-0.0 </span><br>    <span class="hljs-keyword">if</span> (le &lt; <span class="hljs-number">0</span> )<br>        le = <span class="hljs-number">0</span>; <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.1lf&quot;</span>, le*<span class="hljs-number">100</span>);   <span class="hljs-comment">// le是可行解，其实ri也是，间距已小于精度。打百分数形式，扩大100倍 </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入样例3：</span><br><span class="hljs-comment">1 1 1</span><br><span class="hljs-comment">正确输出：</span><br><span class="hljs-comment">0.0   // 若输出-0.0，是因为le为-4.27791595e-06，没落在精度的点上，这数离0更近，应视为0了 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输入样例5：</span><br><span class="hljs-comment">443423 23477 3767</span><br><span class="hljs-comment">正确输出：</span><br><span class="hljs-comment">5.3</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="p2440-木材加工二分答案求最大解">2.5 P2440木材加工——二分答案，求最大解</h2><p>原题链接：<a href="https://www.luogu.com.cn/problem/P2440">P2440木材加工</a></p><p>这是“二分答案”知识点的第2个入门题，求符合条件的<strong>最大</strong>解。本题不存在f(x)，但存在check(woodlen)函数，用来判断woodlen是否在可行解区间内。随着woodlen从小变大，每一根木材能被分割的段数之和会变小，所以woodlen和总段数之间是一个单调递减的映射关系，不存在“随着woodlen的增大，在某个区间内总段数不降反升”的非单调的映射关系。所以本题可以用“二分答案”的方式做暴力尝试来搞定。（这是很重要的分析鉴定过程，必须要有！）</p><p>check(x)在判断x是否为可行解的过程中，不再做代数运算，而是采用while循环等具体操作。此时一定注意check()函数的代码要吻合题意！</p><p>本题不存在nums[]数组（woods[]只是每根木料的长度，并不是分段的长度值）。我们需要在[1,1e8]这个区间范围内找到最合适的整数解，jd=1。题目求&gt;=k段的<strong>最大</strong>长度值，而不是最小（若要求最小长度值，直接=1就可以了，分段数最多，基本上肯定能&gt;=k，没必要去费心折半了）。<strong>既然是求最大，当找到可行解(check(mid)成立)的时候，我们应该尝试在二分的右侧区间去进一步细找，即砍掉左半部份，le=mid</strong>。代码末尾也应该是returnle，因为<strong>这种情况下的le始终是在可行解范围内的</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long         </span><br><span class="hljs-type">int</span> n, k, woods[maxn], jd=<span class="hljs-number">1</span>; <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> woodlen)</span></span>&#123;<br>LL cnt=<span class="hljs-number">0</span>;          <span class="hljs-comment">// cnt可能较大，应long long </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>cnt += woods[i]/woodlen;<br><span class="hljs-comment">// 只要得到的木头个数&gt;=k段，那么woodlen就视为一个可行解 </span><br><span class="hljs-keyword">return</span> cnt&gt;=k;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> le = <span class="hljs-number">1</span>-jd, ri = <span class="hljs-number">1e8</span>+jd;   <span class="hljs-comment">// 开区间，le和ri的初值一定要在可选范围[1..1e8]之外！ </span><br><span class="hljs-keyword">while</span> (le + <span class="hljs-number">1</span> &lt; ri)&#123;<br><span class="hljs-type">int</span> mid = le + (ri - le) / <span class="hljs-number">2</span>; <span class="hljs-comment">// int mid = le + (ri - le&gt;&gt;1);这样也行，但一定别忘了加括号 </span><br><span class="hljs-keyword">if</span> ( <span class="hljs-built_in">check</span>(mid) ) <span class="hljs-comment">// 如果mid值在可行解范围内 </span><br>le = mid;  <span class="hljs-comment">// 本题明确提出要“求出l的最大值”，所以当方案可行时，需要进一步扩大le值，以找到最大的可行的mid值 </span><br><span class="hljs-keyword">else</span><br>ri = mid;<br>&#125;<br><span class="hljs-keyword">return</span> le;  <span class="hljs-comment">// 在本题中，le一直都在可行区域内，le就是最终的答案 </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;woods[i]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">find</span>());<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="p1873-砍树-二分答案求最大解">2.6 P1873 砍树——二分答案，求最大解</h2><p>原题链接：<a href="https://www.luogu.com.cn/problem/P1873">P1873[COCI 2011/2012 #5] EKO / 砍树</a></p><p>这里的分析，和2.5节其实是高度相似的，可以作为对2.5节的巩固练习。</p><p>这是“二分答案”知识点的第3个入门题，仍然是求符合条件的<strong>最大</strong>整数解（伐木机锯片的最大的整数高度<spanclass="math inline">\(H\)</span>）。本题不存在f(x)，但存在check(h)函数，用来判断h是否在可行解区间内。随着h变大，切割下来的木材总米数会变小，所以h和总米数之间是一个单调递减的映射关系，不存在“随着h的增大，在某个区间内总米数不降反升”的非单调的映射关系。所以本题可以用“二分答案”的方式做暴力尝试来搞定。（这是很重要的分析鉴定过程，必须要有！）</p><p>check(h)在判断h是否为可行解的过程中，不再做代数运算，而是采用for循环等具体操作。此时一定注意check()函数的代码要吻合题意！sum&gt;=M时，h即为合法可行解之一，但不一定是最优解。</p><p>我们需要在[0,max(d[i])]这个区间范围内找到最合适的整数解，且jd=1。题目求&gt;=M米的<strong>最大</strong>高度值，而不是最小（若要求最小高度值，直接h=0，让锯子贴地锯下整棵树就可以了，得到的木材最多，基本上肯定能&gt;=M，没必要去费心折半了）。<strong>既然是求最大，当找到可行解(check(h)成立)的时候，我们应该尝试在二分的右侧区间去进一步细找，即砍掉左半部份，le=mid</strong>。代码末尾也应该是returnle，因为<strong>这种情况下的le始终是在可行解范围内的</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">这个题，有一百万棵树， 树高度值也到10^9，所以要注意哦!看先把树按照高度值进行排序？</span><br><span class="hljs-comment">然后再以高度值来做折半尝试，从而尽快找出合适的锯子高度</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">需要注意，本题数据接近int的极限，建议用LL来表示各种数据。本代码用时接近750ms </span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 1000001</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long  <span class="hljs-comment">// 本题的规模较大，不开longlong要见祖宗！ </span></span><br>LL N, M, maxh=<span class="hljs-number">0</span>;<br>LL d[MAX];<br><span class="hljs-comment">// 锯子如果位于高度h，能获得多少米的木材 </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(LL h)</span></span>&#123;<br>LL sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(LL i=N; i&gt;<span class="hljs-number">0</span>; i--)&#123;<br><span class="hljs-keyword">if</span> (d[i] &gt; h)<br>sum += d[i] - h;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">break</span>;<br>&#125; <br><span class="hljs-keyword">return</span> sum &gt;= M;   <span class="hljs-comment">// 题上说至少要M米的木材，能让sum&gt;=M就是可行的解h </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>LL i;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;N, &amp;M);<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=N; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;d[i]);<br><span class="hljs-keyword">if</span> (d[i] &gt; maxh)     <span class="hljs-comment">// 找出d[i]的最大值maxh，作为折半的上界，为程序提速 </span><br>maxh = d[i];<br>&#125;<br><span class="hljs-comment">// 如果不排序，在check()函数中的实际复杂度就会增大。排不排，都是O(nlgn )</span><br><span class="hljs-built_in">sort</span>(d+<span class="hljs-number">1</span>, d+<span class="hljs-number">1</span>+N);  <br><br><span class="hljs-type">int</span> jd=<span class="hljs-number">1</span>;      <span class="hljs-comment">// 锯子每次抬高或降低，都至少1米 </span><br>LL le=<span class="hljs-number">0</span>-jd, ri= maxh+jd, mid;  <br><span class="hljs-keyword">while</span> (le + jd &lt; ri )&#123;<br>mid = le + (ri-le&gt;&gt;<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> ( <span class="hljs-built_in">check</span>(mid) )  <span class="hljs-comment">// 如果mid是可行解，那需要进一步增大（本题是求最大解） </span><br>le = mid;<br><span class="hljs-keyword">else</span> <br>ri = mid;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, le);      <span class="hljs-comment">// le是可行解，ri不是。打印le </span><br> <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p2678-跳石头二分答案求最大解">2.7 P2678跳石头——二分答案，求最大解</h2><p>原题链接：<a href="https://www.luogu.com.cn/problem/P2678">P2678[NOIP2015 提高组] 跳石头</a></p><p>本题也是二分答案求最大解，和2.5、2.6节高度相似。需要注意的是不要被题面文字绕进去了。“使得选手们在比赛过程中的<strong>最短</strong>跳跃距离<strong>尽可能长</strong>。由于预算限制，组委会<strong>至多</strong>从起点和终点之间移走<span class="math inline">\(M\)</span>块岩石（不能移走起点和终点的岩石）。”这里的“最短距离”实际上对二分答案的模板并没有影响，“最短距离”影响的主要是check函数中对移走石头数量的统计过程。<strong>真正影响二分答案代码模板的是“尽可能长”（表示这是在求最大解），以及“至多”（表示移动石头数量不能超过M快，即应该&lt;=M，这是在check()函数中判断mid值是否为可行解的重要依据）</strong>。</p><p>关于这个跳跃距离的有效取值范围，一则不能原地跳，所以至少要为1；二则最多也就是从起点一步跳到终点，也就是说，跳跃距离为L。所以有效取值范围为[1,L]。应该在这个范围内去考虑二分答案。</p><p>坑点：终点位置的石头也应该参与判断和统计，但因为其无法删除（根据题意），所以如果此时要删石头，应该删pos[pre]位置的石头，计数器cnt仍然要++。请分析代码末尾块注释中的样例。</p><p>分析到位后，剩下的就是套模板了。AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, m, L, pos[maxn];<br><br><span class="hljs-comment">// check函数去除掉一些石头，使得剩下的所有石头之间的间距都 &gt;= dis，统计去掉的石头个数是否&lt;=M </span><br><span class="hljs-comment">// i从左往右，若pos[i] - pos[pre] &lt; dis，即若靠得太近，</span><br><span class="hljs-comment">// 则把第i个石头去掉（否则间距变得更小，dis不再是最小间距） </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> dis)</span></span>&#123;<br><span class="hljs-type">int</span> pre=<span class="hljs-number">0</span>, cnt=<span class="hljs-number">0</span>;<br><span class="hljs-comment">// 起点是第0块石头，不参与判断和统计 </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n+<span class="hljs-number">1</span>; i++)&#123;        <span class="hljs-comment">// 终点也参与判断和统计，要循环n+1次，[1, n+1]</span><br><span class="hljs-keyword">if</span> ( pos[i]-pos[pre] &lt; dis )&#123;  <span class="hljs-comment">// pre[0]=0</span><br>cnt++;   <span class="hljs-comment">// 移除第i个石头。当i是终点石头时，无法移除，此时算移除其左侧石头 </span><br>                      <span class="hljs-comment">// 且pre值不变，只存放保留下来的上一块（左侧）石头的下标 </span><br>&#125;<br><span class="hljs-keyword">else</span><br>pre = i; <span class="hljs-comment">// 间距符合要求，保留当前第i块石头，刷新pre值为i，以便后续算间距 </span><br>&#125;<br><span class="hljs-keyword">return</span> cnt&lt;=m;   <span class="hljs-comment">// 如果满足cnt&lt;=m，此时的dis值为可行解 </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;L, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;pos[i]);<br>pos[n+<span class="hljs-number">1</span>] = L;            <span class="hljs-comment">// 设置好起点和终点</span><br>pos[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> jd = <span class="hljs-number">1</span>, le = <span class="hljs-number">1</span> - jd, ri = L + jd;   <span class="hljs-comment">// 开区间 </span><br><span class="hljs-keyword">while</span> (le + jd &lt; ri)&#123;<br><span class="hljs-type">int</span> mid = le + (ri-le &gt;&gt;<span class="hljs-number">1</span>); <span class="hljs-comment">// 算术运算的优先级比移位操作的优先级高， </span><br><span class="hljs-keyword">if</span> ( <span class="hljs-built_in">check</span>(mid) )   <span class="hljs-comment">// 如果 mid是可行解，题意希望跳跃距离尽可能长，故砍掉左半段，le往中间靠 </span><br>le = mid;       <span class="hljs-comment">// 让le一直为可行解 </span><br><span class="hljs-keyword">else</span><br>ri = mid;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, le);       <span class="hljs-comment">// 既然le一直在可行解区域，当结束while时，此时的le就是最优解 </span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入： </span><br><span class="hljs-comment">8 3 1</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">4</span><br><span class="hljs-comment">7</span><br><span class="hljs-comment">正确输出： </span><br><span class="hljs-comment">2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">分析：</span><br><span class="hljs-comment">0  2  4   7 8 </span><br><span class="hljs-comment">#  #  #   # #</span><br><span class="hljs-comment">   X      X    最短间距为3时需要移除2块石头 </span><br><span class="hljs-comment">          X    最短间距为2时需要移除1块石头 </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="p1314-聪明的质监员最大化最小化可行解">2.8 P1314聪明的质监员——最大化/最小化可行解</h2><p>原题链接：<a href="https://www.luogu.com.cn/problem/P1314">P1314[NOIP2011 提高组] 聪明的质监员</a></p><p>视频讲解：<ahref="https://www.bilibili.com/video/BV128411M7GT/?vd_source=607514df4428a309d5130d87a0423d0c">A06二分答案 最好的套路</a>(16:37位置)</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240314145639360.png" style="zoom: 67%;" /></p><p>这是一个绿标题，所需知识为二分答案、数学公式的理解以及前缀和。绿标题考二分，其check函数一般都不会很简单，往往是其他一些知识的叠加。此处需要对题目文字说明一下：</p><p>1）给定m个区间<span class="math inline">\([l_i, r_i](1 \leq i \leqm)\)</span>；</p><p>2）<span class="math inline">\(w_j\)</span>、<spanclass="math inline">\(v_j\)</span>和<spanclass="math inline">\(s\)</span>都已明说了是整数，所以<spanclass="math inline">\(y_i\)</span>和<spanclass="math inline">\(y\)</span>都是整数。<spanclass="math inline">\(W\)</span>没有明说。实际上这个<spanclass="math inline">\(W\)</span>也是整数哈！建议开long long！</p><p>3）对于题目中的流程3里的公式中提到了"<span class="math inline">\([w_j\geq W]\)</span>"，当<span class="math inline">\(w_j \geqW\)</span>时，该中括号部分的值为1，否则为0。以题目中的样例#1为例，5个矿石的重量w[]分别为[1,2,3,4,5]，v[]=[5,5,5,5,5],假设W=3。那么对于第1个区间[1,5]有：<span class="math display">\[\begin{align*}y_1&amp;=\sum_{j=l_i}^{r_i}[w_j \geq W]\times\sum_{j=l_i}^{r_i}[w_j \geq W]v_j \\&amp;=\sum_{j=1}^{5}[w_j \geq 3] \times\sum_{j=1}^{5}[w_j \geq 3]v_j \\&amp;=\sum_{j=3}^{5}1 \times\sum_{j=3}^55 \\&amp;=3×15 \\&amp;=45\end{align*}\]</span></p><ol type="a"><li><p>对于第1、2个矿石，该式的值为0，不予考虑和计算。</p></li><li><p>对于重量<spanclass="math inline">\(\geq3\)</span>的第3、4、5个矿石，<spanclass="math inline">\([w_j \geq3]\)</span>的值为1，进行个数累加和v[]累加；</p></li></ol><p>题目中的<spanclass="math inline">\(y_i\)</span>公式是区间内多个矿石针对W计算后的结果值，不是某一个矿石的计算结果。</p><p>4）一批矿石的检验结果值<spanclass="math inline">\(y\)</span>是每个区间算出来的<spanclass="math inline">\(y_i\)</span>值的累加和。一方面，这里区间个数<spanclass="math inline">\(m\)</span>较大，达到了2e5。而3）中的公式内的求和，也能达到2e5，所以这里的<spanclass="math inline">\(y_i\)</span>和<spanclass="math inline">\(y\)</span>有可能会爆int，必须要上longlong。另一方面，对每个区间进行处理时又需要进行累加，所以应考虑使用“前缀和”这种手段来尽量简化3）中的公式计算复杂度，使其变成<spanclass="math inline">\(O(1)\)</span>最好。而这当中又涉及到了条件筛选（即那个<spanclass="math inline">\([w_j \geqW]\)</span>），所以应在做前缀和数组时就把这个条件考虑进去，而不是单纯的累加。处理方式应该是“如果<spanclass="math inline">\(w_j \geq W\)</span>条件成立，那么sn[i] = sn[i-1] +1, sv[i] = sv[i-1]+ v[i]; 否则的话，则<strong>应不加这个矿石，即sn[i] =sn[i-1], sv[i] = sv[i-1];</strong>”</p><p>5）根据题意，检验值<spanclass="math inline">\(y\)</span>已然是跟随<spanclass="math inline">\(W\)</span>的变化而变化（逆相关）。我们现在需要调整<spanclass="math inline">\(W\)</span>，使得y值尽可能接近（无论高低）预先给定的<spanclass="math inline">\(s\)</span>值，计算出<spanclass="math inline">\(y\)</span>和<spanclass="math inline">\(s\)</span>之间的最小差距值（取绝对值）。本题并不求<spanclass="math inline">\(W\)</span>，而是要去求最接近<spanclass="math inline">\(s\)</span>的<spanclass="math inline">\(y\)</span>值。因为<spanclass="math inline">\(y\)</span>和<spanclass="math inline">\(W\)</span>是逆相关的关系，单调递减，所以可以考虑使用二分答案来暴力地找到。因为<spanclass="math inline">\(W\)</span>是整数，所以二分答案模板中的jd=1，而y值必然随着W的增大而出现离散地变小，其中必然会存在某1个y点到s点的纵向距离最小，或者某2个y点到s点的纵向距离同时达到最小。</p><p>所以，我们只需要在二分答案的过程中，即在check()函数中算出距离值，然后求出其最小的那一个距离值就可以了。这个操作算是check()函数的副产品。这里有一个重要的问题需要想清楚，即check()函数算出y值之后，check函数最后是returny&lt;=s; 或者return y&gt;=s; ?</p><p>我们假设在s线及以下为有效点（check()函数中写为returny&lt;=s;）。根据这个假设，我们的二分答案法最终能找到矮于s这条线的最小点D点（我们要找符合y&lt;=s的最大y点，而y和W是逆相关，所以就是找符合y&lt;=s的最小的W点，即D点）。上图展示了两种情况，我们分别来看。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240315094550221.png" style="zoom:67%;" /></p><p>A.在左图中，D点为二分的最优解。在确认D是最优的之前，代码模板肯定会先计算check(C点)，算出一个距离值，然后判定C点无效（）。这里是先算check(C)或者先算check(D)呢？顺序是不确定的，但其实也并不重要。无论何种顺序，必然是在C和D都check过之后才确定出D是最优解。既然C和D都必然要被check，各自算个距离，找出最小距离值，即本题答案ans。</p><p>B.右图的处理过程和左图其实是一样的。在确定D为最优解之前，C和D都会被check，谁前谁后都不重要，关键是都会被调用。既然会被调用，那么就肯定能确定C到s的距离最短，是本题答案。</p><p>如果check函数写成return y&gt;=s;是否可行呢？我们来看看。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240315095110494.png" style="zoom:67%;" /></p><p>A.在左图中，C点为二分的最优解。在确认C是最优的之前，代码模板肯定会先计算check(D点)，算出一个距离值，然后判定D点无效（）。顺序仍然并不重要。无论何种顺序，必然是在C和D都check过之后才确定出C是最优解。既然C和D都必然要被check，各自算个距离，找出最小距离值，即本题答案ans。</p><p>B.右图的处理过程和左图是一样的。在确定C为最优解之前，C和D都会被check，谁前谁后都不重要，关键是都会被调用。既然会被调用，那么就肯定能确定C到s的距离最短，是本题答案。</p><p>综合y&lt;=s和y&gt;=s的两种情况的AB分析，我们得出结论，check函数最后那句代码，写成returny&lt;=s;或者returny&gt;=s;都是可以的。<del>好像分析总结了个寂寞……</del></p><p>完整的AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">d41里对这个题讲的比较清楚透彻，比洛谷题解详细。可以看看</span><br><span class="hljs-comment">*/</span> <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br>  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, w[maxn], v[maxn], L[maxn], R[maxn], jd=<span class="hljs-number">1</span>;<br>LL s, sn[maxn], sv[maxn], ans = <span class="hljs-number">1e18</span>;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> W)</span></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++) sn[i] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++) sv[i] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br><span class="hljs-keyword">if</span> (w[i] &gt;= W )<br>sn[i] = sn[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>, sv[i] = sv[i<span class="hljs-number">-1</span>]+ v[i];<br><span class="hljs-keyword">else</span><br>sn[i] = sn[i<span class="hljs-number">-1</span>], sv[i] = sv[i<span class="hljs-number">-1</span>];<br><br>LL y=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)<br>y += (sn[ R[i] ] - sn[ L[i]<span class="hljs-number">-1</span> ])  *  ( sv[ R[i] ] - sv[ L[i]<span class="hljs-number">-1</span> ] ); <br><br>ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">llabs</span>(y-s));    <span class="hljs-comment">//  ans是一个LL哦 </span><br><br><span class="hljs-comment">// 题上要求靠s越近越好，此处假设&lt;=s为true，其实&gt;=s或者&lt;=s为true都没问题，</span><br><span class="hljs-comment">// 因为本题关键不是求le或者ri，而是求ans。不管&lt;=s或&gt;=s，都需要经过check()的不断</span><br><span class="hljs-comment">// 调用才能不断缩小区间，直到退出while。在这个过程中ans已经得到正确的最小值。 </span><br><span class="hljs-keyword">return</span> y&lt;=s;  <br>&#125;<br><br><span class="hljs-function">LL <span class="hljs-title">find</span><span class="hljs-params">()</span></span>&#123;       <span class="hljs-comment">// 本题不开long long要见祖宗～～～ ans是一个LL哦！～ </span><br><span class="hljs-type">int</span> le = <span class="hljs-number">0</span>-jd, ri = <span class="hljs-number">1e6</span>+jd;<br><span class="hljs-keyword">while</span> (le + jd &lt; ri)&#123;<br><span class="hljs-type">int</span> mid = le + (ri-le)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> ( <span class="hljs-built_in">check</span>(mid) )  <span class="hljs-comment">//  W和y逆相关。本题假设y&lt;=s为true，在这种情况下， </span><br>ri = mid;      <span class="hljs-comment">//  就需要求最大的合法y，即最小的合法W。合法时砍掉右半段，所以ri要往左靠 </span><br><span class="hljs-keyword">else</span><br>le = mid; <br>&#125;<br><span class="hljs-keyword">return</span> ans;            <span class="hljs-comment">// 既然二分的最优解拿来无用，干脆直接返回最小距离值得了。 </span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%lld&quot;</span>, &amp;n, &amp;m, &amp;s);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;w[i], &amp;v[i]);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;L[i], &amp;R[i]);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, <span class="hljs-built_in">find</span>());   <span class="hljs-comment">// 这个差值可以是一个long long </span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：find函数是<spanclass="math inline">\(O(logW)\)</span>的，check函数是<spanclass="math inline">\(O(3n+m)\)</span>的。n和m都是2e5级别，<spanclass="math inline">\(W\)</span>是1e6级别，所以整个程序的复杂度是<spanclass="math inline">\(O(4n*logW)=4*2e5*log(1e6)=8e5*20=160*e5=1.6e7\)</span>，能过。</p><p>后语：这个题是一个绿标题，回头来看这个题的代码，其实最难的部分是对公式的理解，以及check函数的实现。“二分答案”的代码框架在本题中并没有什么变化，find函数就是个裸板子。不要怕绿标题！</p><h2 id="p1083-借教室最大化可行解">2.9 P1083 借教室——最大化可行解</h2><p>原题链接：<a href="https://www.luogu.com.cn/problem/P1083">P1083[NOIP2012 提高组] 借教室</a></p><p>视频讲解链接：<ahref="https://www.bilibili.com/video/BV128411M7GT/?vd_source=607514df4428a309d5130d87a0423d0c">A06二分答案 最好的套路</a>(25:10位置)</p><p>这是个黄标题，但难度实际上已经接近绿标题了。题目文字多，难理解题意。下面先搞清楚样例输出是如何得来的。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240315110134567.png" style="zoom:67%;" /></p><p>输入样例：</p><p>共4天 共3个订单</p><p>1～4天的可供教室个数[2个教室 5个教室 4个教室 3个教室]</p><p>第1个订单要2个教室，从第1天到第3天</p><p>第2个订单要3个教室，从第2天到第4天</p><p>第3个订单要4个教室，从第2天到第4天</p><p>输出样例：</p><p>-1 （无法全部满足）</p><p>2 （需要修改第2个订单）</p><p>这个输出是怎么得来的呢？此时我们最好是静下心来，耐心地模拟一下数据。</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">第1天</th><th style="text-align: center;">第2天</th><th style="text-align: center;">第3天</th><th style="text-align: center;">第4天</th><th style="text-align: center;">第5天</th><th style="text-align: center;">复杂度</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">可供教室个数</td><td style="text-align: center;">2</td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">3</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">第0单</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">第1单</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;"><spanclass="math inline">\(O(n)\)</span></td></tr><tr class="even"><td style="text-align: center;">第2单</td><td style="text-align: center;">2</td><td style="text-align: center;">5</td><td style="text-align: center;"><font color=red size=5>5</font></td><td style="text-align: center;">3</td><td style="text-align: center;">0</td><td style="text-align: center;"><spanclass="math inline">\(O(n)\)</span></td></tr></tbody></table><p>在第2单时，第3天无法提供5个教室，所以输出-1和2。样例讲解完毕。</p><p>下面开始分析解法：</p><p>这个题，直觉思维肯定是去暴力模拟，实现上述这个矩阵的填写过程。矩阵的行数就是总单数<spanclass="math inline">\(m\)</span>，列数为总天数<spanclass="math inline">\(n\)</span>。在决定暴力之前，我们应先看数据范围，发现<spanclass="math inline">\(m\)</span>和<spanclass="math inline">\(n\)</span>都是1e6的级别，每个区间的范围<spanclass="math inline">\(s_j\)</span>和<spanclass="math inline">\(t_j\)</span>也是<span class="math inline">\(1\leqs_j \leq t_j \leqn\)</span>的。如果从上往下，从左往右填写这个矩阵每个元素的值，时间复杂度为1e12，早就TLE了。（空间复杂度不需要1e12这个级别，只需要长度为总天数<spanclass="math inline">\(n\)</span>的一个一维数组即可。）根据题目提供的数据范围，直接暴力只能得30分。有没有更好的暴力做法呢？</p><p>仔细分析题目中的数据输入，我们可以发现，每次来一个新订单，我们需要在一个区间内去累加一个固定的数，区间的个数和区间的范围都很大，这很像差分啊！能否用一维差分来模拟呢？试试看！</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">第1天</th><th style="text-align: center;">第2天</th><th style="text-align: center;">第3天</th><th style="text-align: center;">第4天</th><th style="text-align: center;">第5天</th><th style="text-align: center;">复杂度</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">可供教室个数</td><td style="text-align: center;">2</td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">3</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">第0单</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">第1单</td><td style="text-align: center;">2</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">-2</td><td style="text-align: center;">0</td><td style="text-align: center;"><spanclass="math inline">\(O(1)\)</span></td></tr><tr class="even"><td style="text-align: center;">第2单</td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><font color=red size=5>0</font></td><td style="text-align: center;">0</td><td style="text-align: center;">-3</td><td style="text-align: center;"><spanclass="math inline">\(O(1)\)</span></td></tr></tbody></table><p>通过这样的方式，我们可以把一个原本为<spanclass="math inline">\(O(m*n)=1e12\)</span>的操作，降为<spanclass="math inline">\(O(m)=1e6\)</span>的操作。看着好像很棒！但这样做存在一个问题，即数据不能直观地反映出“无法满足所有订单”。例如，在第2单加入后，我们如何得知第3天无法满足呢？唯一的做法就是根据当前的差分数组，还原出其对于的基本数组。但是这个过程，是一个<spanclass="math inline">\(O(n)=1e6\)</span>的过程。如果针对每个订单加入后都去做这样的还原，再来判断是否满足，这样的差分是不彻底的，并没有达到降低时间复杂度的实效，时间复杂度仍然是1e12。我们不能每加一个新单就去做还原和比较，那该怎么办呢？</p><p>我们可以注意到，根据题意，如果在前<spanclass="math inline">\(t\)</span>单加入后无法满足要求的话，那么第<spanclass="math inline">\(t\)</span>个后面的所有订单加入后必然也是无法满足要求的（因为原始数据全都是非负数，累加只会越来越大）；反之，如果在前<spanclass="math inline">\(t\)</span>单加入后能够满足要求，那么第<spanclass="math inline">\(t\)</span>个前面的订单必然是满足要求的。也就是说，订单的加入，和“是否满足”是存在一个单调性的。这种单调性，不是“变大”或者“变小”，而是一种“0/1”单调性，从“满足”变到“不满足”的单调性。这种单调性，使得我们仍然可以用“二分答案”来快速找到临界值。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240319110044813.png" style="zoom:67%;" /></p><p>如上图所示，x表示前x个订单，取值为1、2、3、……、m，y表示“是否满足”，取值为1（true）和0（false）。在本题中，因为x必须是整数，所以这个y和x对应的函数是离散的。我们的二分答案模板返回的是符合条件的x，所以可以先<strong>求出y=true时最大的x值</strong>，那么x+1就是所求答案了。</p><p>分析至此，基本上已经可以写出AC代码了，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">“差分数组+前缀和+二分答案”的题，</span><br><span class="hljs-comment">如果一个订单一个订单地去累加，O(m*n)，必定爆TLE</span><br><span class="hljs-comment">对前x个订单，采用check()来统计其是否满足供给需求。在其中，用差分数组叠加的方式来简化数据统计，check的效率从O(m*n)降为O(n+m)。再配上二分暴力尝试的O(logm)，所以算法总效率为O(logm * (n+m) ) </span><br><span class="hljs-comment"> 需要写check()，送入前x个订单，做出差分数组，还原成前缀和数组，同时判断是否满足。</span><br><span class="hljs-comment">*/</span> <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> r[maxn];         <span class="hljs-comment">// r[2] = 5 表示第2天能提供5间教室以出租 </span><br><span class="hljs-type">int</span> d[maxn];         <span class="hljs-comment">// d[3]=5 表示第3个订单要用5间教室，d[]都是正数 </span><br><span class="hljs-type">int</span> s[maxn], t[maxn];<span class="hljs-comment">// s[2]=3, t[2]=5表示第2个订单所需教室要用第3天用到第5天 </span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> num[maxn]; <span class="hljs-comment">// num[3]=4 表示到第3天时，需要增用4间教室； </span><br> <span class="hljs-comment">// num[6]=-2表示到第6天时，需要收回2间教室；</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-built_in">memset</span>(num, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> num);<br><span class="hljs-comment">// 差分！对前x个订单，在num[]中标记好差分数据，+di，-di </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=x; i++)&#123;<br>num[ s[i] ] += d[i];<br>num[ t[i]+<span class="hljs-number">1</span> ] -= d[i];<br>&#125;<br><br><span class="hljs-comment">// 对差分数组num[]原地还原出前缀和数组，算出前x个订单后，n天每天的教室需求总量 </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>num[i] += num[i<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">if</span> (num[i] &gt; r[i] ) <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <span class="hljs-comment">// 需求大于供给，爆掉 </span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;   <span class="hljs-comment">// x越小，则num[]最后越小，那越容易true </span><br>&#125;<br> <br><span class="hljs-comment">// 用二分查找的方式，返回满足check条件的最大下标值le </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> le=<span class="hljs-number">0</span>, ri = m+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (le + <span class="hljs-number">1</span> &lt; ri)&#123;<br><span class="hljs-type">int</span> mid= le + (ri - le)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> ( <span class="hljs-built_in">check</span>(mid) ) <span class="hljs-comment">// 如果满足，就尽量最大化 </span><br>le = mid;     <span class="hljs-comment">// 求最大化，砍掉左半段 </span><br><span class="hljs-keyword">else</span><br>ri = mid;<br>&#125;<br><span class="hljs-keyword">return</span> le; <br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;r[i]);  <span class="hljs-comment">// 一共n天 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;d[i], &amp;s[i], &amp;t[i]); <span class="hljs-comment">// 一共m个订单 </span><br><span class="hljs-type">int</span> pos = <span class="hljs-built_in">find</span>();<br><span class="hljs-comment">// 如果到第m个订单都不会爆，那就是全都符合啦，输出0 </span><br><span class="hljs-keyword">if</span> (pos == m)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0&quot;</span>);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n%d&quot;</span>, pos+<span class="hljs-number">1</span>);  <span class="hljs-comment">// find()返回的是满足不爆的最后那个订单编号，那下一个，+1就是要爆掉的订单编号了 </span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>后记：</p><p>回头来看这个题，它的“二分答案”的策略是比较隐蔽的。之所以采取“二分”，必须要分析意识到“每次加入一个订单后，马上就对差分数组进行还原”的效率会很差，进而才会去分析这个题的“前x个订单”和“是否满足”之间的单调性。</p><p>如果你深刻体会到了这一点，并且也已经学过了“差分二维差分”帖子，那么可以再挑战一下“<ahref="https://www.lanqiao.cn/problems/180/learning/">三体攻击</a>”这个题（三维差分+二分答案）。</p><h2 id="p1902-刺杀大使最小化可行解">2.10 P1902刺杀大使——最小化可行解</h2><p>原题链接：<a href="https://www.luogu.com.cn/problem/P1902">P1902刺杀大使</a></p><p>视频讲解链接：<ahref="https://www.bilibili.com/video/BV128411M7GT/?vd_source=607514df4428a309d5130d87a0423d0c">A06二分答案 最好的套路</a>(35:45位置)</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240315154748379.png" alt="image-20240315154748379"  /></p><p>这个题又是个绿标题，所用知识为二分答案+广搜，总体来说不算太难。题目文字很多，简化题意，以上图的样例来说，有一个5行3列的整数矩阵，第1排和第5排值都是0。每个点都能走到上下左右的其他各点，现在找一条不交叉的路线，从第一行的<strong>任意点</strong>出发，走到第5行的<strong>任意点</strong>结束，要求<strong>其经过的所有点的最大值要尽可能小</strong>，输出这个最小值。在样例中这条路径是“0-2-1-4-2-0”，最大值4，是所有路线中最小的了。</p><p>这种题想要找一条路线。我们的第一反应是“深搜”或者“广搜”。“广搜”一般主要用于在地图上找节点数<strong>最少</strong>的路径，不适用本题。“深搜”可以一边前进一边更新“经过的所有点的最大值”，但当对最大值点做回退操作时，需要把这条路径上的次大值作为最大值。也就是说，我们需要一直维护一个有序且能很方便地增删的堆，可能会是一个费时的操作（行1000，列1000，路径最长可达1e6个节点）。这是一个大坑，如果跳进去了，很有可能爬不出来。还有没有其他思路呢？</p><p>我们注意到每个伤害值都不大（<spanclass="math inline">\(\leq1000\)</span>），可以把这张地图比喻为每个怪的战斗值，而我自己肯定有一个战斗力值X。我们从第一行任意点出发，一路过关斩将，最终走到第n行。遇到菜鸡直接砍翻前进，遇到比自己更牛逼的boss就绕开它。“打得赢就打，打不赢就躲”。按照这样的思想，我们能走到第n行吗？很明显，这完全取决于我们的X有多大。我们可以假设一个X值，去试试看能不能走通。如果能，找到最小的这个X值，即为本题答案。</p><p>也就是说，我们需要假设X的值，然后去尝试：走得通就缩小X的值，走不通就增大X的值。这种暴力尝试，是基于一个单调性基础之上的。什么单调性呢？一条路，如果X的战力能走到底，那么X+1的战力值肯定更能走通；如果X战力值走不通，X-1肯定更不行。我们需要找到合法（能走通）的最小的X来。画出图来，就是下图：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240319110545629.png" style="zoom:67%;" /></p><p>这张图，看上去是不是有点似曾相似啊？不错，我们在2.9节中也有类似的图，也是在一种0-1类型的单调性关系中找临界点。所以实际上2.10节和2.9节的这两个题，其实都是同一类型的题。</p><p>每次当我们设定了一个X值之后，网格中所有&gt;X的节点就视为障碍不可通过，然后这个题就可以用“迷宫”的思路去做了，用广搜算法即可（广搜非常擅长于解决“能到/不能到”的问题）。每次广搜的复杂度为<spanclass="math inline">\(O(1e6)\)</span>，二分答案的复杂度为<spanclass="math inline">\(log_2{1000}=10\)</span>，所以整个程序的复杂度是<spanclass="math inline">\(1e7\)</span>，能1秒内过。</p><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    二分答案的题，走迷宫的升级版，O(n*m*logP) ，P为矩阵元素的最大值 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1005</span>;<br><span class="hljs-type">int</span> dr[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> dc[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> n, m, p[maxn][maxn];<br><span class="hljs-type">bool</span> vis[maxn][maxn];<br><br><span class="hljs-comment">// 类似于二分答案里面的check() </span><br><span class="hljs-comment">// 表示从(r,c)点出发，途径的点值不能超过P，能不能走到第n行的任意列呢？</span><br><span class="hljs-comment">// 如果能，返回true，否则返回false </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> P)</span></span>&#123;<br><span class="hljs-keyword">if</span> (r == n) <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>vis[r][c] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++)&#123;<br><span class="hljs-type">int</span> nr = r + dr[i];<br><span class="hljs-type">int</span> nc = c + dc[i];<br><span class="hljs-keyword">if</span> (nr &gt;=<span class="hljs-number">1</span> &amp;&amp; nr &lt;=n &amp;&amp; nc &gt;=<span class="hljs-number">1</span> &amp;&amp; nc &lt;=m \<br>&amp;&amp; !vis[nr][nc] &amp;&amp; p[nr][nc]&lt;= P )&#123;<br><span class="hljs-keyword">if</span> ( <span class="hljs-built_in">check</span>(nr, nc, P) )<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 返回符合条件的最小值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> jd=<span class="hljs-number">1</span>, le= <span class="hljs-number">0</span>-jd, ri= <span class="hljs-number">1000</span>+jd;<br><span class="hljs-keyword">while</span> (le + jd &lt; ri)&#123;<br><span class="hljs-type">int</span> mid= le + (ri-le&gt;&gt;<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 这句memset不能忘，也不能放在check中，只能放在这里哟！～ </span><br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> vis);<br><span class="hljs-keyword">if</span> ( <span class="hljs-built_in">check</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, mid) ) <span class="hljs-comment">// 如果mid值合法，则取最小值， </span><br>ri = mid;           <span class="hljs-comment">// 砍掉右半部分 </span><br><span class="hljs-keyword">else</span><br>le = mid;<br>&#125;<br><span class="hljs-keyword">return</span> ri;                  <span class="hljs-comment">// ri是可行解中的最优解 </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r=<span class="hljs-number">1</span>; r&lt;=n; r++) <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>; c&lt;=m; c++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;p[r][c]);<br>&#125; <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-built_in">find</span>());<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 线性结构基础算法 </category>
          
          <category> 二分查找与二分答案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位操作（与、或、异或）方法详解</title>
      <link href="/2024/01/30/%E4%BD%8D%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%8E%E3%80%81%E6%88%96%E3%80%81%E5%BC%82%E6%88%96%EF%BC%89%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/01/30/%E4%BD%8D%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%8E%E3%80%81%E6%88%96%E3%80%81%E5%BC%82%E6%88%96%EF%BC%89%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="一.-按位与">一. 按位与（ &amp; ）</h1><h2 id="基本运算常识">1.1 基本运算常识</h2><p>参加运算的两个数据，按<strong>二进制位</strong>进行“与”运算。</p><p>运算规则：0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1;</p><p>即：<strong>两位同时为“1”，结果才为“1”，否则为0</strong></p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">AndOperator</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a &amp; b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 3&amp;5 即 0000 0011 &amp; 0000 0101 = 0000 0001  因此，3&amp;5的值得1</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">5</span>;<br>    cout&lt;&lt; <span class="hljs-built_in">AndOperator</span>(a, b) &lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：<strong>负数按补码形式参加按位与运算</strong>。</p><p>例如： -3 &amp; 5 　　　即 1111 1101 &amp; 0000 0101 = 0000 0101　　　因此，-3 &amp; 5的值得5</p><h2 id="与运算的小技巧">1.2 “与”运算的小技巧</h2><h3 id="清零">1.2.1 清零</h3><p>若想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。 例：3 &amp; 0 = 0</p><h3 id="提取一个数的指定位">1.2.2 提取一个数的指定位</h3><p>将一个数指定的某个或某些bit值设置为1，其余为0。</p><p>例：设 <span class="math inline">\(X = (1010 \ 1110)_2\)</span>，　　取X的低4位： 1010 <font color="red">1110</font> &amp; 0000<font color="yellow">1111</font> = 0000 <font color="red">1110</font>　　取X的第5位： 1010 <font color="red">1110</font> &amp; 0000<font color="yellow">1</font>000 = 0000<font color="red">1</font>000</p><h3 id="判断奇偶">1.2.3 判断奇偶</h3><p>根据未位是0还是1来决定该数的奇偶，若为0就是偶数，为1就是奇数。</p><p>因此可以用if (a &amp; 1 == 0)代替if (a % 2 ==0)来判断“a是不是偶数”。那判断“a是不是奇数”该怎么做呢？见下面的代码。</p><p>下面程序将输出0到100之间的所有奇数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i)&#123;  <br>    <span class="hljs-keyword">if</span> (i &amp; <span class="hljs-number">1</span>)   <span class="hljs-comment">// 等效于 if (i % 2) 或者 if ( i % 2 == 1)</span><br>        cout&lt;&lt; i &lt;&lt;endl;<br>&#125; <br></code></pre></td></tr></table></figure><h1 id="二.-按位或">二. 按位或（|）</h1><h2 id="基本运算常识-1">2.1 基本运算常识</h2><p>参加运算的两个对象，按二进制位进行“或”运算。</p><p>运算规则：0|0=0； 0|1=1； 1|0=1； 1|1=1；</p><p>即 ：<strong>参加运算的两个对象只要有一个为1，其值为1</strong>。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">OrOperator</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a | b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 3|5 即 0000 0011 | 0000 0101 = 0000 0111  因此，3|5的值得7</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">5</span>;<br>    cout&lt;&lt; <span class="hljs-built_in">OrOperator</span>(a, b) &lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：<strong>负数按补码形式参加按位或运算</strong>。</p><p>例如： -3 | 5 　　　即 <strong>1111 1101</strong> | 0000 0101 = 11111101 　　　因此，-3 | 5的值为-3</p><h2 id="或运算的小技巧">2.2 “或”运算的小技巧</h2><h3 id="常用来将一个数的-指定bit设置为1">常用来将一个数的指定bit设置为1</h3><p>例：将<span class="math inline">\(X=(1010\ 0000)_2\)</span>的低4位置1，用 <font color="red">1010</font> 0000 | 0000<font color="yellow">1111</font> = <font color="red">1010</font>1111即可得到。</p><h1 id="三.-按位异或">三. 按位异或（^）</h1><h2 id="运算规则及推论">3.1 运算规则及推论</h2><h3 id="运算规则">3.1.1 运算规则</h3><p>“异或”运算的<strong>数学</strong>表达符号是“<strong><spanclass="math inline">\(\oplus\)</span></strong>”，或者“<strong>xor</strong>”。例如<span class="math inline">\(a \oplus b \oplus c\)</span>，或者<spanclass="math inline">\(a\,\,xor\,\,b\,\,xor\,\, c\)</span></p><p>“异或”运算的C++代码书写符号是'^'。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>, b=<span class="hljs-number">-8</span>;<br><span class="hljs-type">int</span> c= a ^ b;<br></code></pre></td></tr></table></figure><p>参加运算的两个数据，按二进制位进行“异或”运算：</p><p>0^0=0； 0^1=1； 1^0=1； 1^1=0；</p><p>即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">XOR</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a ^ b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 3^5 即 0000 0011 ^ 0000 0101 = 0000 0111  因此，3|5的值得6</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">5</span>;<br>    cout&lt;&lt; <span class="hljs-built_in">XOR</span>(a, b) &lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="相关的重要推论">3.1.2 相关的重要推论</h3><p>假如有两个int或者char变量，分别为a和b，则有：</p><p>（1）交换律 <span class="math display">\[a \oplus b = b \oplus a\]</span> （2）结合律 <span class="math display">\[a \oplus b \oplus c = a \oplus (b \oplus c)\]</span> （3）任何数a与0异或后结果是a自己 <span class="math display">\[a \oplus 0 = a\]</span> （4）任何数a与自己异或后结果是0 <span class="math display">\[a \oplus a = 0\]</span></p><h2 id="异或运算的小技巧">3.2 “异或”运算的小技巧</h2><h3 id="使特定bit翻转其余bit不变">3.2.1使特定bit翻转，其余bit不变</h3><p>假如现在有一个X，想将其指定的某些bit值进行翻转，该怎么做呢？很简单，找到一个数Y，对应X要翻转的各位，该数Y的对应位为1，Y的其余位为零，此数与X做异或运算即可。例：<span class="math inline">\(X=(1010\1110)_2\)</span>，若要使X的低3位翻转，则用<font color="red">10101</font><font color="green">110</font> ^ 00000<font color="yellow">111</font> = <font color="red">10101</font><font color="green">001</font>即可得到。</p><h3 id="与0相异或保留原值">3.2.2 与0相异或，保留原值</h3><p>1010 1110 ^ 0000 0000 = 1010 1110。从上面的例题可以清楚的看到这一点。</p><h3 id="交换a和b的值">3.2.3 交换a和b的值</h3><p>交换两个整数a和b的值，不允许使用临时变量，该如何实现？用“异或”操作可以实现！但“异或”操作仅限于整数和char，不适用于double和结构体等类型。</p><p>这里只有a和b两个变量，但为了体现出变量因为时间先后而引起的值的差异，所以用a1和b1表示变量a和b的初始值，用a2和b2表示其经过更改后的值。数学步骤如下三步所示：</p><p><span class="math display">\[\begin{align*}(1)\qquad a2 &amp;= a1 \oplus b1\qquad\qquad\qquad\qquad\qquad\quad\end{align*}\]</span></p><p><span class="math display">\[\begin{align*}(2)\qquad b2 &amp;= \underline{a2} \oplus b1\\&amp;=(\underline{a1 \oplus b1})  \oplus b1\qquad (根据(1式))\\&amp;=a1\oplus (b1 \oplus b1)  \qquad(异或的结合律)\\&amp;=a1 \oplus 0\\&amp;=a1\end{align*}\]</span></p><p><span class="math display">\[\begin{align*}(3)\qquad a2&amp;= a2 \oplus \underline{b2} \\&amp;=(a1 \oplus b1)\oplus \underline{a1} \qquad(根据(1)、(2)式)\\&amp;=(b1 \oplus a1) \oplus a1\qquad\quad(交换律) \\&amp;=b1 \oplus (a1 \oplus a1)\qquad\quad(结合律) \\&amp;=b1 \oplus 0\\&amp;=b1 \\\end{align*}\]</span></p><p>其代码形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a, b;<br>cin &gt;&gt;a &gt;&gt;b;<br>a = a ^ b;  <span class="hljs-comment">// 这里三个赋值语句的左端变量，可以a、b、a；也可以b、a、b（体现出任意两个数）交换</span><br>b = a ^ b;  <span class="hljs-comment">// 右侧两个变量左右均可随意交换，因为“异或”满足交换律</span><br>a = a ^ b;<br>cout &lt;&lt;a &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;b;<br></code></pre></td></tr></table></figure><h2 id="强化练习">3.3 强化练习</h2><h3 id="p1469-找筷子">3.3.1 P1469 找筷子</h3><p>原题链接：<a href="https://www.luogu.com.cn/problem/P1469">P1469找筷子</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">给你 n 个数，求出现了奇数次的数（确保只有一个）的数值是多少? </span><br><span class="hljs-comment">n达到1e7，每个数的范围也很大，只能用O(n)的效率才能过，空间要求4MB，卡得很严，如果定义数组，很容易MLE</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">需要知道一个性质：</span><br><span class="hljs-comment">0 ^ a = a （1） </span><br><span class="hljs-comment">a ^ a = 0      （2） </span><br><span class="hljs-comment">a ^ a ^ a = a</span><br><span class="hljs-comment">a ^ a ^ b ^ b = 0   根据（2） </span><br><span class="hljs-comment">a ^ b ^ a ^ b = 0   满足交换律 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">所以，本题就简单了，只需要把n个数进行连续异或，其结果值就是那个具有奇数个的数。 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n,x,ans = <span class="hljs-number">0</span>;<br>n = <span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <br>x = <span class="hljs-built_in">read</span>(),ans ^= x;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> s = <span class="hljs-number">0</span>,f = <span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>((ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &amp;&amp; ch != EOF) &#123;<br><span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;-&#x27;</span>) f = <span class="hljs-number">-1</span>;<br>ch = <span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>s = s * <span class="hljs-number">10</span> + ch - <span class="hljs-string">&#x27;0&#x27;</span>;<br>ch = <span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">return</span> s * f;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="b3908-异或构造题">3.3.2 B3908 异或构造题？</h3><p>原题链接：<a href="https://www.luogu.com.cn/problem/B3908">B3908[语言月赛 202312] 异或构造题？</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n,a, x=<span class="hljs-number">0</span>;<br>    cin &gt;&gt;n;<br>    <span class="hljs-keyword">while</span> (n--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a), x=x^a;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld 0&quot;</span>, x);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="p8845-小卡和质数">3.3.3 P8845 小卡和质数</h3><p>原题链接：<a href="https://www.luogu.com.cn/problem/P8845">P8845[传智杯 #4 初赛] 小卡和质数</a></p><p>怎么样的两个数异或值为 00000001呢？显然是二进制下只有末位bit的值不同的数。要满足这个条件，需要两个质数的其他位都相同，而末位不同，也就是说，两者值相差1。所有质数中，只有3 和 2 相差1，所以他们的异或值为 1。最终得到：两个质数只能是 3 和2。</p><p>3是第2个质数，2 是第1个质数，则x和y为2和1，或者1和2。两数可能调换位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> t,a,b;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)&#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>((a==<span class="hljs-number">2</span>&amp;&amp;b==<span class="hljs-number">1</span>)||(a==<span class="hljs-number">1</span>&amp;&amp;b==<span class="hljs-number">2</span>)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="p9227异或积">3.3.4 P9227异或积</h3><p>原题链接：<a href="https://www.luogu.com.cn/problem/P9227">P9227异或积</a></p><p>分析：</p><p>拿到一个题，看懂题意之后，首先看数据规模。本题中n最大可到<spanclass="math inline">\(10^5\)</span>个数，最多要求做<spanclass="math inline">\(k=10^{18}\)</span>轮变化。如果直接硬干，早就TLE了。所以这个题必然是有巧方法的，不能硬干。根据3.1.2节中介绍的3）和4），所以我们可以从n和k的奇偶性方面来作为分析的切入点试试看。</p><p>此时，我们可以举个例子来试试看，推演一下，尝试看能不能找到其中的规律。</p><p>（1）假设n=4（当然，你也可以假设n=5或者6，但建议不要太多，不然草稿纸不够你写的），则有：</p><p><span class="math display">\[\begin{align*}(a_1,\quad a_2,\quada_3,\quad a_4)&amp;\stackrel{第1轮}{\Longrightarrow} (a_2\oplusa_3\oplus a_4, \quad a_1\oplus a_3\oplus a_4, \quad a_1\oplus a_2\oplusa_4, \quad a_1\oplus a_2\oplus a_3) \\&amp;\stackrel{第2轮}{\Longrightarrow}((\textcolor[RGB]{225,0,0}{\cancel{a_1}}\oplus\textcolor[RGB]{0,225,0}{\cancel{a_3}}\oplus\textcolor[RGB]{225,225,0}{\cancel{a_4}}\oplus\textcolor[RGB]{225,0,0}{\cancel{a_1}}\oplus\textcolor[RGB]{100,100,225}{\cancel{a_2}}\oplus\textcolor[RGB]{225,225,0}{\cancel{a_4}}\oplus a_1\oplus\textcolor[RGB]{100,100,225}{\cancel{a_2}}\oplus\textcolor[RGB]{0,225,0}{\cancel{a_3}}),\,\,数列第2项值\,\,,\,\,数列第3项值\,\,,\,\,数列第4项值\,\,)\\&amp;=(a_1,数列第2项值\,\,,\,\,数列第3项值\,\,,\,\,数列第4项值)\\&amp;=(a_1,a_2,a_3,a_4)\qquad\qquad//其他3项按照和a_1类似的方法\\\end{align*}\]</span></p><p>可以看出，当n为偶数时，经过第1轮变换后的每一项值，都是奇数个其他原数的连续异或值，则在进行第2轮变换时，该位置上的结果必然是n-1（n-1是奇数）个数值的异或，且这些数值也是奇数个原数的异或，<spanclass="math inline">\(a_1\)</span>经过两轮变换之后仍然还是<spanclass="math inline">\(a_1\)</span>，这样就很好办了！如果k为偶数，就返回原始序列的值；如果k为奇数，就返回第一轮的序列值。</p><p>（2）假设n=3，则有：</p><p><span class="math display">\[\begin{align*}(a_1,\quad a_2,\quada_3)&amp;\stackrel{第1轮}{\Longrightarrow} (a_2\oplus a_3, \quada_1\oplus a_3, \quad a_1\oplus a_2 )\\&amp;\stackrel{第2轮}{\Longrightarrow}((\textcolor[RGB]{225,0,0}{\cancel{a_1}}\oplusa_3\oplus \textcolor[RGB]{225,0,0}{\cancel{a_1}}\oplusa_2),\,\,数列第2项值\,\,,\,\,数列第3项值\,\,,\,\,数列第4项值\,\,) \\&amp;=(a_2\oplus a_3, \quad a_1\oplus a_3, \quad a_1\oplus a_2)\qquad//其他3项按照和a_1类似的方法\\\end{align*}\]</span></p><p>可以看出，当n为奇数时，经过第1轮变换后的每一项值，都是偶数个其他原数的连续异或值，则在进行第2轮变换时，该位置上的结果不变，仍然是第1轮的结果，这样也很好办了！不管k是奇数或者是偶数，都返回第一轮的序列值。</p><p>（3）可以对上述两点进行归纳，即：“<strong>当n为偶数且k为偶数时，返回原始序列的值；否则返回第一轮序列的值</strong>”</p><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br>ll T, n;<br>ll k;<br>ll a[N], b[N];<br><span class="hljs-comment">// 最多10万个数据的输入，建议上快读 </span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    ll x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> ch; <br>    <span class="hljs-keyword">while</span>(ch = <span class="hljs-built_in">getchar</span>() , ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;-&#x27;</span>) f = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        x = (x &lt;&lt; <span class="hljs-number">1</span>) + (x &lt;&lt; <span class="hljs-number">3</span>) + (ch ^ <span class="hljs-number">48</span>);<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> x * f;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    T = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">while</span>(T--) &#123;<br>        n = <span class="hljs-built_in">read</span>(), k = <span class="hljs-built_in">read</span>();<br>        ll sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            a[i] = <span class="hljs-built_in">read</span>();<br>            sum ^=a[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; k % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)  <span class="hljs-comment">// 输出原始序列的值，作为答案 </span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, a[i]);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)  <span class="hljs-comment">// 输出第一轮序列的值，作为答案</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, sum^a[i]);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四.-位运算综合练习">四. 位运算综合练习</h1><h2 id="p1100-高低位交换">4.1 P1100 高低位交换</h2><p>原题链接：<a href="https://www.luogu.com.cn/problem/P1100">P1100高低位交换</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> x;    <span class="hljs-comment">// 必须要unsigned，才是真正的32位有效数据，不管正负号</span><br>cin&gt;&gt;x;<br><span class="hljs-comment">//cout&lt;&lt;( (x&amp;0x0000ffff)&lt;&lt;16 | (x&amp;0xffff0000)&gt;&gt;16 ) &lt;&lt;endl;  //法1</span><br><span class="hljs-comment">//cout&lt;&lt; (x&lt;&lt;16) + (x&gt;&gt;16) &lt;&lt;endl;                           //法2</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u&quot;</span>,(x&gt;&gt;<span class="hljs-number">16</span>)+(x&lt;&lt;<span class="hljs-number">16</span>));                              <span class="hljs-comment">//法3，注意是%u</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="b3919-二进制与一">4.2 B3919 二进制与一</h2><p>原题链接：<a href="https://www.luogu.com.cn/problem/B3919">B3919[语言月赛 202401] 二进制与一</a></p><p>将 n 对 <span class="math inline">\(2^{k-1}\)</span>取模，就可以得到n 的最末尾k-1个二进制位的十进制结果 c 。也就是说，c=n%(1ll&lt;&lt;k);当然，也可以用另外一种计算方法，即c=n&amp;((1ll&lt;&lt;k)-1);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> n, q, ans=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>    cin &gt;&gt;n &gt;&gt;q;;<br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> k;<br>        cin &gt;&gt; k;<br>        --k; <span class="hljs-comment">// 得到 k - 1</span><br>        <span class="hljs-keyword">if</span> (n &amp; (<span class="hljs-number">1ll</span> &lt;&lt; k)) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果整数n的二进制右数第k位已经是1，则不需要加任何数 </span><br>        <span class="hljs-comment">//long long c = n % (1ll &lt;&lt; k);       // 方法 1 </span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> c = n &amp; ((<span class="hljs-number">1ll</span>&lt;&lt;k) - <span class="hljs-number">1</span>);     <span class="hljs-comment">// 方法 2   两种都要会写 </span><br>        ans += (<span class="hljs-number">1ll</span> &lt;&lt; k) - c;<br>        n += (<span class="hljs-number">1ll</span> &lt;&lt; k) - c;<br>    &#125;<br>    cout &lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基本知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针与尺取法</title>
      <link href="/2024/01/04/%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%88%E5%B0%BA%E5%8F%96%E6%B3%95%EF%BC%89/"/>
      <url>/2024/01/04/%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%88%E5%B0%BA%E5%8F%96%E6%B3%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="最长不重复字串问题">1.1 “最长不重复字串”问题</h2><p>“最长不重复子串”是一个经典问题。题意如下：</p><p><ahref="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">Leetcode第3题</a>：给定一个字符串s(<code>s</code>由英文字母、数字、符号和空格组成，长度在[0,50000])，请你找出其中不含有重复字符的 <strong>最长子串</strong>的长度。</p><h3 id="初步分析">1.1.1 初步分析</h3><p>首先我们分析一下这个问题的关键信息，主要有以下四个：</p><ul><li><p>1）n的取值范围是 <span class="math inline">\(0\leq n\leq5*10^4\)</span> ；</p></li><li><p>2）最长；</p></li><li><p>3）所有字符不重复；</p></li><li><p>4）子串；</p></li></ul><p>根据以上的几个关键词，我们可以得出一些结论：</p><p>1)根据的范围已经能够大致确认这是一个需要<spanclass="math inline">\(O(n)\)</span>或者<spanclass="math inline">\(O(lon_2n)\)</span>的算法才能解决的问题；</p><p>2)"最长"意味着可能是一个动态规划问题或者贪心问题，也有可能是搜索。所以这个关键词给我们的信息用处不大；</p><p>3)而“判断字符是否重复”可以用 <strong>哈希表</strong> 在<spanclass="math inline">\(O(1)\)</span>的时间内判断；</p><p>4)左和右两个端点能确定出一个子串，所以<strong>枚举所有"子串"</strong>意味着要枚举这两个端点，其时间复杂度是<spanclass="math inline">\(O(n^2)\)</span>的。</p><h3 id="朴素算法简单了解即可">1.1.2 朴素算法（简单了解即可）</h3><p>由以上分析，我们可以发现第1）个和第4）个关键词给我们得出的结论是矛盾的。那么，我们可以先尝试减小 n的范围。当<span class="math inline">\(n\leq10^3\)</span>时，怎么解决这个问题呢？浅显一点地来想：因为最后求的是满足条件的最长子串，所以我们如果能够枚举所有子串，那么选择长度最长的满足条件<spanclass="math inline">\(^{(*)}\)</span>的子串就是答案了（这里的条件<spanclass="math inline">\(^{(*)}\)</span>是指子串中所有字符都不同）。</p><p>用 ans 记录我们需要求的最大不重复子串的长度，用一个哈希表 h[]来代表某个字符是否出现过（你可以理解为一个访问标记数组，类似于vis[]），一个不太成熟的算法就成型了，描述如下：</p><ul><li><p>1）外层循环枚举子串的左端点 <span class="math inline">\(i=0\rightarrow n−1\)</span>；</p></li><li><p>2）清空哈希表h[]；</p></li><li><p>3）内层循环枚举子串的右端点 <span class="math inline">\(j=i\rightarrow n−1\)</span> ，如果当前这个字符<spanclass="math inline">\(s_j\)</span>出现过（即 <spanclass="math inline">\(h[s_j]=true\)</span>），则跳出j的循环；否则令<spanclass="math inline">\(h[s_j]=true\)</span>，并且用当前长度去考虑更新ans （即 <spanclass="math inline">\(ans=max⁡(ans, j−i+1)\)</span>）；</p></li><li><p>4）回到 2）；</p></li></ul><p><ahref="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">Leetcode第3题</a>的C++实现部分代码(朴素，AC，超过6.4%)如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>            <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">int</span> h[<span class="hljs-number">50005</span>]= &#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, i, j, len;<br>            <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;           <span class="hljs-comment">// 1)</span><br>                j = i;<br>                <span class="hljs-built_in">memset</span>(h, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(h));   <span class="hljs-comment">// 2)</span><br>                <span class="hljs-keyword">while</span>(j &lt; n &amp;&amp; !h[s[j]]) &#123;<br>                    h[ s[j] ] = <span class="hljs-literal">true</span>;        <span class="hljs-comment">// 3)</span><br>                    len = j - i + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(len &gt; ans)<br>                        ans = len; <span class="hljs-comment">// 记录最长值len的同时，也记录下其左端位置i和右端位置j的值</span><br>                    ++j;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>• 1）枚举对应子串的左端点i；</p><p>• 2）清空哈希表h，其中<spanclass="math inline">\(h[s_j]=true\)</span>代表原字符串的第j个字符<spanclass="math inline">\(s_j\)</span>是否出现在以第i个字符为左端点的子串中；</p><p>•3）如果字符串s[i..j]中已经出现重复的字符，那么s[i..j+1],s[i..j+2],…,s[i..n−1]必然会有重复字符，所以这里不需要继续往下枚举，直接跳出内层循环即可。</p><p>这个算法执行完毕， ans就是我们要求的最长不重复子串的长度， [l,r]代表了最长不重复子串在原字符串的区间。正确性毋庸置疑，因为已经枚举了所有子串的情况，如果字符集的个数为z ，那么算法的时间复杂度就是O(n∗z) 。</p><p>上述朴素算法的求解过程，其动图和不动图如下所示：</p><table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/clip_image001.gif"alt="图片" />原图</th><th><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104150815148.png"alt="image-20240104150815148" /> （i=0)</th><th><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104150831827.png"alt="image-20240104150831827" />(i=1)</th><th><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104150853687.png"alt="image-20240104150853687" />（i=2)</th></tr></thead><tbody><tr class="odd"><td><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104151050940.png"alt="image-20240104151050940" /> （i=3)</td><td><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104151122690.png"alt="image-20240104151122690" /> （i=4)</td><td><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104151137103.png"alt="image-20240104151137103" /> （i=5、6、7)</td><td></td></tr></tbody></table><p>结论：字符串下标从 0开始编号，该样例最长无重复子串为：s[1:5]=“bcaed”，长度为 5。</p><p>复杂度分析：由于该串是字符串，而一般的字符集内最多256个不同的字符。所以时间复杂度基本就是O(n∗256) ，当 <span class="math inline">\(1\leqn\leq 10^7\)</span> 时，这个时间复杂度<spanclass="math inline">\(O(1e7∗256) \geq1e7\)</span>，是肯定会TLE的，必须需要想办法优化。</p><h3 id="对朴素算法进行优化">1.1.3 对朴素算法进行优化</h3><p>如果仔细思考上面例题1的朴素算法的求解过程，就会发现：枚举子串的时候有很多区间是重叠的，所以必然存在许多没有必要的重复计算。</p><p>我们考虑一个子串以i为左端点，j为右端点，且s[i..j−1]中不存在重复字符，s[i..j]中存在重复字符（换言之，s[j]和s[i..j−1]中某个字符产生重复）的情况。如下图所示。</p><div data-align="center"><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104152821376.png" width = 40%/></div><p>在上图的情况下，我们没必要再去检测 s[i..j+1], s[i..j+2],…, s[i..n−1]这几个字符串的合法性，因为当前情况s[i..j]是非法的，而这些字符串是完全包含s[i..j]的，所以它们必然也是不合法的。</p><p>那么我们可以把枚举的左端点i自增，即：i=i+1，这时，按照朴素算法的实现，右端点需要重置，即j=i，实际上这里的右端点可以不动。</p><p>可以这么考虑，由于s[j]这个字符和s[i..j−1]中的某个字符s[k](k值未知)产生了重复，那么如果现在必须要加入s[j]且整个串不能产生重复字符，也就意味着s[x]必须要出局，即i 必须在位置x的右侧，即满足 i&gt;k ，换言之， i可以一直自增，直到i=k+1，如下图所示：</p><div data-align="center"><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104153650717.png" width = 40%/></div><p>利用上述思路，我们重新实现 最长不重复子串 的算法， c++代码（改进，AC，超过70%）实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>            <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">-1</span>, len;   <span class="hljs-comment">// i=0, j=i-1代表 s[i:j] 为一个空串，从空串开始枚举</span><br>            <span class="hljs-type">int</span> h[<span class="hljs-number">50005</span>]= &#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-keyword">while</span> (j++ &lt; n - <span class="hljs-number">1</span>) &#123;              <span class="hljs-comment">// 外层循环看快指针j，快指针j右移前进，拓宽区间</span><br>                ++h[ s[j] ];<br>                <span class="hljs-keyword">while</span> (h[ s[j] ] &gt; <span class="hljs-number">1</span>) &#123;        <span class="hljs-comment">// 如果区间[i,j]不满足指定条件，</span><br>                    --h[ s[i] ];               <span class="hljs-comment">//   就调整慢指针i右移，收窄区间，直到满足指定条件为止</span><br>                    ++i;                       <span class="hljs-comment">//</span><br>                &#125;<br>                len = j - i + <span class="hljs-number">1</span>;               <span class="hljs-comment">// 此时的区间[i,j]是局部最优解，记录</span><br>                <span class="hljs-keyword">if</span>(len &gt; ans)                  <span class="hljs-comment">//        考虑刷新</span><br>                    ans = len;                 <span class="hljs-comment">// 可以在此处记录i和j，以记录最长区间的左右端</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于待定区间[i,j]，如何确定该区间是否符合指定条件（即区间内的字符不重复）呢？其实也很简单。只需要维护h[]和判断h[str[j]]&gt;1，如果判断成立，则表示重复，不符合条件。这是<spanclass="math inline">\(O(1)\)</span>的操作，满足区间的时效性。</p><p>算法执行完毕后，我们就可以得到最长不重复子串的长度为 ans ，并且 i 和j 这两个指针分别只自增 n次。当j右移时，i未动。当i右移时，j未动。两个指针都从未回退过。所以该算法的时间复杂度为<span class="math inline">\(O(n*2)=O(n)\)</span> 。</p><p>可以将第9行处的1改为k，以适应“求字符的重复次数不超过k次的最长子串”问题。</p><p>利用该优化算法优化后的最长不重复子串的求解过程如图所示：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/640%20(1).gif"alt="640 (1)" /><figcaption aria-hidden="true">640 (1)</figcaption></figure><p>对上述内容的简单总结是：当区间中存在重复（红色）字符时，左指针 i自增；否则，右指针 j 自增。</p><h2 id="尺取法双指针法">1.2 尺取法（双指针法）</h2><h3 id="算法定义">1.2.1 算法定义</h3><p>如1.1.3节所述，这种利用问题特性，<strong>通过两个指针，不断调整区间，从而求出问题最优解</strong>的模型就叫"<strong>尺取法</strong>"模型。由于利用的是两个指针，所以又叫 "双指针"模型。</p><p>这里 "尺"的含义，主要还是因为这类问题最终要求解的都是连续的序列（子串），就好比一把尺子一样，故而得名。</p><p><strong>双指针法</strong>（又称为“<strong>尺取法</strong>”）模型，是一个常用的优化技巧，用来解决<strong>序列的区间问题</strong>。</p><p>在双指针法中，会有两个指针i、j分别代表了区间的左右位置下标。它们有两种扫描方向：</p><p>1）反向扫描：i、j方向相反，i从左往右，j从右往左，在中间相会；</p><p>2）同向扫描：i、j方向相同，都从左往右，可以让j跑在i的前面。</p><p>其中，同向扫描的两个指针称为“<strong>快慢指针</strong>”。它们在序列上产生一个大小可变的“<strong>滑动窗口</strong>”，有多种灵活的运用。本帖研究的主要就是这种同向扫描。</p><h3 id="指定条件与代码模板的适用场合">1.2.2“指定条件”与代码模板的适用场合</h3><p>在1.2.1节中曾指出，双指针法，是用来解决序列的区间上的问题。如果问题是“要求从原始序列中抽取分散的多个数据”，这不是区间问题，不能用双指针法模型。如果要求连续区间，但不满足下述的“单调性”，则只能采用普通的办法。反之，如果是要找满足<strong>指定条件(<spanclass="citation" data-cites="1">@1</span>)</strong>的最<strong>短(<spanclass="citation" data-cites="2">@2</span>)</strong>/最<strong>长(<spanclass="citation"data-cites="3">@3</span>)</strong>的连续区间，则可以使用一定的套路模板。该模板会在1.2.3节中详述。</p><p>这里所说的"<strong>指定条件</strong>"的内涵并未明确化。对于本题来说，<strong>指定条件</strong>就是"字符不重复"。当然，其他题也可以是 "每个字符重复次数不超过 k次"，"至少包含 k 种字符"，"求和不大于 k " 等等，千变万化，因题而异。</p><p>如果要使用双指针法的代码模板，那么这个"指定条件"必须要满足以下两点：</p><p>1）待定区间的<strong>单调性</strong></p><p>所谓“单调性”，就是说：任意一个指针的增加，条件满足与否只会出现两种情况，即：【满足 -&gt; 不满足】或者 【不满足 -&gt; 满足】，<strong>不能出现【满足 -&gt; 不满足 -&gt; 满足】这样反复不定的情况。</strong></p><p>2）待定区间的<strong>时效性</strong></p><p><strong>所谓“时效性”，就是说：必须在 <spanclass="math inline">\(O(1)\)</span>或者 <spanclass="math inline">\(O(log_2⁡n)\)</span> 的时间内就能确定出当前区间 [i,j] 是否满足指定条件，否则无法用尺取法求解。</strong></p><h3 id="算法描述">1.2.3 算法描述</h3><p>在1.2.2节中我们提到了求最短<spanclass="math inline">\((@2)\)</span>和最长<spanclass="math inline">\((@3)\)</span>区间这两种情况。这两种情况，算法有差异，下面分开进行阐述。</p><h4 id="求最长区间">1.2.3.1 求最长区间</h4><ul><li><p>1）初始化i=0（数组从0存）/1（数组从1存） ,j=i−1，表示初始区间的长度为 0；</p></li><li><p>2）外层循环为<strong>快</strong>指针j，<strong>右拓宽</strong>区间，（右移j，j++）；</p></li><li><p>3）当区间<font color="red"><strong>不满足</strong></font>条件时，一直<strong>左收窄</strong>（内层循环）该新区间（慢指针i右移,i++),直到区间满足条件，结束内层循环；</p></li><li><p>4）此时的区间是局部最优解，<font color="red"><strong>记录</strong></font>，回到2）；</p></li></ul><p>之所以求最长区间，往往是因为当区间右拓宽之后，会导致区间不合法（否则直接拿[1,n]当答案得了）。所以，在步骤2）之后，需要持续检验新区间并左收窄之，直到新区间合法为止。</p><h4 id="求最短区间">1.2.3.2 求最短区间</h4><ul><li><p>1）初始化i=0（数组从0存）/1（数组从1存） ,j=i−1，表示初始区间的长度为 0；</p></li><li><p>2）外层循环为<strong>快</strong>指针j，<strong>右拓宽</strong>区间，（右移j，j++）；</p></li><li><p>3）当区间<font color="red"><strong>满足</strong></font>条件时，一直<strong>左收窄</strong>（内层循环）该新区间（慢指针i右移,i++),<font color="red"><strong>记录</strong></font>局部最优解，直到区间不满足条件，结束内层循环；</p></li><li><p>4）回到 2）；</p></li></ul><p>之所以求最短区间，往往是因为当区间右拓宽之后，虽然仍然合法（单调性决定），但区间不够短。所以，在步骤2）之后，需要持续检验新区间并左收窄之，尝试优化局部解，直到新区间不合法为止。</p><h1 id="二实战训练">二、实战训练</h1><h2id="视频教学链接"><a href="https://www.bilibili.com/video/BV1Mp4y1E74K/?_blank" target="_blank">视频教学链接：</a></h2><h2 id="最长无重复子串问题最长">2.1 最长无重复子串问题（最长）</h2><p><ahref="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">Leetcode第3题</a></p><p>题解代码见1.1.3节。</p><h2 id="区间和问题最短">2.2 区间和问题（最短）</h2><p><a href="http://poj.org/problem?id=3061"><strong>POJ 3061Subsequence</strong></a></p><p>【中文大意】现在有t组数据，每组数组中给定 <spanclass="math inline">\(n(10&lt;n&lt;10^5)\)</span> 个正数 <spanclass="math inline">\(a_i (0&lt;a_i \leq 10^4)\)</span> 和一个正数 <spanclass="math inline">\(p(0&lt;p&lt;10^8)\)</span>。找到一个最短的连续子序列，满足它的和 <span class="math inline">\(s\geqp\)</span>，输出该区间的长度值。如果全部加起来都不能&gt;=m，则该样例输出0。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">输入样例：<br>2  // 有2组数据<br>10 15                   // 第一组数据有10个正数，阀值p为15<br>5 1 3 5 10 7 4 9 2 8    // 10个数据<br>5 11                    // 第二组数据有5个正数，阀值p为11<br>1 2 3 4 5               // 5个数据<br>输出样例：               <br>2                       // 在第一组数据中，a4+a5=15&gt;=p=15，长度2，且是最短的<br>3                       // 在第二组数据中，a3+a4+a5=12&gt;=p=11，长度3，且是最短的   <br></code></pre></td></tr></table></figure><p>解题分析：</p><p>A. 单调性分析：对于一个连续子序列a[i..j] ，它所有数之和 s[i..j]<spanclass="math inline">\(=\sum_{k=i}^{j}a_k\)</span> 。如果我们已经知道<span class="math inline">\(s[i..j] \geq p\)</span>，那么就没必要再去求s[i..j+1] ( 因为a[j+1]&gt;0，所以s[i..j+1]= s[i..j]+ a[j+1] &gt; s[i..j] <span class="math inline">\(\geq p\)</span>，但题目要求找最短的区间，所以没必要再去求s[i..j+1])。所以基于这点，该题所述的“条件”满足单调性。</p><p>B. 时效性分析：可以定义前缀和数组 ，通过 O(1)的代价计算出给定区间[i..j]之间的连续子序列的和。O(1)的代价，这是具有时效性的。</p><p>C. 本题要求满足指定条件的一个区间[i,j]，但根据题意，有可能不存在这样的区间。（举个反例:"在1..10这个数列中找出一个区间，使得该区间数值和大于等于500万"，根本找不到这样的区间）。所以要留意区间长len=0的可能。</p><div data-align="center"><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240111160121957.png" width = 80%/></div><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//// 方法1：尺取法</span><br><span class="hljs-comment">// 基本题意：给长度为n (10 &lt; n &lt; 1e5)的数组，每个元素&lt;=1e4。另外有一个整数m(m&lt;1e9)，</span><br><span class="hljs-comment">//           求数组中数的总和&gt;=m的连续子序列的最小长度。如果全部加起来都不能&gt;=m，则</span><br><span class="hljs-comment">//           该样例输出 0</span><br><span class="hljs-comment">//  输入：</span><br><span class="hljs-comment">//  2组样例</span><br><span class="hljs-comment">//  n = 10，m = 15</span><br><span class="hljs-comment">//  5 1 3 5 10 7 4 9 2 8</span><br><span class="hljs-comment">//  输出：</span><br><span class="hljs-comment">//  2        (至少要有2个数，即5 10 这个子序列的和满足&gt;=15)</span><br><span class="hljs-comment">//  n = 5，m = 11</span><br><span class="hljs-comment">//  1 2 3 4 5</span><br><span class="hljs-comment">//  输出：</span><br><span class="hljs-comment">//  3        (至少要有3个数，即3 4 5 这个子序列的和满足&gt;=11)</span><br><br><span class="hljs-comment">//#include &lt;bits/stdc++.h&gt;</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br>LL data[maxn], le, ri, n, m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    LL t, i;<br>    cin &gt;&gt;t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        cin &gt;&gt;n &gt;&gt;m;<br>        <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>            cin&gt;&gt;data[i];<br>        &#125;<br>        le=<span class="hljs-number">1</span>;                      <span class="hljs-comment">// 区间左端至少应该是从第一个数开始</span><br>        LL minlen=n+<span class="hljs-number">1</span>;             <span class="hljs-comment">// 求符合条件的数的最小值的套路：先让最小值的初值为一个不可能的极大值，然后打擂台 </span><br>        LL sum=<span class="hljs-number">0</span>, len=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> ( ri=<span class="hljs-number">1</span>; ri&lt;=n; ri++) &#123; <span class="hljs-comment">// 快指针朝前进，作为主循环</span><br>            sum+=data[ri];         <span class="hljs-comment">// 区间已拓宽，处理相关事务（刷新sum和len）</span><br>            len++;<br>            <span class="hljs-comment">// 我们希望找到&quot;最短&quot;区间，所以每次拓宽区间的同时要想着能不能缩短区间(在符合条件的前提下)</span><br>            <span class="hljs-keyword">while</span> (sum-data[le] &gt;= m) &#123; <span class="hljs-comment">// 当区间[le+1, ri]合法时，连续尝试缩短区间</span><br>                sum= sum - data[le];  <span class="hljs-comment">// 缩短区间后，处理相关事务（刷新sum、le指针、len和minlen） </span><br>                le++;<br>                len--;<br>                <span class="hljs-keyword">if</span> (len&lt;minlen) &#123;<br>                    minlen= len;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (minlen==n+<span class="hljs-number">1</span>)       <span class="hljs-comment">// 如果全都不符合题意，即所有数加起来都不够m </span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, minlen);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入样例：</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">10 15</span><br><span class="hljs-comment">5 1 3 5 10 7 4 9 2 8</span><br><span class="hljs-comment">5 11</span><br><span class="hljs-comment">1 5 3 4 2</span><br><span class="hljs-comment">10 1000000</span><br><span class="hljs-comment">5 1 3 5 10 7 4 9 2 8</span><br><span class="hljs-comment">输出样例：</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">0 </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="luogu-p1147-连续自然数和img">2.3 <ahref="https://www.luogu.com.cn/problem/P1147">Luogu P1147连续自然数和</a><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230825170629229-1325480434.png"alt="img" /></h2><p>这个题，咋一看感觉像是“区间和”问题，但仔细分析发现：当区间拓宽或收窄时，都有可能会出现“不符合条件——符合——不符合”的情况。所以上面总结的两个代码模板，不适合本题。只能双指针硬干。</p><p>P1147 AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>,sum=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= m/<span class="hljs-number">2</span>) &#123;     <span class="hljs-comment">// 因为要求区间内至少2个数，所以左端数必然&lt;=m/2</span><br>        <span class="hljs-keyword">if</span>(sum&lt;m) &#123;       <span class="hljs-comment">// 不够就加右 </span><br>            j++;          <span class="hljs-comment">// 右拓宽 </span><br>            sum += j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum&gt;=m) &#123;      <span class="hljs-comment">// 超过就减左</span><br>            <span class="hljs-keyword">if</span>(sum==m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,i,j);<br>            sum -= i;     <span class="hljs-comment">// 左收窄</span><br>            i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一个类似的题目是<ahref="https://www.luogu.com.cn/problem/P1638">P1638</a>。其AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn= <span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> num,minwidth,le,j,ll,rr;<br><span class="hljs-type">int</span> n,m,a[maxn];  <span class="hljs-comment">// a[5]=3 表示第5幅画是3号画家画的</span><br><span class="hljs-type">int</span> cnt[<span class="hljs-number">2005</span>]; <span class="hljs-comment">// cnt[i]表示当前区间[le, j]内画家i的图画数</span><br><span class="hljs-comment">// cnt[10]=2 表示10号画家有2幅画在当前区间【le,j】里</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n, &amp;m);  <span class="hljs-comment">// n 幅画，m个画家</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    le=<span class="hljs-number">1</span>;      <span class="hljs-comment">// 区间左端至少应该是从第一个画家开始</span><br>    num=<span class="hljs-number">0</span>;     <span class="hljs-comment">// 当前区间内画家的人数</span><br>    minwidth=maxn;<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>; j&lt;=n; j++) &#123;  <span class="hljs-comment">// 快指针作为主循环</span><br>        <span class="hljs-comment">// 快指针前进，处理相关事情，尤其是num </span><br>        cnt[ a[j] ]++;      <br>        <span class="hljs-keyword">if</span>(cnt[ a[j] ]==<span class="hljs-number">1</span>) num++;<br><br>        <span class="hljs-keyword">while</span>(num&gt;=m) &#123; <span class="hljs-comment">//本题求最短区间，所以当该区间符合条件时，持续收窄区间</span><br>            <span class="hljs-comment">// 先记录</span><br>            <span class="hljs-keyword">if</span>(minwidth &gt; j-le + <span class="hljs-number">1</span>) &#123;   <br>                minwidth = j-le+<span class="hljs-number">1</span>;      <br>                ll=le;<br>                rr=j;<br>            &#125;<br>            <span class="hljs-comment">// 再收窄</span><br>            cnt[ a[le] ]--;<br>            <span class="hljs-keyword">if</span>(cnt[ a[le] ]==<span class="hljs-number">0</span>) num--;  <span class="hljs-comment">// 收窄时一定会影响到num的值 </span><br>            le++; <br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,ll,rr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入</span><br><span class="hljs-comment">12 5</span><br><span class="hljs-comment">2 5 3 1 3 2 4 1 1 5 4 3</span><br><span class="hljs-comment">输出</span><br><span class="hljs-comment">2 7</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="luogu-p1102-a-b-数对">2.4 <ahref="https://www.luogu.com.cn/problem/P1102">Luogu P1102 A-B数对</a></h2><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230825170629214-1614732805.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>本题已知C，要找有多少对“A-B”对。因为A和B都可能有多个，存在重复，且ABC都是正值，所以A必然大于B。对于每一个B，在排序后，存在连续的多个A符合题意。这多个A形成一个等值区间，用i和j-1来标识这个等值区间的左右端，即慢指针和快指针。当存在多个B时，i和j不变，能在<spanclass="math inline">\(O(1)\)</span>的效率内解决第二个、第三个B等，使得算法保持高效。i和j都不后退，所以算法效率为<spanclass="math inline">\(O(n)\)</span>。但因为需要先sort（sort函数效率<spanclass="math inline">\(O(n*log_2n)\)</span>），所以整体算法效率仍然是<spanclass="math inline">\(O(n*log_2n)\)</span>。</p><p>P1102 AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//  方法2：尺取法  详见“D双指针(尺取法)”  233ms</span><br><span class="hljs-comment">//  该方法和方法1高度相似，只是在for循环内确定i和j时，是采用快慢针前进。</span><br><span class="hljs-comment">//  快慢指针同步向右推进，k表示B，慢指针i指向第一个A，快指针j指向最后一个A的下一个元素 </span><br><span class="hljs-comment">//  因为快慢针并不会后退，所以二重循环的效率实际上是O(n)，优于方法1的O(n*logn) </span><br><span class="hljs-comment">//  </span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7 </span><br><span class="hljs-comment">//  k     i           j                    （1）ans=0+3 =3</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//     k  i           j                    （2）ans=3+3 =6</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//        k               i/j              （3）ans=6+0 =6</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//            k           i/j              （4）ans=6+0 =6</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//                k       i/j              （5）ans=6+0 =6</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//                    k    i          j    （6）ans=6+2 =8</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//                         k         i/j   （7）ans=8+0 =8</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//                              k    i/j   （8）ans=8+0 =8</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//                                    k    i/j=len+1  （9）ans=8+0 =8</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-type">const</span> LL N=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br>LL n,c,a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin&gt;&gt;n&gt;&gt;c;<br><span class="hljs-keyword">for</span>(LL k=<span class="hljs-number">1</span>; k&lt;=n; k++) cin&gt;&gt;a[k];<br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+n);<br><br>LL ans=<span class="hljs-number">0</span>;<br>LL i=<span class="hljs-number">1</span>, j=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(LL k=<span class="hljs-number">1</span>; k&lt;=n; k++) &#123; <span class="hljs-comment">//i&lt;=j</span><br><span class="hljs-keyword">while</span>(i&lt;=n &amp;&amp; a[i]-a[k]&lt; c) i++;   <span class="hljs-comment">// 此处不同于方法1，使用了快慢针 </span><br><span class="hljs-keyword">while</span>(j&lt;=n &amp;&amp; a[j]-a[k]&lt;=c) j++;  <span class="hljs-comment">// j指向相同值区间右端的下一个下标 </span><br>ans+=j-i;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="至少有k个重复字符的最长子串">2.5[至少有K个重复字符的最长子串</h2><p><ahref="https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/description/">Leetcode395</a></p><p>给你一个字符串s和一个整数k，请你找出s中的最长子串，要求该子串内的每一字符出现次数都不少于k。返回这一子串的长度。如果不存在这样的子字符串，则返回0。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：s = &quot;aaabb&quot;, k = 3<br>输出：3<br>解释：最长子串为 &quot;aaa&quot; ，其中 &#x27;a&#x27; 重复了 3 次。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：s = &quot;ababbc&quot;, k = 2<br>输出：5<br>解释：最长子串为 &quot;ababb&quot; ，其中 &#x27;a&#x27; 重复了 2 次， &#x27;b&#x27; 重复了 3 次。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><span class="math inline">\(1 \leq s.length \leq 10^4\)</span></li><li>s仅由小写英文字母组成</li><li><span class="math inline">\(1 \leq k \leq 10^5\)</span></li></ul><p>解题分析：</p><p>A.单调性分析：对于一个连续子序列a[i..j]，假设其区间长度为t，且满足条件（且此时k &gt; 1），那么将该区间长度扩成 t+1时（无论是往左扩还是往右扩）：</p><ol type="a"><li><p>如果新位置的字符在原有区间出现过，那必然还是满足出现次数大于 k次，这时候该新区间仍满足要求；</p></li><li><p>如果新位置的字符在原有区间没出现过，那新字符的出现次数只有 1次，这时候该新区间不满足要求；</p></li></ol><p>所以<strong>该题所要求的“条件”不满足区间的单调性</strong>，即不会随着区间的移动或者变化而肯定出现“不符合<spanclass="math inline">\(\rightarrow\)</span>符合”或者反之的情况。因此我们不能使用「二分答案法」，也<strong>不能直接使用</strong>「滑动窗口」思路的双指针法。</p><p>那么还有什么性质可以利用呢？这时候要留意数据范围「数值小」的内容。</p><p>题目说明了只包含小写字母（26个，为有限数据），如果我们把原题条件（区间内所包含的字符的重复次数至少为k次）<strong>改为新条件（区间内所包含的字符种类数量只能为t <span class="math inline">\((1 \leq t \leq26)\)</span>种）</strong>时，区间重新具有了单调性质。</p><p>当我们使用双指针的时候：</p><ol type="a"><li><p>右端点往右移动必然会导致字符类型数量增加（或不变）</p></li><li><p>左端点往右移动必然会导致字符类型数量减少（或不变）</p></li></ol><p>然后我们可以对t进行暴力枚举，范围从1到26，毕竟这也不大。然后可以看出，原题的答案区间必然会和我们在暴力枚举t的过程中找到的某个区间是一致的。例如s= "aaabb", k = 3的答案区间（子串aaa）必然会在我们枚举t=1时找到，而s ="ababbc", k = 2的答案区间（子串ababb）必然会在我们枚举t=2时找到。</p><p>B.时效性分析：当区间拓宽或收窄时，可以通过计数器数组来识别出从无到有的字符，或者从有到无的字符，通过O(1) 的代价判断出给定区间[i..j]是否符合新条件，具有时效性。</p><p>“搂草”的同时，还要“打兔子”！本题的最终目的是要找每种字符出现至少k次的最长子串，所以在双指针右移的过程中，顺带着还要记录区间内出现的每个字符的次数。这才是我们的最终目的！可以设置<strong>不达标字符（已出现在区间中，但个数不够k个）</strong>的个数less。当新增一个从无到有的字符时less++，若次数达到k次则less--；新减掉一个原本出现仅1次的字符时less--，新减掉一个原本出现了k次的字符时less++。当less==0时意味着区间没有不达标字符，即区间内所有字符都次数&gt;=k，记录该区间。</p><p>C.本题要求满足指定条件的一个区间[i,j]，但根据题意，有可能不存在这样的区间。（举个反例:"在aabbccdef这个字符串中找出一个区间，使得该区间每个字符都出现了至少10次"，根本找不到这样的区间）。所以要留意区间长len=0的可能。</p><p>AC代码如下：（8ms，超过45%）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestSubstring</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;                      <span class="hljs-comment">// 先假设找不到任何合法区间 </span><br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">1</span>; t &lt;= <span class="hljs-number">26</span>; t++) &#123;   <span class="hljs-comment">// 暴力枚举区间内出现的字符种数t </span><br>            <span class="hljs-comment">// 每次新的暴力枚举都需重置相关变量！ </span><br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;             <span class="hljs-comment">//  </span><br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br>            <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;             <br>            <span class="hljs-type">int</span> less = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (r &lt; n) &#123;               <span class="hljs-comment">// 双指针模板，快指针最多只到最后一个字符的下标n-1，</span><br>                <span class="hljs-comment">// 搂草，针对新进字符来处理tot</span><br>                cnt[s[r] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>                <span class="hljs-keyword">if</span> (cnt[s[r] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">1</span>) &#123;<br>                    tot++;                <span class="hljs-comment">// 处理tot </span><br>                    less++;<br>                &#125;<br>                <span class="hljs-comment">// 打兔子 </span><br>                <span class="hljs-keyword">if</span> (cnt[s[r] - <span class="hljs-string">&#x27;a&#x27;</span>] == k) &#123;<br>                    less--;<br>                &#125;<br><br>                <span class="hljs-keyword">while</span> (tot &gt; t) &#123;         <span class="hljs-comment">// 搂草，双指针模板。最长区间，当区间不合法时收窄左端 </span><br>                    cnt[s[l] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                    <span class="hljs-keyword">if</span> (cnt[s[l] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span>) &#123;<br>                        tot--;            <span class="hljs-comment">// 处理tot，模板 </span><br>                        less--;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (cnt[s[l] - <span class="hljs-string">&#x27;a&#x27;</span>] == k - <span class="hljs-number">1</span>) &#123;<br>                        less++;<br>                    &#125;<br>                    l++;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (less == <span class="hljs-number">0</span>) &#123;          <span class="hljs-comment">// 能到这里来，区间肯定合法，此时如果less也==0的话，就找到一个区间满足题意了 </span><br>                    ret = <span class="hljs-built_in">max</span>(ret, r - l + <span class="hljs-number">1</span>);<br>                &#125;<br>                r++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="poj2566-bound-found">2.6 POJ2566 Bound Found</h2><p>原题链接 ：<a href="http://poj.org/problem?id=2566">POJ2566</a></p><p>基本题意：给定一个数组n个元素和一个值t，求一个子区间使得其和的绝对值与t的差值最小，如果存在多个，任意解都可行。1&lt;=n &lt;= 1e5 ; 0&lt;= t &lt;= 1e9;</p><p>样例输入数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5 1             // 第1组样例：n=5个数   t=1次查询<br>-10 -5 0 5 10<br>3               // 查区间和的绝对值最靠近3的区间<br><br>10 2            // 第2组样例：n=10个数  t=2次查询<br>-9 8 -7 6 -5 4 -3 2 -1 0<br>5 11            // 查区间和的绝对值最靠近5的区间，查区间和的绝对值最靠近11的区间<br><br>15 2            // 第3组样例：n=15个数  t=2次查询<br>-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1<br>15 100          // 查区间和的绝对值最靠近15的区间，查区间和的绝对值最靠近100的区间<br>0 0             // 结束<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5 4 4 // 区间和为5，从4号到4号(网页此处写错了！输出测试样例给的是5 2 2，即区间[2,2]，该区间只有-5这个数，绝对值为5，与3的距离为3，最接近了。[4,4]这个5的下标没有[2,2]的小)<br>5 2 8           // 区间和5  从2号 到8号<br>9 1 1           // 区间和9  从1号 到1号<br>15 1 15         // 区间和15  从1号 到15号<br>15 1 15         // 区间和15  从1号 到15号<br></code></pre></td></tr></table></figure><p>分析：</p><p>之前的POJ3061题中，序列都是正数。随着区间拓宽，其sum呈现单调递增的特性。但是现在本题有正数有负数，其区间和不再具备单调性，而取绝对值之后，更不具备单调性了。不能直接用双指针法来做，需要想一下如何重构条件或者数据。</p><p>这个题我们首先能想到的是，既然要求区间之和，我们可以先利用前缀和数组，它能在O(1)的效率实现原区间求和。但必须要解决两个问题：</p><p>1）问题是如何枚举区间的左右端呢？</p><p>2)如何让每一次枚举出的区间更靠近所求的答案区间呢？</p><p>朴素做法就是先求前缀和数组s[]，然后基于该数组，for (ri=1..len)for(le=0..ri-1)这样去暴力枚举（因为前缀和数组有正有负，看似无规律，不单调）区间的左右端，然后用s[ri]-s[le]得到该区间和，然后看差值，求最小值。但这样做，并未解决问题2），每一次枚举都完全无视上一次枚举的比较结果，算法效率注定低下。</p><p>假设一个区间之和sum=data[le..ri]=s[ri]-s[le-1]，且sum&lt;t。那现在该如何调节？肯定是希望能扩大区间之和，即找到一个更大的s[<spanclass="math inline">\(\acute{ri}\)</span>]<font color="red">**(*)**</font>。但扩大区间之和，不能简单地理解为ri++,快指针在data[]上右移一格。因为data[]有正有负，s[]数组不是单调递增。所以不能简单地通过ri++来在data[]上拓宽区间。那我们如何去找一个比原来的s[ri]值更大的s[]值呢？</p><p>我们可以对s[]进行递增排序产生s2[]（也可以原地排序），弃用s[]原来的数据顺序关系，反正这种前后关系没有单调性，已无任何作用。（在排序之前注意要保存元素的原始序号pos，因为我们需要表示最初的data[]中的下标的区间。）因为s2[]是经过排序的，必然是单调递增的（<del>似乎这里是句废话</del>），所以当ri++，在s2[]上右移（<strong>理解的重点：不管是le或ri，都不是在data[]上右移！给一对le和ri，不要想成了data[le..ri]，非也！</strong>）后，s2[ri(新)]必然是&gt;s2[ri(旧)]的（单调性决定）。</p><p>排序之后，s[]单调递增，但其原元素发生了移动，所以s[ri].value -s[le].value 不再代表 sum(data[le+1] .. data[ri])！它代表的是sum(data[1..s[ri].pos]) - sum(data[1..s[le].pos])。虽然ri&gt;le，但是s[ri].pos 不一定大于 s[le].pos !所以在表示时，ll=min(s[ri].pos, s[le].pos)且rr=max(s[ri].pos,s[le].pos)</p><p>可能有人会说：因为s2[]是排序后的前缀和数组，举个例子：s2[4].v可能等于data[0..7]，根本就不等于s2[3].v+data[4]！但仔细一想，其实这个问题根本就不是什么问题。我们只需要找到比原来的s2[3].v更大一点的s2[7].v就达到<font color="red">**(*)**</font>处所述的“让sum变大”的目的了!看似好像在跳跃性地胡乱枚举，但实际上是递增地枚举。</p><p>1）当sum&lt;t时，ri在s2[]上右移；</p><p>2）当sum&gt;t时，此时再去ri++岂不是区间和更大？人家要最接近t值的区间和，你搞个越来越远是什么意思？果断不再ri++！此时意味着该le++，让le在s2[]上右移一格，换一个更大一点的s[<spanclass="math inline">\(\acute{le}\)</span>]，从而让sum变小一点。这样才能让sum越来越靠近t，算法高效！</p><p>原题链接中提供的三个样例都不太具有一般性，本帖重新列举一个更具一般性的输入样例和输出样例如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">输入样例：<br>10 1             //10个数，1次查询 <br>20 -25 10 5 -10 25 15 -10 15 5 <br>22               // 查找区间和绝对值最接近22的那个区间<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240119091130982.png" alt="image-20240119091130982" style="zoom:80%;" /></p><p>当ri=6，le=3时s2[6].v-s2[3].v= 20-5=15;这个结果15代表的是data[0..1]-data[0..3]=s[1]-s[3]= 20-5=15。虽然6&gt;3，但s2[6].pos=1 &lt; s2[3].pos=3！所以(&amp;1)<strong>此处data[0..1]-data[0..3]无法表达成data[2..3]，所以在data[]上表示这个区间时，假设区间为[ll+1,rr]，那么ll=<font color="red">min(1, 3)</font>=1 =min(s2[6].pos,s2[3].pos)，且rr= <font color="red">max(1, 3)</font>=3 =max(s2[6].pos,s2[3].pos)</strong>。然后把ll+1，得到2，最终得到区间为[2..3]，即data[2..3]。</p><p>但此时因为15&lt;22，需继续找个更大的区间，ri++，因为s2[7].v=s2[6].v=20，所以继续ri++，ri=8。</p><p>当ri=8，le=3时s2[8].v-s2[3].v= 30-5 =25;这个结果25代表的是data[0..7]-data[0..3]=s[7]-s[3]= 30-5 =25。ll= min(3,7)=3，且rr=max(3,7)=7。然后把ll+1，得到4，最终得到区间为[4..7]，即data[4..7]，其和25更接近22。</p><p>不管是sum&gt;t或者sum&lt;t，都无法预知下一次尝试是否更接近t，所以都需要记录和考虑刷新。但如果当sum==t时，没有什么区间比这更优了，首次遇到就不再尝试后续，结束程序。</p><p>需要注意的是：</p><ol type="1"><li><p>我们需要将下标为0的元素的id和sum字段都设置为0，并将该元素参与排序。这样当遇到类似s[7]-s[0]时，表示的是data[0..7]-data[0..0]=data[1..7]。</p></li><li><p>因为sum[j]-sum[i]表示的是[i+1,j]，此外在最后得到的答案左区间都 +1</p></li><li><p>网页上输出样例的第一组数据有毒，写错了。但其OJ系统的测试数据没问题，应该就是网页上写错了而已。</p></li><li><p>s[0]的初始化每次都要做，而且要先做，因为后面求前缀和时会用到s[0]</p></li><li><p>long long类型求绝对值需要用 llabs(long long)函数</p></li></ol><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>     <span class="hljs-comment">// sort()需要 </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span>         <span class="hljs-comment">// llabs()需要 </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>LL value;<br>LL pos;<br>&#125;;<br>LL data[maxn];<br>node s[maxn];<br>LL le, ri, n, t, k;<br>LL sum, ll, rr;<br>LL mindis;     <span class="hljs-comment">// 记录区间和与k之间的最近距离值（绝对值，正）</span><br>LL ans;        <span class="hljs-comment">// 记录具有这个最近距离值的区间之和值</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node x1, node x2)</span> </span>&#123;<br><span class="hljs-keyword">return</span> x1.value &lt; x2.value;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;t), !(n==<span class="hljs-number">0</span>&amp;&amp;t==<span class="hljs-number">0</span>)) &#123;<br>    s[<span class="hljs-number">0</span>].pos=<span class="hljs-number">0</span>;                 <span class="hljs-comment">// 别忘了先做初始化这个，排序后元素顺序会打乱，s[0]将可能会不再是(0,0)  </span><br>    s[<span class="hljs-number">0</span>].value=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(LL i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;    <span class="hljs-comment">// 需要先初始化好s[0]之后才能for，因为此处用到了原s[0] </span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;data[i]);<br>        s[i].value = s[i<span class="hljs-number">-1</span>].value + data[i];  <span class="hljs-comment">// 此时，s[ri].value - s[le].value代表sum(data[le+1] .. data[ri])，前缀和基本定义 </span><br>        s[i].pos = i;<br>        &#125;<br>        <br>    <span class="hljs-built_in">sort</span>(s, s+<span class="hljs-number">1</span>+n, cmp);        <span class="hljs-comment">// 需要把s[0]也参与排序</span><br>        <br>    <span class="hljs-keyword">while</span>( t-- ) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;k);<br>        le=<span class="hljs-number">0</span>;                   <span class="hljs-comment">// 因为s[ri].value - s[le].value代表sum(data[le+1] .. data[ri])，所以le应从0号开始，这样区间左端从1开始 </span><br>        ri=<span class="hljs-number">1</span>;<br>        mindis = <span class="hljs-number">1e17</span>+<span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">while</span>( ri&lt;=n ) &#123;        <span class="hljs-comment">// 也可以用for(ri=1; ri&lt;=n; ri++)  </span><br>            LL sum = s[ri].value - s[le].value; <span class="hljs-comment">// sum=sum(data[1..s[ri].pos]) - sum(data[1..s[le].pos])  &gt;0 </span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">llabs</span>(sum-k) &lt; mindis) &#123;        <span class="hljs-comment">// 如果le和ri表示的这个区间更优（更贴近 k），则更新mindis、ans、ll和rr  </span><br>                mindis = <span class="hljs-built_in">llabs</span>(sum-k);          <span class="hljs-comment">// </span><br>                ans = sum;<br>                ll=<span class="hljs-built_in">min</span>(s[ri].pos, s[le].pos)+<span class="hljs-number">1</span>; <span class="hljs-comment">// 此处解释见题解的(&amp;1)处 </span><br>                rr=<span class="hljs-built_in">max</span>(s[ri].pos, s[le].pos);<br>                &#125;<br>                <span class="hljs-comment">// 排序后的s[]是单调递增的，所以s[ri+1].value &gt;= s[ri].value  &gt;= s[le+1].value &gt;= s[le].value的，</span><br>                <span class="hljs-comment">// 也就是说，sum(data[1..s[ri+1].pos])必然是大于等于sum(data[1..s[ri].pos])的 </span><br>                <span class="hljs-comment">// 如果区间之和值sum少于k，应想办法增大sum值。故而选择了这个s[ri+1].value。</span><br>                <span class="hljs-comment">// s[ri+1].value - s[le].value  &gt; s[ri].value - s[le].value</span><br>            <span class="hljs-keyword">if</span> (sum &lt; k)        <br>                ri++;<br>                <span class="hljs-comment">// 如果区间和值sum在k的右侧，应想办法减小sum值。故而选择更大一点的s[le+1].value。</span><br>                <span class="hljs-comment">// s[ri].value - s[le+1].value  &lt; s[ri].value - s[le].value</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; k)<br>                le++;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;          <span class="hljs-comment">// 没有比这更完美的了，不必再算后续，跳出循环，输出 </span><br>                <br>            <span class="hljs-keyword">if</span> (le == ri)       <span class="hljs-comment">// 不允许也不考虑空区间，所以不允许le==ri，一旦相等，ri强行前进一格 </span><br>                ri++; <br>            &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld %lld\n&quot;</span>, ans, ll, rr);<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">5 1</span><br><span class="hljs-comment">-10 -5 0 5 10</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">10 2</span><br><span class="hljs-comment">-9 8 -7 6 -5 4 -3 2 -1 0</span><br><span class="hljs-comment">5 11</span><br><span class="hljs-comment">15 2</span><br><span class="hljs-comment">-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1</span><br><span class="hljs-comment">15 100</span><br><span class="hljs-comment">0 0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输出</span><br><span class="hljs-comment">5 2 2  // 网页数据有误！测试数据没问题 </span><br><span class="hljs-comment">5 2 8</span><br><span class="hljs-comment">9 1 1</span><br><span class="hljs-comment">15 1 15</span><br><span class="hljs-comment">15 1 15</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="poj2739-sum-of-consecutive-prime-numbers">2.7 POJ2739 Sum ofConsecutive Prime Numbers</h2><p><ahref="http://poj.org/problem?id=2739">POJ2739</a>的AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    一个整数分解为连续的素数之和，有多少种分法? 这是一个“区间和精确相等”的问题，</span><br><span class="hljs-comment">    因为“精确相等”不满足单调性，但“正数的累加和”是有单调性的，所以可在模板基础</span><br><span class="hljs-comment">    上微调即可。 </span><br><span class="hljs-comment">    思路：</span><br><span class="hljs-comment">    1. 打表，先打出素数表</span><br><span class="hljs-comment">    2. 然后用尺取法查询是否精确等？若s&lt;num就继续ri++，若s&gt;num就le++，若s==num就统计 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxn 10000+16        <span class="hljs-comment">// 1万以内求素数 </span></span><br>vector&lt;<span class="hljs-type">int</span>&gt; primes;<br>vector&lt;<span class="hljs-type">bool</span>&gt; is_prime;<br><br><span class="hljs-comment">// 暴力打表，也可以把这个代码单独开一个cpp文件来写，然后把打印结果复制为POJ2739的全局数组。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_prime</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化vector的前10000个元素均为true</span><br>    is_prime = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(maxn + <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 0和1都不是素数</span><br>    is_prime[<span class="hljs-number">0</span>] = is_prime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 埃氏筛法求素数，填入primes[]中。此处也可以换成欧拉筛法</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; maxn; i++) &#123;<br>        <span class="hljs-keyword">if</span> (is_prime[i]) &#123;<br>            primes.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i * <span class="hljs-number">2</span>; j &lt; maxn; j += i) &#123;<br>                is_prime[j] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-built_in">init_prime</span>();<br>    <span class="hljs-type">int</span> size = primes.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; num &amp;&amp; num) &#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>, s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>,r = <span class="hljs-number">0</span>; r&lt;size;  ) &#123;<br>            <span class="hljs-comment">// s没加够，且右边还有数可以继续加，那就一直加（因为正数的累加和是有单调性的）</span><br>            <span class="hljs-keyword">while</span> (r&lt;size &amp;&amp; s&lt;num)<br>                s = s + primes[r++];<br>            <span class="hljs-keyword">if</span> (s == num)  <span class="hljs-comment">// 找到一个方案，记上</span><br>                result++;<br>            <span class="hljs-comment">// 不管找没找到一个方案，如果r还没走到底而s已经超过num，就砍掉左端l++,s-=，然后循环上去继续r右移</span><br>            s -= primes[l++];<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, result);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入1： </span><br><span class="hljs-comment">17</span><br><span class="hljs-comment">输出1： </span><br><span class="hljs-comment">2     （2+3+5+7，17） </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="poj2100-graveyard-design">2.8 POJ2100 Graveyard Design</h2><p><a href="http://poj.org/problem?id=2100">POJ2100</a>的AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">给一个数 n （1 &lt;= n &lt;= 10^14）。</span><br><span class="hljs-comment">求一段连续的数的数字，使得其平方和等于n。</span><br><span class="hljs-comment">输出的时候，先输出有多少组解，然后换行，每一行输出一组解内的元素个数，及这些元素的数值。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    学习本代码，需要预先掌握尺取法的基本思想。本题思路和POJ2739很相似</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">注意typedef的这种写法，要学会</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">注意pair的使用，虽然本题还可以用其他结构来实现，但建议学会pair的使用。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;    <span class="hljs-comment">//  基本上等效于 #define LL long long</span><br>vector&lt;pair&lt;LL, LL&gt; &gt; ans;    <span class="hljs-comment">// 这里一定要注意这个&quot;&gt; &gt;&quot;之间要有空格</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(LL n)</span> </span>&#123;<br>    LL l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>, sq;<br>    <span class="hljs-comment">// 这里写成死循环比较方便一些！ </span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// r是否要右移。不在外层循环中决定，而是在内层循环中决定</span><br>        <span class="hljs-keyword">while</span> (sum &lt; n) &#123; <span class="hljs-comment">//当sum不够n时，因为区间平方和是单调的，所以右移r以扩大区间，从而扩大sum</span><br>            sq = r * r;<br>            sum += sq;<br>            r++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sq &gt; n)   <span class="hljs-comment">// 如果一个数的平方和都已经超过n，那后面不可能再有符合要求的区间了。可以输结果了 </span><br><span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// 当sum&gt;=n时走到这里来</span><br>        <span class="hljs-keyword">if</span> (sum == n)<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(l, r));    <span class="hljs-comment">// 注意，这里表示的是[l, r-1],因为r在while里多加了一次</span><br>        <span class="hljs-comment">// 不管有没有找到一个解，都需要慢指针右移，慢指针前行</span><br>        sum -= l * l;<br>        l++;<br>    &#125;<br><br>    <span class="hljs-comment">// 下面的代码都在凑输出</span><br>    LL size = ans.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, size);<br>    <span class="hljs-keyword">for</span> (LL i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        LL ansr = ans[i].second;<br>        LL ansl = ans[i].first;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,ansr-ansl);              <span class="hljs-comment">// 因为ansr偏大了1，所以这里算区间长度不需要再加1了</span><br>        <span class="hljs-keyword">for</span> (LL j=ansl; j&lt;ansr; j++)           <span class="hljs-comment">// ansr偏大了1，所以j最多到ansr-1就可以了</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %lld&quot;</span>, j);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);      //读入数据生成器造出来的数据</span><br><span class="hljs-comment">//    freopen(&quot;test.txt&quot;, &quot;w&quot;, stdout);   //输出答案</span><br>    <br>    LL n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;n);<br>    <span class="hljs-built_in">solve</span>(n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p1381-单词背诵">2.9 P1381 单词背诵</h2><p>视频链接：<ahref="https://www.bilibili.com/video/BV1MP411W7tk">双指针P1381（单词背诵）</a></p><p>原题链接：<ahref="https://www.luogu.com.cn/problem/P1381">P1381（单词背诵）</a></p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230825182436716-225604155.png" alt="img" style="zoom: 67%;" /></p><p>题意表述不太准确，需要澄清：文章由 <em>m</em>个单词构成，在该文章中找出连续的一段，其中包含<strong>最多种类</strong>（允许不包含完目标单词表的所有目标单词）的目标单词（重复的单词只算一种），且允许子串内包含其他非目标单词。并且在目标单词种类尽量多的前提下，还要使选出的文章区间尽量短。</p><p>举个例子：假如现在目标单词为A，B，C,D（为了表述方便，特意将每个目标单词假设为单字母大写，非目标单词假设为单字母小写），文章为hACnnBgC。其中“AC”是“包含两种目标单词”的最短子串，但“hACnnBgC”中存在有子串“ACnnB”和“ACnnBgC”这两个子串（不止这两个）包含了三种目标单词。根据题意，种类较多的胜出（哪怕长度值大于“AC”），所以最终答案在这些包含了三种目标单词的子串中选择，很明显最终答案是“ACnnB”，更短。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240121173427411.png"alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    基本题意：求文章中出现单词种数最多且最短的连续区间</span><br><span class="hljs-comment">    如果种数不是最多的，不是答案！ 如果不够短，不是答案！ </span><br><span class="hljs-comment">    如果该区间内有非单词表的单词，允许！</span><br><span class="hljs-comment">*/</span> <br><span class="hljs-type">int</span> n,m;<br>string s[<span class="hljs-number">100005</span>],s1;    <span class="hljs-comment">//s[] 记录文章中的所有单词</span><br>map&lt;string,<span class="hljs-type">bool</span>&gt; wordmp;<span class="hljs-comment">//wordmp[] 记录目标单词表中的所有单词</span><br>map&lt;string,<span class="hljs-type">int</span>&gt; cntmp;  <span class="hljs-comment">//cntmp[] 记录文章当前区间内各个目标单词出现的次数</span><br><span class="hljs-type">int</span> sum;                <span class="hljs-comment">//sum 记录文章中出现单词表的单词数（不算重复的）</span><br><span class="hljs-type">int</span> len;                <span class="hljs-comment">//len 记录包含表中单词最多的区间的最短长度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    cin&gt;&gt;s1,wordmp[s1]=<span class="hljs-number">1</span>;<br>cin&gt;&gt;m;                   <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>,i=<span class="hljs-number">1</span>; j&lt;=m; j++) &#123; <span class="hljs-comment">//i&lt;=j</span><br>    cin&gt;&gt;s[j];<br>        <span class="hljs-comment">// 处理快指针j的相关事务 </span><br>    <span class="hljs-keyword">if</span>(wordmp[s[j]])        <span class="hljs-comment">//如果新进单词是目标单词表里的单词，就累加其出现次数 </span><br>        cntmp[s[j]]++;<br>    <span class="hljs-keyword">if</span>(cntmp[s[j]]==<span class="hljs-number">1</span>)      <span class="hljs-comment">//如果新进单词是第一次出现，更新sum和len </span><br>        sum++, len=j-i+<span class="hljs-number">1</span>;   <span class="hljs-comment">//重难点！区间出现新单词时，放弃原来的len值，重新存新的区间长度，因为新区间内的目标单词“更多”，但不够精简 </span><br>            <br>        <span class="hljs-comment">// 本题求最短区间，所以考虑收窄区间</span><br>        <span class="hljs-comment">// 应收窄的情况1. 左端单词出现多次，则可以放弃1次左端单词，不影响区间内单词种数</span><br>        <span class="hljs-comment">// 应收窄的情况2. 左端单词不是目标单词表内的单词，直接无视，收窄 </span><br>    <span class="hljs-keyword">while</span>(i&lt;=j &amp;&amp; (cntmp[s[i]]&gt;=<span class="hljs-number">2</span> || !wordmp[s[i]])) &#123;<br>        <span class="hljs-keyword">if</span>(cntmp[s[i]]&gt;=<span class="hljs-number">2</span>)     <span class="hljs-comment">// 如果区间左端的单词在区间内有重复，则可以把它忽视掉，毕竟右侧还有它的其他副本 </span><br>            cntmp[s[i]]--,i++; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!wordmp[s[i]]) <span class="hljs-comment">// 如果当前区间左端的单词是目标单词表里的单词，直接无视，收缩区间 </span><br>            i++; <br>        &#125;<br>    len=<span class="hljs-built_in">min</span>(len,j-i+<span class="hljs-number">1</span>);     <span class="hljs-comment">//收窄，更新len </span><br>    &#125;<br>cout&lt;&lt;sum&lt;&lt;endl&lt;&lt;len&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="abc098d-xor-sum-2">2.10 [ABC098D] Xor Sum 2</h2><p>视频链接：<ahref="https://www.bilibili.com/video/BV1h14y117rq">[ABC098D] Xor Sum2</a></p><p>原题链接：<ahref="https://www.luogu.com.cn/problem/AT_arc098_b">[ABC098D] Xor Sum2</a></p><p>大致题意：</p><p>给你一串数a[]，求出满足<spanclass="math inline">\(a_l+a_{l+1}+...+a_r=a_l \enspace xor\enspace  a_{l+1}\enspace...\enspace xor \enspace a_r (l \leqr)\)</span>的<span class="math inline">\((i,j)\)</span>的数量。已知<spanclass="math inline">\(1 \leq n\leq2*10^5,\quad 1\leq i\leq n,\quad 0\leqa_i\leq2^{20}\)</span>。</p><p>预备知识：本题涉及到了“异或”操作，这是一个按位进行的操作。</p><p>初步分析：这个题求"有多少个符合题意要求的连续区间"，并不求"最长区间"，也不求"最短区间"，不能用1.2.3节总结出来的套路模板,但因为是求连续区间，所以仍可以用普通的双指针法。下面做1.2.2节中讲到的单调性分析和时效性分析。</p><p>1）单调性分析：本题求区间的个数，有点类似于“求逆序对的个数”这种风格，必然会涉及到对两个数的暴力枚举。但如果是无脑枚举，<spanclass="math inline">\(O(n^2)\)</span>的效率，复杂度为4e10，是会TLE的。不可取。题目涉及到的是连续区间。也就是说，区间内的所有数，代入公式，条件成立。如果遇到区间[l,r]内的某一个数<span class="math inline">\(a_k\)</span>代入该公式后<spanclass="math inline">\(a_l+...+a_k+...+a_r \neq a_l \enspace xor...\enspace xor\enspace  a_k\enspace...\enspace xor \enspace a_r (l &lt;k\le r)\)</span>，则需放弃该区间[l,r]。对于[l,r]，假设l固定不动，随着r的右移，区间变宽，只会出现“符合<spanclass="math inline">\(\Rightarrow\)</span>不符合”的情况，而不会出现“符合<spanclass="math inline">\(\Rightarrow\)</span>不符合<spanclass="math inline">\(\Rightarrow\)</span>符合”的情况。<strong>所以本题的“条件”具备单调性</strong>。一旦出现了上述这个<spanclass="math inline">\(a_k\)</span>，则k右侧的所有端点不必再枚举了，区间必定是不符合条件的。所以这里不应该盲目地采用<spanclass="math inline">\(O(n^2)\)</span>的效率去无脑枚举。</p><p>2）时效性分析：对于一个给定的区间[l,r]，假设该区间已经符合公式，有sum[l..r]=sumxor[l..r]。现在r尝试右移，仍然可以在O(1)的效率内计算出sum[l..r]+data[r+1]的值，以及sumxor[l..r]xor data[r+1]的值，进而判断是否相等。即该条件的判定具有时效性。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230826095827743-1068963304.png" alt="img" style="zoom:80%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230826095827887-317965124.png" alt="img" style="zoom:80%;" /></p><p>在上图的样例中，一共有9个区间符合公式条件。i不动的前提下，j指针每次尝试右移前先判定，符合就右移，答案数+1，换句话说，j右移一次，答案数加1，直到不符合条件。所以当i不动的前提下，贡献的答案数其实就是不符合之前的区间宽度，即j-i+1。然后i右移，j归位到i，再周而复始，直到i到最右侧。所以“j到最右侧”并不是外层循环的结束条件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL; <span class="hljs-comment">// 或者#define LL long long</span><br>LL a[<span class="hljs-number">200005</span>];<br>LL s1,s2,ans;<br><span class="hljs-comment">//s1:算术和, s2:异或和, ans:方案数</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) cin&gt;&gt;a[i];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>; i&lt;=n; ) &#123; <span class="hljs-comment">//外层循环以慢指针i到最右为止。可以看出，双指针法需要具体情况具体分析</span><br>        <span class="hljs-comment">// 当i不变时，让j走到不符合条件之前停下来</span><br>        <span class="hljs-keyword">while</span>(j+<span class="hljs-number">1</span>&lt;=n&amp;&amp;s1+a[j+<span class="hljs-number">1</span>]==(s2^a[j+<span class="hljs-number">1</span>])) &#123; <span class="hljs-comment">//预判，这里不能先改j的值！</span><br>            j++;<br>            s1+=a[j];    <span class="hljs-comment">// 累加和</span><br>            s2^=a[j];    <span class="hljs-comment">// 累异或和</span><br>        &#125;<br>        ans += j-i+<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 慢指针i前进，刷新</span><br>        s1-=a[i];<br>        s2^=a[i];<br>        i++;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 线性结构基础算法 </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和 二维前缀和</title>
      <link href="/2024/01/03/%E5%89%8D%E7%BC%80%E5%92%8C%20%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>/2024/01/03/%E5%89%8D%E7%BC%80%E5%92%8C%20%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><p>视频教学链接：<ahref="https://www.bilibili.com/video/BV1ja4y1F7Fk/?_blank&amp;vd_source=0e7cc4e4bbbb67e5c3c2a3e7d967f075">前缀和二维前缀和</a></p><h1 id="二实战训练">二、实战训练</h1><h2 id="luogu-p8218-b3612深进1.例1求区间和">2.1 Luogu P8218/B3612【深进1.例1】求区间和</h2><h3 id="原题链接">2.1.1 原题链接</h3><p><a href="https://www.luogu.com.cn/problem/P8218">Luogu P8218/B3612【深进1.例1】求区间和</a></p><p>这两个题是完全相同的内容和要求，合并在一起讲解。这个题是“前缀和”的入门模板题，裸求一维前缀和。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230704111737035-889544091.png" style="zoom: 67%;" /></p><h3 id="分析">2.1.2 分析</h3><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230704111737059-1374681507.png" style="zoom:80%;" /></p><h3 id="ac代码">2.1.3 AC代码</h3><p>下面展现B3612的AC代码。快读版本的代码可看P8218的AC代码，就不在此处展现了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[<span class="hljs-number">100005</span>],s[<span class="hljs-number">100005</span>];   <span class="hljs-comment">// 大量录入和输出，可以上快读、快写</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>        s[i]=s[i<span class="hljs-number">-1</span>]+a[i];  <span class="hljs-comment">// 此处也可以直接a[i] += a[i-1]，一数组两用，不需要s[]</span><br>    &#125;<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++) &#123;<br>        <span class="hljs-type">int</span> l,r;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="hljs-number">-1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与本题比较类型的还有<ahref="https://www.luogu.com.cn/problem/P10233">P10233 [yLCPC2024] A. dx分计算</a>，可以试试。</p><h2 id="p1115-最大子段和">2.2 <span id="jump1">P1115最大子段和</span></h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p><a href="https://www.luogu.com.cn/problem/P1115">P1115最大子段和</a></p><h3 id="分析-1">2.2.2 分析</h3><p>这个题是对前缀和的一个小变化。如果强行去暴力枚举每个区间的左右两个端点来求和，复杂度为<spanclass="math inline">\(O(n^2)=4e10\)</span>，铁定会TLE。我们可以换一个思路：如果左侧多个数的“累加和”对sum增加没有贡献，甚至变成累赘，那不如放弃而从当前数重新开始。这是一种贪心的思维，时间复杂度是<spanclass="math inline">\(O(n)\)</span>的。</p><h3 id="ac代码-1">2.2.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">这个题，一边累加sum，同时一边判断sum的正负，从而丢弃sum。这个sum实际上也算是</span><br><span class="hljs-comment">    一种前缀和，但没有用专门的数组来存储。这种思想可以琢磨琢磨。</span><br><span class="hljs-comment">复杂度O(n) </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-type">int</span> a[<span class="hljs-number">200001</span>];   <span class="hljs-comment">// 本题其实可以不使用这个数组也能AC </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> i,n,maxsum=<span class="hljs-number">-2e10</span>,sum=<span class="hljs-number">0</span>;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>cin&gt;&gt;a[i];<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-comment">// 不管当前的a[i]是正或者是负，都应该根据sum来做区别处理 </span><br><span class="hljs-comment">// 如果sum加前已为负数，那应放弃之前sum的积累，从当前数开始（不管当前数的正负） </span><br><span class="hljs-keyword">if</span>(sum&gt;<span class="hljs-number">0</span>)<br>sum+=a[i];<br><span class="hljs-keyword">else</span><br>sum=a[i];  <span class="hljs-comment">// 当前数应至少为sum </span><br><br><span class="hljs-keyword">if</span>(maxsum&lt;=sum)<br>maxsum=sum;<br>&#125;<br>cout&lt;&lt;maxsum;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">//// 如果数据全为负数，也应该得到-20，而不是-100000 </span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">-200 -20 -150 -100 -120</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="后记">2.2.4 后记</h3><p>1）这个题，我们要去找一个最大的子段和，但是我们并没有去暴力枚举区间的左端和右端，否则时间复杂度肯定是<spanclass="math inline">\(O(n^2)\)</span>。采用前缀和的思想，一旦发现sum&lt;=0，立刻丢弃累赘重新开始。用这种思想可以解决“不限宽度的区间最大和值”的问题。</p><p>2）如果我们不仅要求出最大的子段和，还要求这个区间的左右端点的下标值，那该怎么做呢？其实也简单，在新开辟一个“累加和”区间时，用le记录其下标i值，表示为区间的起始左端点。当刷新maxsum的同时也记录保存maxle的值为le值即可。展示代码如下：（完整代码见“P1115强化.cpp”）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> le, maxle=<span class="hljs-number">0</span>;  <br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>, le=<span class="hljs-number">0</span>; i&lt;=n; i++) &#123;<br>    <span class="hljs-keyword">if</span>(sum&gt;<span class="hljs-number">0</span>)            <span class="hljs-comment">// 如果当前数的左侧的数据之和是正的 </span><br>        sum+=a[i];       <span class="hljs-comment">// 那就累加当前，此刻暂时不管加起来是正或负（加后为负的情况在下一个数时做处理） </span><br>    <span class="hljs-keyword">else</span><br>        sum=a[i], le=i;  <span class="hljs-comment">// 如果左侧的数之和已为负数，是累赘，丢弃，从当前数重新开始累加 </span><br><br>    <span class="hljs-keyword">if</span>(maxsum&lt;=sum)      <span class="hljs-comment">// 刷新最大值的操作，应独立出来单独处理 </span><br>        maxsum=sum, maxle=le;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i=%-4d, sum=%-4d, le=%-4d, maxsum=%-4d, maxle=%-4d\n&quot;</span>, i, sum, le, maxsum, maxle);<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;le=%a, maxsum=%a&quot;</span>, maxle, maxsum);<br></code></pre></td></tr></table></figure><p>其运行结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs text">16<br>-20 15 10 -5 -20 5 15 10 -30 10 -5 10 30 -20 5 -1000<br>i=1   , sum=-20 , le=1   , maxsum=0   , maxle=0<br>i=2   , sum=15  , le=1   , maxsum=15  , maxle=1<br>i=3   , sum=25  , le=1   , maxsum=25  , maxle=1<br>i=4   , sum=20  , le=1   , maxsum=25  , maxle=1<br>i=5   , sum=0   , le=5   , maxsum=25  , maxle=1<br>i=6   , sum=5   , le=5   , maxsum=25  , maxle=1<br>i=7   , sum=20  , le=5   , maxsum=25  , maxle=1<br>i=8   , sum=30  , le=5   , maxsum=30  , maxle=5<br>i=9   , sum=0   , le=9   , maxsum=30  , maxle=5<br>i=10  , sum=10  , le=9   , maxsum=30  , maxle=5<br>i=11  , sum=5   , le=9   , maxsum=30  , maxle=5<br>i=12  , sum=15  , le=9   , maxsum=30  , maxle=5<br>i=13  , sum=45  , le=9   , maxsum=45  , maxle=9<br>i=14  , sum=25  , le=9   , maxsum=45  , maxle=9<br>i=15  , sum=30  , le=9   , maxsum=45  , maxle=9<br>i=16  , sum=-970, le=16  , maxsum=45  , maxle=9<br>le=9, maxsum=45<br></code></pre></td></tr></table></figure><h2 id="luogu-p2280-hnoi2003-激光炸弹">2.3 Luogu P2280 [HNOI2003]激光炸弹</h2><h3 id="原题链接-2">2.3.1 原题链接</h3><p>[Luogu P2280 <ahref="https://www.luogu.com.cn/problem/P2280">HNOI2003] 激光炸弹</a></p><p><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230704111737118-1986573874.png" /></p><h3 id="分析-2">2.3.2 分析</h3><p>这个题实际上就是要<strong>计算网格内<spanclass="math inline">\(m*m\)</span>的诸多正方形中，哪一个正方形内框住的数据之和值最大？</strong>需要频繁地计算某个大小区域范围内的数据之和，起点不同。采用二维前缀和的思路来做最方便：</p><p>1）首先需要先求出s[1..5001][1..5001]。s[i][j]表示长方形[1..i][1..j]范围内的数据之和值，即二维前缀和。这里需要注意，前缀和数组最好是从下标1开始存储数据，<strong>把0行和0列空出来并置为0，以方便后续的运算</strong>。递推方程式中0行及0列的数据都是0，才能正确做二维递推。</p><p>2）求出二维前缀和数组之后，当需要查询二维区间和值时，因为每个二维区间都是<spanclass="math inline">\(m *m\)</span>的正方形，其右下角方格的坐标应该在[m..R][m..C]范围内，所以只需要在这个范围<spanclass="math inline">\(O((R-m)*(C-m))\)</span>内以<spanclass="math inline">\(O(4)^{\textcolor[RGB]{225,0,0}{[*]}}\)</span>的代价就能求出其二维区间和值，找出其最大值。得解。</p><p>3）"二维前缀和"的递推方程式，以及"二维区间和"的求解方程式请见下图。</p><p>4）关于高维前缀和的求法，请见本页底部的拓展介绍。</p><p><strong><spanclass="math inline">\(\textcolor[RGB]{225,0,0}{[*]}\)</span>：此处的公式是一个变长的公式，其加减项的个数随着维数d的变化而呈现指数级的变化。因为本题是二维，所以此处复杂度都是<spanclass="math inline">\(O(4)\)</span>，近似等于<spanclass="math inline">\(O(1)\)</span>，忽略不计。但如果是d维(d&gt;=3)的前缀和，按容斥原理的这种写法计算，公式会有<spanclass="math inline">\(2^d\)</span>个加减项，所以此处的复杂度为<spanclass="math inline">\(O(2^d)\)</span>，不容忽视。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230704111737007-1486719667.png" style="zoom: 67%;" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1961668-20231208155117693-539585701.png" /></p><h3 id="p2280-ac代码">2.3.3 P2280 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*    用二维前缀和来求解二维区间和的模板题   */</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5005</span>;<br><span class="hljs-type">int</span> R,C;          <span class="hljs-comment">// R个目标, 边长为C的正方形</span><br><span class="hljs-type">int</span> s[N][N];      <span class="hljs-comment">// 价值前缀和</span><br><span class="hljs-comment">// 因为空间较为紧张，这里只用了一个数组，计算出前缀和之后，原数组直接被覆盖</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin&gt;&gt;R&gt;&gt;C;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;R; i++) &#123;<br>        <span class="hljs-type">int</span> x,y,v;<br>        cin&gt;&gt;x&gt;&gt;y&gt;&gt;v;<br>        x++,y++; <span class="hljs-comment">//先加1再存值，即基本数据从1行或1列开始存储，把0行和0列空出来以方便递推</span><br>        s[x][y]+=v;<br>    &#125;<br>    <span class="hljs-comment">// 求二维前缀和，方法一</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5001</span>; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=<span class="hljs-number">5001</span>; j++)<br>            s[i][j]+=s[i<span class="hljs-number">-1</span>][j]+s[i][j<span class="hljs-number">-1</span>]-s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br><span class="hljs-comment">//    // 方法二</span><br><span class="hljs-comment">//    for (int i = 1; i &lt;= N; i ++)</span><br><span class="hljs-comment">//        for (int j = 1; j &lt;= N; j ++) s[i][j] += s[i][j - 1];</span><br><span class="hljs-comment">//    for (int j = 1; j &lt;= N; j ++)</span><br><span class="hljs-comment">//        for (int i = 1; i &lt;= N; i ++) s[i][j] += s[i - 1][j];</span><br><br>    <span class="hljs-comment">// 查询二维区间和</span><br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C; i&lt;=<span class="hljs-number">5001</span>; i++)   <span class="hljs-comment">// 从C出发，因为C*C的正方形的右下角坐标至少应该是[C][C]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=C; j&lt;=<span class="hljs-number">5001</span>; j++)<br>            res=<span class="hljs-built_in">max</span>(res,s[i][j]-s[i-C][j]-s[i][j-C]+s[i-C][j-C]);<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p1719-1224-最大加权矩形最大子矩阵">2.4 P1719 /1224最大加权矩形(最大子矩阵)</h2><h3 id="原题链接-3">2.4.1 原题链接</h3><p><a href="https://www.luogu.com.cn/problem/P1719">P1719最大加权矩形</a> / <ahref="https://ybt.ssoier.cn/problem_show.php?pid=1224">1224最大子矩阵</a></p><h3 id="分析-3">2.4.2 分析</h3><p>这个题与2.3节的P2280最大的不同，就是P2280中规定了子矩阵的形状必定是<spanclass="math inline">\(m*m\)</span>的，而本题中并没有规定子矩阵的形状，需要自行去枚举和比较。而如果对一个子矩阵的两个端点(左上角坐标、右下角坐标)进行暴力枚举的话，因为n=120，所以其复杂度会达到<spanclass="math inline">\(O(n^4)=1e8\)</span>，将会TLE了，不能采用四重循环来解决。但如果我们能把<spanclass="math inline">\(n^4\)</span>降为<spanclass="math inline">\(n^3\)</span>，就没问题了。如何降低一维呢？</p><p>还记得我们曾经做过的"<a href="#jump1">P1115求最大子段和</a>"这个题吗？我们在一维数组中去寻找一个区间（区间宽度未知），并没有强行去枚举区间的左右端点，而是采用了一种<spanclass="math inline">\(O(n)\)</span>的算法来降维搞定，核心思想就是“贪心”（若左侧多个数据的前缀和已成累赘，丢弃之，从当前数据重新开始累加）！</p><p>我们能否把这种思想用在本题中呢？当然是可以的！但需要改良，如下图所示。我们可以对左右两端的列号le和ri进行枚举（<spanclass="math inline">\(O(C^2)\RightarrowO(n^2)\)</span>），但不枚举上端和下端的行号，而是从1到R枚举当前行号i。事先准备好矩阵每一行的前缀和数组，可以在<spanclass="math inline">\(O(1)\)</span>的范围内(sum[i][ri]-sum[i][le-1])算出每一行从data[i][le..ri]的数据之和。这样的话，就可以把一个二维的问题变成竖向的一维数据（每个长方形代表了一个数）的“求最大累加和”问题，和P1115很相似了。从上往下累加sum。一旦发现sum&lt;=0，则直接放弃上面的累加，从当前行开始重新累加。这个操作是<spanclass="math inline">\(O(R)\RightarrowO(n)\)</span>的，所以，整个算法的复杂度就是<spanclass="math inline">\(O(n^2*n=O(n^3))\)</span>，从而实现降维，搞定！</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240320105148242.png" style="zoom:50%" /></p><h3 id="ac代码-2">2.4.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 121</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f </span><br><span class="hljs-comment">// sum[i][j]：第i行元素的前缀和，即第i行前j个元素的和，行列都是从1开始编号</span><br><span class="hljs-comment">// sum[i][j] = 90 表示 第i行从左往右前j个元素之和等于90  </span><br><span class="hljs-type">int</span> sum[N][N], data[N][N];<br><span class="hljs-type">int</span> ans = -INF, sum, n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)<br>        &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data[i][j]);<br>        <span class="hljs-comment">// data[][]的行前缀和，注意！sum[][]并非二维前缀和！ </span><br>        sum[i][j] = sum[i][j<span class="hljs-number">-1</span>] + data[i][j];<br>&#125;<br>    <span class="hljs-comment">// 穷举子矩阵，从le列到ri列，逐行累加求子矩阵元素总和sum，</span><br><span class="hljs-comment">// 一旦sum为负，立刻清零并从下一行重新开始    </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> le=<span class="hljs-number">1</span>; le&lt;=n; le++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ri=le; ri&lt;=n; ri++) <span class="hljs-comment">// ri可以和le重叠 </span><br>    &#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;            <span class="hljs-comment">// 每次从上往下求和之前，sum都需要重新归零 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> row=<span class="hljs-number">1</span>; row&lt;=n; row++)<br>            &#123;<br>sum += sum[row][ri] - sum[row][le<span class="hljs-number">-1</span>];  <span class="hljs-comment">// O(1)的代价得到data[row][le..ri]的和值 </span><br>          ans = <span class="hljs-built_in">max</span>(sum, ans); <span class="hljs-comment">// ans记录sum曾经出现过的最大值 </span><br>            sum = <span class="hljs-built_in">max</span>(sum, <span class="hljs-number">0</span>);   <span class="hljs-comment">// 如果累加和为负数，直接放弃，sum重新归0 </span><br>    &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一本通的<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1224">1224</a>、<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1282">1282</a>，和本题完全一模一样，可作为巩固练习。</p><h2 id="luogu-p1387-最大正方形">2.5 Luogu P1387 最大正方形</h2><h3 id="原题链接-4">2.5.1 原题链接</h3><p><a href="https://www.luogu.com.cn/problem/P1387">Luogu P1387最大正方形</a></p><h3 id="基本题意">2.5.2 基本题意</h3><p>在一个 <span class="math inline">\(n*m\)</span> 的只包含 0 和 1的矩阵里找出一个不包含0(只包含1)的最大正方形，输出其边长。</p><h3 id="分析-4">2.5.3 分析</h3><p>这个题，其实和“前缀和”的关系不大，可以运用递推的思维来解决。搞定<spanclass="math inline">\(f[1][1..C]\)</span>和<spanclass="math inline">\(f[1..R][1]\)</span>，然后看<spanclass="math inline">\(f[i][j]\)</span>和之前的<spanclass="math inline">\(f[i-1][j]\)</span>、<spanclass="math inline">\(f[i-1][j-1]\)</span>、<spanclass="math inline">\(f[i][j-1]\)</span>等有什么关联，从而进一步推出dp的递推方程式。</p><p>1） 状态定义</p><p><strong>f[i][j]:表示以节点i,j为右下角，可构成的最大正方形的边长</strong>。</p><p>2） 所求目标 <span class="math display">\[max(f[1..R][1..C])\]</span> 3） 状态转移方程</p><p>if (a[i][j]==1) f[i][j] = min( min(f[i][j-1], f[i-1][j]),f[i-1][j-1]) + 1;</p><p>只有a[i][j]==1时，节点i,j才能作为正方形的右下角；</p><p>对于一个已经确定的f[i][j]=x，它表明包括节点i，j在内，向上x个节点，向左x个节点扫过的正方形中所有a[][]的值都为1；</p><p>对于一个待确定的f[i][j]，我们已知f[i-1][j]，f[i][j-1]，f[i-1][j-1]的值，如下：</p><p>                          f数组:        原a数组：</p><p><span class="math display">\[\left[\begin{matrix}   ? &amp; ? &amp; ? &amp; ?\\   ? &amp; ? &amp; 2 &amp; 1\\   ? &amp; ? &amp; 3 &amp; \textcolor{red}{?}\\   ? &amp; ? &amp; ? &amp; ?  \end{matrix}  \right]    反推出\Longrightarrow \left[\begin{matrix}   1 &amp; 1 &amp; 1 &amp; 0\\   1 &amp; 1 &amp; 1 &amp; 1\\   1 &amp; 1 &amp; 3 &amp; 1\\   ? &amp; ? &amp; ? &amp; ?  \end{matrix}  \right]\]</span> 由此得出状态转移方程：</p><p>if (a[i][j]==1) f[i][j]=min(min(f[i][j-1], f[i-1][j]), f[i-1][j-1]) +1;</p><p>例如:                           a数组:       f数组： <spanclass="math display">\[\left[\begin{matrix}   0 &amp; 0 &amp; 0 &amp; 1\\   1 &amp; 1 &amp; 1 &amp; 1\\   0 &amp; 1 &amp; 1 &amp; 1\\   1 &amp; 1 &amp; 1 &amp; 1  \end{matrix}  \right]    正推出\Longrightarrow \left[\begin{matrix}   0 &amp; 0 &amp; 0 &amp; 1\\   1 &amp; 1 &amp; 1 &amp; 1\\   0 &amp; 1 &amp; 2 &amp; 2\\   1 &amp; 1 &amp; 2 &amp; 3  \end{matrix}  \right]\]</span></p><h3 id="ac代码-3">2.5.4 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    二维前缀和的拓展题</span><br><span class="hljs-comment">    1） 状态定义</span><br><span class="hljs-comment">        f[i][j]表示以节点i,j为右下角，可构成的最大正方形的边长。</span><br><span class="hljs-comment">    2） 所求目标</span><br><span class="hljs-comment">        max(f[1..R][1..C])</span><br><span class="hljs-comment">    3） 状态转移方程</span><br><span class="hljs-comment">        if (a[i][j]==1)</span><br><span class="hljs-comment">            f[i][j] = min(min(f[i][j-1], f[i-1][j]), f[i-1][j-1]) + 1;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    只有a[i][j]==1时，节点i,j才能作为正方形的右下角；</span><br><span class="hljs-comment">    对于一个已经确定的f[i][j]=x，它表明包括节点i，j在内向上x个节点，向左x个节点扫过的正方形中所有a值都为1；</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> a,R,C,f[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>],ans;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;R,&amp;C);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=R; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=C; ++j) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);<br>            <span class="hljs-comment">//因为只需用到i，j上方，左方，左上方的信息，读入同步处理</span><br>            <span class="hljs-keyword">if</span> (a == <span class="hljs-number">1</span>)<br>                f[i][j] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(f[i][j<span class="hljs-number">-1</span>], f[i<span class="hljs-number">-1</span>][j]), f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])   +  <span class="hljs-number">1</span>;<br>            ans=<span class="hljs-built_in">max</span>(ans,f[i][j]);    <span class="hljs-comment">//同步更新答案</span><br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三高维前缀和">三、高维前缀和</h1><h2 id="高维前缀和">3.1 高维前缀和</h2><p>所谓“高维前缀和”，就是指”二维及以上“的前缀和</p><p>例如我们给定一个矩阵： <span class="math display">\[\left[\begin{matrix}   1 &amp; 2 &amp; 4 &amp; 3\\   5 &amp; 1 &amp; 2 &amp; 4\\   6 &amp; 3 &amp; 5 &amp; 9\\  \end{matrix}  \right] \tag{1}\]</span></p><p>那么它的前缀和就是： <span class="math display">\[\left[\begin{matrix}   1 &amp; 3 &amp; 7 &amp; 10\\   6 &amp; 9 &amp; 15 &amp; 22\\   12 &amp; 18 &amp; 29 &amp; 45\\  \end{matrix}  \right]\]</span></p><h2 id="两种求法">3.2 两种求法</h2><p>由于二维前缀和最为常用，我们先来看二维的情况。</p><h3 id="递推实现利用容斥原理效率一般">3.2.1递推实现（利用容斥原理，效率一般）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span> to R<br>    <span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span> to C<br>        sum[i][j] = sum[i<span class="hljs-number">-1</span>][j] + sum[i][j<span class="hljs-number">-1</span>] - sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + a[i][j];<br></code></pre></td></tr></table></figure><p>其实就是运用了容斥原理。</p><h3 id="硬干按维做前缀和效率更优更利于拓展为多维操作">3.2.2硬干（按维做“前缀和”，效率更优，更利于拓展为多维操作）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span> to R                           <br>    <span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span> to C<br>        sum[i][j]+=sum[i][j<span class="hljs-number">-1</span>]+a[i][j];<span class="hljs-comment">// 横向累加</span><br><span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span> to C                           <br>    <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span> to R<br>        sum[i][j]+=sum[i<span class="hljs-number">-1</span>][j];        <span class="hljs-comment">// 纵向累加。注意，这里没有a[][]参与了！因为都已经累加到累加和数组sum[][]里了</span><br></code></pre></td></tr></table></figure><p>第一遍循环后，所得的矩阵是<strong>每行各自独立的前缀和</strong>。</p><p>还是看上面的那个矩阵a[][]： <span class="math display">\[\left[\begin{matrix}   1 &amp; 2 &amp; 4 &amp; 3\\   5 &amp; 1 &amp; 2 &amp; 4\\   6 &amp; 3 &amp; 5 &amp; 9\\  \end{matrix}  \right] \tag{1}\]</span></p><p>第一个二重循环（先行后列）做完后，得到矩阵 <spanclass="math inline">\(sum^*[][]\)</span>： <span class="math display">\[\left[\begin{matrix}   1 &amp; 3 &amp; 7 &amp; 10\\   5 &amp; 6 &amp; 8 &amp; 12\\   6 &amp; 9 &amp; 14 &amp; 23\\  \end{matrix}  \right] \tag{2}\]</span> 第二个二重循环是将<spanclass="math inline">\(sum^*[][]\)</span>的每列再按行从上往下各自再做一遍前缀和，此时已经不需要原始数组a[][]的参与了。最终的二维前缀和矩阵sum[][]如下所示：<span class="math display">\[\left[\begin{matrix}   1 &amp; 3 &amp; 7 &amp; 10\\   6 &amp; 9 &amp; 15 &amp; 22\\   12 &amp; 18 &amp; 29 &amp; 45\\  \end{matrix}  \right]\tag{3}\]</span></p><p>现在我们变化一下循环顺序，对矩阵（1）按照“先列后行”的顺序来做，看看会得到什么不同的结果。<span class="math display">\[\left[\begin{matrix}   1 &amp; 2 &amp; 4 &amp; 3\\   5 &amp; 1 &amp; 2 &amp; 4\\   6 &amp; 3 &amp; 5 &amp; 9\\  \end{matrix}  \right] \stackrel{从上往下累加}{\Longrightarrow}\left[\begin{matrix}   1 &amp; 2 &amp; 4 &amp; 3\\   6 &amp; 3 &amp; 6 &amp; 7\\   12 &amp; 6 &amp; 11 &amp; 16\\  \end{matrix}  \right]\stackrel{从左往右累加}{\Longrightarrow}\left[\begin{matrix}   1 &amp; 3 &amp; 7 &amp; 10\\   6 &amp; 9 &amp; 15 &amp; 22\\   12 &amp; 18 &amp; 29 &amp; 45\\  \end{matrix}  \right]\]</span></p><p>可以看出，先列后行，仍然能得到相同的最终结果。</p><p>这里需要强调两点：</p><p>1）我们在书写两个二重for循环时写下的"for R for C"或者"for C forR"，它们是我们在填写数组时的<strong>填写顺序</strong>，比如"for R forC"表示“按照(1,1)、（1，2）...（1，R）、（2，1）、（2，2）”这个顺序来填写。经过我们刚才以实际数据来测试的结果，只要和推导的方向一致，那么两种顺序都是可以的。</p><p>2）针对每个具体的位置，例如sum[3][5]，它的数值来自于左侧的sum[3][4]或者上方的sum[2][5]呢？这个就要取决于你决定的累加顺序了。这里罗嗦一下，已经看懂的同学可以跳过本段后续的内容。如果你打算先从左往右累加前缀和，那么在第一个二重for里就应该写sum[i][j]=sum[i][j-1]+a[i][j]，然后在后续的二重循环里写sum[i][j]=sum[i-1][j]+sum[i][j]。反之，如果你打算先从上往下累加前缀和，那么在第一个二重for里就应该写sum[i][j]=sum[i-1][j]+a[i][j]，然后在后续的二重循环里写sum[i][j]=sum[i][j-1]+sum[i][j]。</p><h3 id="比较">3.2.3 比较</h3><p>两种求法的时间复杂度都是 <spanclass="math inline">\(O(len_1*len_2)\)</span>。但考虑维数 d的话，“递推实现”的复杂度为 <spanclass="math inline">\(O(len_1*len_2*...*len_d*\textcolor{red}{2^d})\)</span>（基于容斥原理去计算前缀和的复杂度为 <spanclass="math inline">\(O(2^d)\)</span>），“按维累加来实现”的复杂度为<span class="math inline">\(O( len_1*len_2*...*len_d*\textcolor{red}{d})\)</span>。所以如果是求多维数组的前缀和，<strong>推荐还是使用第二种方法</strong>。</p><h1 id="四拓展阅读">四、拓展阅读</h1><p><strong>（NOIP难度，普及、提高免进）</strong></p><h3 id="高维前缀和总结sosdp---heyuhhh---博客园-cnblogs.com">1. <ahref="https://www.cnblogs.com/heyuhhh/p/11585358.html">高维前缀和总结(sosdp)- heyuhhh - 博客园 (cnblogs.com)</a></h3><h3 id="专题高维前缀和---ruakker---洛谷博客-luogu.org">2.<ahref="https://chocola4ever.blog.luogu.org/prefix">专题——高维前缀和 -Ruakker - 洛谷博客 (luogu.org)</a></h3>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 前缀和/差分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序 第k小的数 nth_element()函数</title>
      <link href="/2024/01/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%20%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0%20nth_element()%E5%87%BD%E6%95%B0/"/>
      <url>/2024/01/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%20%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0%20nth_element()%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h3id="视频教学链接"><a href="https://bilibili.com/video/BV17h4y1E73i/?spm_id_from=333.999.0.0/?_blank" target="_blank">视频教学链接：</a></h3><h1 id="二实战训练">二、实战训练</h1><h3 id="p1177-模板排序">1.<ahref="https://www.luogu.com.cn/problem/P1177">P1177【模板】排序</a></h3><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1961668-20231206160224364-485932827.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1961668-20231206161152271-458682285.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1961668-20231206161726712-668972664.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>强调补充说明：</p><p>1）当左指针和右指针重叠或者错位时，退出while循环，所以while循环条件应写为<strong>while( i &lt; j ) ，不要加入'='号</strong>！</p><p>2）对x的取值，不一定非要去取区间中段的值，可以随机取（仍然无法确保肯定能把区间分成长度接近的两段）。</p><p>3）如果要取区间中段值，为防止int 或者longlong的加法溢出，<strong>最好是写成 x = a[ le + (ri - le)/2]的代码形式</strong>。</p><p>4）当退出while循环时，<strong>i 和 j 正好是重叠的(i == j)，或者是错位的( j+1 == i )</strong>。此时往下递归，左区间取[le, j]，<strong>右区间取[j+1, ri ]（不能取[i, ri]，因为i和j可能是重叠的，若取i 会让 a[i] 同时在两个子区间内）</strong></p><p>5）代码模板建议背下来！</p><p>P1177 AC代码： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,a[<span class="hljs-number">100005</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span>;         <span class="hljs-comment">// 重叠就返回</span><br>    <span class="hljs-type">int</span> i=l<span class="hljs-number">-1</span>, j=r+<span class="hljs-number">1</span>;        <span class="hljs-comment">// 左右指针分别初始化为“区间的外侧”</span><br>    <span class="hljs-type">int</span> x=a[i+(j-i)/<span class="hljs-number">2</span>];      <span class="hljs-comment">// x一定要提前取出来，不能在while内去临时取，因为中间位置的值可能在变化！</span><br>    <span class="hljs-keyword">while</span>(i&lt;j) &#123;             <span class="hljs-comment">// 当i==j（重叠）或者i&gt;j（错位）时跳出循环</span><br>        <span class="hljs-keyword">do</span> i++;<br>            <span class="hljs-keyword">while</span>(a[i]&lt;x);   <span class="hljs-comment">//向右找&gt;=x的数，不能写成while(a[i]&lt;a[i+(j-i/2)])！</span><br>        <span class="hljs-keyword">do</span> j--;<br>           <span class="hljs-keyword">while</span>(a[j]&gt;x);   <span class="hljs-comment">//向左找&lt;=x的数</span><br>        <span class="hljs-keyword">if</span>(i&lt;j)<br>            <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>    &#125;<br>    <span class="hljs-comment">// 不管是重叠或是错位，下面的写法都没问题</span><br>    <span class="hljs-built_in">quicksort</span>(l, j);<br>    <span class="hljs-built_in">quicksort</span>(j+<span class="hljs-number">1</span>, r);       <span class="hljs-comment">// 不能写成(i, ri)，因为可能ij重叠</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]); <span class="hljs-comment">// 从0号位开始存储</span><br>    <span class="hljs-built_in">quicksort</span>(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">6</span><br><span class="hljs-comment">4 3 2 4 5 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">10</span><br><span class="hljs-comment">4 2 1 2 8 9 -2 4 5 1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p><h3 id="p1923-深基9.例4求第-k-小的数">2.<ahref="https://www.luogu.com.cn/problem/P1923">P1923 【深基9.例4】求第 k小的数</a></h3><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1961668-20231206164116179-1683421866.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>方法(1)：快速排序搞定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,k,a[<span class="hljs-number">5000010</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qnth_element</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> a[l];<br>    <span class="hljs-type">int</span> i=l<span class="hljs-number">-1</span>, j=r+<span class="hljs-number">1</span>, x=a[(l+r)/<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">while</span>(i&lt;j) &#123;<br>        <span class="hljs-keyword">do</span> i++;<br>            <span class="hljs-keyword">while</span>(a[i]&lt;x); <span class="hljs-comment">//向右找&gt;=x的数</span><br>        <span class="hljs-keyword">do</span> j--;<br>            <span class="hljs-keyword">while</span>(a[j]&gt;x); <span class="hljs-comment">//向左找&lt;=x的数</span><br>        <span class="hljs-keyword">if</span>(i&lt;j) <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(k&lt;=j) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qnth_element</span>(l,j);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">qnth_element</span>(j+<span class="hljs-number">1</span>,r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">qnth_element</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>方法(2)：nth_element()函数实现程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,k,a[<span class="hljs-number">5000010</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-built_in">nth_element</span>(a,a+k,a+n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a[k]);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三-拓展nth_element函数讲解">三、拓展——<strong>nth_element()函数讲解</strong>：</h1><h3 id="作用">1、作用</h3><p><strong>将数组指定范围内第 k (从1开始编此号码)小的元素（会更改原数组中所有元素的位置。如需不变，请预先备份）存于a[k-1]位置上，其左侧的元素都&lt;=a[k-1]，右侧的元素都&gt;a[k-1]，但左右两侧区间内的数据仍然凌乱。</strong></p><h3 id="用法">2、用法</h3><p>nth_element(起始地址，k-1，最后一个元素地址+1，自定义排序)；</p><p>举例：查找数组中第5小的元素 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span><span class="hljs-comment">//必要头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>&#125;;<br>    <span class="hljs-comment">// 将数组中第5小（从1开始编）的元素放在a[4]位置，</span><br>    <span class="hljs-comment">// 其左侧元素都&lt;=a[4]，右侧元素都&gt;a[4]</span><br>    <span class="hljs-built_in">nth_element</span>(a, a+<span class="hljs-number">4</span>, a+<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">// 此时数组a[]的元素已发生挪位更改。a[]=&#123;2, 1, 3, 5, 5, 9, 8, 7, 6, 10&#125;</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;第5小的数是：&quot;</span>&lt;&lt;a[<span class="hljs-number">4</span>];<span class="hljs-comment">//第5小的数在a[4]</span><br>&#125;<br><span class="hljs-comment">//console:</span><br><span class="hljs-comment">//第5小的数是：5</span><br></code></pre></td></tr></table></figure></p><p>查找第 k 大的元素也是可以的。将第 k 大的问题转换为求第 n - k + 1小的问题就可以了例如：<strong>一个数组有10个元素，求第2大的数，那么它等同于求第10-2+1=9小的元素</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span><span class="hljs-comment">//必要头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;请问您需要查找第几大的数？&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">10</span>&#125;;<br>    <span class="hljs-built_in">nth_element</span>(a, a+<span class="hljs-number">10</span>-n, a+<span class="hljs-number">10</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;第&quot;</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">&quot;大的数是：&quot;</span>&lt;&lt;a[<span class="hljs-number">10</span>-n];<br>&#125;<br><span class="hljs-comment">//console:</span><br><span class="hljs-comment">//请问您需要查找第几大的数？</span><br><span class="hljs-comment">//2</span><br><span class="hljs-comment">//第2大的数是：9</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度乘法（高精×高精）</title>
      <link href="/2024/01/03/%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95%EF%BC%88%E9%AB%98%E7%B2%BE%C3%97%E9%AB%98%E7%B2%BE%EF%BC%89/"/>
      <url>/2024/01/03/%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95%EF%BC%88%E9%AB%98%E7%B2%BE%C3%97%E9%AB%98%E7%B2%BE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h3id="视频教学链接"><a href="https://www.bilibili.com/video/BV1dG411G7eb/?_blank" target="_blank">视频教学链接：</a></h3><h1 id="二实战训练">二、实战训练</h1><h3 id="洛谷-p1303-ab-problem">1.<ahref="https://www.luogu.com.cn/problem/P1303">洛谷 P1303 A*Bproblem</a></h3><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1961668-20231206102606663-606897136.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>注意：</p><p>1）这里的乘法式，是正常的写法，出于书写方便而没有左右翻转。但在真实代码中右侧是数组低位，左侧是数组高位，<strong>循环是从低位往高位进行的！数组仍然是从0号位开始存储。</strong>书写代码时尽量统一。</p><p>2）高精度乘法比加减法稍微复杂一些，建议同学们当遇到代码问题时，分阶段去调试。<strong>首先确保A[]和B[]是正确的；然后核对乘法结果C[]是否正确，最后再来核对前导0的处理是否正确。</strong>分阶段调试是很重要的一个编程经验。</p><p>3）乘法结果数组C[]的数组长度至少应该是为乘数和被乘数的长度之和以上。对于两个2000位的数相乘，乘积结果的初始长度建议定成4010以上。并且<strong>强烈推荐所有数组从0开始存储</strong>！统一风格，不要混乱。</p><p>4）对于下标的对应关系，从上图中可以看出，A[i] *B[j]的结果值末位是存放于C[i+j]位，而结果值的进位是存于其右侧，即C[i+j+1]位。例如：A[0] *B[0]的结果值末位是存放于C[0+0]=C[0]位，而结果值的进位是存于其右侧，即C[1]位。A[1] *B[2]的结果值末位是存放于C[1+2]=C[3]位，而结果值的进位是存于其右侧，即C[4]位。A[2] *B[1]的结果值末位是存放于C[2+1]=C[3]位，而结果值的进位是存于C[4]位。 A[2]*B[2]的结果值末位是存放于C[2+2]=C[4]位，而结果值的进位是存于其右侧，即C[5]位。<strong>学生不要盲目去背这些公式，而应该拿一张草稿纸，详细列出乘法算式，然后观察对应关系，总结规律，形成公式。切莫就这么盯着而不动笔。</strong></p><p>5）<strong>关于进位的处理，可以用专门的变量c来存储，也可以直接存于C[i+j+1]位，但应是累加"+="而不是直接赋值"="</strong></p><p>版本一： <strong>int[] + c[i+j+1] 存储进位</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">4001</span>;<br><span class="hljs-type">int</span> a[N],b[N],c[N];<br><span class="hljs-type">int</span> la,lb,lc;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> b[],<span class="hljs-type">int</span> c[])</span> </span>&#123; <span class="hljs-comment">//a*b=c</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=la; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=lb; j++)<br>            c[i+j<span class="hljs-number">-1</span>]+=a[i]*b[j]; <span class="hljs-comment">//存乘积</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;lc; i++) &#123;<br>        c[i+<span class="hljs-number">1</span>]+=c[i]/<span class="hljs-number">10</span>;  <span class="hljs-comment">//存进位</span><br>        c[i]%=<span class="hljs-number">10</span>;         <span class="hljs-comment">//存余数</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(c[lc]==<span class="hljs-number">0</span>&amp;&amp;lc&gt;<span class="hljs-number">1</span>) lc--; <span class="hljs-comment">//去0</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> A[N],B[N];<br>    cin&gt;&gt;A&gt;&gt;B;<br>    la=<span class="hljs-built_in">strlen</span>(A);<br>    lb=<span class="hljs-built_in">strlen</span>(B);<br>    lc=la+lb;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=la; i++)a[i]=A[la-i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=lb; i++)b[i]=B[lb-i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-built_in">mul</span>(a,b,c);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lc; i&gt;=<span class="hljs-number">1</span>; i--) cout&lt;&lt;c[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>版本二：<strong>vector<int></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-type">int</span>&gt; VI;<br>VI A,B;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mul</span><span class="hljs-params">(VI &amp;A, VI &amp;B, VI &amp;C)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;A.<span class="hljs-built_in">size</span>(); i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;B.<span class="hljs-built_in">size</span>(); j++) &#123;<br>            C[i+j] += A[i]*B[j];   <span class="hljs-comment">//乘积</span><br>            C[i+j+<span class="hljs-number">1</span>] += C[i+j]/<span class="hljs-number">10</span>; <span class="hljs-comment">//进位</span><br>            C[i+j] %= <span class="hljs-number">10</span>;          <span class="hljs-comment">//余数</span><br>        &#125;<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;!C.<span class="hljs-built_in">back</span>()) C.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//前导0</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string a, b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; ~i; i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; ~i; i--) B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-function">VI <span class="hljs-title">C</span><span class="hljs-params">(A.size()+B.size())</span></span>;<br>    <span class="hljs-built_in">mul</span>(A, B, C);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; ~i; i --) cout &lt;&lt; C[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>版本三：<strong>int[] + c 专门存储进位</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 2001</span><br><span class="hljs-type">char</span> stra[N], strb[N];<br><span class="hljs-type">int</span> ia[N], ib[N], ans[<span class="hljs-number">2</span>*N];<br><br><span class="hljs-type">int</span> lena, lenb, anslen;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//请在这里写新代码...</span><br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, stra);<br>    <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, strb);<br>    <span class="hljs-comment">// cin&gt;&gt;stra &gt;&gt;strb;  // 也可以这样写，简单方便</span><br><br>    lena= <span class="hljs-built_in">strlen</span>(stra);<br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">0</span>; i&lt;lena; i++)<br>        ia[i] = stra[lena-i<span class="hljs-number">-1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>    lenb= <span class="hljs-built_in">strlen</span>(strb);<br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">0</span>; i&lt;lenb; i++)<br>        ib[i] = strb[lenb-i<span class="hljs-number">-1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>    <span class="hljs-type">int</span> t, c;   <span class="hljs-comment">// c是进位</span><br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">0</span>; i&lt;lenb; i++) &#123;<br>        c = <span class="hljs-number">0</span>;           <span class="hljs-comment">// 每行都需要重新把进位清0</span><br>        <span class="hljs-keyword">for</span>( j=<span class="hljs-number">0</span>; j&lt;lena; j++) &#123;<br>            <span class="hljs-comment">// 这里直接对ans[i+j]位置上的数进行乘积和累加，</span><br>            <span class="hljs-comment">//   可以解决&quot;相加后超过10&quot;以及&quot;连续进位&quot;的问题</span><br>            ans[i+j] = ia[j] * ib[i] + c + ans[i+j];<br>            c = ans[i+j] / <span class="hljs-number">10</span>;<br>            ans[i+j] = ans[i+j] % <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (c&gt;<span class="hljs-number">0</span>) <span class="hljs-comment">// 高位如果有进位，则往前进位，这里不需要考虑超过10的情况</span><br>            ans[i+lena] = ans[i+lena] + c;<br>    &#125;<br>    anslen = lena + lenb;<br>    <span class="hljs-keyword">while</span> (anslen &gt;<span class="hljs-number">0</span> &amp;&amp; ans[anslen]==<span class="hljs-number">0</span>)<br>        anslen--;<br><br>    <span class="hljs-keyword">while</span> (anslen &gt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans[anslen--]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">        8 5 6      a    j</span><br><span class="hljs-comment">    ×     2 5      b    i</span><br><span class="hljs-comment">———————————————</span><br><span class="hljs-comment">      4 2 8 0</span><br><span class="hljs-comment">+   1 7 1 2</span><br><span class="hljs-comment">———————————————</span><br><span class="hljs-comment">    2 1 4 0 0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1 id="拓展练习">拓展练习：</h1><h3 id="例1.3高精度乘法">1. <ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1307">1307：【例1.3】高精度乘法</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 110</span><br><span class="hljs-type">char</span> strA[N], strB[N];<br><span class="hljs-type">int</span> intA[N], intB[N], intC[<span class="hljs-number">2</span>*N];<br><span class="hljs-type">int</span> i, j, lenA, lenB, lenC, jinwei;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//在设定字符串和数字串长度的时候，可以适当稍微设置长一些！</span><br>    cin&gt;&gt;strA &gt;&gt;strB;  <span class="hljs-comment">// 注意，输入可能有多余的前导0，也就是说，会有0045这种数输入。</span><br>    lenA= <span class="hljs-built_in">strlen</span>(strA); <span class="hljs-comment">//本题不允许输入前导0，所以长度值会精确等于实际数字的位数</span><br>    lenB= <span class="hljs-built_in">strlen</span>(strB);<br><br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;lenA; i++)<br>        intA[i]= strA[lenA - <span class="hljs-number">1</span> - i]- <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;lenB; i++)<br>        intB[i]= strB[lenB - <span class="hljs-number">1</span> - i]- <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;lenB; j++) &#123;<br>        jinwei = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;lenA; i++) &#123;<br>            intC[i+j] = intC[i+j] + intA[i]*intB[j] + jinwei;<br>            jinwei = intC[i+j] / <span class="hljs-number">10</span>;<br>            intC[i+j] = intC[i+j] %<span class="hljs-number">10</span>;<br>        &#125;<br>        intC[j + lenA] = jinwei;<br>    &#125;<br><br>    lenC = lenA + lenB;<br>    <span class="hljs-comment">// 根据intC中的情况，来精确计算实际的差的位数，避免多打印0出来</span><br>    <span class="hljs-comment">// 4455 - 4422 应该打印33，而不是0033!</span><br>    <span class="hljs-keyword">while</span> (intC[lenC<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>)<br>        lenC--;<br><br>    <span class="hljs-keyword">for</span>(i=lenC<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--) cout &lt;&lt;intC[i];<br>    cout &lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 高精度 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度减法</title>
      <link href="/2024/01/03/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95/"/>
      <url>/2024/01/03/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h3id="视频教学链接"><a href="https://www.bilibili.com/video/BV1Ge4y1o7mD/?_blank" target="_blank">视频教学链接：</a></h3><h1 id="二实战训练">二、实战训练</h1><ol type="1"><li><strong><a href="https://www.luogu.com.cn/problem/P2142">洛谷P2142高精度减法</a></strong></li></ol><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1961668-20231206093711336-916385698.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>方法一，<strong>int[]</strong> 的做法。注意，不管是字符串,或是int[]，<strong>都是从0开始编号和存储</strong></p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1961668-20231206094612459-220630901.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>方法二：<strong>vector<int></strong>做法</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1961668-20231206095219812-1958911268.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>其AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-type">int</span>&gt; vi;<br>vi a,b,c;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vi &amp;a, vi &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>()!=b.<span class="hljs-built_in">size</span>())<br>        <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>()&lt;b.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; ~i; i--)<br>        <span class="hljs-keyword">if</span>(a[i]!=b[i]) <span class="hljs-keyword">return</span> a[i]&lt;b[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sub</span><span class="hljs-params">(vi &amp;a, vi &amp;b, vi &amp;c)</span> </span>&#123;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;a.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        t=a[i];<br>        <span class="hljs-keyword">if</span>(i&lt;b.<span class="hljs-built_in">size</span>()) t-=b[i];<br>        <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>) a[i+<span class="hljs-number">1</span>]--,t+=<span class="hljs-number">10</span>;<br>        c.<span class="hljs-built_in">push_back</span>(t);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(c.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;!c.<span class="hljs-built_in">back</span>())c.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string sa,sb;<br>    cin&gt;&gt;sa&gt;&gt;sb;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=sa.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; ~i; i--) a.<span class="hljs-built_in">push_back</span>(sa[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=sb.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; ~i; i--) b.<span class="hljs-built_in">push_back</span>(sb[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(a, b)) <span class="hljs-built_in">swap</span>(a,b),cout&lt;&lt;<span class="hljs-string">&#x27;-&#x27;</span>;<br>    <span class="hljs-built_in">sub</span>(a,b,c);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=c.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; ~i; i--) cout&lt;&lt;c[i];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三拓展练习">三、拓展练习：</h1><h3 id="大整数减法">1. <ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1169">1169大整数减法</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//在设定字符串和数字串长度的时候，可以适当稍微设置长一些！</span><br>    <span class="hljs-type">char</span> strA[<span class="hljs-number">301</span>], strB[<span class="hljs-number">301</span>];<br>    <span class="hljs-type">int</span> intA[<span class="hljs-number">301</span>]= &#123;<span class="hljs-number">0</span>&#125;, intB[<span class="hljs-number">301</span>]= &#123;<span class="hljs-number">0</span>&#125;, intC[<span class="hljs-number">322</span>]= &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> i, lenM, lenN, lenC;<br><br>    cin&gt;&gt;strA &gt;&gt;strB;  <span class="hljs-comment">// 注意，输入可能有多余的前导0，也就是说，会有0045这种数输入。</span><br>    lenM= <span class="hljs-built_in">strlen</span>(strA); <span class="hljs-comment">//本题不允许输入前导0，所以长度值会精确等于实际数字的位数</span><br>    lenN= <span class="hljs-built_in">strlen</span>(strB);<br><br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;lenM; i++)<br>        intA[i]= strA[lenM - <span class="hljs-number">1</span> - i]- <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;lenN; i++)<br>        intB[i]= strB[lenN - <span class="hljs-number">1</span> - i]- <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>    i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i&lt;lenM )&#123;<br>        <span class="hljs-keyword">if</span> (intA[i] &lt; intB[i])&#123;<br>            intA[i]= intA[i] +<span class="hljs-number">10</span>;<br>            <span class="hljs-comment">//感觉这一步，如果原本intA[i+1]的值是0，岂不是要变成-1？</span><br>            <span class="hljs-comment">//回答：变成-1不可怕，因为下一轮时intA[i+1]位的值是-1，加上10之后，变成9，又成正数咯！</span><br>            intA[i+<span class="hljs-number">1</span>]--;<br>        &#125;<br>        intC[i] = intA[i] - intB[i];<br>        i++;<br>    &#125;<br><br>    lenC = i;<br>    <span class="hljs-comment">//根据intC中的情况，来精确计算实际的差的位数，避免多打印0出来</span><br>    <span class="hljs-comment">// 4455 - 4422 应该打印33，而不是0033!</span><br>    <span class="hljs-keyword">while</span> (intC[lenC<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>) lenC--;<br>    <span class="hljs-keyword">for</span>(i=lenC<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--) cout &lt;&lt;intC[i];<br>    cout &lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 高精度 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度加法</title>
      <link href="/2024/01/03/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95/"/>
      <url>/2024/01/03/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h3id="视频教学链接"><a href="https://www.bilibili.com/video/BV1UG4y1B7ur/?_blank" target="_blank">视频教学链接：</a></h3><h1 id="二实战训练">二、实战训练</h1><h3 id="luogu-p1601-ab-problem高精-img">1.<ahref="https://www.luogu.com.cn/problem/P1601">Luogu P1601 A+BProblem（高精）</a> <imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1961668-20231205162708919-1362491442.png"alt="img" /></h3><h4 id="方法1string-int-版本">1) 方法1：String + int [ ] 版本</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">505</span>;<br><span class="hljs-type">int</span> a[N],b[N],c[N];<br><span class="hljs-type">int</span> la,lb,lc;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> b[],<span class="hljs-type">int</span> c[])</span> </span>&#123; <span class="hljs-comment">//a+b=c</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=lc; i++) &#123;<br>        c[i]+=a[i]+b[i]; <span class="hljs-comment">//求和</span><br>        c[i+<span class="hljs-number">1</span>]+=c[i]/<span class="hljs-number">10</span>; <span class="hljs-comment">//进位</span><br>        c[i]%=<span class="hljs-number">10</span>;        <span class="hljs-comment">//存余</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(c[lc+<span class="hljs-number">1</span>]) lc++;  <span class="hljs-comment">//最高位</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string sa,sb;<br>    cin&gt;&gt;sa&gt;&gt;sb;<br>    la=sa.<span class="hljs-built_in">size</span>(),lb=sb.<span class="hljs-built_in">size</span>(),lc=<span class="hljs-built_in">max</span>(la,lb);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=la; i++) a[i]=sa[la-i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=lb; i++) b[i]=sb[lb-i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-built_in">add</span>(a,b,c);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lc; i; i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,c[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法2string-vector-版本">2) 方法2：String + vector<int>版本</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-type">int</span>&gt; VI;<br>VI a, b, c;<br><span class="hljs-type">int</span> la,lb,lc;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(VI &amp;a,VI &amp;b,VI &amp;c)</span> </span>&#123;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;lc; i++) &#123;<br>        <span class="hljs-keyword">if</span>(i&lt;la) t+=a[i];<br>        <span class="hljs-keyword">if</span>(i&lt;lb) t+=b[i];<br>        c.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>); <span class="hljs-comment">//存余</span><br>        t/=<span class="hljs-number">10</span>;             <span class="hljs-comment">//进位</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(t) c.<span class="hljs-built_in">push_back</span>(t);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string sa,sb;<br>    cin&gt;&gt;sa&gt;&gt;sb;<br>    la=sa.<span class="hljs-built_in">size</span>();<br>    lb=sb.<span class="hljs-built_in">size</span>();<br>    lc=<span class="hljs-built_in">max</span>(la,lb);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=la<span class="hljs-number">-1</span>; ~i; i--) a.<span class="hljs-built_in">push_back</span>(sa[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lb<span class="hljs-number">-1</span>; ~i; i--) b.<span class="hljs-built_in">push_back</span>(sb[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-built_in">add</span>(a,b,c);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=c.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; ~i; i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, c[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法3-char-int-版本">3) 方法3： char[ ] + int [ ] 版本</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">char</span> stra[<span class="hljs-number">501</span>], strb[<span class="hljs-number">501</span>], ansstr[<span class="hljs-number">502</span>];<br><span class="hljs-type">int</span> lena, lenb, anslen, ia[<span class="hljs-number">501</span>], ib[<span class="hljs-number">501</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, stra); <span class="hljs-comment">// 也可以直接cin&gt;&gt;stra &gt;&gt;strb; 简单，不易出错。</span><br>    <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, strb);<br>    lena= <span class="hljs-built_in">strlen</span>(stra);<br>    lenb= <span class="hljs-built_in">strlen</span>(strb);<br>    anslen = <span class="hljs-built_in">max</span>(lena, lenb);<br>    <span class="hljs-comment">// char stra[] --&gt; int ia[] ，并且是反序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;lena; i++) ia[i] = stra[lena-i<span class="hljs-number">-1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;lenb; i++) ib[i] = strb[lenb-i<span class="hljs-number">-1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>    <span class="hljs-comment">// 对ia[]和ib[]开始高精度加法</span><br>    <span class="hljs-type">int</span> c=<span class="hljs-number">0</span>, t;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;anslen; i++) &#123;<br>        t= ia[i] + ib[i] + c;<br>        <span class="hljs-keyword">if</span> (t &gt;= <span class="hljs-number">10</span>) <br>            c= <span class="hljs-number">1</span>, ansstr[i] = t % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">else</span> <br>            c= <span class="hljs-number">0</span>, ansstr[i] = t + <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( c == <span class="hljs-number">1</span> ) ansstr[anslen++] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=anslen<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, ansstr[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入1：</span><br><span class="hljs-comment">9876543210</span><br><span class="hljs-comment">9876543210</span><br><span class="hljs-comment">输出1：</span><br><span class="hljs-comment">19753086420</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输入2：</span><br><span class="hljs-comment">9876543210</span><br><span class="hljs-comment">   6543210</span><br><span class="hljs-comment">输出2：</span><br><span class="hljs-comment">9883086420</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">987654321  --&gt;12345678900000</span><br><span class="hljs-comment">654321     --&gt;12345600000000</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1 id="拓展训练">拓展训练</h1><h3 id="一本通-1168-大整数加法">1.<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1168">一本通 1168大整数加法</a></h3><p>做法和P1601类似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">char</span> strM[<span class="hljs-number">301</span>], strN[<span class="hljs-number">301</span>];<br><span class="hljs-type">int</span> intM[<span class="hljs-number">301</span>]= &#123;<span class="hljs-number">0</span>&#125;, intN[<span class="hljs-number">301</span>]= &#123;<span class="hljs-number">0</span>&#125;, intC[<span class="hljs-number">322</span>]= &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> i, lenM, lenN, lenC, jinwei=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt;strM &gt;&gt;strN;  <span class="hljs-comment">// 注意，输入可能有多余的前导0，也就是说，会有0045这种数输入。</span><br>    lenM= <span class="hljs-built_in">strlen</span>(strM); <span class="hljs-comment">//这两个长度值由于前导0的允许输入，所以会大于实际数字的位数</span><br>    lenN= <span class="hljs-built_in">strlen</span>(strN);<br><br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;lenM; i++) intM[i]= strM[lenM - <span class="hljs-number">1</span> - i]- <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;lenN; i++) intN[i]= strN[lenN - <span class="hljs-number">1</span> - i]- <span class="hljs-string">&#x27;0&#x27;</span>;<br>    i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i&lt;lenM || i&lt;lenN)&#123;<br>        intC[i] = intM[i] + intN[i] + jinwei;<br>        jinwei  = intC[i] / <span class="hljs-number">10</span>;<br>        intC[i] = intC[i] % <span class="hljs-number">10</span>;<br>        i++;<br>    &#125;<br>    intC[i] = jinwei;<br>    <span class="hljs-keyword">if</span> (jinwei == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 如果两个数相加没有产生最高位的进位</span><br>        lenC = i;<br>        <span class="hljs-comment">//根据intC中的情况，来精确计算实际的和的位数，避免多打印0出来</span><br>        <span class="hljs-comment">// 0000011 + 0022 应该打印33，而不是0000033!</span><br>        <span class="hljs-keyword">while</span> (intC[lenC<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>)<br>            lenC--;<br>    &#125;<br>    <span class="hljs-keyword">else</span>  <span class="hljs-comment">//如果产生了最高位的进位，那和就要比最长的那个数多1位</span><br>        lenC = i+<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span>(i=lenC<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--) cout &lt;&lt;intC[i];<br>    cout &lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 高精度 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度除法（高精/整数）</title>
      <link href="/2024/01/03/%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95%EF%BC%88%E9%AB%98%E7%B2%BE%20%20%E6%95%B4%E6%95%B0%EF%BC%89/"/>
      <url>/2024/01/03/%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95%EF%BC%88%E9%AB%98%E7%B2%BE%20%20%E6%95%B4%E6%95%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h3id="视频教学链接"><a href="https://www.bilibili.com/video/BV1Je4y1o7vR/?_blank" target="_blank">视频教学链接：</a></h3><h1 id="二实战训练">二、实战训练</h1><h3 id="p1480-ab-problem高精整数">1.<ahref="https://www.luogu.com.cn/problem/P1480">P1480 A/BProblem</a>（高精/整数）</h3><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1961668-20231206142344207-564554929.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>注意：</p><p>1） 商的数组C[]的初始长度lc 应该和被除数a[]的长度la 保持一致。</p><p>2）为了让高精除法和前面的高精加减乘法的运算结果都保持统一的存储风格（C[0]存结果的个位，C[lc-1]存结果的最高位），所以上图的代码在取商的同时就做了C[]的翻转映射C[la-1-i]。当然，也可以除完之后再处理lc，最后再来翻转。做法不唯一。</p><p>3） ～i表示对i按bit位取反。只有-1 按位取反的结果是0，即false。所以～i写在此处，等效于 i != -1</p><p>版本1：采用int[]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5005</span>;<br><span class="hljs-type">int</span> a[N],b,c[N];<br><span class="hljs-type">int</span> len;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c[])</span> </span>&#123; <span class="hljs-comment">// a/b=c</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len; i&gt;=<span class="hljs-number">1</span>; i--) &#123;<br>        t=t*<span class="hljs-number">10</span>+a[i];  <span class="hljs-comment">//被除数</span><br>        c[i]=t/b;     <span class="hljs-comment">//存商</span><br>        t%=b;         <span class="hljs-comment">//余数</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(c[len]==<span class="hljs-number">0</span>&amp;&amp;len&gt;<span class="hljs-number">1</span>) len--; <span class="hljs-comment">//去0</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> A[N];<br>    cin&gt;&gt;A&gt;&gt;b;<br>    len=<span class="hljs-built_in">strlen</span>(A);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=len; i++) a[i]=A[len-i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-built_in">div</span>(a,b,c);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len; i; i--) cout&lt;&lt;c[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>版本2：采用vector<int></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-type">int</span>&gt; a,c;<br><span class="hljs-type">int</span> b,pos;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string A;<br>    cin&gt;&gt;A&gt;&gt;b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; ~i; i--)<br>        a.<span class="hljs-built_in">push_back</span>(A[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> r=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; ~i; i--) &#123;<br>        r=r*<span class="hljs-number">10</span>+a[i];      <span class="hljs-comment">//被除数</span><br>        c.<span class="hljs-built_in">push_back</span>(r/b); <span class="hljs-comment">//存商</span><br>        r%=b;             <span class="hljs-comment">//余数</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;c.<span class="hljs-built_in">size</span>(); i++)<br>        <span class="hljs-keyword">if</span>(c[i]) &#123;<br>            pos=i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pos; i&lt;c.<span class="hljs-built_in">size</span>(); i++)cout&lt;&lt;c[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>练习：<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1175">1175：除以13</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    数据都从0号位开始存储，有区别于图片/视频中的代码。建议如此。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> A[N],b,C[N];<br><span class="hljs-type">int</span> len;<br>LL yu;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> C[])</span> </span>&#123; <span class="hljs-comment">// A/b=C</span><br>    yu=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>; ~i; i--) &#123;   <span class="hljs-comment">// 当i!= -1时（-1按位取反结果为0，false）</span><br>        yu = yu*<span class="hljs-number">10</span> + A[i];  <span class="hljs-comment">//被除数</span><br>        C[i] = yu / b;      <span class="hljs-comment">//存商</span><br>        yu %= b;            <span class="hljs-comment">//余数</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(len&gt;<span class="hljs-number">1</span> &amp;&amp; C[len<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>)<br>        len--;               <span class="hljs-comment">//去高位前导0</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> a[N];<br>    cin&gt;&gt;a;<br>    b=<span class="hljs-number">13</span>;<br>    len=<span class="hljs-built_in">strlen</span>(a);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++) A[i]= a[len-i<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-built_in">div</span>(A,b,C);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>; ~i; i--) cout&lt;&lt;C[i];    <span class="hljs-comment">// ~i 等价于 i!=-1</span><br>    cout &lt;&lt;endl &lt;&lt;yu;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 高精度 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序 逆序对</title>
      <link href="/2024/01/02/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%20%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
      <url>/2024/01/02/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%20%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h3id="视频教学链接"><a href="https://www.bilibili.com/video/BV1Mx4y1o7B1/?_blank" target="_blank">视频教学链接：</a></h3><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1961668-20231207164029327-587949983.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>当a[i] == a[j] 时，只执行b[k++] = a[i++]， i 右移而 j不右移，也就是说，当值相同时，先拷贝左侧元素a[i]</strong>。这种思路下，如果元素是结构体类型的话，可以确保排序是稳定的。这样做的话，不管a[i]的下一个元素值是否和a[j]相等，都没问题。</p><h1 id="二实战训练">二、实战训练</h1><h3 id="luogu-p1177-模板排序">1. <ahref="https://www.luogu.com.cn/problem/P1177">Luogu P1177【模板】排序</a></h3><p>程序代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//// 方法3： 归并排序实现，时间复杂度O(nlogn)，空间复杂度O(n)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n,a[N],tmp[N];           <span class="hljs-comment">// tmp为辅助数组</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">msort</span><span class="hljs-params">(<span class="hljs-type">int</span> le, <span class="hljs-type">int</span> ri)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(le==ri) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid=le+(ri-le&gt;&gt;<span class="hljs-number">1</span>);   <span class="hljs-comment">// 先算术运算-，再移位&gt;&gt;。移位优先级低。建议mid=le+(ri-le&gt;&gt;1);</span><br>    <span class="hljs-built_in">msort</span>(le,mid);           <span class="hljs-comment">// 拆分</span><br>    <span class="hljs-built_in">msort</span>(mid+<span class="hljs-number">1</span>,ri);<br><br>    <span class="hljs-comment">// 此时左右两段数据已经各自有序，类似于后序遍历（左右根）的手法</span><br>    <span class="hljs-type">int</span> i=le,j=mid+<span class="hljs-number">1</span>,k=le;   <span class="hljs-comment">// 开始有序表的合并</span><br>    <span class="hljs-keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=ri) &#123; <span class="hljs-comment">// 注意各种++</span><br>        <span class="hljs-keyword">if</span>(a[i]&lt;=a[j])<br>            tmp[k++]=a[i++];<br>        <span class="hljs-keyword">else</span><br>            tmp[k++]=a[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid) tmp[k++]=a[i++]; <span class="hljs-comment">// 剩余部分原封照搬</span><br>    <span class="hljs-keyword">while</span>(j&lt;=ri) tmp[k++]=a[j++];  <span class="hljs-comment">// 剩余部分原封照搬</span><br>    <span class="hljs-keyword">for</span>(i=le; i&lt;=ri; i++)          <span class="hljs-comment">// 将临时数组的指定段内容复制回去，便于上一层递归时使用</span><br>        a[i]=tmp[i];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-built_in">msort</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="luogu-p1908-逆序对">2. <ahref="https://www.luogu.com.cn/problem/P1908">luogu P1908逆序对</a></h3><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1961668-20231208110609092-538862436.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>本题的数据规模是n=5e5，如果采用冒泡排序的做法，必然会2e11,TLE了，只能得部分分。如果采用<spanclass="math inline">\(O(n*log_2n)\)</span>算法，则为5e5 × 19 = 95 × 1e5&lt; 1e7，能过。所以本题必须要采用<spanclass="math inline">\(O(n*log_2n)\)</span>的算法才能AC。</p><p>采用归并排序可以AC本题，主要是因为在排序过程中，<strong>一次性找出多个逆序对，而不是一个一个地找出来的</strong>，所以更有效率。</p><p>P1908 AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    1328-1237-P1908-1311，这几个题，合在一起看！只有数据规模不同</span><br><span class="hljs-comment">    可以在归并排序的基础上补部分代码来实现</span><br><span class="hljs-comment">    下列代码是基于归并排序的基础来实现</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N= <span class="hljs-number">5e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, d[N], tmp[N];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mysort</span><span class="hljs-params">(<span class="hljs-type">int</span> le, <span class="hljs-type">int</span> ri)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (ri&lt;=le) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid= le + (ri-le)/<span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">mysort</span>(le, mid);<br>    <span class="hljs-built_in">mysort</span>(mid+<span class="hljs-number">1</span>, ri);<br><br>    <span class="hljs-type">int</span> i=le;<br>    <span class="hljs-type">int</span> k=le;<br>    <span class="hljs-type">int</span> j=mid+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=ri) &#123;<br>        <span class="hljs-comment">// 注意，d[i] == d[j] 时，右段指针j并不右移  ！</span><br>        <span class="hljs-comment">// 因为要继续看左段后续的数据是否大于d[j]</span><br>        <span class="hljs-keyword">if</span> (d[i] &lt;= d[j])<br>            tmp[k++] = d[i++];<br>        <span class="hljs-keyword">else</span> &#123;<br>            tmp[k++] = d[j++];<br>            ans = ans + (mid - i + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> ( i &lt;= mid )<br>        tmp[k++] = d[i++];<br><br>    <span class="hljs-keyword">while</span> ( j &lt;= ri )<br>        tmp[k++] = d[j++];<br><br>    <span class="hljs-keyword">for</span>(i=le; i&lt;=ri; i++)<br>        d[i] = tmp[i];<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;d[i]);<br>    <span class="hljs-built_in">mysort</span>(<span class="hljs-number">1</span>, n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三-巩固练习">三、 巩固练习：</h1><p>1）<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1328">1328</a></p><p>2）<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1311">1311</a></p><p>3）<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1237">1237</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2020/03/13/hello/"/>
      <url>/2020/03/13/hello/</url>
      
        <content type="html"><![CDATA[<h1 id="是">是</h1><p><span class="math display">\[\lim_{h \rightarrow 0 } \frac{f(x+h)-f(x)}{h}\]</span></p><h2 id="一.-归并排序">一. 归并排序</h2><p>来一个分段函数</p><p>点击<a href="/2020/03/13/hello/#jump1">这里</a>可以到站内文章"hello.md"的锚点jump1，在下面的1.2.3。<span class="math display">\[f(n)=\begin{cases}1 &amp; (n=1) \\1 &amp; (n=2) \\f(n-1)+f(n-2) &amp; (n&gt;=3)\end{cases}\]</span></p><p><span class="math display">\[y=\begin{cases}0 &amp; z&lt;0 \\0.5 &amp; z=0 \\1 &amp; z&gt;0\end{cases}\]</span> <span class="math display">\[\begin{cases}s_{\Delta}=\sum_{i=1}^n(x_i^2+y_i^2)+\frac i{20} \\7x - 2y + 4z=C_n^m+10^{20} \\s_{\Delta}=\sqrt[]{x+\sqrt[3]{1+x}}\\\lfloor x \rfloor+\lceil \log_2n \rceil\end{cases}\]</span></p><p><span class="math display">\[s_{\Delta}=\sum_{i=1}^n(x_i^2+y_i^2)+\frac i{20}\label{a}\\7x - 2y + 4z=C_n^m+10^{20} \\s_{\Delta}=\sqrt[]{x+\sqrt[3]{1+x}}\\\lfloor x \rfloor+\lceil \log_2n \rceil\]</span></p><p><span class="math inline">\(\log_2{log_2n}\)</span></p><p><span class="math display">\[\begin{align}\label{eq2}u_{i1}(t)&amp;=-b_{i}(t),f(q_{i}),\u_{i2}(t)&amp;=\sum_{j\in \mathcal{N}{i}}c{ij}h(p_{j}(t)-p_{i}(t)),\quadi\in\bar{N}\end{align}\]</span></p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20231228124457143.png"alt="image-20231228124457143" /><figcaption aria-hidden="true">image-20231228124457143</figcaption></figure><p>$ dp[i][j]=dp[i-1][j]+data[i][j-1](i,j) $</p><p>$ dp_i$</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic/img/image-20241119161909303.png" alt="image-20241119161909303" style="zoom:67%;" /></p><p>dp[i]=data[i] + dp[i-1]</p><p><span class="math display">\[\begin{array}{|r|l|c|}\hline 20&amp;*&amp;?\\    \hline \leftarrow&amp;5&amp;3\\    \hline 6&amp;1&amp;8\\    \hline\end{array}\]</span></p><p><span class="math display">\[\begin{array}{}           &amp;0&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7\\    \hlinec&amp;\gets&amp;\Leftrightarrow&amp;\Longleftrightarrow&amp;\iff&amp;*\\    \hline c&amp;\to&amp;\Rightarrow&amp;3&amp;20000&amp;*\\    \hline maxc&amp;60000&amp;\Leftarrow&amp;8&amp;a_i\\    \hline\end{array}\]</span></p><p><span class="math display">\[\begin{array}{cc|c}           努力&amp;你好&amp;再见\\    \hline 0&amp;0&amp;0\\           0&amp;1&amp;1\\           1&amp;0&amp;1\\           1&amp;1&amp;1\\\end{array}\]</span></p><p>这里我打算嵌入一张gif图片试试看效果： <imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/a511f48b5a6455b8dfe0a256ab2eb466.gif"alt="a511f48b5a6455b8dfe0a256ab2eb466" /></p><p>AC代码参考如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> <span class="hljs-comment">// 我刚试了一下Ctrl + Shift + K</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> distance;<br><span class="hljs-type">double</span> s1, s2;<br>    <br>cin &gt;&gt;distance;<br>s1= <span class="hljs-number">27</span> +<span class="hljs-number">23</span> + distance/<span class="hljs-number">3.0</span>;<br>s2= distance / <span class="hljs-number">1.2</span>;<br><span class="hljs-keyword">if</span> (s1&lt;s2)<br>cout&lt;&lt;<span class="hljs-string">&quot;Bike&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s2 &lt; s1)<br>cout&lt;&lt;<span class="hljs-string">&quot;Walk&quot;</span>;<br><span class="hljs-keyword">else</span><br>cout&lt;&lt;<span class="hljs-string">&quot;All&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="本标题暗含了一个锚点名叫jump1">1.2.3 <spanid="jump1">本标题暗含了一个锚点名叫jump1</span></h2><p>或者版本二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">哈希查找的模板题 </span><br><span class="hljs-comment">2123 7044 013 013 7957 ll是一个1e18的超大质数，末尾有个ll，表示该数的长整型</span><br><span class="hljs-comment">不好意思，怕是要背下来…… </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span> <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><br>ull a[<span class="hljs-number">10010</span>];<br><span class="hljs-type">char</span> s[<span class="hljs-number">10010</span>];<br><span class="hljs-type">int</span> n,ans=<span class="hljs-number">1</span>;<br><span class="hljs-comment">//int prime=233317;</span><br><span class="hljs-comment">//ull mod=212370440130137957ll;</span><br><br><span class="hljs-function">ull <span class="hljs-title">BKDRHash</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span></span><br><span class="hljs-function"></span>&#123;<br>    ull seed = <span class="hljs-number">31</span>;    <span class="hljs-comment">// 31 131 1313 13131 131313 etc.. 37</span><br>    ull key = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (*str)<br>        key = (key * seed + (ull)(*str++)) % <span class="hljs-number">212370440130137957ll</span> + <span class="hljs-number">233317</span>;<br> <br><span class="hljs-keyword">return</span> key &amp; <span class="hljs-number">0x7fffffff</span>;  <span class="hljs-comment">// 舍弃符号位，稳妥起见。不加也能ac本题 </span><br>&#125;<br><span class="hljs-comment">//ull hashe(char s[]) &#123;</span><br><span class="hljs-comment">//int len=strlen(s);</span><br><span class="hljs-comment">//ull base=131;</span><br><span class="hljs-comment">//ull ans=0;</span><br><span class="hljs-comment">//for (int i=0; i&lt;len; i++)</span><br><span class="hljs-comment">//ans=(ans*base+(ull)s[i])%mod+prime;</span><br><span class="hljs-comment">//return ans;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<br>a[i]=<span class="hljs-built_in">BKDRHash</span>(s);<br>&#125;<br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++) &#123;<br><span class="hljs-keyword">if</span>(a[i]!=a[i+<span class="hljs-number">1</span>])<br>ans++;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,ans);<br>&#125;<br></code></pre></td></tr></table></figure><p>矩阵：</p><p><span class="math display">\[\begin{pmatrix}  1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n \\  1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \\  \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\  1 &amp; a_m &amp; a_m^2 &amp; \cdots &amp; a_m^n \\  \end{pmatrix}\]</span></p><script>    // add script tag and code at the end of your post    alert("Hello World");</script>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
