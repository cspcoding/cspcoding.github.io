<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>（三）宽度小于等于m的区间的“最大的和值”问题</title>
      <link href="/2025/01/01/%EF%BC%88%E4%B8%89%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"/>
      <url>/2025/01/01/%EF%BC%88%E4%B8%89%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>　　本帖是“最大子段和”系列问题的第3帖，主要研究固定宽度小于等于m的区间的“最大的和值”这个问题。</p><h1 id="一.-理论教学">一. 理论教学</h1><p>　　教学视频：<ahref="https://www.bilibili.com/video/BV1m54y117uu/?">单调队列连续子序列的最大和</a></p><h1 id="二.实战练习">二.实战练习</h1><h2 id="例-2最大连续和">2.1 1598：【 例 2】最大连续和</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<ahref="https://ybt.ssoier.cn/problem_show.php?pid=1598">1598：【 例2】最大连续和</a></p><h3 id="分析">2.1.2 分析</h3><p>　　之前我们练习过“不限区间宽度”及“区间宽度<spanclass="math inline">\(==m\)</span>”的情况。在“不限区间宽度”时，我们曾经在方法２中的版本２代码中，用单调队列来解决问题。已经记不太清楚的同学请看<a href="/2024/12/24/%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E5%BA%A6%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/#jump1"><font color="red">这里</font></a>。在单调队列进行处理时，因为并没有限制滑窗（即区间）宽度，所以在代码中并不需要处理队头的出队操作。</p><p>　　在本帖的1598这种题中，要求“区间宽度<spanclass="math inline">\(\leqm\)</span>”，只需要在单调队列代码模板里维护好滑窗宽度，做好队头的出队操作即可。单调队列本来就可以处理滑窗宽度<spanclass="math inline">\(\leqm\)</span>的情况。另外需要注意的是，在用单调队列求解时，是针对原始数据的<strong>“前缀和数组s[]”</strong>，在第i个元素<strong>左侧</strong>的宽度为ｍ（当<spanclass="math inline">\(i &lt; m\)</span>时允许滑窗宽度<spanclass="math inline">\(&lt;m\)</span>）的滑窗内求其<strong>最小值</strong>。而这正好也是“单调队列求最值”能做到的事情。</p><p>　　<span id="jump1">假设<spanclass="math inline">\(m=3\)</span>，</span>原始数组为<spanclass="math inline">\(a[1..n]\)</span>，对应的前缀和数组为<spanclass="math inline">\(s[1..n]\)</span>，<spanclass="math inline">\(dpmax[i]\)</span>表示"<strong>在选定<spanclass="math inline">\(a[i]\)</span>的前提下，在<spanclass="math inline">\(a[i-m+1..i]\)</span> 这<spanclass="math inline">\(m\)</span>个元素中选择的连续子段内所有数的最大和值</strong>"，写法"<spanclass="math inline">\(a[3..5]\)</span>"表示"<spanclass="math inline">\(a[3]+a[4]+a[5]\)</span>"，则有 $$ <spanclass="math display">\[\begin{align}dpmax[1]&amp;=max(\ a[1..1]\ ) \tag{1}  \\&amp;=max(s[1]-s[0]) \\&amp;=s[1]-min(s[0])（无它，保持和公式(2..5)一致的公式模式而已）\\&amp;= s[1]-0=s[1] = a[1]\\\\dpmax[2]&amp;=max(\ a[1..2],\ \ a[2..2]\ ) \\&amp;=max(s[2]-s[0],\ s[2]-s[1]) \\&amp;=s[2]-min(\ s[0], s[1])  \tag{2}\\\\dpmax[3]&amp;=max(\ \ a[1..3],\ \ \qquad \quad a[2..3],\ \ \qquad \quada[3..3]\ \ ) \\&amp;=max(\ s[3]-s[0],\ \quad s[3]-s[1],\ \quad s[3]-s[2]\ ) \\&amp;=s3-min(\ s[0],\ s[1],\ s[2]\ ) \tag{3}\\\\dpmax[4]&amp;=max(\ \ a[2..4],\ \ \qquad\quad  a[3..4],\ \ \qquad \quada[4..4]\ \ )  \\&amp;=max(\ s[4]-s[1],\ \quad s[4]-s[2],\ \quad s[4]-s[3]\ ) \\&amp;=s[4]-min(\ s[1],\ s[2],\ s[3]\ ) \tag{4}\\\\dpmax[5]&amp;=max(\ \ a[3..5],\ \ \qquad\quad  a[4..5],\ \ \qquad \quada[5..5]\ \ )  \\&amp;=max(\ s[5]-s[2],\ \quad s[5]-s[3],\ \quad s[5]-s[4]\ ) \\&amp;=s[5]-min(\ s[2],\ s[3],\ s[4]\ ) \tag{5}\\\\\end{align}\]</span> <span class="math display">\[则有一般性公式推导如下：\]</span> <span class="math display">\[\begin{align}dpmax[i]&amp;=max(\ \ a[i-m+1..i],\ \ \quad  a[i-m+2..i],\quad ......\,\ \quad a[i-1..i],\ \qquad \quad a[i..i]\qquad\ )  \\&amp;=max(\ s[i]-s[i-m],\ \quad s[i]-s[i-m+1],\ ......\ ,\quads[i]-s[i-2],\quad s[i]-s[i-1]\ ) \\&amp;=s[i]-\textcolor[RGB]{255,0,0}{min(\ s[i-m],\qquads[i-m+1]\qquad,\  ......\ ,\qquad \quad s[i-2],\qquad s[i-1]\ \qquad\ )}\tag{6}\\\\\end{align}\]</span> $$ 　　从上面的公式（６）可以看出：</p><p>１）我们把一个求最大值的问题，变成了一个求最小值的问题。</p><p>２）原本是求<spanclass="math inline">\(a[]\)</span>的“和值”，现在改成了求<spanclass="math inline">\(s[]\)</span>的最值。</p><p>３）在第<spanclass="math inline">\(i\)</span>轮，对应的滑窗下标是<spanclass="math inline">\(s[i-m..i-1]\)</span>，单调队列考虑进队的新元素为<spanclass="math inline">\(s[i-1]\)</span>，队尾进队的值是<spanclass="math inline">\(i-1\)</span>（存下标）。</p><h3 id="ac代码">2.1.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">求子段长度不大于m的最大子段和</span><br><span class="hljs-comment">用单调队列来进行优化 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>,INF=<span class="hljs-number">1e9</span>,M=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> dq[M];  <span class="hljs-comment">// 单调队列，规模看M即可</span><br><span class="hljs-type">int</span> s[N];   <span class="hljs-comment">// 前缀和数组 </span><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;s[i]), s[i]+=s[i<span class="hljs-number">-1</span>];<span class="hljs-comment">//输入原始数据的同时算出前缀和数组 </span><br>    <span class="hljs-type">int</span> h=<span class="hljs-number">1</span>,t=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> res =-INF;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<span class="hljs-comment">//单调队列保存下标</span><br>     <span class="hljs-comment">//根据方法2的公式6得，用单调队列在第i轮处理min(s[i-m..i-1])这m个前缀和值的最小值 </span><br>        <span class="hljs-keyword">while</span>(h&lt;=t&amp;&amp;s[i<span class="hljs-number">-1</span>]&lt;=s[dq[t]]) t--;<span class="hljs-comment">//如果当前对头元素比当前元素大，并且队列不空就滑出队列</span><br>        dq[++t]=i<span class="hljs-number">-1</span>;        <br><br>        <span class="hljs-keyword">if</span>((i<span class="hljs-number">-1</span>)-dq[h]+<span class="hljs-number">1</span> &gt; m ) h++;<span class="hljs-comment">//如果队尾下标不在m范围的话就划出队列</span><br>        <br>        res=<span class="hljs-built_in">max</span>(res,s[i]-s[dq[h]]);<br>    &#125;<br>    cout&lt;&lt;res&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">6 4</span><br><span class="hljs-comment">1 -3 5 1 -2 3</span><br><span class="hljs-comment">7</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线性结构编程技巧 </category>
          
          <category> 最大子段和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（二）固定宽度为m的区间的“最大的和值”问题</title>
      <link href="/2025/01/01/%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9B%BA%E5%AE%9A%E5%AE%BD%E5%BA%A6%E4%B8%BAm%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"/>
      <url>/2025/01/01/%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9B%BA%E5%AE%9A%E5%AE%BD%E5%BA%A6%E4%B8%BAm%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>　　本帖是“最大子段和”系列问题的第2帖，主要研究固定宽度为m的区间的“最大的和值”问题。内容比较简单，橙标题，就直接上题目了。</p><h1 id="一.-p3353-在你窗外闪耀的星星">一. P3353 在你窗外闪耀的星星</h1><h2 id="原题链接">1.1 原题链接</h2><p>　　<a href="https://www.luogu.com.cn/problem/P3353">P3353在你窗外闪耀的星星</a></p><p>　　概要题意：</p><p>　　录入<spanclass="math inline">\(n\)</span>个数的一维坐标整数值<spanclass="math inline">\(pos\)</span>和整数值<spanclass="math inline">\(w\)</span>，求所有坐标宽度为<spanclass="math inline">\(m\)</span>的区间内（含整数边界点）的数之和的最大值。假设<spanclass="math inline">\(m=3\)</span>，则即求<spanclass="math inline">\(max(sum[1..3],\ sum[2..4],\ sum[3..5], \......)\)</span>。</p><h2 id="分析">1.2 分析</h2><p>　　此题最明显的特征就是区间宽度固定不变，为<spanclass="math inline">\(m\)</span>。用前缀和来解本题最为方便。需要小心的是，根据题意，这<spanclass="math inline">\(n\)</span>个点的坐标是可以重复的，所以需要先叠加好每个坐标上的数值，然后再来做前缀和。在<spanclass="math inline">\(a[i]\)</span>值还没有完全确定时就去做<spanclass="math inline">\(sum[1..i]\)</span>，这样会不准确。</p><p>　　另外，<spanclass="math inline">\(n\)</span>并不是这些数的最大下标值，仅仅只是初始数据规模而已，在填入<spanclass="math inline">\(a[]\)</span>后，建议求出下标的最大值<spanclass="math inline">\(maxp\)</span>，适当简化后续的数据遍历操作。</p><h2 id="ac代码">1.3 AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[maxn];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> pos, w, maxp;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;pos, &amp;w), a[pos]+=w, maxp=<span class="hljs-built_in">max</span>(maxp, pos);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=maxp; i++) a[i]+=a[i<span class="hljs-number">-1</span>];<br><br><span class="hljs-type">int</span> mmax=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=m; i&lt;=maxp; i++)mmax= <span class="hljs-built_in">max</span>(mmax, a[i]-a[i-m]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, mmax);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二.-at_joi2007ho_a-最大の和">二. AT_joi2007ho_a 最大の和</h1><h2 id="原题链接-1">2.1 原题链接</h2><p>　　<ahref="https://www.luogu.com.cn/problem/AT_joi2007ho_a">AT_joi2007ho_a最大の和</a>　／　<ahref="https://atcoder.jp/contests/joi2007ho/tasks/joi2007ho_a"><strong>A- 最大の和</strong></a></p><h2 id="分析-1">2.2 分析</h2><p>　　和P3353基本上类似。</p><h2 id="ac代码-1">2.3 AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">固定区间宽度的最大子段和，用前缀和思想来解决即可 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[maxn];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);<br>a[i]+=a[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-type">int</span> mmax=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=m; i&lt;=n; i++) mmax= <span class="hljs-built_in">max</span>(mmax, a[i]-a[i-m]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, mmax); <span class="hljs-comment">// 此处必须要有\n，ATcoder的变态规则 </span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线性结构编程技巧 </category>
          
          <category> 最大子段和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（七）不限宽的m子段的“最大的和值”问题</title>
      <link href="/2025/01/01/%EF%BC%88%E4%B8%83%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84m%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"/>
      <url>/2025/01/01/%EF%BC%88%E4%B8%83%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84m%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>　　本帖是“最大子段和”系列问题的第7帖，主要研究不限宽的m子段的“最大的和值”问题。</p><h1 id="一.-原题链接">一. 原题链接</h1><p>　　<a href="https://acm.hdu.edu.cn/showproblem.php?pid=1024">HDU1024Max Sum Plus Plus</a></p><p>　　中文大意如下：</p><p>　　给定一个连续的整数序列 <spanclass="math inline">\(a[1:n]=\{a_1、a_2、a_3、a_4、 ... a_i、... a_n\}(1 ≤ i ≤ n ≤ 1,000,000，-32768 ≤ a_i ≤ 32767)\)</span>。有函数 <spanclass="math inline">\(sum(le, ri) = a_{le} + ... + a_{ri} \quad(1 ≤ le ≤ri ≤ n)\)</span>。现在给定一个整数 <span class="math inline">\(m (m &gt;0)\)</span>，你的任务是找出$ m $（不能多，也不能少）对 <spanclass="math inline">\(le\)</span> 和<spanclass="math inline">\(ri\)</span>，使得 $sum(le_1 , ri_1 ) + sum(le_2 ,ri_2 ) + ... + sum(le_m , ri_m ) <spanclass="math inline">\(最大。（不允许\)</span>le_i ≤ le_j ≤ ri_i<spanclass="math inline">\(或\)</span> le_i ≤ ri_j ≤ri_i$，即不允许区间之间有重叠或交叉）。</p><p>　　输入的行数不确定，每一行代表了一个测试样例，该行第１个数是<spanclass="math inline">\(m\)</span>，第２个数是<spanclass="math inline">\(n\)</span>，后续跟着<spanclass="math inline">\(n\)</span>个整数。</p><p>　　输出多行，和输入行数一致，每行为一个测试样例中的ｍ段最大和值。</p><h1 id="二.-分析">二. 分析</h1><p>　　之前我们学过不限宽的２段的最大的和值问题，本题要做的是<spanclass="math inline">\(ｍ(m&gt;0)\)</span>段。感觉这个题是之前旧题的升级版。能不能在原有题型的基础上进行拓展来解决本题型呢？对于２段，我们枚举了分隔点，利用它把整个数组分成了左半段和右半段，然后正推，逆推。但如果是４段、１０段等，明显原来的方法不再适用了。需要重新换思路了，怎么搞？</p><p>　　目前已经学过的方法有贪心、分治、递推（ｄｐ）、深搜、二分等。对于给定的数组<spanclass="math inline">\(a[1..n]\)</span>，原始顺序肯定不能随意改变，否则题解肯定会大变。所以肯定不能排序了。分治和递推实际上是同一种思路，只不过是范围从大到小或从小到大的区别。深搜肯定不行，绝对TLE。二分主要用于在单调性函数中确定一个点的值，这里好像对不上。现在试着来递推一下看看。</p><p>　　递推和ｄｐ是相通的。下面尝试采用ｄｐ的思路来思考。</p><p>　　本题要求在ｎ个数中选择ｍ个连续子段，求其最大子段和。ｎ不同，结果不同；ｍ不同，结果也会不同。所以，ｎ和ｍ都会影响最终的结果值。一个状态由数组元素个数ｊ和子段数ｉ共同确定。鉴于子段数据的连续性，为了方便研究，所以有如下：</p><p>一）状态数组定义</p><p>　　<span class="math inline">\(dp[i][j]\)</span>表示在<spanclass="math inline">\(a[1..j]\)</span>中选择<spanclass="math inline">\(i\)</span>个子段，且<spanclass="math inline">\(a[j]\)</span>属于第<spanclass="math inline">\(i\)</span>个子段后的最大子段和值。（之所以让子段数在第一维，是为后续的dp数组空间优化做准备，这纯属经验；之所以要求<spanclass="math inline">\(a[j]\)</span>必须要在最末子段内，也属经验）</p><p>二）所求目标</p><p>　　<span class="math inline">\(max(\ dp[m][m:n]\ )\)</span></p><p>三）状态转移方程</p><p>　　因为每个子段内的数据必然是连续性的，所以对于每个新元素<spanclass="math inline">\(a[j]\)</span>有如下两种情况：</p><p>　　１）已有<spanclass="math inline">\(i-1\)</span>个子段，新开第<spanclass="math inline">\(i\)</span>个子段，且把<spanclass="math inline">\(a[j]\)</span>作为该新子段的第一个元素；</p><p>　　　　<span class="math inline">\(a[j]\)</span>左侧已经选出了<spanclass="math inline">\(i-1\)</span>个子段，可以模拟个数据来分析一下。假设<spanclass="math inline">\(m=5,n=7\)</span>，现在要求<spanclass="math inline">\(dp[3][5]\)</span>，则在情况１）下，有"前５个数选３个子段的和＝max(前２个数各自成子段且第５个数成第３子段，前３个数选出２子段且第５个数成第３子段，　前４个数选出２个子段且第５个数成第３子段)"，写成公式如下：<span class="math display">\[dp[3][5]=max(\ a[5]+dp[2][2],\ \ \ a[5]+dp[2][3],\ \ \ a[5]+dp[2][4]\ )\]</span> 　　　　将其一般化，有下面的公式（１）： <spanclass="math display">\[dp[i][j]=a[j]\ +\ max(\ dp[i-1][k]\ );\quad(i \in [1:m];\j\in[i:i+n-m];\ k \in[i-1:j-1]\ )\tag{1}\]</span> 　　２）已有<spanclass="math inline">\(i\)</span>个子段，把<spanclass="math inline">\(a[j]\)</span>作为第<spanclass="math inline">\(i\)</span>个子段的元素，总的子段数不变仍为<spanclass="math inline">\(i\)</span>个； <span class="math display">\[dp[i][j]=a[j]+dp[i][j-1];\quad (\ i\in[1:m];\ j\in[i:i+n-m]\ )\tag{2}\]</span> 　　将公式（１）和（２）整合一下，得到最后的状态转移方程如下：<span class="math display">\[dp[i][j]=a[j]+max\textcolor[RGB]{255,0,0}(\ dp[i][j-1]\+\  max\textcolor[RGB]{255,255,0}(\ dp[i-1][k]\\textcolor[RGB]{255,255,0})\ \textcolor[RGB]{255,0,0});\quad(i \in[1:m];\ j\in[i:i+n-m];\ k \in[i-1:j-1]\ )\tag{3}\]</span> 四）循环顺序和边界</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic/img/%EF%BC%88%E4%B8%83%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84m%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%981.png" alt="image-20250101143316213" style="zoom: 80%;" /></p><p>　　对于<span class="math inline">\(i\)</span>，肯定是<spanclass="math inline">\([1:m]\)</span>，根据公式（３），需要用到上一行的内容，所以<spanclass="math inline">\(i\)</span>只能从上往下增序。</p><p>　　对于<spanclass="math inline">\(j\)</span>，我们的目的是要算出<spanclass="math inline">\(dp[m][m:n]\)</span>，例如求<spanclass="math inline">\(dp[4][7]\)</span>，我们没必要去计算和填写<spanclass="math inline">\(dp[1][5]、dp[2][6]\)</span>等数据，为什么呢？因为要想在前７个数中选出４个子段，那么就不可能在前６个数中选出２个子段，因为仅剩７－６＝１个数了，没办法把１个数划分出4－２＝２个子段，也没办法把２个数划分出４－１＝３个子段。所以虽然<spanclass="math inline">\(dp[1][5]、dp[2][6]\)</span>存在，但对我们的所求目标没有任何贡献，自然不需要去计算了（如上图灰色区域格子）。准确地说，剩余的数的个数<spanclass="math inline">\(n-j\)</span>要大于等于剩余的子段数<spanclass="math inline">\(m-i\)</span>，即有<spanclass="math inline">\(n-j\geq m-i\quad \Rightarrow\quad j \leq i+n-m\\)</span>。另外，我们也没必要去填写诸如<spanclass="math inline">\(dp[5][2]\)</span>这类数据（如上图红色区域格子），因为前２个数据不可能被分为５个子段，因为每个子段至少要有１个数据。也就是说，<spanclass="math inline">\(j\geq i\)</span>。归纳一下得<spanclass="math inline">\(j \in[i:i+n-m]\)</span>，每行填写<spanclass="math inline">\(n-m+1\)</span>个数即可。因为需要用到第<spanclass="math inline">\(j-1\)</span>列的数据，所以<spanclass="math inline">\(j\)</span>只能从左往右增序。</p><p>　　对于<spanclass="math inline">\(k\)</span>，来自于公式（３）中的<spanclass="math inline">\(max(dp[i-1][k])\)</span>，对应的<spanclass="math inline">\(dp[][]\)</span>数据来自于上一行，全都已知，故<spanclass="math inline">\(k\)</span>增序降序都可以。假设第<spanclass="math inline">\(i-1\)</span>个子段的最右侧元素下标为<spanclass="math inline">\(k\)</span>，则<spanclass="math inline">\(k\)</span>可能的最小值为<spanclass="math inline">\(i-1\)</span>（前面的每１个元素都自成１个子段，则第<spanclass="math inline">\(i-1\)</span>个子段为<spanclass="math inline">\(a[i-1:i-1]\)</span>）。<spanclass="math inline">\(k\)</span>可能的最大值是<spanclass="math inline">\(j-1\)</span>。总结后<spanclass="math inline">\(k\)</span>的范围就是<spanclass="math inline">\([i-1:j-1]\)</span>。</p><p>五）特例和初始化</p><p>　　对于对角线和第１行的数据，均来自于左侧一列、上一行和<spanclass="math inline">\(a[]\)</span>，当默认数据为０时公式（３）并不冲突，所以直接初始化<spanclass="math inline">\(dp[0:m][0:n]\)</span>为全０即可。</p><p>六）复杂度分析</p><p>　　可以看到，公式（３）的时间复杂度和空间复杂度都是比较高的，时间复杂度为<spanclass="math inline">\(O(m*(n-m)^2)\)</span>，空间复杂度为<spanclass="math inline">\(O(m*n)\)</span>。</p><p>七）时间复杂度优化</p><p>　　对于上图中求红色长方框内区域的最大值，没必要针对每个<spanclass="math inline">\(dp[i][j]\)</span>去循环<spanclass="math inline">\(k\)</span>来重新计算当前的最大值，完全可以利用上一轮计算的结果来刷新最大值。需要注意的是，随着<spanclass="math inline">\(j\)</span>的循环，需要比较最大值的元素是<spanclass="math inline">\(dp[i-1][j-1]\)</span>。这样可以把三重循环降为二重循环，时间复杂度变为<spanclass="math inline">\(O(m*(n-m))\)</span>。</p><p>八）空间复杂度优化</p><p>　　从上图和公式（３）可以看到，每次填写一个网格，只需要用到上一行和当前行左侧一格的数据，但此处不能用滚动数组，因为根据分析，我们必须要从左往右去循环<spanclass="math inline">\(j\)</span>（不能从右往左），且需要用到的是<spanclass="math inline">\(dp[i-1][i-1:j-1]\)</span>，而不是<spanclass="math inline">\(dp[i][i-1:j-1]\)</span>。但所幸的是，只需要用到当前行和上一行的完整数据，所以没必要设定<spanclass="math inline">\(dp[][]\)</span>为<spanclass="math inline">\(m\)</span>行。故而只需要设定<spanclass="math inline">\(dp[2][0..n]\)</span>这２行即可，空间复杂度降为<spanclass="math inline">\(O(2*n)\)</span>。</p><p>　　我们没必要每次填完之后去来回复制整行，这里可以学习一个小的编程技巧。我们知道<spanclass="math inline">\(0\oplus 1=1;1\oplus 1=0;\)</span>（<spanclass="math inline">\(\oplus\)</span>表示“按位异或”），也就是说，不管起初变量a=1或者a=0，在做<spanclass="math inline">\(\oplus1\)</span>操作后的算式值都会恰好相反（即从０变成１，或从１变成０），所以在提取上一行值时可以用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">maxpre=<span class="hljs-built_in">max</span>(maxpre, dp[k^<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]);  <span class="hljs-comment">// k^1表示上一行。当k==0时k^1的值为1,当k==1时k^1的值为0</span><br></code></pre></td></tr></table></figure><p>　　这样设置后，第<spanclass="math inline">\(m\)</span>行的结果最后是存放在<spanclass="math inline">\(dp[0][...]\)</span>或者<spanclass="math inline">\(dp[1][...]\)</span>呢？当<spanclass="math inline">\(m=1\)</span>时最终结果在第１行，当<spanclass="math inline">\(m=2\)</span>时最终结果在第０行，当<spanclass="math inline">\(m=3\)</span>时最终结果在第１行，当<spanclass="math inline">\(m=4\)</span>时最终结果在第０行，当<spanclass="math inline">\(m=5\)</span>时最终结果在第１行，……。可以看出，ｍ若为奇数则在１，ｍ若为偶数则在０。故结果可以写成<spanclass="math inline">\(dp[m\%2][...]\)</span>或者<spanclass="math inline">\(dp[m\&amp;1][...]\)</span>。</p><h1 id="三.-ac代码">三. AC代码</h1><p>　　注意一下，longlong类型的最大值为LLONG_MAX。不过本题数据弱，使用INT_MAX也没报错～～</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>; <br><span class="hljs-type">int</span> n,m;<br>ll a[N],dp[<span class="hljs-number">2</span>][N];   <span class="hljs-comment">//只保存上一行和当前行 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;m,&amp;n))&#123;   <span class="hljs-comment">//n个数字，m子段和 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,a+i);  <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) dp[<span class="hljs-number">0</span>][i]=<span class="hljs-number">0</span>,dp[<span class="hljs-number">1</span>][i]=<span class="hljs-number">0</span>;    <br><span class="hljs-comment">// 仍然需要设定i来标识出j的左右边界值，k只是0或1，无法代替这一个功能，k只在存入和读取dp的时候起作用 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,k=<span class="hljs-number">1</span>; i&lt;=m; i++,k^=<span class="hljs-number">1</span>)&#123;    <span class="hljs-comment">//分为i段，k为两行之间的切换</span><br>        dp[k][i<span class="hljs-number">-1</span>]= -LLONG_MAX;    <span class="hljs-comment">// 让同行左侧的dp[i][i-1]值不去影响dp[i][i]的填写，此时也需用到 k </span><br>            ll maxpre = -LLONG_MAX;    <span class="hljs-comment">// maxpre记录上一行的最大值，在每一行开始时需要重新置初始值 </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n-m+i;j++)&#123;<br>                maxpre=<span class="hljs-built_in">max</span>(maxpre,dp[k^<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]);      <span class="hljs-comment">//随时更新上一行最大值</span><br>                dp[k][j]=<span class="hljs-built_in">max</span>(dp[k][j<span class="hljs-number">-1</span>],maxpre)+a[j]; <span class="hljs-comment">//对应公式３</span><br>            &#125;<br>        &#125;<br>        ll ans= -LLONG_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m;i&lt;=n;i++) ans=<span class="hljs-built_in">max</span>(ans,dp[m&amp;<span class="hljs-number">1</span>][i]);  <span class="hljs-comment">//找到第m行的最大值，即为答案</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>    &#125;  <br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入 </span><br><span class="hljs-comment">4 7 -2 11 -4 13 -5 6 -2</span><br><span class="hljs-comment">输出</span><br><span class="hljs-comment">28 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线性结构编程技巧 </category>
          
          <category> 最大子段和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（六）不限宽的2子段的“最大的和值”问题</title>
      <link href="/2024/12/31/%EF%BC%88%E5%85%AD%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%842%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"/>
      <url>/2024/12/31/%EF%BC%88%E5%85%AD%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%842%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>　　本帖是“最大子段和”系列问题的第6帖，主要研究不限宽的2个子段区间内的“最大的和值”这个问题。要求学生已学过<spanclass="math inline">\(dp\)</span>入门类的题目。本题是后续的“不限宽的ｍ个子段区间内的最大的和值”的特殊情况<spanclass="math inline">\((m=2)\)</span>，可以用比较简单的做法来做，所以本帖先搞定简单的做法。（<del>其实也不简单，若不看题解，可能会搞死一些小朋友的</del>）</p><h1 id="一.-原题链接">一. 原题链接</h1><p>　　<a href="https://www.luogu.com.cn/problem/P2642">P2642双子序列最大和</a></p><h1 id="二.-分析">二. 分析</h1><p>　　我们之前已经学过了“不限宽的区间的“最大的和值”问题”，只需要求１个子段，是本系列的第一个帖子。现在要求２个子段，这该怎么办呢？</p><p>　　我们可以枚举一个分隔点<spanclass="math inline">\(i\)</span>，然后在<spanclass="math inline">\(a[0:i-1]\)</span>和<spanclass="math inline">\(a[i+1:n-1]\)</span>这两个数组中各自选出１个最大子段和，再相加即可。根据题意，<spanclass="math inline">\(a[i]\)</span>不属于左段，也不属于右段。</p><p>　　因为<spanclass="math inline">\(i\)</span>是枚举的变量，是不断在变化的，在求<spanclass="math inline">\(a[0:i-1]\)</span>中的最大子段和时，可以<strong>设定<spanclass="math inline">\(dp1[k]\)</span>为“在选定<spanclass="math inline">\(a[k]\)</span>的前提下，在<spanclass="math inline">\(a[0:k]\)</span>数组中选择１个子段后得到的最大的和值”</strong>，可以在<font color="red">从左往右</font>枚举<spanclass="math inline">\(i\)</span>的时候同步填写<spanclass="math inline">\(dp[k]\)</span>（即<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(k\)</span>同步，不需要专门定义变量<spanclass="math inline">\(k\)</span>），其解决思想和“<ahref="https://www.luogu.com.cn/problem/P1115">P1115最大子段和</a>”很相似，需要用到贪心的思想去递推即可。</p><p>　　但要去求<spanclass="math inline">\(a[i+1:n-1]\)</span>的１个最大子段和时，因为右子段的起始位置不再是０，而是变化的位置<spanclass="math inline">\(i+1\)</span>，这使得程序变得复杂。但如果我们反过来思考，<strong>设定<spanclass="math inline">\(dp2[k]\)</span>为“在选定a[k]的前提下，在<spanclass="math inline">\(a[k:n-1]\)</span>数组中选择１个子段后得到的最大的和值”</strong>，<font color="red">从右端往左端</font>使用贪心的思想来递推即可。这种思想，和以前练过的“<ahref="https://www.luogu.com.cn/problem/P1091">P1091 [NOIP2004 提高组]合唱队形</a>”的思想很相似。</p><p>　　但是，所求的目标并不等于<spanclass="math inline">\(max(dp1[i]+dp2[i])\quad(i\in[0..n-1])\)</span>，也不等于<spanclass="math inline">\(max(dp1[i]+dp2[i]-a[i])\)</span>，为什么呢？请看下图：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic/img/%EF%BC%88%E5%85%AD%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%842%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%981.png" alt="image-20241231161546354" style="zoom: 67%;" /></p><p>　　在上面的图中，我们把整个数组分成了<spanclass="math inline">\(a[0:i-1]、\ \ a[i]、\ \a[i+1:n]\)</span>这三段。红框表示左半段中选择的最大子段，绿框表示右半段中选择的最大子段，橙色表示选中子段的最左／最右的那个元素。根据题意，图（ａ）肯定是不可能的，因为题意说了两个子段必须要分开，至少间隔１个元素，不能视为一个子段。图（ｂ）和图（ｃ）都是符合题意的。但是根据我们对<spanclass="math inline">\(dp1[i]\)</span>和<spanclass="math inline">\(dp2[i]\)</span>的定义，<spanclass="math inline">\(dp1[i]+dp2[i]\)</span>只能表达出图（ａ），是不符合题意规定的；而<spanclass="math inline">\(dp1[i-1]+dp2[i+1]\)</span>也只能表达出图（ｂ）的情况，而无法表达图（ｃ）。那该怎么办呢？</p><p>　　我们仔细看图（ｃ）的左半段，可以发现，<font color="red">红框内元素之和，是<spanclass="math inline">\(a[0:i-1]\)</span>这个左半段中的最大子段和（<strong>不一定要以<spanclass="math inline">\(a[i-1]\)</span>结尾</strong>），设其为<spanclass="math inline">\(dple[i-1]\)</span>；绿框内元素之和，是<spanclass="math inline">\(a[i+1:n-1]\)</span>这个右半段中的最大子段和（<strong>不一定要以<spanclass="math inline">\(a[i+1]\)</span>开头</strong>），设其为<spanclass="math inline">\(dpri[i+1]\)</span></font>。可以发现，这样定义涵盖了图（ｂ）和图（ｃ）这两种情况。最终所求目标就为<spanclass="math inline">\(\textcolor[RGB]{250,250,100}{max(\dple[i-1]+dpri[i+1]\ )\quad(\ i \in[1..n-2]\ )}\)</span>。</p><p>　　现在只剩最后一个问题：如何求出这样定义下的<spanclass="math inline">\(dple[]\)</span>和<spanclass="math inline">\(dpri[]\)</span>？</p><p>　　还记得我们做过的P1115题要求的是什么吗？给定<spanclass="math inline">\(a[0..n-1]\)</span>，求这<spanclass="math inline">\(n\)</span>个数中的最大子段和。该题并没有说一定要以<spanclass="math inline">\(a[n-1]\)</span>为最大子段的末尾元素哦！　我们是怎么求的？　弄了一个前缀和变量<spanclass="math inline">\(sum\)</span>（表示选定<spanclass="math inline">\(a[i]\)</span>的前提下前<spanclass="math inline">\(i\)</span>个数中选出的最大子段和值），不断累加<spanclass="math inline">\(a[i]\)</span>，一旦变负就清零继续累加，同时<strong>搞了一个<spanclass="math inline">\(maxSum\)</span>来保存出现过的<spanclass="math inline">\(sum\)</span>的最大值</strong>，采用的方法是<spanclass="math inline">\(maxSum=max(maxSum, sum)\)</span>。</p><p>　　但此时我们要的并不是一个值，而是<spanclass="math inline">\(dple[0:n-1]\)</span>，即一堆的值。上面提到的<spanclass="math inline">\(maxSum\)</span>就对应着<spanclass="math inline">\(dple[i]\)</span>，而上面提到的<spanclass="math inline">\(sum\)</span>就对应着我们之前已求出的<spanclass="math inline">\(dp1[i]\)</span>。所以有如下的公式（对<spanclass="math inline">\(dpri[]\)</span>的分析类似，只是需要从右往左逆推）：$$ <span class="math display">\[\begin{align}dple[i]=max(\ dple[i-1],\quad dp1[i]\ ) \qquad(\ i \in[\\textcolor[RGB]{255,0,0}1:n-1\ ]\ )\tag{1} \\dpri[i]=max(\ dpri[i+1],\quad dp2[i]\ ) \qquad(\ i \in[\\textcolor[RGB]{255,0,0}{n-2}:0\ ]\ )\tag{2} \\\end{align}\]</span> $$</p><p>#　三. dp归纳总结</p><p>　　下面用<spanclass="math inline">\(dp\)</span>的套路来归纳所有的细节。</p><p>（一）状态数组定义</p><p>　　<span class="math inline">\(dp1[i]\)</span>为“在选定<spanclass="math inline">\(a[i]\)</span>的前提下，在<spanclass="math inline">\(a[0:i]\)</span>数组中选择１个子段后得到的最大的和值”；</p><p>　　<spanclass="math inline">\(dple[i]\)</span>为“在不限制是否选定<spanclass="math inline">\(a[i]\)</span>的前提下，在<spanclass="math inline">\(a[0:i]\)</span>数组中选择１个子段后得到的最大的和值”；</p><p>　　<spanclass="math inline">\(dp2[i]\)</span>为“在选定a[i]的前提下，在<spanclass="math inline">\(a[i:n-1]\)</span>数组中选择１个子段后得到的最大的和值”；</p><p>　　<spanclass="math inline">\(dpri[i]\)</span>为“在不限制是否选定<spanclass="math inline">\(a[i]\)</span>的前提下，在<spanclass="math inline">\(a[0:i]\)</span>数组中选择１个子段后得到的最大的和值”；</p><p>（二）所求目标</p><p>　　<span class="math inline">\(max(\ dple[i]+dpri[i]\ )\qquad (i \in[1..n-2])\)</span> （分隔点不能在两个端点，否则无法分成左右两段 ）</p><p>（三）状态转移方程 <span class="math display">\[\begin{align}dp1[i]&amp;=max(\ dp1[i-1],\quad 0\ )+a[i]\qquad(\ i\in[\textcolor[RGB]{255,0,0}{1}:n-1]\ ) \tag{3}\\dple[i]&amp;=max(\ dple[i-1],\quad dp1[i]\ ) \qquad(\ i \in[\\textcolor[RGB]{255,0,0}1:n-1\ ]\ )\tag{4} \\\\dp2[i]&amp;=max(\ dp2[i\textcolor[RGB]{255,0,0}+1],\quad 0\)+a[i]\qquad(\ i \in[\textcolor[RGB]{255,0,0}{n-2}:0]\ ) \tag{5}\\dpri[i]&amp;=max(\ dpri[i\textcolor[RGB]{255,0,0}+1],\quad dp2[i]\ )\qquad(\ i \in[\ \textcolor[RGB]{255,0,0}{n-2}:0\ ]\ )\tag{6} \\\end{align}\]</span> （四）循环顺序和边界</p><p>　　上面公式的附属条件中已经写得很清楚了。</p><p>（五）特例和初始化</p><p>　　<span class="math inline">\(dp1[0]=a[0];\qquaddp2[n-1]=a[n-1];\)</span></p><p>　　需要注意的是，当<spanclass="math inline">\(i\)</span>位于两个端点坐标时，因为必须要选至少１个数而形成１个子段，所以会有<spanclass="math inline">\(dple[0]=a[0];\ \)</span>。在不限制是否选定<spanclass="math inline">\(a[0]\)</span>的前提下，在<spanclass="math inline">\(a[0:0]\)</span>数组中选择１个子段后得到的最大的和值，这……必须得选<spanclass="math inline">\(a[0]\)</span>啊！否则子段就要为空了（本题要求子段不能为空，否则就不叫做２段了）。同理有<spanclass="math inline">\(dpri[n-1]=a[n-1];\ \)</span>。</p><h1 id="四.-ac代码">四. AC代码　</h1><p>　　注意要设置long long ，不然可能要见祖宗了～</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> a[maxn], n;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp1[maxn], dp2[maxn];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dple[maxn], dpri[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; ++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);<br>dp1[<span class="hljs-number">0</span>]=a[<span class="hljs-number">0</span>], dple[<span class="hljs-number">0</span>]= a[<span class="hljs-number">0</span>];<br>dp2[n<span class="hljs-number">-1</span>]=a[n<span class="hljs-number">-1</span>], dpri[n<span class="hljs-number">-1</span>]= a[n<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++) dp1[i]=<span class="hljs-built_in">max</span>(dp1[i<span class="hljs-number">-1</span>],<span class="hljs-number">0LL</span>)+a[i], dple[i]= <span class="hljs-built_in">max</span>(dple[i<span class="hljs-number">-1</span>], dp1[i]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>; i&gt;=<span class="hljs-number">0</span>; i--) dp2[i]=<span class="hljs-built_in">max</span>(dp2[i+<span class="hljs-number">1</span>],<span class="hljs-number">0LL</span>)+a[i], dpri[i]= <span class="hljs-built_in">max</span>(dpri[i+<span class="hljs-number">1</span>], dp2[i]);;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> mmax=<span class="hljs-number">-1e18</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n<span class="hljs-number">-1</span>; i++) mmax= <span class="hljs-built_in">max</span>(mmax, dple[i<span class="hljs-number">-1</span>]+dpri[i+<span class="hljs-number">1</span>]);<br>cout &lt;&lt; mmax;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">20 50 -10 1300 -900</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线性结构编程技巧 </category>
          
          <category> 最大子段和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（五）环状的不限宽的区间的“最大的和值”问题</title>
      <link href="/2024/12/30/%EF%BC%88%E4%BA%94%EF%BC%89%E7%8E%AF%E7%8A%B6%E7%9A%84%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"/>
      <url>/2024/12/30/%EF%BC%88%E4%BA%94%EF%BC%89%E7%8E%AF%E7%8A%B6%E7%9A%84%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>　　本帖是“最大子段和”系列问题的第5帖，主要研究环状的不限宽的区间的“最大的和值”这个问题。</p><h1 id="一.-理论教学">一. 理论教学</h1><p>　　在学习本题型之前，需要学生先掌握“（一）不限宽的区间的“最大的和值”问题，如果不会，请点击<a href="/2024/12/24/%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E5%BA%A6%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/#jump2"><font color="red">这里</font></a>。</p><p>　　<strong>环形数组</strong>意味着数组的末端将会与开头相连呈环状，给定一个长度为 <spanclass="math inline">\(n\)</span>的<strong>环形整数数组</strong> <spanclass="math inline">\(a[0..n-1]\)</span>，返回<spanclass="math inline">\(a[]\)</span>的非空子数组／子段／子序列的最大可能和 。例如<span class="math inline">\(a[]=\{5,-3,5\}\)</span>，则其环状最大子段和为<spanclass="math inline">\(5+5=10\)</span>。</p><p>　　对于这个题型，有三种方法可以解决。希望同学们尽量看懂下面的三种解法的思路。</p><h2 id="方法一用ｄｐ硬干时间on空间on">1.1 方法一：用ｄｐ硬干（时间<spanclass="math inline">\(O(n)\)</span>，空间<spanclass="math inline">\(O(n)\)</span>）</h2><p>　　总体思路：尽可能用“不限宽区间的最大和值”的思路来解决本题型中的“环状”的问题。因为环状可能会涉及到取余，而且对应的题是用vector来存储原始数据，所以建议最好把原始数组<spanclass="math inline">\(a[]\)</span>从下标０开始存储。在环形情况中，答案可能包括以下两种情况：</p><p>　　１）构成最大子数组和的子数组为 <spanclass="math inline">\(a[le:ri]\)</span>，包括 <spanclass="math inline">\(a[le:ri]\)</span> 共 <spanclass="math inline">\(ri−le+1\)</span> 个元素，其中 <spanclass="math inline">\(0≤le≤ri≤n-1\)</span>。　　２）构成最大子数组和的子数组为 <spanclass="math inline">\(a[0:le]\)</span> 和 <spanclass="math inline">\(a[ri:n-1]\)</span>，其中 <spanclass="math inline">\(0≤le&lt;ri≤n-1\)</span>。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic/img/%EF%BC%88%E4%BA%94%EF%BC%89%E7%8E%AF%E7%8A%B6%E7%9A%84%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%981.png" alt="image-20241230102930185" style="zoom: 80%;" /></p><p>　　对于情况１），可以用以前学过的“（一）不限宽的区间的“最大的和值”问题的解法来做，此处不再赘述。</p><p>　　对于情况２），其最大和值应分为左右两部分，如上图所示，<spanclass="math inline">\(nums[0:le]\)</span>和 <spanclass="math inline">\(nums[ri:n]\)</span>为实际<strong>被选</strong>子段，且有<spanclass="math inline">\(le+1&lt;ri\)</span>，否则就无法同时存在两段数据而蜕变成了情况１）。我们可以在<spanclass="math inline">\([2:n-1]\)</span>范围内枚举 <spanclass="math inline">\(ri\)</span>，故左子段<strong>“备选”</strong>的数据区间就是<spanclass="math inline">\([0..ri-2]\)</span>（因为左右两个子段之间至少要间隔１个数据不能选），而左子段的实际<strong>被选</strong>区间是<spanclass="math inline">\(a[0:le]\)</span>。此时我们很容易算出右子段<strong>“被选”</strong>数据段区间元素之和为<spanclass="math inline">\(sum(a[ri:n])\)</span>(可用“后缀和”的思想，或者用“前缀和相减”也行)，然后算出左子段<spanclass="math inline">\(a[0:ri−2]\)</span>的最大前缀和，将它和右子段的那个“和值”相加后考虑更新答案。</p><p>　　 <span class="math inline">\(leftMax[i]\)</span> 表示<spanclass="math inline">\(a[0:i]\)</span>的最大前缀和。注意，该最大前缀和的选择，不一定会选择到<spanclass="math inline">\(a[i]\)</span>。这就是“<strong>备选</strong>”和“<strong>被选</strong>”的差别。例如<spanclass="math inline">\(a[0:10]\)</span>这段数据的最大前缀和可能只是<spanclass="math inline">\(a[0:6]\)</span>，最后四个数因为是负数而不能选。又例如<spanclass="math inline">\(a[]=\{2,5,-2,4,-4,-2\}\)</span>，则有<spanclass="math inline">\(leftMax[]=\{2,7,7,9,9,9\}\)</span>，在计算<spanclass="math inline">\(leftMax[5]＝2+5-2+4=9\)</span>时，<spanclass="math inline">\(a[0..5]\)</span>都是<strong>备选</strong>元素，但只有<spanclass="math inline">\(a[0..3]\)</span>是<strong>被选</strong>元素。递推方程如下：<span class="math display">\[leftMax[le]=max(leftMax[le−1],\quad sum(nums[0:le])\qquad(le\in[0..n-1])\]</span></p><h2 id="方法二取反-时间on空间o1">1.2 方法二：取反 （时间<spanclass="math inline">\(O(n)\)</span>，空间<spanclass="math inline">\(O(1)\)</span>）</h2><p>　　对于上面1.1节中提到的情况２），我们不一定非要去求绿色区域的和值。我们可以改为求白色区域的最小和值，然后用总和去减它，剩下的自然就是绿色区域的和值了。此时这个白色区域肯定是一个连续块，不会断成首尾两截。</p><p>　　注意：</p><p>　　a）“取反”只适合于解决上面的情况２），并不能解决情况１）。所以，代码中仍然需要处理情况１）。</p><p>　　b）取反只适合于当<spanclass="math inline">\(n&gt;1\)</span>的情况，当<spanclass="math inline">\(a[]\)</span>只有一个元素时，只能取这个数，而其反集为空。而我们目前的做法都没有考虑空集的问题。</p><p>　　c）取反的时候要注意“其反集为全集”的情况。如<spanclass="math inline">\(\{-3,-2,-4\}\)</span>这种情况，其子段的最小和为<spanclass="math inline">\(-3-2-4=-9\)</span>，即所有数据都要选。此时若再用总和去减，则其结果为<spanclass="math inline">\(-9-(-9)=0\)</span>。这意味着不选就是最大。当根据我们的题意，必须要选至少一个数，不符合题意。所以取反求最小子段和的时候，若求出来的是全集，则也会失效，应剔除而不于考虑。</p><h2 id="方法三单调队列数组长度翻倍时间o2n空间o2n">1.3方法三：单调队列＋数组长度翻倍（<spanclass="math inline">\(时间O(2n),空间O(2n)\)</span>）</h2><p>　　我们可以将数组<spanclass="math inline">\(a[0:n-1]\)</span>延长一倍为<spanclass="math inline">\(a[0:2*n-1]\)</span>，即对于延长的区域内的元素，令<span class="math inline">\(a[i]=a[i−n]\quad(i \geqn)\)</span>。然后，对于1.1节中提到的第２）种情况，则左子段和右子段不会再分离，可以组成连续的一段<spanclass="math inline">\(a[ri:n+le]\)</span>。如下图所示：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic/img/%EF%BC%88%E4%BA%94%EF%BC%89%E7%8E%AF%E7%8A%B6%E7%9A%84%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%982.png"alt="image-20241231091109644" /><figcaption aria-hidden="true">image-20241231091109644</figcaption></figure><p>　　至此，我们就把一个“环状”的问题转变成了一个“链状”的问题。这和以前做过的“<ahref="https://www.luogu.com.cn/problem/P1880">P1880　合并石子</a>”的原理相似。剩下的就是按照本站之前讲过的（三）来处理了，有如下递推方程：<span class="math display">\[dpmax[i]=s[i]-\textcolor[RGB]{255,0,0}{min(\ s[i-m],\quads[i-m+1]\quad,\  ......\ ,\quad  s[i-2],\quad s[i-1]\ \quad\ ) }\tag{1}\]</span> 　　红色区域的处理需要用到单调队列来解决，在第<spanclass="math inline">\(i\)</span>轮求出<spanclass="math inline">\(s[i-m:i-1]\)</span>这个滑窗内的最小元素值，从而求出<spanclass="math inline">\(dpmax[i]\)</span>。具体做法若不清楚，请见<a href="/2025/01/01/%EF%BC%88%E4%B8%89%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/#jump1"><font color="red">这里</font></a>。</p><h1 id="二实战练习">二、实战练习</h1><h2 id="leetcode918-环状子数组的最大和">2.1 LeetCode918环状子数组的最大和</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<ahref="https://leetcode.cn/problems/maximum-sum-circular-subarray/description/">LeetCode918环状子数组的最大和</a></p><h3 id="ac代码">2.1.2 AC代码</h3><p>　　按照上面的理论讲解来实现三种代码，分别如下：</p><h4 id="方法１dp硬干">2.1.2.1 方法１：dp硬干</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 版本1： dp硬干 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//  提交内容如下</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubarraySumCircular</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">// leftMax[5]=12 表示nums[0..5]之间选择子段，子段的最大和值为12</span><br><span class="hljs-comment">// sum[5]=10 表示nums[0..5]的总和为10 </span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftMax</span><span class="hljs-params">(n)</span>, <span class="hljs-title">sum</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-comment">// 对坐标为 0 处的元素单独处理，避免考虑子数组为空的情况</span><br>leftMax[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>sum[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>sum[i] = sum[i<span class="hljs-number">-1</span>] + nums[i];<br>leftMax[i] = <span class="hljs-built_in">max</span>(leftMax[i - <span class="hljs-number">1</span>], sum[i]);<br>&#125;<br><br><span class="hljs-comment">// 处理情况2： </span><br><span class="hljs-comment">// 从右到左枚举后缀，固定后缀，选择最大前缀</span><br><span class="hljs-type">int</span> ans=sum[n<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ri = <span class="hljs-number">2</span>; ri &lt; n; ri++) &#123;<br><span class="hljs-comment">// sum[n-1]- sum[ri-1]是a[ri:n-1]的和，即后缀和</span><br><span class="hljs-comment">// 当前以ri为右子段的左边界，则左子段的右边界应为ri-2，两个子段之间必须要空至少一个元素不选 </span><br>ans = <span class="hljs-built_in">max</span>(ans, (sum[n<span class="hljs-number">-1</span>]- sum[ri<span class="hljs-number">-1</span>]) + leftMax[ri - <span class="hljs-number">2</span>]);   <br>&#125;<br><br><span class="hljs-comment">// 处理情况1： </span><br><span class="hljs-type">int</span> ms=nums[<span class="hljs-number">0</span>];ans= <span class="hljs-built_in">max</span>(ans, ms);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++) &#123;<br>ms= <span class="hljs-built_in">max</span>(ms,<span class="hljs-number">0</span>) + nums[i];<br>ans= <span class="hljs-built_in">max</span>(ans, ms);<br>&#125;<br><br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br><span class="hljs-comment">//提交内容如上</span><br>vector&lt;<span class="hljs-type">int</span>&gt; nums= &#123;<span class="hljs-number">-3</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-3</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br>Solution s1;<br>cout &lt;&lt;s1.<span class="hljs-built_in">maxSubarraySumCircular</span>(nums);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法２取反">2.1.2.2 方法２：取反</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 版本2： 取反，求最小 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//  提交内容如下</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubarraySumCircular</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">// 处理情况1： </span><br><span class="hljs-type">int</span> ms=nums[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> preSum=nums[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> ans=nums[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++) &#123;<br>ms= <span class="hljs-built_in">max</span>(ms,<span class="hljs-number">0</span>) + nums[i];<br>ans= <span class="hljs-built_in">max</span>(ans, ms);<br><br>preSum+= nums[i];<br>&#125;<br><br><span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ans;  <span class="hljs-comment">//若只有1个元素，则不适合情况2 </span><br><span class="hljs-comment">// 处理情况2： </span><br><span class="hljs-comment">// 对坐标为 0 处的元素单独处理，避免考虑子数组为空的情况</span><br><span class="hljs-type">int</span> minSum = nums[<span class="hljs-number">0</span>];<br>ans= <span class="hljs-built_in">max</span>(ans, preSum-minSum);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++) &#123;<br>minSum= <span class="hljs-built_in">min</span>(minSum,<span class="hljs-number">0</span>) + nums[i];<br><span class="hljs-keyword">if</span> (preSum != minSum) <br>ans= <span class="hljs-built_in">max</span>(ans, preSum-minSum);<br>&#125;<br><br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br><span class="hljs-comment">//提交内容如上</span><br>vector&lt;<span class="hljs-type">int</span>&gt; nums= &#123;<span class="hljs-number">-3</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-3</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br>Solution s1;<br>cout &lt;&lt;s1.<span class="hljs-built_in">maxSubarraySumCircular</span>(nums);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单调队列翻倍数组">2.1.2.3 单调队列＋翻倍数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 版本3： 单调队列，翻倍延长数组 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">将a[1..n]变成a[1..2*n]，延长一倍后，求a[1..2*n]中窗口宽度&lt;=n的最大和值。</span><br><span class="hljs-comment">需要用单调队列求sum[]中滑窗宽度&lt;=n内元素的最小值，第i轮的新元素是sum[i-1] </span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//  提交内容如下</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubarraySumCircular</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        deque&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q; <span class="hljs-comment">// &lt;pos, value&gt;</span><br>        <span class="hljs-type">int</span> pre = nums[<span class="hljs-number">0</span>], res = nums[<span class="hljs-number">0</span>];<br>        q.<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">0</span>, pre&#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">2</span> * n; i++) &#123;<br>            <span class="hljs-comment">// 根据之前学过的单调队列求最大和的模板，此处求&lt;=n的元素的最小值，pre=sum[i-1]是新元素 </span><br>            <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; pre &lt;= q.<span class="hljs-built_in">back</span>().second ) &#123;<br>                q.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            q.<span class="hljs-built_in">push_back</span>(&#123;i<span class="hljs-number">-1</span>, pre&#125;);<br><br>            <span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; (i<span class="hljs-number">-1</span>) - q.<span class="hljs-built_in">front</span>().first + <span class="hljs-number">1</span> &gt; n) &#123;<br>                q.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>            <span class="hljs-comment">// 计算出sum[i]，在下一轮时pre就是sum[i-1]了 </span><br>            pre += nums[i % n];<br>            <span class="hljs-comment">// 在第i轮，计算出dpmax[i]= sum[i] - min( s[i-m], sum[i-m+1], ...... , sum[i-2], sum[i-1] )</span><br>            res = <span class="hljs-built_in">max</span>(res, pre - q.<span class="hljs-built_in">front</span>().second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//提交内容如上</span><br>vector&lt;<span class="hljs-type">int</span>&gt; nums= &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-2</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br>Solution s1;<br>cout &lt;&lt;s1.<span class="hljs-built_in">maxSubarraySumCircular</span>(nums);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线性结构编程技巧 </category>
          
          <category> 最大子段和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（四）宽度大于等于m的区间的“最大的和值”问题</title>
      <link href="/2024/12/27/%EF%BC%88%E5%9B%9B%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"/>
      <url>/2024/12/27/%EF%BC%88%E5%9B%9B%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>　　本帖是“最大子段和”系列问题的第4帖，主要研究宽度大于等于m的区间的“最大的和值”这个问题。</p><h1 id="一.-理论教学">一. 理论教学</h1><p>　　之前我们练习过“区间宽度<span class="math inline">\(\leqm\)</span>”的情况，用单调队列来解决了问题。已经记不太清楚的同学请看<a href="/2025/01/01/%EF%BC%88%E4%B8%89%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"><font color="red">这里</font></a>。看到当前这个题型，第一反应就是“能不能用之前解决<spanclass="math inline">\(\leq m\)</span>的公式推导过程来解决本题型呢？”</p><p>　　可以试试看！</p><p>　　假设<span class="math inline">\(m=3\)</span>，原始数组为<spanclass="math inline">\(a[1..n]\)</span>，对应的前缀和数组为<spanclass="math inline">\(s[1..n]\)</span>，<spanclass="math inline">\(dpmax[i]\)</span>表示"<strong>在选定<spanclass="math inline">\(a[i]\)</span>的前提下，子段内所有数的最大和值</strong>"，且满足子段宽度<spanclass="math inline">\(\geq m\)</span>，而写法"<spanclass="math inline">\(a[3..5]\)</span>"表示"<spanclass="math inline">\(a[3]+a[4]+a[5]\)</span>"，则有 $$ <spanclass="math display">\[\begin{align}dpmax[1]&amp;=max(\ a[1..1]\ )\qquad(区间宽度均不够3，无解)\tag{1}  \\\\dpmax[2]&amp;=max(\ a[1..2], a[2..2]\ )\qquad(区间宽度仍均不够3，无解)\tag{1}  \\\\dpmax[3]&amp;=max(\ \ a[1..3]　\ \ )\qquad(只有[1..3]这个区间满足:宽度\geq 3)\\&amp;=max(\ s[3]-s[0]\ ) \\&amp;=s3-min(\ s[0]\ ) \tag{3}\\\\dpmax[4]&amp;=max(\ \ a[1..4],\ \ \qquad\quad  a[2..4]\quad ) \qquad(有[1..4]和[2..4]这２个区间满足：宽度\geq 3)\\&amp;=max(\ s[4]-s[0],\ \quad s[4]-s[1]\ ) \\&amp;=s[4]-min(\ s[0],\qquad\ s[1]\qquad\ )\tag{4}\\\\dpmax[5]&amp;=max(\ \ a[1..5],\ \ \qquad\quad  a[2..5],\ \ \qquad \quada[3..5]\ \ )  \\&amp;=max(\ s[5]-s[0],\ \quad s[5]-s[1],\ \quad s[5]-s[2]\ ) \\&amp;=s[5]-min(\ s[0],\quad \qquad s[1],\ \qquad\qquad s[2]\quad\  )\tag{5}\\\\dpmax[6]&amp;=max(\ \ a[1..6],\ \ \qquad\quad  a[2..6],\ \ \qquad \quada[3..6]\ \ ,\ \ \quad \quad a[4..6]\ \ )  \\&amp;=max(\ s[6]-s[0],\ \quad s[6]-s[1],\ \quad s[6]-s[2]\ ,\ \quads[6]-s[3]\ ) \\&amp;=s[6]-min(\ s[0],\quad \qquad s[1],\ \qquad\qquad s[2],\\qquad\qquad s[3]\quad) \tag{6}\\\\\end{align}\]</span> <span class="math display">\[则有一般性公式推导（注：从$\ i-m+1\ $到$\ i\$，一共有$m$个数；从$1$到$i-m+1$，或者从$0$到$i-m$，都是有$i-m+1$个数）如下：\]</span> <span class="math display">\[\begin{align}dpmax[i]&amp;=max(\ \ a[1..i],\ \ \qquad\quad  a[2..i],\quad\ \ ......\,\ \qquad a[i-m..i],\ \qquad\ \  a[i-m+1..i]\ )  \\&amp;=max(\ s[i]-s[0],\ \quad s[i]-s[1],\quad ......\ ,\quads[i]-s[i-m-1],\quad s[i]-s[i-m]\ \ ) \\&amp;=s[i]-\textcolor[RGB]{255,0,0}{min(\ s[0],\qquads[1]\qquad,\  ......\ ,\qquad \quad s[i-m-1],\qquad s[i-m]\ \qquad\ )}\qquad(i \in [m..n])\tag{6}\\\\\end{align}\]</span> $$ 　　从上面的公式（６）可以看出：</p><p>１）我们把一个求最大值的问题，变成了一个求最小值的问题。</p><p>２）原本是求<spanclass="math inline">\(a[]\)</span>的“和值”，现在改成了求<spanclass="math inline">\(s[]\)</span>的最值。</p><p>３）在第<span class="math inline">\(i\)</span>轮，<spanclass="math inline">\(min\)</span>操作的操作数的个数随着<spanclass="math inline">\(i\)</span>的增大而增大，也就是说，本题型并不是固定滑窗求最值，却和“（一）不限宽度的区间的“最大的和值”问题”中的单调队列处理方法比较类似。所以不需出队（因为没有滑窗宽度限制），甚至也可以不用单调队列而直接用变量<spanclass="math inline">\(mmin\)</span>就可搞定。</p><h1 id="二.实战练习">二.实战练习</h1><h2 id="p1404-平均数">2.1 P1404 平均数</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P1404">P1404平均数</a></p><h3 id="分析">2.1.2 分析</h3><p>　　原题的题意是“给一个长度为 <spanclass="math inline">\(n\)</span>的数列，我们需要找出该数列的一个子串，使得子串的平均数最大化，并且子串长度<span class="math inline">\(\geq m\)</span>”，要求输出最大的平均数。</p><p>　　我们可以初步分析一下：</p><p>　　１）要找一个子串，也就是说，要找一个子序列，或者说子段。</p><p>　　２）要想使得子段均值最大，也就意味着并不是子段越宽越好或者越窄越好。假设当前所选子段的均值为５，而新加入的数值为<spanclass="math inline">\(8&gt;5\)</span>，则势必会拉高均值，这是有益的；但如果新加入的数值为<spanclass="math inline">\(2&lt;5\)</span>，则势必会拉低均值，是有害的。但有害的数据并不意味着就不能选，万一在２后面的下一个数是１００呢？所以，这并不是一个简单的贪心策略能搞定的，多半会和暴力枚举所涉及的算法有关。目前已经学过的暴力枚举的算法，除了简单模拟之外，有<spanclass="math inline">\(dfs\)</span>、<spanclass="math inline">\(dp\)</span>和二分答案。<spanclass="math inline">\(dfs\)</span>复杂度太高，基本上放弃。</p><p>　　３）要求子段长度<span class="math inline">\(\geqm\)</span>，这个条件如何利用呢？这个感觉和题型H：“借助单调队列来求子段宽度<spanclass="math inline">\(\geqm\)</span>的最大的和值”很相似啊。但题型H是求和，而当前题型是求平均数，而且还要求最大的平均数。这里需要一个外力点拨。我们可以把原始数组元素都减去一个假定的均值<spanclass="math inline">\(avg\)</span>，然后对数组再来做题型H，这样就解决了“子段长度<spanclass="math inline">\(\geq m\)</span>”的问题。若求出的最大和值<spanclass="math inline">\(&gt;0\)</span>，说明<spanclass="math inline">\(avg\)</span>太小了；若最大的和值<spanclass="math inline">\(&lt;0\)</span>，说明<spanclass="math inline">\(avg\)</span>太大了。这听上去是不是很像“二分答案？的确是的。至此，已经完全分析清楚了。</p><p>　　例如：对于<spanclass="math inline">\(a[10]=\{2,5,7,9,6,1,6,7,4,1\},m=3\)</span>，假设<spanclass="math inline">\(avg=5\)</span>，则<spanclass="math inline">\(a_1^*[10]=\{-3,0,2,4,1,-4,1,2,-1,-4\}\)</span>，对<spanclass="math inline">\(a_1^*[]\)</span>求子段宽度<spanclass="math inline">\(\geq 3\)</span>的最大子段和为<spanclass="math inline">\(2+4+1=7\)</span>，这意味着什么呢？这说明这三个数对应的<spanclass="math inline">\(7,9,6\)</span>原数的真实均值是大于当前的<spanclass="math inline">\(avg=5\)</span>的，换句话说，当前的<spanclass="math inline">\(avg\)</span>太小了，可以再大一点。</p><p>　　二分答案的代码模板就不多说了，若不清楚请复习本站帖"二分查找和二分答案.md"，点击<a href="#jump1"><font color="red">这里</font></a>。注意对check(x)函数的把握。</p><p>　　需要注意的是，本题并不是标准的二分答案，因为题目要求输出的是二分后的结果砍掉末尾后的精确值，而不是四舍五入后的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++">输入样例１：<br><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span><br>正确输出：<br><span class="hljs-number">5000</span><br>错误输出：<br><span class="hljs-number">4999</span><br><br>输入样例２：<br><span class="hljs-number">10</span> <span class="hljs-number">10</span><br><span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">10</span> <span class="hljs-number">3</span> <span class="hljs-number">8</span> <span class="hljs-number">5</span> <span class="hljs-number">9</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><br>正确输出：<br><span class="hljs-number">5200</span><br>错误输出：<br><span class="hljs-number">5199</span>    <br></code></pre></td></tr></table></figure><p>　　鉴于上面的问题，所以需要把输出改为打印<spanclass="math inline">\(\ ri\ \)</span>端值就可以了。</p><h3 id="ac代码">2.1.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> jd=<span class="hljs-number">1e-7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> a[maxn],sum[maxn],le,ri,mid;<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)  sum[i]=sum[i<span class="hljs-number">-1</span>]+a[i]-x;<br><span class="hljs-type">double</span> maxsum=<span class="hljs-number">-1e9</span>, mmin=<span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m; i&lt;=n; i++) &#123;<br>mmin= <span class="hljs-built_in">min</span>(mmin, sum[i-m]);<br>maxsum=<span class="hljs-built_in">max</span>(maxsum,sum[i]-mmin);<br>&#125;<br><span class="hljs-keyword">return</span> (maxsum&gt;=<span class="hljs-number">0</span>);  <span class="hljs-comment">// 若平均化后的子段和&gt;0，则说明该x太小 </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;a[i]);<br>ri=<span class="hljs-built_in">max</span>(ri,a[i]);<br>&#125;<br>le=<span class="hljs-number">0</span>-jd;ri=ri+jd;<br><span class="hljs-keyword">while</span>( le+jd &lt; ri ) &#123;<br>mid =(ri+le) / <span class="hljs-number">2</span>;   <br><span class="hljs-keyword">if</span>( <span class="hljs-built_in">check</span>(mid) )<br>le=mid;    <span class="hljs-comment">// 既然mid太小，就砍掉左半段 </span><br><span class="hljs-keyword">else</span><br>ri=mid;<br>&#125;<br><span class="hljs-comment">//printf(&quot;le=%lf, ri=%lf\n&quot;, le, ri);</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">int</span>(ri*<span class="hljs-number">1000</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">10 10</span><br><span class="hljs-comment">6 4 2 10 3 8 5 9 4 1</span><br><span class="hljs-comment">5200</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2 2</span><br><span class="hljs-comment">5 5</span><br><span class="hljs-comment">5000</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">3 3</span><br><span class="hljs-comment">5 5 5</span><br><span class="hljs-comment">5000</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线性结构编程技巧 </category>
          
          <category> 最大子段和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（一）不限宽度的区间的“最大的和值”问题</title>
      <link href="/2024/12/24/%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E5%BA%A6%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"/>
      <url>/2024/12/24/%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E5%BA%A6%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>　　本帖是“最大子段和”系列问题的第1帖，主要研究不限宽度的区间的“最大的和值”和“最大的积值”这两个问题。</p><h1 id="一不限宽度的区间子段的最大的和值"><spanid="jump2">一、不限宽度的区间（子段）的"最大的<font color="red">和</font>值"</span></h1><h2 id="原题链接">1.1 原题链接</h2><p>　　<a href="https://www.luogu.com.cn/problem/P1115">P1115最大子段和</a>　／　<ahref="https://leetcode.cn/problems/maximum-subarray/description/">53最大子数组和</a></p><h2 id="分析">1.2 分析</h2><p>　　如果我们用 <span class="math inline">\(dp[i]\)</span> 表示前 i个元素中选择的子段内所有数的最大和值，<spanclass="math inline">\(a[]\)</span>表示题目上对应的数组，那么所求目标即为<spanclass="math inline">\(dp[n]\)</span>。但我们会发现，要根据<spanclass="math inline">\(dp[i-1]\)</span>等来递推出<spanclass="math inline">\(dp[i]\)</span>是很困难的，因为我们不确定<spanclass="math inline">\(a[i-1]\)</span>在<spanclass="math inline">\(dp[i-1]\)</span>的方案中是否被选中。如果<spanclass="math inline">\(a[i-1]\)</span>曾被选中，那现在去计算<spanclass="math inline">\(dp[i]\)</span>就比较简单了，对于<spanclass="math inline">\(a[i]\)</span>无非有“选<spanclass="math inline">\(a[i]\)</span>”或“不选<spanclass="math inline">\(a[i]\)</span>”这两种方案，所以有<spanclass="math inline">\(dp[i]=max(dp[i-1]+a[i],\ \dp[i-1])\)</span>。但如果<spanclass="math inline">\(a[i-1]\)</span>不曾被选中，那根据本题对“子段”的“下标连续性”的要求，就很难去推导了。</p><p>　　此路不通。不通的原因不是因为不该用<spanclass="math inline">\(dp\)</span>，而是因为<spanclass="math inline">\(dp[i]\)</span>的定义不对，因为违背了<spanclass="math inline">\(dp\)</span>的定义并不满足「最优子结构」(即“问题的最优解包含子问题的最优解”。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解)。<strong>而在当前<spanclass="math inline">\(dp[]\)</span>的这种定义下，当前位置的最优解未必是由前一个位置的最优解转移得到的</strong>。</p><p>　　正确的定义应该是用 <span class="math inline">\(dp[i]\)</span>表示"<strong>在选定<span class="math inline">\(a[i]\)</span>的前提下，前i个元素中选择的子段内所有数的最大和值</strong>"。之所以正确，是因为在这种定义下，强制要求选定<spanclass="math inline">\(a[i]\)</span>后，剔除掉了上面段落中所提到的“如果<spanclass="math inline">\(a[i-1]\)</span>不曾被选中”的情况，使得<spanclass="math inline">\(dp\)</span>的定义满足了“最优子结构”的要求。只不过在这样的定义下，所求目标不再是<spanclass="math inline">\(dp[n]\)</span>，而变成了<spanclass="math inline">\(max(dp[1..n])\)</span>。</p><p>　　这个题型，<spanclass="math inline">\(O(n)\)</span>的做法有两种。</p><p>　　１）<span class="math inline">\(dp[i]=max(\ dp[i-1],\ \ 0)+a[i]\)\qquad(i \in[1..n])\)</span></p><p>　　２）<span class="math inline">\(dp[i]=sum[i]-min(\ sum[1..i-1]\)\qquad(\ i \in[1..n]\ )\)</span></p><p>　　第１种方法，在本站《前缀和　二维前缀和》有非常详细的讲述，请点击<a href="#jump1"><font color="red">这里</font></a>直达讲述位置，内含视频教学和AC代码，此处不再提。下面重点讲解第２种方法的得来。　</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic/img/%E4%B8%8D%E9%99%90%E5%AE%BD%E5%BA%A6%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%981.png" alt="image-20241227150534177" style="zoom:150%;" /></p><p>　　在上图中，我们以<spanclass="math inline">\(i=3\)</span>为例来进行讲解。我们知道<spanclass="math inline">\(dp[i]\)</span>的含义是“在选定<spanclass="math inline">\(a[i]\)</span>的前提下，前<spanclass="math inline">\(i\)</span>个元素中选择的子段内所有数的最大和值”，且用<spanclass="math inline">\(a[1..3]\)</span>表示<spanclass="math inline">\(a[1]+a[2]+a[3]\)</span>的值，则我们可以把<spanclass="math inline">\(dp[1]、dp[2]、dp[3]、dp[4]\)</span>的定义演绎成下面的公式：<span class="math display">\[\begin{align}dp[1]&amp;=max(\ a[1..1]\ ) \tag{1} \\dp[2]&amp;=max(\ a[1..2],\ \ a[2..2]\ ) \tag{2} \\dp[3]&amp;=max(\ a[1..3],\ \ a[2..3],\ \ a[3..3]\ ) \tag{3} \\dp[4]&amp;=max(\ a[1..4],\ \ a[2..4],\ \ a[3..4],\ \ a[4..4]\ ) \tag{4}\\\end{align}\]</span> 　　由（4）推出更加普遍的公式如下： <spanclass="math display">\[dp[i]=max(\ a[1..i],\ \ a[2..i],\ \ ......,\ \ a[i-1..i],\ \ a[i..i]\ )\tag{5}\]</span> 　　假设用<span class="math inline">\(sum[i]\)</span>表示<spanclass="math inline">\(a[1..i]\)</span>，即<spanclass="math inline">\(sum[i]=a[1]+a[2]+...+a[i]\)</span>。用前缀和思想，可以把（５）式进一步演变如下：<span class="math display">\[\begin{align}dp[i]&amp;=max(\\qquad\textcolor[RGB]{50,200,0}{a[1..i]},\qquad\qquad\quad\textcolor[RGB]{0,150,255}{a[2..i]},\ \ \ \quad\quad  ......,\ \\qquad\textcolor[RGB]{255,0,0}{a[i-1..i]},\ \\qquad\qquad\quad\textcolor[RGB]{255,225,0}{a[i..i]}\qquad\qquad)  \tag{}\\&amp;=max(\ \textcolor[RGB]{50,200,0}{sum[i]-sum[0]},\ \\textcolor[RGB]{0,150,255}{sum[i]-sum[1]},\ \ ......\ \ ,\ \\textcolor[RGB]{255,0,0}{sum[i]-sum[i-2]},\ \\textcolor[RGB]{255,225,0}{sum[i]-sum[i-1]}\ ) \tag{}\\&amp;=sum[i]-min(\ sum[0],\ sum[1],\ sum[2],\ ......\ ,\ sum[i-1]\ )\tag{6}\end{align}\]</span>　　从公式（６）中可以看到，我们需要在对应的前缀和数组sum[]中去求多个前缀和的最小值。在本题中因为没有限制子段的区间宽度，所以公式（６）比较简单。但如果要求区间的宽度受限制（<spanclass="math inline">\(==m、\leq m、\geqm\)</span>）等，公式（６）会变得稍微复杂一点，就需要用到单调队列来解决了。要实现方法２中的公式（６），可以有两种版本。</p><p>版本１）：用单变量<spanclass="math inline">\(mmin\)</span>来保存<spanclass="math inline">\(sum[1..i-1]\)</span>中各和值的最小值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> mmin=INT_MAX;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123;<br>    mmin=<span class="hljs-built_in">min</span>(mmin, sum[i<span class="hljs-number">-1</span>]); <br>    dp[i]=sum[i]-mmin;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　为了给后续帖展示复杂区间宽度限制，此处也给同学们展示做法２的过程。</p><p><span id="jump1">版本２）</span>：用单调队列来处理<spanclass="math inline">\(sum[1..i-1]\)</span>中各和值的最小值。需要注意的是，此处是求滑窗区间<spanclass="math inline">\(sum[0..i-1]\)</span>的最小值，基础数组是<spanclass="math inline">\(sum[]\)</span>；而且在第<spanclass="math inline">\(i\)</span>轮处理的是数据是<spanclass="math inline">\(sum[i-1]\)</span>，进队的下标应该是<spanclass="math inline">\(i-1\)</span>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 使用单调队列求sum[0..i-1]区间中的最小值，基础数组是sum[]哦！在第i轮处理的是sum[i-1]！</span><br><span class="hljs-keyword">while</span> (h&lt;=t &amp;&amp; sum[i<span class="hljs-number">-1</span>]&lt;=sum[dq[t]] ) t--;<br>dq[++t]=i<span class="hljs-number">-1</span>;<br><span class="hljs-comment">// 因为不限滑窗宽度，根本就没有滑窗，所以不用考虑队头元素这端被挤出滑窗而出队的情况了</span><br>mmin=sum[dq[h]];  <span class="hljs-comment">//使用“滑窗”内的最小值，即min(sum[0],sum[1],sum[2],sum[3],......,sum[i-1])</span><br></code></pre></td></tr></table></figure><h2 id="ac代码">1.3 AC代码</h2><p>　　用方法１（贪心策略）的代码就不在这里展示了，此处展示的是方法２的两个版本代码。</p><h3 id="不用单调队列">1.3.1 不用单调队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法2，版本1，不用单调队列</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">方法2：dp[i]= sum[i] - min(sum[0],sum[1],sum[2],......,sum[i-1])</span><br><span class="hljs-comment">    版本1： 用 单变量mmin来保存 sum[1..i-1] 中各和值的最小值。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> dp[<span class="hljs-number">200001</span>];   <br><span class="hljs-type">int</span> sum[<span class="hljs-number">200001</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> i,n,a,mmin=INT_MAX, ans=INT_MIN;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a);<br>sum[i]=sum[i<span class="hljs-number">-1</span>]+a;<br>mmin=<span class="hljs-built_in">min</span>(mmin, sum[i<span class="hljs-number">-1</span>]);<br>dp[i]=sum[i]-mmin;<br>ans= <span class="hljs-built_in">max</span>(ans, dpmax[i]);  <span class="hljs-comment">// 可以不定义dpmax[]：ans= max(ans, sum[i]-mmin); </span><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">//// 如果数据全为负数，也应该得到-20，而不是-100000</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">-200 -20 -150 -100 -120</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="用单调队列">1.3.2 用单调队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法2，版本2，用单调队列 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">方法2：dp[i]= sum[i] - min(sum[0],sum[1],sum[2],......,sum[i-1])</span><br><span class="hljs-comment">    版本2： 用 单调队列来保存 sum[1..i-1] 中各和值的最小值。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> dq[<span class="hljs-number">200001</span>];   <br><span class="hljs-type">int</span> sum[<span class="hljs-number">200001</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> i,n,a,mmin=INT_MAX, ans=INT_MIN;<br>cin&gt;&gt;n;<br><span class="hljs-type">int</span> h=<span class="hljs-number">1</span>, t=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a);<br>sum[i]=sum[i<span class="hljs-number">-1</span>]+a;<br><span class="hljs-comment">// 使用单调队列求sum[0..i-1]中的区间最小值，基础数组是sum[]哦！在第i轮处理的是sum[i-1]！ </span><br><span class="hljs-keyword">while</span> (h&lt;=t &amp;&amp; sum[i<span class="hljs-number">-1</span>]&lt;=sum[dq[t]] ) t--;<br>dq[++t]=i<span class="hljs-number">-1</span>;<br><span class="hljs-comment">// 因为不限滑窗宽度，根本就没有滑窗，所以不用考虑队头元素这端被挤出滑窗而出队的情况了 </span><br>mmin=sum[dq[h]];  <span class="hljs-comment">// 使用单调队列方法的成果，即sum[dq[h]]，</span><br>ans= <span class="hljs-built_in">max</span>(ans, sum[i]-mmin);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">//// 如果数据全为负数，也应该得到-20，而不是-100000</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">-200 -20 -150 -100 -120</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1id="二不限宽度的区间子段的最大的积值">二、不限宽度的区间（子段）的“最大的<font color="red">积</font>值”</h1><h2 id="原题链接-1">2.1 原题链接</h2><p>　　<ahref="https://leetcode.cn/problems/maximum-product-subarray/description/">１５２　乘积最大子数组（leetcode）</a></p><h2 id="分析-1">2.2 分析</h2><p>　　如果我们用 <span class="math inline">\(dpmax[i]\)</span> 表示以第i 个元素结尾的子段内所有数的最大乘积值，<spanclass="math inline">\(a[]\)</span>表示题目上对应的数组 <spanclass="math inline">\(nums[]\)</span>，那么根据“<ahref="https://www.luogu.com.cn/problem/P1115">P1115最大子段和</a>”的经验，我们很容易推导出这样的状态转移方程： <spanclass="math display">\[dpmax[i]=max(\ a[i],\quad dpmax[i-1]*a[i]\ )\qquad(i \in[1..n])  \tag{1}\]</span> 　　它表示以第 i 个元素结尾的乘积最大子数组的乘积，可以考虑<span class="math inline">\(a[i]\)</span> 加入前面的 <spanclass="math inline">\(dpmax[i-1]\)</span>对应的一段，或者单独成为一段，且在两种情况下取最大值。最后把 <spanclass="math inline">\(max(dpmax[1..n])\)</span>作为答案。</p><p>　　可是在这里，这样做是错误的（需要孩子们认真仔细地在草稿纸上枚举多个样例，就必然能发现这一点）。为什么呢？</p><p>　　因为这里的定义并不满足「最优子结构」(即“问题的最优解包含子问题的最优解”。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解)。具体地讲，如果<span class="math inline">\(a[]=\{5,\ 6,\ −3,\ 4,\−3\}\)</span>，那么此时<spanclass="math inline">\(dpmax[]\)</span>对应的序列是 <spanclass="math inline">\(\{\ 5,\ 30,\ −3,\ 4,\ −3\\}\)</span>，按照前面的算法我们得到的答案为 30（即<spanclass="math inline">\(5\times6\)</span>），而实际上答案应该是全体数字的乘积。我们来想一想问题出在哪里呢？问题出在最后一个−3 所对应的<span class="math inline">\(dpmax[5]\)</span>的值既不是−3，也不是 <span class="math inline">\(4×(−3)\)</span>，而是 <spanclass="math inline">\(5×6×(−3)×4×(−3)\)</span>。所以我们得到了一个结论：<strong>在这种定义下，当前位置的最优解未必是由前一个或前几个位置的最优解转移得到</strong>。</p><p>　　我们可以根据正负性进行分类讨论。</p><p>　　１）如果<span class="math inline">\(a[i]&lt;0\)</span>，那么我们希望<spanclass="math inline">\(dpmax[i-1]&lt;0\)</span>，这样就可以负负得正，并且我们希望<spanclass="math inline">\(dpmax[i-1]\)</span>尽可能"负得更多"(即尽可能小)。</p><p>　　２）如果<spanclass="math inline">\(a[i]&gt;0\)</span>，我们更希望<spanclass="math inline">\(dpmax[i-1]&gt;0\)</span>，并且希望<spanclass="math inline">\(dpmax[i-1]\)</span>尽可能地大。</p><p>　　于是这里我们可以再维护一个 <spanclass="math inline">\(dpmin[i]\)</span>，它表示以第 i个元素结尾的乘积最小子数组的乘积，那么我们可以得到这样的动态规划转移方程：<span class="math display">\[\begin{align}dpmax[i]&amp;=max(dpmax[i-1]*a[i],\quad dpmin[i-1]*a[i],\quad a[i])\qquad(i \in[2..n]) \tag{2}\\dpmin[i]&amp;=min(dpmax[i-1]*a[i],\quad dpmin[i-1]*a[i],\quad a[i])\qquad(i \in[2..n])\tag{3}\end{align}\]</span> 　　特例值很好分析，<spanclass="math inline">\(dpmax[1]=dpmin[1]=a[1];\)</span></p><p>　　仔细分析公式（２）和（３），可以发现，<spanclass="math inline">\(dpmax[]\)</span>和<spanclass="math inline">\(dpmin[]\)</span>不必开数组，只需要用两个变量<spanclass="math inline">\(dpmax\)</span>和<spanclass="math inline">\(dpmin\)</span>就能搞定了。</p><h2 id="ac代码-1">2.3 AC代码</h2><h3 id="数组版本">2.3.1 数组版本</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 版本2： dp数组版本 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//  提交内容如下 </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector &lt;<span class="hljs-type">long</span>&gt; <span class="hljs-built_in">maxF</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>()), <span class="hljs-built_in">minF</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            maxF[i] = <span class="hljs-built_in">max</span>(maxF[i - <span class="hljs-number">1</span>] * nums[i], <span class="hljs-built_in">max</span>((<span class="hljs-type">long</span>)nums[i], minF[i - <span class="hljs-number">1</span>] * nums[i]));<br>            minF[i] = <span class="hljs-built_in">min</span>(minF[i - <span class="hljs-number">1</span>] * nums[i], <span class="hljs-built_in">min</span>((<span class="hljs-type">long</span>)nums[i], maxF[i - <span class="hljs-number">1</span>] * nums[i]));<br>            <span class="hljs-keyword">if</span>(minF[i]&lt;INT_MIN) &#123;<br>                minF[i]=nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-built_in">max_element</span>(maxF.<span class="hljs-built_in">begin</span>(), maxF.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//提交内容如上</span><br> <br>vector&lt;<span class="hljs-type">int</span>&gt; nums=&#123;<span class="hljs-number">-4</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">-2</span>&#125;; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br>Solution s1;<br>cout &lt;&lt;s1.<span class="hljs-built_in">maxProduct</span>(nums);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">a[i]:-4     -3     -2</span><br><span class="hljs-comment">dpmax[i]    -4     12      6</span><br><span class="hljs-comment">dpmin[i]-4     -3     -24</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">ans=max(-4,12,6) = 12</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="变量版本">2.3.2 变量版本</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 版本1： dp变量版本 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//  提交内容如下 </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> dpmax, dpmin, dpmax11, dpmin11, ans;<br>        dpmax11=dpmin11=ans=nums[<span class="hljs-number">0</span>];<br><span class="hljs-comment">//        printf(&quot;%d %d %d\n&quot;, dpmax11, dpmin11, ans);</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            dpmax = <span class="hljs-built_in">max</span>(dpmax11*nums[i], <span class="hljs-built_in">max</span>((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)nums[i], dpmin11*nums[i]));<br>            dpmin = <span class="hljs-built_in">min</span>(dpmax11*nums[i], <span class="hljs-built_in">min</span>((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)nums[i], dpmin11*nums[i]));<br>            ans=<span class="hljs-built_in">max</span>(dpmax,<span class="hljs-built_in">max</span>(dpmin,ans));<br><span class="hljs-comment">//            printf(&quot;%d %d %d\n&quot;, dpmax, dpmin, ans);</span><br>            dpmax11=dpmax;<br>            dpmin11=dpmin;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//提交内容如上</span><br> <br>vector&lt;<span class="hljs-type">int</span>&gt; nums=&#123;<span class="hljs-number">-4</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">-2</span>&#125;; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br>Solution s1;<br>cout &lt;&lt;s1.<span class="hljs-built_in">maxProduct</span>(nums);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">a[i]:-4     -3     -2</span><br><span class="hljs-comment">dpmax[i]    -4     12      6</span><br><span class="hljs-comment">dpmin[i]-4     -3     -24</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">ans=max(-4,12,6) = 12</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线性结构编程技巧 </category>
          
          <category> 最大子段和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2020/03/13/hello/"/>
      <url>/2020/03/13/hello/</url>
      
        <content type="html"><![CDATA[<h1 id="是">是</h1><p><span class="math display">\[\lim_{h \rightarrow 0 } \frac{f(x+h)-f(x)}{h}\]</span></p><h2 id="一.-归并排序">一. 归并排序</h2><p>来一个分段函数</p><p>点击<a href="/2020/03/13/hello/#jump1">这里</a>可以到站内文章"hello.md"的锚点jump1，在下面的1.2.3。<span class="math display">\[f(n)=\begin{cases}1 &amp; (n=1) \\1 &amp; (n=2) \\f(n-1)+f(n-2) &amp; (n&gt;=3)\end{cases}\]</span></p><p><span class="math display">\[y=\begin{cases}0 &amp; z&lt;0 \\0.5 &amp; z=0 \\1 &amp; z&gt;0\end{cases}\]</span> <span class="math display">\[\begin{cases}s_{\Delta}=\sum_{i=1}^n(x_i^2+y_i^2)+\frac i{20} \\7x - 2y + 4z=C_n^m+10^{20} \\s_{\Delta}=\sqrt[]{x+\sqrt[3]{1+x}}\\\lfloor x \rfloor+\lceil \log_2n \rceil\end{cases}\]</span></p><p><span class="math display">\[s_{\Delta}=\sum_{i=1}^n(x_i^2+y_i^2)+\frac i{20}\label{a}\\7x - 2y + 4z=C_n^m+10^{20} \\s_{\Delta}=\sqrt[]{x+\sqrt[3]{1+x}}\\\lfloor x \rfloor+\lceil \log_2n \rceil\]</span></p><p><span class="math inline">\(\log_2{log_2n}\)</span></p><p><span class="math display">\[\begin{align}\label{eq2}u_{i1}(t)&amp;=-b_{i}(t),f(q_{i}),\u_{i2}(t)&amp;=\sum_{j\in \mathcal{N}{i}}c{ij}h(p_{j}(t)-p_{i}(t)),\quadi\in\bar{N}\end{align}\]</span></p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20231228124457143.png"alt="image-20231228124457143" /><figcaption aria-hidden="true">image-20231228124457143</figcaption></figure><p>$ dp[i][j]=dp[i-1][j]+data[i][j-1](i,j) $</p><p>$ dp_i$</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic/img/image-20241119161909303.png" alt="image-20241119161909303" style="zoom:67%;" /></p><p>dp[i]=data[i] + dp[i-1]</p><p><span class="math display">\[\begin{array}{|r|l|c|}\hline 20&amp;*&amp;?\\    \hline \leftarrow&amp;5&amp;3\\    \hline 6&amp;1&amp;8\\    \hline\end{array}\]</span></p><p><span class="math display">\[\begin{array}{}           &amp;0&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7\\    \hlinec&amp;\gets&amp;\Leftrightarrow&amp;\Longleftrightarrow&amp;\iff&amp;*\\    \hline c&amp;\to&amp;\Rightarrow&amp;3&amp;20000&amp;*\\    \hline maxc&amp;60000&amp;\Leftarrow&amp;8&amp;a_i\\    \hline\end{array}\]</span></p><p><span class="math display">\[\begin{array}{cc|c}           努力&amp;你好&amp;再见\\    \hline 0&amp;0&amp;0\\           0&amp;1&amp;1\\           1&amp;0&amp;1\\           1&amp;1&amp;1\\\end{array}\]</span></p><p>这里我打算嵌入一张gif图片试试看效果： <imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/a511f48b5a6455b8dfe0a256ab2eb466.gif"alt="a511f48b5a6455b8dfe0a256ab2eb466" /></p><p>AC代码参考如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> <span class="hljs-comment">// 我刚试了一下Ctrl + Shift + K</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> distance;<br><span class="hljs-type">double</span> s1, s2;<br>    <br>cin &gt;&gt;distance;<br>s1= <span class="hljs-number">27</span> +<span class="hljs-number">23</span> + distance/<span class="hljs-number">3.0</span>;<br>s2= distance / <span class="hljs-number">1.2</span>;<br><span class="hljs-keyword">if</span> (s1&lt;s2)<br>cout&lt;&lt;<span class="hljs-string">&quot;Bike&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s2 &lt; s1)<br>cout&lt;&lt;<span class="hljs-string">&quot;Walk&quot;</span>;<br><span class="hljs-keyword">else</span><br>cout&lt;&lt;<span class="hljs-string">&quot;All&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="本标题暗含了一个锚点名叫jump1">1.2.3 <spanid="jump1">本标题暗含了一个锚点名叫jump1</span></h2><p>或者版本二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">哈希查找的模板题 </span><br><span class="hljs-comment">2123 7044 013 013 7957 ll是一个1e18的超大质数，末尾有个ll，表示该数的长整型</span><br><span class="hljs-comment">不好意思，怕是要背下来…… </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span> <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><br>ull a[<span class="hljs-number">10010</span>];<br><span class="hljs-type">char</span> s[<span class="hljs-number">10010</span>];<br><span class="hljs-type">int</span> n,ans=<span class="hljs-number">1</span>;<br><span class="hljs-comment">//int prime=233317;</span><br><span class="hljs-comment">//ull mod=212370440130137957ll;</span><br><br><span class="hljs-function">ull <span class="hljs-title">BKDRHash</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span></span><br><span class="hljs-function"></span>&#123;<br>    ull seed = <span class="hljs-number">31</span>;    <span class="hljs-comment">// 31 131 1313 13131 131313 etc.. 37</span><br>    ull key = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (*str)<br>        key = (key * seed + (ull)(*str++)) % <span class="hljs-number">212370440130137957ll</span> + <span class="hljs-number">233317</span>;<br> <br><span class="hljs-keyword">return</span> key &amp; <span class="hljs-number">0x7fffffff</span>;  <span class="hljs-comment">// 舍弃符号位，稳妥起见。不加也能ac本题 </span><br>&#125;<br><span class="hljs-comment">//ull hashe(char s[]) &#123;</span><br><span class="hljs-comment">//int len=strlen(s);</span><br><span class="hljs-comment">//ull base=131;</span><br><span class="hljs-comment">//ull ans=0;</span><br><span class="hljs-comment">//for (int i=0; i&lt;len; i++)</span><br><span class="hljs-comment">//ans=(ans*base+(ull)s[i])%mod+prime;</span><br><span class="hljs-comment">//return ans;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<br>a[i]=<span class="hljs-built_in">BKDRHash</span>(s);<br>&#125;<br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++) &#123;<br><span class="hljs-keyword">if</span>(a[i]!=a[i+<span class="hljs-number">1</span>])<br>ans++;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,ans);<br>&#125;<br></code></pre></td></tr></table></figure><p>矩阵：</p><p><span class="math display">\[\begin{pmatrix}  1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n \\  1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \\  \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\  1 &amp; a_m &amp; a_m^2 &amp; \cdots &amp; a_m^n \\  \end{pmatrix}\]</span></p><script>    // add script tag and code at the end of your post    alert("Hello World");</script>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
