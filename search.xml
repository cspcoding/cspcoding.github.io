<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>完全背包问题</title>
      <link href="/2024/05/11/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2024/05/11/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学　　</h1><h2 id="模型引入">1.1 模型引入</h2><p>　　总约束量为YS1，n<font color="red"><strong>种</strong></font>可待选择的物品需要装入，每种物品有无限个，它们都有各自的重量和价值，你需要从中选择合适的组合来使得总约束量内的物品总价值最大（<strong>每种物品可以装0个，也可以装任意多个；不需要刚好装满，允许不"刚好"装满</strong>）</p><p>　　上面这段就是完全背包最常见的题面。</p><h2 id="完全背包和普通01背包之间的关系">1.2完全背包和普通01背包之间的关系</h2><p>　　从上面的模型可以看到，普通01背包是“有n个物品”可选“0个或者1个”，而完全背包是“有n种物品，每种物品可选0个或者任意个”。也就是说，完全背包可以对一种物品选任意个。虽然理论上来说是任意个，但实际上个数肯定不能超过总约束量的约束，即不能超过YS1/ys1[i]个（否则背包撑爆了）。</p><p>　　那这种“可以选任意个数”该如何处理呢？我们需要先想想之前的普通01背包模型中选1个是如何处理的？我们先看看之前01背包的分析，并稍微换一下措辞：</p><p>　　对于第i种物品：</p><ul><li><p>1）如果背包的总容量j不足以容纳第i种物品的1个，此时只能被迫放弃第i种物品，价值没有一点增加。所以有：<span class="math display">\[dp[i][j]=dp[i-1][j] \tag{1}\]</span></p></li><li><p>2）如果背包的总容量j能够容纳第i种物品的1个，此时可以有2种选择：“装0个”、“装1个”第i种物品。此时需要对这2种决策进行比较判断，选出价值最大的决策。</p><ul><li><p>a)如果<strong>装0个</strong>第i种物品，则有:</p><p><span class="math display">\[dp[i][j]=dp[i-1][j] \tag{2}\]</span>　　既然决定对第i种物品一个都不装，那么总价值不会增加，仍然和“前i-1种物品对于总容量j的策略”是一致的。</p></li><li><p>b)如果<strong>装1个</strong>第i种物品，则有:</p><p><span class="math display">\[dp[i][j]=dp[i-1][j-ys1[i]]+value[i] \tag{3}\]</span></p></li></ul></li><li><p>综上情况1）和情况2），则有状态转移方程为：</p></li></ul><p><span class="math display">\[dp[i][j]=\begin{cases}dp[i-1][j] &amp; (j&lt;ys1[i]) \\max(\ dp[i-1][j], \quad dp[i-1][j-ys1[i]]\ +\ value[i]\ ) &amp; (j\geqys1[i])\end{cases} \tag{4}\]</span></p><p>　　以上就是01背包的分析过程。当允许装同一种物品的多个时，我们发现，只需要把其中的第2）点分析稍微调整一下即可。调整后的内容如下：</p><ul><li><p>2）如果背包的总容量j能够容纳第i种物品的<strong>任意</strong>个，此时可以有<strong>多</strong>种选择：“装0个”、“装1个”<strong>、“装2个”、……“装j/ys1[i]个”</strong>第i种物品。此时需要对<strong>多</strong>种决策进行比较判断，选出价值最大的决策。维持a）和b）决策不变，并在后面加入其他决策，如下：</p><ul><li><p>c)如果<strong>装<font color="red">2</font>个</strong>第i种物品，此时可以把这2个第i种物品捆绑起来视为1个物品，其约束量为2*ys1[i]，其收益为2*value[i]，则有:</p><p><span class="math display">\[dp[i][j]=dp[i-1][j-2*ys1[i]]\ +\ 2*value[i] \tag{5}\]</span></p></li><li><p>d)如果<strong>装<font color="red">3</font>个</strong>第i种物品，此时可以把这3个第i种物品捆绑起来视为1个物品，其约束量为3*ys1[i]，其收益为3*value[i]，则有:</p><p><span class="math display">\[dp[i][j]=dp[i-1][j-3*ys1[i]]\ +\ 3*value[i] \tag{6}\]</span></p></li><li><p>……以此类推</p></li><li><p>如果<strong>装<spanclass="math inline">\(\textcolor{red}{\lfloor} j/ys1[i]\textcolor{red}{\rfloor}\quad(\lfloor  \ \rfloor表示向下取整)\)</span>个</strong>第i种物品，此时可以把这<spanclass="math inline">\(\lfloor j/ys1[i]\rfloor\)</span>个第i种物品捆绑起来视为1个物品，其约束量为<spanclass="math inline">\(\mathbf{ \textcolor{red}{\lfloor} j/ys1[i]\textcolor{red}{\rfloor}}\ *\ ys1[i]\)</span>，其收益为<spanclass="math inline">\(\mathbf{\lfloor j/ys1[i] \rfloor}\ *\value[i]\)</span>，则有:</p><p><span class="math display">\[dp[i][j]=dp[i-1]\textcolor[RGB]{0,225,0}[j-\textcolor[RGB]{225,0,0}\lfloorj/ys1[i]\textcolor[RGB]{225,0,0}\rfloor*ys1[i]\textcolor[RGB]{0,225,0}]\+\ \textcolor[RGB]{225,0,0}\lfloorj/ys1[i]\textcolor[RGB]{225,0,0}\rfloor*value[i] \tag{7}\]</span></p></li></ul><p>　　这里一共有<span class="math inline">\(\lfloor j/ys1[i]\rfloor+1\)</span>种决策（举个例子：整个背包总容量为20，当前要处理的总约束量j=10斤。对于第i种物品，ys1[i]=3斤，一共有<spanclass="math inline">\(\lfloor 10/3 \rfloor+1=4\\)</span>种决策，分别是“装0个第i种物品”、“装1个第i种物品”、“装2个第i种物品”、“装3个第i种物品”）。</p><p>　　因为dp[i][j]表示总容量为j时前i种物品能装入的最大价值，所以需要对这<spanclass="math inline">\(\lfloor j/ys1[i]\rfloor+1\)</span>​个决策的结果取其最大值。对于上述2种情况，多个决策（第1、2、3、5、6、7式）取最大值，数学公式整理如下：<span class="math display">\[dp[i][j]=\begin{cases}dp[i-1][j] &amp; (j&lt;ys1[i]) \\max(dp[i-1][j],\quaddp[i-1][j-ys1[i]]+value[i],\quad dp[i-1][j-2*ys1[i]]+2*value[i], \quaddp[i-1][j-3*ys1[i]]+3*value[i], \quad ......,dp[i-1]\textcolor[RGB]{0,225,0}[j-\textcolor[RGB]{225,0,0}\lfloorj/ys1[i]\textcolor[RGB]{225,0,0}\rfloor*ys1[i]\textcolor[RGB]{0,225,0}]+\textcolor[RGB]{225,0,0}\lfloorj/ys1[i]\textcolor[RGB]{225,0,0}\rfloor*value[i] \ &amp; (j\geq ys1[i]))\end{cases} \tag{8}\]</span></p><p>　　可以看到，完全背包实际上就是在01普通背包的基础上，对更多的决策取最大值而已。下面展示针对公式8的多种代码实现方法。</p></li></ul><h2 id="代码实现方法">1.3 代码实现方法</h2><h3 id="三重for-标准状态数组-正序逆序效率一般">1.3.1 三重for +标准状态数组 + 正序/逆序（效率一般）</h3><p>　　<strong>在标准状态数组和三重for的前提下</strong>，对于公式8不需做任何改动，直接照搬即可。实现代码如下：　　</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    //// 标准状态数组，三重for</span><br><span class="hljs-comment">    // 该代码尚未优化，不必硬背，只需对照着公式(8)来看即可</span><br><span class="hljs-comment">    for(int i=1; i&lt;=n; i++)        // 针对每1种物品</span><br><span class="hljs-comment">    for(int j=0; j&lt;=YS1; j++)&#123;   // 枚举填写背包总容量j，正序逆序均可，j=0也需要填写 </span><br><span class="hljs-comment">            if (j &lt; ys1[i])         </span><br><span class="hljs-comment">                dp[i][j]= dp[i-1][j];</span><br><span class="hljs-comment">            else&#123;</span><br><span class="hljs-comment">                dp[i][j]= dp[i-1][j];</span><br><span class="hljs-comment">                dp[i][j]= max(dp[i][j], dp[i-1][j-ys1[i]] + value[i]);</span><br><span class="hljs-comment">                dp[i][j]= max(dp[i][j], dp[i-1][j-2*ys1[i]] + 2*value[i]);</span><br><span class="hljs-comment">                dp[i][j]= max(dp[i][j], dp[i-1][j-3*ys1[i]] + 3*value[i]);</span><br><span class="hljs-comment">                ......</span><br><span class="hljs-comment">            &#125;  // end if</span><br><span class="hljs-comment">        &#125; // end for</span><br><span class="hljs-comment">*/</span><br><br>    <span class="hljs-comment">//// 对上面注释的代码进行优化后的代码如下：</span><br>    <span class="hljs-comment">//// 标准状态数组，三重for</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)        <span class="hljs-comment">// 针对每1种物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举填写背包总容量j，正序逆序均可，j=0也需要填写 </span><br>            dp[i][j]= dp[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">if</span> (j &gt;= ys1[i])<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=j/ys1[i]; k++) <br>                <span class="hljs-comment">//for (int k=1; k*ys1[i]&lt;=j; k++)  //这样写也是等效的 </span><br>                    dp[i][j]= <span class="hljs-built_in">max</span>(dp[i][j],  dp[i<span class="hljs-number">-1</span>][j-k*ys1[i]] + k*value[i] );<br>        &#125;<br></code></pre></td></tr></table></figure><p>　　这种实现方式，时间复杂度为<spanclass="math inline">\(O(n*YS1*k)\)</span>，空间复杂度为<spanclass="math inline">\(O(n*YS1)\)</span>。可以看到，不管是时间或是空间，该方法都是比较差的，无法应对n或者YS1较大的情况。但要求同学们还是要掌握该方法，因为它是后续多个改进版本的理论基石，有助于理解和掌握后续版本。</p><h3 id="三重for-滚动状态数组-逆序效率一般">1.3.2 三重for +<font color="red">滚动</font>状态数组 + 逆序（效率一般）</h3><p>　　<strong>在<font color="red">滚动</font>状态数组和三重for的前提下</strong>，需要对1.3.1节的代码做数组压缩。实现的关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    for(int i=1; i&lt;=n; i++)        </span><br><span class="hljs-comment">    for(int j=YS1; j&gt;=0; j--)&#123;   // 枚举填写背包总容量j，逆序，j=0也需要填写 </span><br><span class="hljs-comment">            dp[j]= dp[j];</span><br><span class="hljs-comment">            if (j &gt;= ys1[i])</span><br><span class="hljs-comment">                for (int k=1; k&lt;=j/ys1[i]; k++) </span><br><span class="hljs-comment">                //for (int k=1; k*ys1[i]&lt;=j; k++)  //这样写也是等效的 </span><br><span class="hljs-comment">                    dp[j]= max(dp[j],  dp[j-k*ys1[i]] + k*value[i] );</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    上面这个代码存在大量冗余，优化后的代码如下：</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)        <span class="hljs-comment">// 针对每1种物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)&#123;   <span class="hljs-comment">// 枚举填写背包总容量j，只能逆序，j=0也需要填写 </span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=j/ys1[i]; k++) <br>                <span class="hljs-comment">//for (int k=1; k*ys1[i]&lt;=j; k++)  //这样写也是等效的 </span><br>                    dp[j]= <span class="hljs-built_in">max</span>(dp[j],  dp[j-k*ys1[i]] + k*value[i] );<br>        &#125;<br></code></pre></td></tr></table></figure><p>　　其实上面的代码，枚举j也可以用正序，只不过这样一来，就变成带冗余循环的方法四了。</p><p>　　上面的这种实现方式，时间复杂度为<spanclass="math inline">\(O(n*YS1*k)\)</span>，空间复杂度为<spanclass="math inline">\(O(\textcolor[RGB]{225,0,0}{YS1})\)</span>。</p><p>　　可以看到，1.3.1和1.3.2节的代码都是三重for，这是阻碍算法效率的瓶颈。有没有什么办法进一步优化呢？还真有。请看下节。</p><h3 id="二重for-标准状态数组-正序较优掌握是下一节的铺垫">1.3.3<font color="red">二重</font>for + 标准状态数组 +正序（较优，掌握，是下一节的铺垫）</h3><p>　　本节内容建议同学们还是应该掌握，以便于加深对背包问题的理解。有些题解是采用这种方法和结构来写代码的。看懂本节后有利于同学们读懂这些题解代码。而且，标准状态数组能够记录路径，能倒推出具体的决策内容，这是滚动数组无法比拟的。</p><h4 id="分析">1.3.3.1 分析</h4><p>　　之前在普通01背包的处理时，对于标准状态数组枚举总容量j时顺序是可正可逆的。因为dp[i][j]完全依赖于dp[i-1][0..YS1]的数据，即依赖于上一行的数据，和本行数据无关，所以第i行的填写顺序可正可逆。dp[i][j]和dp[i][j-ys1[i]]之间会有什么关系吗？请看下图：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240515101440755.png"alt="image-20240515101440755" /><figcaption aria-hidden="true">image-20240515101440755</figcaption></figure><p>　　在右图中，当i=2，更新dp[2][5]时，dp[2][5]=max(dp[1][5],dp[2][3]+10)=max(5,10+10)=20。这里需要注意到一点：<strong>dp[1][3]之前已经针对物品B而更新过了，其值为10，表示背包总容量为3斤时的最优决策是“只装入了一个物品B”。在这种情况下，dp[2][5]选择了dp[2][3]+10这个决策，表示“在dp[2][3]对应决策的基础上，再装入第二个物品B”，</strong>也就是说，dp[2][5]对应的决策是“只装入两个物品B”。这就体现了完全背包的含义。其关键动作在于“一定要从左往右更新dp[i][]”。<strong>只有这样，才能在之前已针对第i个物品做过决策的基础上，再次针对第i个物品做当前的决策</strong>，这样就体现出完全背包的“重复选择”含义。</p><h4 id="关键代码">1.3.3.2 关键代码</h4><p>　　关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)       <span class="hljs-comment">// 针对每1种物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举背包总空间j，必须只能正序，不能逆序！</span><br><span class="hljs-keyword">if</span> ( j &lt; ys1[i] )<br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];   <span class="hljs-comment">// 别忘了公式8是两种情况，不够装时只能放弃物品i，照抄即可 </span><br><span class="hljs-keyword">else</span>  <br>    <span class="hljs-comment">// dp[i-1][j] 表示“能装而不装”，照抄上一行数据，注意是[i-1] </span><br>               <span class="hljs-comment">// dp[i][j - ys1[i]] + value[i]是当前行左侧（注意是[i]），它可能已经装有若干个物品i </span><br>dp[i][j] = <span class="hljs-built_in">max</span>( dp[i<span class="hljs-number">-1</span>][j] , dp[i][j - ys1[i]] + value[i] );<br>&#125;<br><br></code></pre></td></tr></table></figure><p>　　上述代码中的if语句和普通01背包的标准状态数组实现代码中的if语句只有一个地方不一样，那就是dp[<font color="red"><strong>i</strong></font>][j-ys1[i]]+value[i]，其他都完全一样。另外，完全背包要求枚举背包空间j必须只能正序！不能再“正序逆序均可（适用于普通01背包）”了。</p><h4 id="路径管理和输出不常考有时间建议还是看看">1.3.3.3路径管理和输出（不常考，有时间建议还是看看）</h4><p>　　在这个模型下，背包决策路径如何记录和输出呢？即如何看出来每个物品选择了多少个？</p><ol type="1"><li>方法一（不额外定义路径数组，直接从dp[][]倒推决策）</li></ol><p>　　其实很简单，原理和普通01背包的处理是一样的。如果dp[i][j]!=dp[i-1][j]，则背包里必然有物品i，水平往左跳转到dp[i][j-ys1[i]]，再和其上一行数据dp[i-1][j-ys1[i]]相比：如果相同，说明物品i只选择了1个，该处理物品i-1了；如果值不相同，说明还选择了第二个物品i，继续水平往左跳到dp[i][j-2*ys1[i]]，以此类推。通过这样的方式就能找到所有的决策。</p><p>　　举个例子，如下图所示：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240515113238734.png"alt="image-20240515113238734" /><figcaption aria-hidden="true">image-20240515113238734</figcaption></figure><ol start="2" type="1"><li>方法二（定义专门的路径数组ppre[][]来实现）</li></ol><p>　　在二维数组中如果存在多条树状路径，每个点的位置标记为(x,y)，且有唯一的前驱。这种模型下要记录路径，可以采用如下的模式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> r, c;<br>&#125;path[maxn][maxYS1];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pri</span><span class="hljs-params">(node cur)</span></span>&#123;<br><span class="hljs-keyword">if</span> (cur.r==<span class="hljs-number">-1</span> &amp;&amp; cur.c==<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">pri</span>( ppre[cur.r][cur.c] );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;选择物品%d\n&quot;</span>, cur.r);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)       <span class="hljs-comment">// 针对每1种物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举背包总空间j，必须只能正序，不能逆序！</span><br><span class="hljs-keyword">if</span> ( j &lt; ys1[i] )&#123;<br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];   <span class="hljs-comment">// 别忘了公式8是两种情况，不够装时只能放弃物品i，照抄即可</span><br>                ppre[i][j]=(node)&#123;i<span class="hljs-number">-1</span>, j&#125;;<br>            &#125;<br><span class="hljs-keyword">else</span>  <br>    <span class="hljs-comment">// dp[i-1][j] 表示“能装而不装”，照抄上一行数据，注意是[i-1] </span><br>                <span class="hljs-comment">// dp[i][j - ys1[i]] + value[i]是当前行左侧（注意是[i]），它可能已经装有若干个物品i </span><br>                <span class="hljs-keyword">if</span> (dp[i<span class="hljs-number">-1</span>][j] &lt;= dp[i][j - ys1[i]] + value[i]) <br>   dp[i][j] = dp[i][j - ys1[i]] + value[i] , ppre[i][j]=(node)&#123;i, j-ys1[i]&#125;;<br>            <span class="hljs-keyword">else</span><br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j], ppre[i][j]=(node)&#123;i<span class="hljs-number">-1</span>, j&#125;;<br>&#125;<br><span class="hljs-comment">/////// 上面代码可以简化一下。此处为了让同学们理解其根源，所以没去简化。</span><br></code></pre></td></tr></table></figure><h3 id="二重for-滚动状态数组-正序最优做法背">1.3.4<font color="red">二重</font>for + <font color="red">滚动</font>状态数组+ 正序（最优做法，背）</h3><h4 id="分析-1">1.3.4.1 分析</h4><p>　　之前在普通01背包的处理时，对于滚动数组，要求从右往左枚举总容量j，以顺利完成新旧数据的读取和更新。那如果非要从左往右更新，会出现什么情况呢？请看下图：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240515091316889.png"alt="image-20240515091316889" /><figcaption aria-hidden="true">image-20240515091316889</figcaption></figure><p>　　在右图中，当i=2，更新dp[5]时，dp[5]=max(dp[5],dp[3]+10)=max(5,20)=20。这里需要注意到一点：<strong>dp[3]之前已经针对物品B而更新过了，其值为10，表示背包总容量为3斤时的最优决策是“装入了一个物品B”。在这种情况下，dp[5]选择了dp[3]+10这个决策，表示“装入第二个物品B”</strong>，也就是说，dp[5]对应的决策是“在dp[2][3]对应决策的基础上，再装入两个物品B”。这就体现了完全背包的含义。其关键动作在于“一定要从左往右更新dp[]，才能体现出完全背包的‘重复选择’含义”。</p><h4 id="关键代码-1">1.3.4.2 关键代码</h4><p>　　关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//版本3. AC代码, 一维状态数组 + 2重for + 增序 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)       <span class="hljs-comment">// 针对每1种物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=ys1[i]; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举背包总容量j，正序，j的取值范围是[ys1[i], YS1] </span><br>dp[j] = <span class="hljs-built_in">max</span>( dp[j] , dp[j - ys1[i]] + value[i] );<br>&#125;<br><span class="hljs-comment">// 或者如下，等效，但不如上述代码更优 </span><br><span class="hljs-comment">//for(int j=0; j&lt;=YS1; j++)&#123;   </span><br><span class="hljs-comment">//if ( ys1[i] &lt;= j ) </span><br><span class="hljs-comment">//dp[j] = max( dp[j] , dp[j - ys1[i]] + value[i] );</span><br><span class="hljs-comment">//&#125;</span><br></code></pre></td></tr></table></figure><h4 id="路径管理和输出不常考有时间建议还是看看-1">1.3.4.3路径管理和输出（不常考，有时间建议还是看看）</h4><p>　　在滚动状态数组模型下，无法根据状态数组来倒推路径，所以1.3.3.3节的方法一不再适用，但方法二是可以的。同学们可以自行调整其代码，此处不再多说。</p><h2 id="彩蛋">1.4 彩蛋</h2><p>　　如果现在有一个题如下：</p><p>　　总背包容量YS1，2种物品，第1种只能选0个或者1个，而第2种物品可以选无限个，求最大价值。分别给出ys1[1..2]和value[1..2]。</p><p>　　这样的题，怎么破？同学们可以思考一下。后续帖会给出答案。</p><h1 id="二.-实战练习">二. 实战练习</h1><h2 id="section">2.1 1268</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1268">1268：【例9.12】完全背包问题</a></p><h3 id="分析-2">2.1.2 分析</h3><p>　　这是一个裸的完全背包的题目，maxn=30，maxYS1=200，这么小的数据量，适合新手用来练习上面的四种方法。本题不需要输出路径。同学们要求掌握四种方法，并重点掌握第四种。</p><h3 id="ac代码">2.1.3 AC代码</h3><h4 id="二维状态数组-3重for-增序降序">2.1.3.1 二维状态数组 + 3重for +增序/降序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 1. AC代码, 二维状态数组 + 3重for + 增序/降序 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">35</span>][<span class="hljs-number">211</span>];<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">35</span>], value[<span class="hljs-number">35</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> YS1, n;<br>cin &gt;&gt;YS1 &gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>cin &gt;&gt;ys1[i] &gt;&gt;value[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)       <span class="hljs-comment">// 针对每1种物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举背包总空间j，正序逆序均可，和第i行数据无关</span><br><span class="hljs-comment">// 这里不是判断放不放了，而是判断放几个！！</span><br><span class="hljs-comment">// k表示放入物品i的个数，把dp[i-1][j]和放不同个数的几种情况都拿来比一比，找到一个最大值！ </span><br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br><span class="hljs-keyword">if</span> ( ys1[i] &lt;= j ) <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k * ys1[i] &lt;= j; k++ ) <br>dp[i][j] = <span class="hljs-built_in">max</span>( dp[i<span class="hljs-number">-1</span>][j - k * ys1[i]] + k*value[i],     dp[i][j]  );<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max=%d&quot;</span>, dp[n][YS1]); ;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一维状态数组-3重for-降序">2.1.3.2 一维状态数组 + 3重for +降序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 2. AC代码, 一维状态数组 + 3重for + 降序 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">201</span>], ys1[<span class="hljs-number">31</span>], value[<span class="hljs-number">31</span>];<br><span class="hljs-type">int</span> YS1, n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin &gt;&gt;YS1 &gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>cin &gt;&gt;ys1[i] &gt;&gt;value[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)              <span class="hljs-comment">// 针对每1个物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)   <span class="hljs-comment">// </span><br><span class="hljs-comment">// 这里不是判断放不放了，而是判断放几个！！</span><br><span class="hljs-comment">// k表示放入物品i的个数，把几种情况都拿来比一比，找到一个最大值！ </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k*ys1[i]&lt;=j; k++) <br>dp[j] = <span class="hljs-built_in">max</span>( dp[j - k*ys1[i]] + k*value[i],  dp[j]);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max=%d&quot;</span>, dp[YS1]); <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="二维状态数组-2重for-正序">2.1.3.3 二维状态数组 + 2重for +正序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//3. AC代码, 二维状态数组 + 2重for + 增序 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">35</span>][<span class="hljs-number">211</span>];<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">35</span>], value[<span class="hljs-number">35</span>];<br><span class="hljs-type">int</span> YS1, n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin &gt;&gt;YS1 &gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>cin &gt;&gt;ys1[i] &gt;&gt;value[i];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)       <span class="hljs-comment">// 针对每1种物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举背包总空间j，只能正序 </span><br><span class="hljs-keyword">if</span> ( j &lt; ys1[i] )<br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];   <span class="hljs-comment">// 别忘了公式8是两种情况，不够装时只能放弃物品i，照抄即可 </span><br><span class="hljs-keyword">else</span>  <br>    <span class="hljs-comment">// dp[i-1][j] 表示“能装而不装”，照搬上一行，注意是i-1 </span><br>                <span class="hljs-comment">// dp[i][j - ys1[i]] + value[i]是当前行左侧（注意是i），它可能已经装有若干个物品i </span><br>dp[i][j] = <span class="hljs-built_in">max</span>( dp[i<span class="hljs-number">-1</span>][j] , dp[i][j - ys1[i]] + value[i] );<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max=%d&quot;</span>, dp[n][YS1]); ;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="一维状态数组-2重for-正序">2.1.3.4 一维状态数组 + 2重for +正序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//4. AC代码, 一维状态数组 + 2重for + 增序 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">211</span>];<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">35</span>], value[<span class="hljs-number">35</span>];<br><span class="hljs-type">int</span> YS1, n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin &gt;&gt;YS1 &gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>cin &gt;&gt;ys1[i] &gt;&gt;value[i];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)               <span class="hljs-comment">// 针对每1种物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=ys1[i]; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举背包总容量j，只能正序，j的取值范围是[ys1[i], YS1] </span><br>dp[j] = <span class="hljs-built_in">max</span>( dp[j] , dp[j - ys1[i]] + value[i] );<br>&#125;<br><span class="hljs-comment">// 或者如下，等效。 </span><br><span class="hljs-comment">//for(int j=0; j&lt;=YS1; j++)&#123;   </span><br><span class="hljs-comment">//if ( ys1[i] &lt;= j ) </span><br><span class="hljs-comment">//dp[j] = max( dp[j] , dp[j - ys1[i]] + value[i] );</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max=%d&quot;</span>, dp[YS1]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="p1616-疯狂的采药">2.2 P1616 疯狂的采药</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P1616">P1616疯狂的采药</a></p><h3 id="分析-3">2.2.2 分析</h3><p>　　所有草药可以无限采摘，这是完全背包的题。</p><p>　　本题数据规模与约定中明确指出了“$1 n*YS1 ^7 <spanclass="math inline">\(”，所以时间复杂度并不会有问题。但是因为\)</span>n^4，YS1^7$，如果定义成标准状态数组，则二维数组空间达到了1e11，这必然会造成MLE。本题只能使用本帖的方法四来破。</p><p>　　从数据规模和约定中看到，每个草药的价值最大可到1e4，最少可1秒内搞定，而且最大可有1e7秒的背包总容量，所以总价值可能达到1e11，故为稳妥起见，开longlong类型。</p><h3 id="ac代码-1">2.2.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">二重for + 一维滚动状态数组 + 正序</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">（1）状态数组定义</span><br><span class="hljs-comment">intdp[i]：在j时间之内能采摘的最大价值</span><br><span class="hljs-comment">（2）所求目标</span><br><span class="hljs-comment">       dp[YS1]</span><br><span class="hljs-comment">（3）状态转换方程</span><br><span class="hljs-comment">A. 时间j内不够，不装第i种草药</span><br><span class="hljs-comment">假设前i-1轮处理中，在时间j内的总价值是dp[j]，既然不采摘第i种草药，</span><br><span class="hljs-comment">所以前i种草药在时间j内的最大总价值dp[j] 和前i-1种草药在时间j内的最大总价值dp[j]是一样的，</span><br><span class="hljs-comment">dp[j] = dp[j]  简单地说，就是什么都不改即可</span><br><span class="hljs-comment">B. 时间j内够装第i种草药  j &gt;= ys[i]</span><br><span class="hljs-comment">a. 装上</span><br><span class="hljs-comment">如果前i-1种草药在时间j-ys1[i]内的最大总价值是dp[j-ys1[i] ]，</span><br><span class="hljs-comment">那么我们可以用剩下的ys1[i]这个时间来装第i种草药的1个，所以有下式：</span><br><span class="hljs-comment">dp[j] = dp[j-ys1[i] ] + value[i];</span><br><span class="hljs-comment">b. 不装 （能装但不装，我当然可以不装，谁说我看到一种草药就非得装啊？要懂策略嘛！）</span><br><span class="hljs-comment">如果不装，那么在j时间内，我面对前i种草药在时间j内能获得的最大价值</span><br><span class="hljs-comment">和 我面对前i-1种草药在时间j内获得的最大价值是一样的</span><br><span class="hljs-comment">dp[j] = dp[j];    这种处理，和前面的A相似</span><br><span class="hljs-comment">归纳汇总：</span><br><span class="hljs-comment">dp[j] = max(dp[j], dp[j-ys1[i] ] + value[i]);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">（4）循环边界和循环顺序</span><br><span class="hljs-comment">j: [ys1[i]..YS1] ys1[i] --&gt; YS1必须增序，这样才能体现出重复背包的含义</span><br><span class="hljs-comment">（5）状态初始化值和特例</span><br><span class="hljs-comment">当value都为0时，不管怎么采，最大价值都为 0, 所以 dp[] 初始化为 0 最合适；</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">动态规划的题，变量众多，请严格遵守命名规则和风格，不要乱取名字</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 10001</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T 10000001</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[T];         <span class="hljs-comment">// 不开long long真的是要见祖宗的，哈哈！～</span><br><span class="hljs-type">int</span> n, YS1;<br><span class="hljs-type">int</span> ys1[N], value[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;YS1, &amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;ys1[i], &amp;value[i]);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=ys1[i]; j&lt;= YS1; j++)<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-ys1[i]] + value[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, dp[YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p2722-总分">2.3 P2722 总分</h2><h3 id="原题链接-2">2.3.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P2722">P2722 [USACO3.1]总分 Score Inflation</a></p><h3 id="分析-4">2.3.2 分析</h3><p>　　每一种题可以无限出多个题，这是完全背包的题。</p><p>　　本题数据规模与约定中明确指出<span class="math inline">\(n \leq10^4，YS1 \leq10^4\)</span>，每个题的收益最大也可到1e4，最少可1秒内搞定，总价值可能达到1e8。本题可用来训练本帖的四种方法。<strong>想练习的同学可以书写四种方法，不必拘泥本帖给出的AC代码。</strong></p><h3 id="ac代码-2">2.3.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 一维状态数组 + 二重for + 正序</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 10001</span><br><span class="hljs-type">int</span> n, YS1, ys1[N], value[N], dp[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;YS1, &amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;value[i], &amp;ys1[i]);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=ys1[i]; j&lt;=YS1; j++)<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-ys1[i]] + value[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dp[YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-1"></h2>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 背包问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长公共子串问题</title>
      <link href="/2024/04/30/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
      <url>/2024/04/30/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="视频教学链接">1.1 视频教学链接</h2><p>　　<ahref="https://www.bilibili.com/video/BV1hv41117gC/?vd_source=0e7cc4e4bbbb67e5c3c2a3e7d967f075">最长公共子串</a></p><h2 id="理论分析">1.2 理论分析</h2><h3 id="什么是子串">1.2.1 什么是子串？</h3><p>　　如图所示:</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240430094645379.png" style="zoom: 50%;" /></p><p>　　它的子串示例：{c,d,e,f}即连续元素c,d,e,f组成的串是给定序列的子串。同理，{a,b,c,d},{g,h}等都是它的子串。</p><p>　　两个序列的最长公共子串的长度值是唯一的，但<strong>公共子串在两个序列中的字符选择，可能是不唯一的</strong>。例如S1="AABAA",S2="AA"，则S2的字符AA和S1中的两个AA都分别构成最长公共子串，长度值都为2。</p><h3 id="动态规划的六步分析">1.2.2 动态规划的六步分析</h3><p>　　1）定义状态数组</p><p>　　假设有两个字符串a[1..lena]和b[1..lenb]，状态数组肯定是一个二维数组无疑。一个直觉是“定义dp[i][j]为‘a[1..i]和b[1..j]的最长公共子串的长度值’”。<strong>但实际上这个定义是错误的</strong>，因为它违反了动态规划方法所要求的第二个前提，即“无后效性”。下面我们举个例子来说明：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240430180913104.png" style="zoom: 70%;" /></p><p>　　上图是两个序列a[]="ABACCB"和b[]="AACCAB"按照“dp[i][j]为a[1..i]和b[1..j]的最长公共子串的长度值”的规定而填写的。仔细研究每一个红圈处，可以发现，都是“a[i]==b[j]且a[i-1]==b[j-1]且a[i-2]==b[j-2]且......”直到“a值和b值不相等”为止。而每一个篮圈处，都是“a[i]==b[j]且a[i-1]!=b[j-1]”的情况，不能简单地加1。<strong>当我们固定a[1..i]，已填好dp[i][j-1]，并且打算填写dp[i][j]时，我们无法确定a[i]在两个序列a[1..i]和b[1..j-1]的公共子串中是否已经被选中过了（若a[i]已用过，则不能再用来和b[j]匹配）。</strong></p><p>　　例如从dp[4][2]开始填写dp[4][3]时，b[3]为字符C，与a[4]相等，且a[4]在a[1..4]和b[1..2]的公共子串"A"中从未出现过，故可用来和b[3]相配，延长子串为“AC”。而填写dp[4][4]时，b[4]为字符C，与a[4]相等，但a[4]在a[1..4]和b[1..3]的公共子串"AC"中已经用过，不能再用来和b[4]相配，故不可加1。</p><p>　　仔细思考，可以发现<strong>因为要求子串必须连续，而“dp[i][j]为a[1..i]和b[1..j]的最长公共子串的长度值”这样的设计，并不能体现和预判出这种“连续性”。这就是问题产生的根源</strong>。</p><p>　　但如果把设计改为“dp[i][j]为a[1..i]和b[1..j]中a[i]==b[j]且a[i]为公共子串的末尾字符时的最长子串长度值”，问题就迎刃而解了。听起来有点长，实际上就是在原来定义的基础上，加上“要求必须两个子串的末尾字符相等，且等于a[i]和b[j]”即可。</p><p>　　按照新的定义，则dp[][]的值如下：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240430204356117.png"alt="image-20240430204356117" /><figcaption aria-hidden="true">image-20240430204356117</figcaption></figure><p>　　从上图中可以看出，<strong>当a[i]==b[j]时，既然不能确定a[i]是否之前已用过，那干脆直接从dp[i-1][j-1]推过来就可以了。这样的话a[i]就肯定没用过了，而b[j]也没用过，正好相配，成为子串的新成员。</strong></p><p>　　2）所求目标</p><p>　　在这种情况下，dp[lena][lenb]不一定是最大值了。所求目标应该是max(dp[1..lena][1..lenb])。</p><p>　　3）状态转移方程：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240430143937061.png" style="zoom: 50%;" /></p><p>　　a）若a[i]==b[j],则至少有它们两个可以构成长度值为1的公共子串。对于a[1..i-1]和b[1..j-1]，根据dp的定义，dp[i-1][j-1]表示它们的最长公共子串的长度值。再尾续上a[i]，长度值应+ 1。</p><p>　　b）若a[i]!=b[j],则不管a[1..i-1]和b[1..j-1]能否构成公共子串，因为必须要以a[i]或者b[j]作为子串的最后一个字符，现在二者不等，所以dp[i][j]=0。</p><p>　　整合a）和b），得状态转移方程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (a[i]==b[j])  <br>    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <br>    dp[i][j] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>　　4）循环顺序和循环边界</p><p>　　　　肯定是需要从上往下、从左往右填写</p><p>　　　　i: 1-----&gt;lena 增序</p><p>　　　　j：1&lt;----&gt;lenb 增序降序均可</p><p>　　5）特例</p><p>　　　　dp[0][j]=dp[i][0]= 0;</p><p>　　　　注意：<del>dp[1][j]=dp[i][1]= 1</del>;是错误的！</p><p>　　6）数组初始化值</p><p>　　　　不需要专门处理普通位置上的初值，都会被覆盖的。</p><h1 id="二.-实战训练">二. 实战训练</h1><h2 id="or15-最长公共子串的长度值">2.1 OR15 最长公共子串的长度值</h2><p>　　原题链接：</p><p>　　　　<ahref="https://www.nowcoder.com/practice/02e7cc263f8a49e8b1e1dc9c116f7602?dayCountBigMember=%E8%BF%9E%E7%BB%AD%E5%8C%85%E6%9C%88&amp;tpId=0&amp;difficulty=&amp;judgeStatus=&amp;tags=&amp;title=%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2&amp;sourceUrl=&amp;gioEnter=menu"><strong>最长公共子串</strong></a>（微信扫码登录)</p><p>　　分析：</p><p>　　dp[i][j]表示str1[0..i-1]和str2[0..j-1]的<strong>以str1[i-1]结尾</strong>的最长公共子串的长度，本题的关键是在于错位存储。因为两个字符串必须以下标0开始存储，所以dp[i][j]表示的不是str1[0..i]和str2[0..j]的子串，换句话说，要在原来1.2.2节分析的基础上，把dp数组的数据区整体往右下方向移动1格即可。</p><p>　　另外，还需要注意一下用vector定义二维数组的写法。</p><p>　　AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LongestSubstring</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLongest</span><span class="hljs-params">(string A, <span class="hljs-type">int</span> n, string B, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> max_len = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//用vector来定义二维数组，长度为[n + 1][m + 1]，默认值为0</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                <span class="hljs-keyword">if</span> (A[i] == B[j]) &#123;<br>                    <span class="hljs-comment">// 递推方程。因为是从00开始，所以把dp的数据区域往右下的方向挪一下而已</span><br>                    <span class="hljs-comment">// dp[i][j]表示a[1..i-1]和b[1..j-1]中a[i-1]==b[j-1]且a[i-1]为公共子串的末尾字符时的最长子串长度值</span><br>                    <span class="hljs-comment">// dp[i+1][j+1]表示a[1..i]和b[1..j]中a[i]==b[j]且a[i]为公共子串的末尾字符时的最长子串长度值</span><br>                    dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = dp[i][j] + <span class="hljs-number">1</span>;<br>                    <span class="hljs-comment">// 找二维数组的最大值</span><br>                    <span class="hljs-keyword">if</span> (max_len &lt; dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 如果不记录下标，&lt;和&lt;=就没区别</span><br>                        max_len = dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max_len;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="cd33-最长公共子串的长度值和子串值">2.2 cd33最长公共子串的长度值和子串值</h2><p>　　原题链接：</p><p>　　　　<ahref="https://www.nowcoder.com/practice/210741385d37490c97446aa50874e62d?dayCountBigMember=%E8%BF%9E%E7%BB%AD%E5%8C%85%E6%9C%88&amp;tpId=0&amp;difficulty=&amp;judgeStatus=&amp;tags=&amp;title=%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2&amp;sourceUrl=&amp;gioEnter=menu"><strong>最长公共子串</strong></a>（微信扫码登录)</p><p>　　分析：</p><p>　　dp[i][j]表示str1[0..i-1]和str2[0..j-1]的以str1[i-1]结尾的最长公共子串的长度，本题在2.1节基础上增加了对“输出子串内容”的要求。所以本题的关键是在dp遍历的过程中记录最长公共子串的结尾下标epos，根据结尾下标以及长度就可以求出子串。</p><p>　　AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>string s1, s2;<br><span class="hljs-comment">//用vector来定义二维数组，长度为[len1 + 1][len2 + 1]，默认值为0</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt;s1 &gt;&gt;s2;<br>    <span class="hljs-type">int</span> len1=s1.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> len2=s2.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> max_len=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> epos=<span class="hljs-number">-1</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len1+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len2+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len1; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;len2; j++) &#123;<br>            <span class="hljs-keyword">if</span>(s1[i]==s2[j]) &#123;<br>                <span class="hljs-comment">// 递推方程。因为是从00开始，所以把dp的数据区域往右下的方向挪一下而已</span><br>                <span class="hljs-comment">// dp[i][j]表示a[1..i-1]和b[1..j-1]中a[i-1]==b[j-1]且a[i-1]为公共子串的末尾字符时的最长子串长度值</span><br>                <span class="hljs-comment">// dp[i+1][j+1]表示a[1..i]和b[1..j]中a[i]==b[j]且a[i]为公共子串的末尾字符时的最长子串长度值</span><br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=dp[i][j] + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 找二维数组的最大值</span><br>                <span class="hljs-keyword">if</span>(max_len &lt; dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 既然要记录下标，此处表示从左往右“第1个”长度为max_len的公共子串的结束下标。如果改为&lt;=，则表示“最后1个”</span><br>                    max_len = dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>];<br>                    epos = i;  <span class="hljs-comment">// 公共子串在s1的结束下标</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> spos=epos - max_len + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 根据“结束下标”和子串长度，算出子串的“起始下标”spos</span><br>    <span class="hljs-keyword">if</span> (epos==<span class="hljs-number">-1</span>)<br>        cout &lt;&lt; <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; s1.<span class="hljs-built_in">substr</span>(spos, max_len);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="hj65-最长公共子串的长度值">2.3 hj65 最长公共子串的长度值</h2><p>　　原题链接：</p><p>　　　　<ahref="https://www.nowcoder.com/practice/02e7cc263f8a49e8b1e1dc9c116f7602?dayCountBigMember=%E8%BF%9E%E7%BB%AD%E5%8C%85%E6%9C%88&amp;tpId=0&amp;difficulty=&amp;judgeStatus=&amp;tags=&amp;title=%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2&amp;sourceUrl=&amp;gioEnter=menu"><strong>查找两个字符串a,b中的最长公共子串</strong></a>（微信扫码登录)</p><p>　　分析：</p><p>　　　　本题在2.2节基础上，加入了“输出在较短串中最先出现的那个”。首先我们需要明白，最长公共子串，是有可能有多个解的。例如s1=“AAXXXXXXXBB”和s2=“BBYAA”就有“AA”和“BB”这两个最长公共子串，长度都是2，都最长。如果按照本题的意思，则应该输出较短的串（即s2）中的“BB”，因为它先出现。</p><p>　　我们需要先比较两串长度，用swap让s1成为最短的串，以方便后面的代码书写。至于“最先出现”该如何搞定呢？只需要在子串最大长度值进行刷新时规定当长度值相等时仍然不刷新对应下标，仍然保留第一次出现长度值为max_len的子串的下标epos。</p><p>　　AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function">string <span class="hljs-title">LCS</span><span class="hljs-params">(string str1, string str2)</span> </span>&#123;<br>    <span class="hljs-comment">// write code here</span><br>    <span class="hljs-keyword">if</span> (str1.<span class="hljs-built_in">size</span>() &gt; str2.<span class="hljs-built_in">size</span>())  <span class="hljs-comment">// 确保str1是最短的串</span><br>        <span class="hljs-built_in">swap</span>(str1, str2);<br>    <span class="hljs-type">int</span> m = str1.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> n = str2.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// dp[i][j] str1前i个字符和str2前j个字符（以其为尾字符）的最长公共子串长度</span><br>    <span class="hljs-type">int</span> dp[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> maxlen = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//base case</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; ++j) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (str1[i - <span class="hljs-number">1</span>] == str2[j - <span class="hljs-number">1</span>]) <br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                dp[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (dp[i][j] &gt; maxlen) &#123; <span class="hljs-comment">// 这里不能写&gt;=，必须是&gt;，确保了“首次出现”</span><br>                maxlen = dp[i][j];<br>                end = i - <span class="hljs-number">1</span>;         <span class="hljs-comment">// 记录i-1，而i对应着str1（短串），所以确保了是短串中的结束下标</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (maxlen == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;-1&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> str1.<span class="hljs-built_in">substr</span>(end - maxlen + <span class="hljs-number">1</span>, maxlen);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s1, s2;<br>    cin &gt;&gt; s1 &gt;&gt; s2；<br>    cout &lt;&lt; <span class="hljs-built_in">LCS</span>(s1, s2) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 线性DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位操作（与、或、异或）方法详解</title>
      <link href="/2024/01/30/%E4%BD%8D%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%8E%E3%80%81%E6%88%96%E3%80%81%E5%BC%82%E6%88%96%EF%BC%89%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/01/30/%E4%BD%8D%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%8E%E3%80%81%E6%88%96%E3%80%81%E5%BC%82%E6%88%96%EF%BC%89%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="一.-按位与">一. 按位与（ &amp; ）</h1><h2 id="基本运算常识">1.1 基本运算常识</h2><p>参加运算的两个数据，按<strong>二进制位</strong>进行“与”运算。</p><p>运算规则：0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1;</p><p>即：<strong>两位同时为“1”，结果才为“1”，否则为0</strong></p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">AndOperator</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a &amp; b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 3&amp;5 即 0000 0011 &amp; 0000 0101 = 0000 0001  因此，3&amp;5的值得1</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">5</span>;<br>    cout&lt;&lt; <span class="hljs-built_in">AndOperator</span>(a, b) &lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：<strong>负数按补码形式参加按位与运算</strong>。</p><p>例如： -3 &amp; 5 　　　即 1111 1101 &amp; 0000 0101 = 0000 0101　　　因此，-3 &amp; 5的值得5</p><h2 id="与运算的小技巧">1.2 “与”运算的小技巧</h2><h3 id="清零">1.2.1 清零</h3><p>若想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。 例：3 &amp; 0 = 0</p><h3 id="提取一个数的指定位">1.2.2 提取一个数的指定位</h3><p>将一个数指定的某个或某些bit值设置为1，其余为0。</p><p>例：设 <span class="math inline">\(X = (1010 \ 1110)_2\)</span>，　　取X的低4位： 1010 <font color="red">1110</font> &amp; 0000<font color="yellow">1111</font> = 0000 <font color="red">1110</font>　　取X的第5位： 1010 <font color="red">1110</font> &amp; 0000<font color="yellow">1</font>000 = 0000<font color="red">1</font>000</p><h3 id="判断奇偶">1.2.3 判断奇偶</h3><p>根据未位是0还是1来决定该数的奇偶，若为0就是偶数，为1就是奇数。</p><p>因此可以用if (a &amp; 1 == 0)代替if (a % 2 ==0)来判断“a是不是偶数”。那判断“a是不是奇数”该怎么做呢？见下面的代码。</p><p>下面程序将输出0到100之间的所有奇数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i)&#123;  <br>    <span class="hljs-keyword">if</span> (i &amp; <span class="hljs-number">1</span>)   <span class="hljs-comment">// 等效于 if (i % 2) 或者 if ( i % 2 == 1)</span><br>        cout&lt;&lt; i &lt;&lt;endl;<br>&#125; <br></code></pre></td></tr></table></figure><h1 id="二.-按位或">二. 按位或（|）</h1><h2 id="基本运算常识-1">2.1 基本运算常识</h2><p>参加运算的两个对象，按二进制位进行“或”运算。</p><p>运算规则：0|0=0； 0|1=1； 1|0=1； 1|1=1；</p><p>即 ：<strong>参加运算的两个对象只要有一个为1，其值为1</strong>。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">OrOperator</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a | b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 3|5 即 0000 0011 | 0000 0101 = 0000 0111  因此，3|5的值得7</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">5</span>;<br>    cout&lt;&lt; <span class="hljs-built_in">OrOperator</span>(a, b) &lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：<strong>负数按补码形式参加按位或运算</strong>。</p><p>例如： -3 | 5 　　　即 <strong>1111 1101</strong> | 0000 0101 = 11111101 　　　因此，-3 | 5的值为-3</p><h2 id="或运算的小技巧">2.2 “或”运算的小技巧</h2><h3 id="常用来将一个数的-指定bit设置为1">常用来将一个数的指定bit设置为1</h3><p>例：将<span class="math inline">\(X=(1010\ 0000)_2\)</span>的低4位置1，用 <font color="red">1010</font> 0000 | 0000<font color="yellow">1111</font> = <font color="red">1010</font>1111即可得到。</p><h1 id="三.-按位异或">三. 按位异或（^）</h1><h2 id="运算规则及推论">3.1 运算规则及推论</h2><h3 id="运算规则">3.1.1 运算规则</h3><p>“异或”运算的<strong>数学</strong>表达符号是“<strong><spanclass="math inline">\(\oplus\)</span></strong>”，或者“<strong>xor</strong>”。例如<span class="math inline">\(a \oplus b \oplus c\)</span>，或者<spanclass="math inline">\(a\,\,xor\,\,b\,\,xor\,\, c\)</span></p><p>“异或”运算的C++代码书写符号是'^'。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>, b=<span class="hljs-number">-8</span>;<br><span class="hljs-type">int</span> c= a ^ b;<br></code></pre></td></tr></table></figure><p>参加运算的两个数据，按二进制位进行“异或”运算：</p><p>0^0=0； 0^1=1； 1^0=1； 1^1=0；</p><p>即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">XOR</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a ^ b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 3^5 即 0000 0011 ^ 0000 0101 = 0000 0111  因此，3|5的值得6</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">5</span>;<br>    cout&lt;&lt; <span class="hljs-built_in">XOR</span>(a, b) &lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="相关的重要推论">3.1.2 相关的重要推论</h3><p>假如有两个int或者char变量，分别为a和b，则有：</p><p>（1）交换律 <span class="math display">\[a \oplus b = b \oplus a\]</span> （2）结合律 <span class="math display">\[a \oplus b \oplus c = a \oplus (b \oplus c)\]</span> （3）任何数a与0异或后结果是a自己 <span class="math display">\[a \oplus 0 = a\]</span> （4）任何数a与自己异或后结果是0 <span class="math display">\[a \oplus a = 0\]</span></p><h2 id="异或运算的小技巧">3.2 “异或”运算的小技巧</h2><h3 id="使特定bit翻转其余bit不变">3.2.1使特定bit翻转，其余bit不变</h3><p>假如现在有一个X，想将其指定的某些bit值进行翻转，该怎么做呢？很简单，找到一个数Y，对应X要翻转的各位，该数Y的对应位为1，Y的其余位为零，此数与X做异或运算即可。例：<span class="math inline">\(X=(1010\1110)_2\)</span>，若要使X的低3位翻转，则用<font color="red">10101</font><font color="green">110</font> ^ 00000<font color="yellow">111</font> = <font color="red">10101</font><font color="green">001</font>即可得到。</p><h3 id="与0相异或保留原值">3.2.2 与0相异或，保留原值</h3><p>1010 1110 ^ 0000 0000 = 1010 1110。从上面的例题可以清楚的看到这一点。</p><h3 id="交换a和b的值">3.2.3 交换a和b的值</h3><p>交换两个整数a和b的值，不允许使用临时变量，该如何实现？用“异或”操作可以实现！但“异或”操作仅限于整数和char，不适用于double和结构体等类型。</p><p>这里只有a和b两个变量，但为了体现出变量因为时间先后而引起的值的差异，所以用a1和b1表示变量a和b的初始值，用a2和b2表示其经过更改后的值。数学步骤如下三步所示：</p><p><span class="math display">\[\begin{align*}(1)\qquad a2 &amp;= a1 \oplus b1\qquad\qquad\qquad\qquad\qquad\quad\end{align*}\]</span></p><p><span class="math display">\[\begin{align*}(2)\qquad b2 &amp;= \underline{a2} \oplus b1\\&amp;=(\underline{a1 \oplus b1})  \oplus b1\qquad (根据(1式))\\&amp;=a1\oplus (b1 \oplus b1)  \qquad(异或的结合律)\\&amp;=a1 \oplus 0\\&amp;=a1\end{align*}\]</span></p><p><span class="math display">\[\begin{align*}(3)\qquad a2&amp;= a2 \oplus \underline{b2} \\&amp;=(a1 \oplus b1)\oplus \underline{a1} \qquad(根据(1)、(2)式)\\&amp;=(b1 \oplus a1) \oplus a1\qquad\quad(交换律) \\&amp;=b1 \oplus (a1 \oplus a1)\qquad\quad(结合律) \\&amp;=b1 \oplus 0\\&amp;=b1 \\\end{align*}\]</span></p><p>其代码形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a, b;<br>cin &gt;&gt;a &gt;&gt;b;<br>a = a ^ b;  <span class="hljs-comment">// 这里三个赋值语句的左端变量，可以a、b、a；也可以b、a、b（体现出任意两个数）交换</span><br>b = a ^ b;  <span class="hljs-comment">// 右侧两个变量左右均可随意交换，因为“异或”满足交换律</span><br>a = a ^ b;<br>cout &lt;&lt;a &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;b;<br></code></pre></td></tr></table></figure><h2 id="强化练习">3.3 强化练习</h2><h3 id="p1469-找筷子">3.3.1 P1469 找筷子</h3><p>原题链接：<a href="https://www.luogu.com.cn/problem/P1469">P1469找筷子</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">给你 n 个数，求出现了奇数次的数（确保只有一个）的数值是多少? </span><br><span class="hljs-comment">n达到1e7，每个数的范围也很大，只能用O(n)的效率才能过，空间要求4MB，卡得很严，如果定义数组，很容易MLE</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">需要知道一个性质：</span><br><span class="hljs-comment">0 ^ a = a （1） </span><br><span class="hljs-comment">a ^ a = 0      （2） </span><br><span class="hljs-comment">a ^ a ^ a = a</span><br><span class="hljs-comment">a ^ a ^ b ^ b = 0   根据（2） </span><br><span class="hljs-comment">a ^ b ^ a ^ b = 0   满足交换律 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">所以，本题就简单了，只需要把n个数进行连续异或，其结果值就是那个具有奇数个的数。 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n,x,ans = <span class="hljs-number">0</span>;<br>n = <span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <br>x = <span class="hljs-built_in">read</span>(),ans ^= x;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> s = <span class="hljs-number">0</span>,f = <span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>((ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &amp;&amp; ch != EOF) &#123;<br><span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;-&#x27;</span>) f = <span class="hljs-number">-1</span>;<br>ch = <span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>s = s * <span class="hljs-number">10</span> + ch - <span class="hljs-string">&#x27;0&#x27;</span>;<br>ch = <span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">return</span> s * f;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="b3908-异或构造题">3.3.2 B3908 异或构造题？</h3><p>原题链接：<a href="https://www.luogu.com.cn/problem/B3908">B3908[语言月赛 202312] 异或构造题？</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n,a, x=<span class="hljs-number">0</span>;<br>    cin &gt;&gt;n;<br>    <span class="hljs-keyword">while</span> (n--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a), x=x^a;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld 0&quot;</span>, x);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="p8845-小卡和质数">3.3.3 P8845 小卡和质数</h3><p>原题链接：<a href="https://www.luogu.com.cn/problem/P8845">P8845[传智杯 #4 初赛] 小卡和质数</a></p><p>怎么样的两个数异或值为 00000001呢？显然是二进制下只有末位bit的值不同的数。要满足这个条件，需要两个质数的其他位都相同，而末位不同，也就是说，两者值相差1。所有质数中，只有3 和 2 相差1，所以他们的异或值为 1。最终得到：两个质数只能是 3 和2。</p><p>3是第2个质数，2 是第1个质数，则x和y为2和1，或者1和2。两数可能调换位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> t,a,b;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)&#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>((a==<span class="hljs-number">2</span>&amp;&amp;b==<span class="hljs-number">1</span>)||(a==<span class="hljs-number">1</span>&amp;&amp;b==<span class="hljs-number">2</span>)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="p9227异或积">3.3.4 P9227异或积</h3><p>原题链接：<a href="https://www.luogu.com.cn/problem/P9227">P9227异或积</a></p><p>分析：</p><p>拿到一个题，看懂题意之后，首先看数据规模。本题中n最大可到<spanclass="math inline">\(10^5\)</span>个数，最多要求做<spanclass="math inline">\(k=10^{18}\)</span>轮变化。如果直接硬干，早就TLE了。所以这个题必然是有巧方法的，不能硬干。根据3.1.2节中介绍的3）和4），所以我们可以从n和k的奇偶性方面来作为分析的切入点试试看。</p><p>此时，我们可以举个例子来试试看，推演一下，尝试看能不能找到其中的规律。</p><p>（1）假设n=4（当然，你也可以假设n=5或者6，但建议不要太多，不然草稿纸不够你写的），则有：</p><p><span class="math display">\[\begin{align*}(a_1,\quad a_2,\quada_3,\quad a_4)&amp;\stackrel{第1轮}{\Longrightarrow} (a_2\oplusa_3\oplus a_4, \quad a_1\oplus a_3\oplus a_4, \quad a_1\oplus a_2\oplusa_4, \quad a_1\oplus a_2\oplus a_3) \\&amp;\stackrel{第2轮}{\Longrightarrow}((\textcolor[RGB]{225,0,0}{\cancel{a_1}}\oplus\textcolor[RGB]{0,225,0}{\cancel{a_3}}\oplus\textcolor[RGB]{225,225,0}{\cancel{a_4}}\oplus\textcolor[RGB]{225,0,0}{\cancel{a_1}}\oplus\textcolor[RGB]{100,100,225}{\cancel{a_2}}\oplus\textcolor[RGB]{225,225,0}{\cancel{a_4}}\oplus a_1\oplus\textcolor[RGB]{100,100,225}{\cancel{a_2}}\oplus\textcolor[RGB]{0,225,0}{\cancel{a_3}}),\,\,数列第2项值\,\,,\,\,数列第3项值\,\,,\,\,数列第4项值\,\,)\\&amp;=(a_1,数列第2项值\,\,,\,\,数列第3项值\,\,,\,\,数列第4项值)\\&amp;=(a_1,a_2,a_3,a_4)\qquad\qquad//其他3项按照和a_1类似的方法\\\end{align*}\]</span></p><p>可以看出，当n为偶数时，经过第1轮变换后的每一项值，都是奇数个其他原数的连续异或值，则在进行第2轮变换时，该位置上的结果必然是n-1（n-1是奇数）个数值的异或，且这些数值也是奇数个原数的异或，<spanclass="math inline">\(a_1\)</span>经过两轮变换之后仍然还是<spanclass="math inline">\(a_1\)</span>，这样就很好办了！如果k为偶数，就返回原始序列的值；如果k为奇数，就返回第一轮的序列值。</p><p>（2）假设n=3，则有：</p><p><span class="math display">\[\begin{align*}(a_1,\quad a_2,\quada_3)&amp;\stackrel{第1轮}{\Longrightarrow} (a_2\oplus a_3, \quada_1\oplus a_3, \quad a_1\oplus a_2 )\\&amp;\stackrel{第2轮}{\Longrightarrow}((\textcolor[RGB]{225,0,0}{\cancel{a_1}}\oplusa_3\oplus \textcolor[RGB]{225,0,0}{\cancel{a_1}}\oplusa_2),\,\,数列第2项值\,\,,\,\,数列第3项值\,\,,\,\,数列第4项值\,\,) \\&amp;=(a_2\oplus a_3, \quad a_1\oplus a_3, \quad a_1\oplus a_2)\qquad//其他3项按照和a_1类似的方法\\\end{align*}\]</span></p><p>可以看出，当n为奇数时，经过第1轮变换后的每一项值，都是偶数个其他原数的连续异或值，则在进行第2轮变换时，该位置上的结果不变，仍然是第1轮的结果，这样也很好办了！不管k是奇数或者是偶数，都返回第一轮的序列值。</p><p>（3）可以对上述两点进行归纳，即：“<strong>当n为偶数且k为偶数时，返回原始序列的值；否则返回第一轮序列的值</strong>”</p><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br>ll T, n;<br>ll k;<br>ll a[N], b[N];<br><span class="hljs-comment">// 最多10万个数据的输入，建议上快读 </span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    ll x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> ch; <br>    <span class="hljs-keyword">while</span>(ch = <span class="hljs-built_in">getchar</span>() , ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;-&#x27;</span>) f = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        x = (x &lt;&lt; <span class="hljs-number">1</span>) + (x &lt;&lt; <span class="hljs-number">3</span>) + (ch ^ <span class="hljs-number">48</span>);<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> x * f;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    T = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">while</span>(T--) &#123;<br>        n = <span class="hljs-built_in">read</span>(), k = <span class="hljs-built_in">read</span>();<br>        ll sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            a[i] = <span class="hljs-built_in">read</span>();<br>            sum ^=a[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; k % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)  <span class="hljs-comment">// 输出原始序列的值，作为答案 </span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, a[i]);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)  <span class="hljs-comment">// 输出第一轮序列的值，作为答案</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, sum^a[i]);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四.-位运算综合练习">四. 位运算综合练习</h1><h2 id="p1100-高低位交换">4.1 P1100 高低位交换</h2><p>原题链接：<a href="https://www.luogu.com.cn/problem/P1100">P1100高低位交换</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> x;    <span class="hljs-comment">// 必须要unsigned，才是真正的32位有效数据，不管正负号</span><br>cin&gt;&gt;x;<br><span class="hljs-comment">//cout&lt;&lt;( (x&amp;0x0000ffff)&lt;&lt;16 | (x&amp;0xffff0000)&gt;&gt;16 ) &lt;&lt;endl;  //法1</span><br><span class="hljs-comment">//cout&lt;&lt; (x&lt;&lt;16) + (x&gt;&gt;16) &lt;&lt;endl;                           //法2</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u&quot;</span>,(x&gt;&gt;<span class="hljs-number">16</span>)+(x&lt;&lt;<span class="hljs-number">16</span>));                              <span class="hljs-comment">//法3，注意是%u</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="b3919-二进制与一">4.2 B3919 二进制与一</h2><p>原题链接：<a href="https://www.luogu.com.cn/problem/B3919">B3919[语言月赛 202401] 二进制与一</a></p><p>将 n 对 <span class="math inline">\(2^{k-1}\)</span>取模，就可以得到n 的最末尾k-1个二进制位的十进制结果 c 。也就是说，c=n%(1ll&lt;&lt;k);当然，也可以用另外一种计算方法，即c=n&amp;((1ll&lt;&lt;k)-1);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> n, q, ans=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>    cin &gt;&gt;n &gt;&gt;q;;<br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> k;<br>        cin &gt;&gt; k;<br>        --k; <span class="hljs-comment">// 得到 k - 1</span><br>        <span class="hljs-keyword">if</span> (n &amp; (<span class="hljs-number">1ll</span> &lt;&lt; k)) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果整数n的二进制右数第k位已经是1，则不需要加任何数 </span><br>        <span class="hljs-comment">//long long c = n % (1ll &lt;&lt; k);       // 方法 1 </span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> c = n &amp; ((<span class="hljs-number">1ll</span>&lt;&lt;k) - <span class="hljs-number">1</span>);     <span class="hljs-comment">// 方法 2   两种都要会写 </span><br>        ans += (<span class="hljs-number">1ll</span> &lt;&lt; k) - c;<br>        n += (<span class="hljs-number">1ll</span> &lt;&lt; k) - c;<br>    &#125;<br>    cout &lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基本知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针与尺取法</title>
      <link href="/2024/01/04/%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%88%E5%B0%BA%E5%8F%96%E6%B3%95%EF%BC%89/"/>
      <url>/2024/01/04/%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%88%E5%B0%BA%E5%8F%96%E6%B3%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="最长不重复字串问题">1.1 “最长不重复字串”问题</h2><p>“最长不重复子串”是一个经典问题。题意如下：</p><p><ahref="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">Leetcode第3题</a>：给定一个字符串s(<code>s</code>由英文字母、数字、符号和空格组成，长度在[0,50000])，请你找出其中不含有重复字符的 <strong>最长子串</strong>的长度。</p><h3 id="初步分析">1.1.1 初步分析</h3><p>首先我们分析一下这个问题的关键信息，主要有以下四个：</p><ul><li><p>1）n的取值范围是 <span class="math inline">\(0\leq n\leq5*10^4\)</span> ；</p></li><li><p>2）最长；</p></li><li><p>3）所有字符不重复；</p></li><li><p>4）子串；</p></li></ul><p>根据以上的几个关键词，我们可以得出一些结论：</p><p>1)根据的范围已经能够大致确认这是一个需要<spanclass="math inline">\(O(n)\)</span>或者<spanclass="math inline">\(O(lon_2n)\)</span>的算法才能解决的问题；</p><p>2)"最长"意味着可能是一个动态规划问题或者贪心问题，也有可能是搜索。所以这个关键词给我们的信息用处不大；</p><p>3)而“判断字符是否重复”可以用 <strong>哈希表</strong> 在<spanclass="math inline">\(O(1)\)</span>的时间内判断；</p><p>4)左和右两个端点能确定出一个子串，所以<strong>枚举所有"子串"</strong>意味着要枚举这两个端点，其时间复杂度是<spanclass="math inline">\(O(n^2)\)</span>的。</p><h3 id="朴素算法简单了解即可">1.1.2 朴素算法（简单了解即可）</h3><p>由以上分析，我们可以发现第1）个和第4）个关键词给我们得出的结论是矛盾的。那么，我们可以先尝试减小 n的范围。当<span class="math inline">\(n\leq10^3\)</span>时，怎么解决这个问题呢？浅显一点地来想：因为最后求的是满足条件的最长子串，所以我们如果能够枚举所有子串，那么选择长度最长的满足条件<spanclass="math inline">\(^{(*)}\)</span>的子串就是答案了（这里的条件<spanclass="math inline">\(^{(*)}\)</span>是指子串中所有字符都不同）。</p><p>用 ans 记录我们需要求的最大不重复子串的长度，用一个哈希表 h[]来代表某个字符是否出现过（你可以理解为一个访问标记数组，类似于vis[]），一个不太成熟的算法就成型了，描述如下：</p><ul><li><p>1）外层循环枚举子串的左端点 <span class="math inline">\(i=0\rightarrow n−1\)</span>；</p></li><li><p>2）清空哈希表h[]；</p></li><li><p>3）内层循环枚举子串的右端点 <span class="math inline">\(j=i\rightarrow n−1\)</span> ，如果当前这个字符<spanclass="math inline">\(s_j\)</span>出现过（即 <spanclass="math inline">\(h[s_j]=true\)</span>），则跳出j的循环；否则令<spanclass="math inline">\(h[s_j]=true\)</span>，并且用当前长度去考虑更新ans （即 <spanclass="math inline">\(ans=max⁡(ans, j−i+1)\)</span>）；</p></li><li><p>4）回到 2）；</p></li></ul><p><ahref="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">Leetcode第3题</a>的C++实现部分代码(朴素，AC，超过6.4%)如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>            <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">int</span> h[<span class="hljs-number">50005</span>]= &#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, i, j, len;<br>            <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;           <span class="hljs-comment">// 1)</span><br>                j = i;<br>                <span class="hljs-built_in">memset</span>(h, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(h));   <span class="hljs-comment">// 2)</span><br>                <span class="hljs-keyword">while</span>(j &lt; n &amp;&amp; !h[s[j]]) &#123;<br>                    h[ s[j] ] = <span class="hljs-literal">true</span>;        <span class="hljs-comment">// 3)</span><br>                    len = j - i + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(len &gt; ans)<br>                        ans = len; <span class="hljs-comment">// 记录最长值len的同时，也记录下其左端位置i和右端位置j的值</span><br>                    ++j;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>• 1）枚举对应子串的左端点i；</p><p>• 2）清空哈希表h，其中<spanclass="math inline">\(h[s_j]=true\)</span>代表原字符串的第j个字符<spanclass="math inline">\(s_j\)</span>是否出现在以第i个字符为左端点的子串中；</p><p>•3）如果字符串s[i..j]中已经出现重复的字符，那么s[i..j+1],s[i..j+2],…,s[i..n−1]必然会有重复字符，所以这里不需要继续往下枚举，直接跳出内层循环即可。</p><p>这个算法执行完毕， ans就是我们要求的最长不重复子串的长度， [l,r]代表了最长不重复子串在原字符串的区间。正确性毋庸置疑，因为已经枚举了所有子串的情况，如果字符集的个数为z ，那么算法的时间复杂度就是O(n∗z) 。</p><p>上述朴素算法的求解过程，其动图和不动图如下所示：</p><table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/clip_image001.gif"alt="图片" />原图</th><th><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104150815148.png"alt="image-20240104150815148" /> （i=0)</th><th><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104150831827.png"alt="image-20240104150831827" />(i=1)</th><th><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104150853687.png"alt="image-20240104150853687" />（i=2)</th></tr></thead><tbody><tr class="odd"><td><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104151050940.png"alt="image-20240104151050940" /> （i=3)</td><td><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104151122690.png"alt="image-20240104151122690" /> （i=4)</td><td><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104151137103.png"alt="image-20240104151137103" /> （i=5、6、7)</td><td></td></tr></tbody></table><p>结论：字符串下标从 0开始编号，该样例最长无重复子串为：s[1:5]=“bcaed”，长度为 5。</p><p>复杂度分析：由于该串是字符串，而一般的字符集内最多256个不同的字符。所以时间复杂度基本就是O(n∗256) ，当 <span class="math inline">\(1\leqn\leq 10^7\)</span> 时，这个时间复杂度<spanclass="math inline">\(O(1e7∗256) \geq1e7\)</span>，是肯定会TLE的，必须需要想办法优化。</p><h3 id="对朴素算法进行优化">1.1.3 对朴素算法进行优化</h3><p>如果仔细思考上面例题1的朴素算法的求解过程，就会发现：枚举子串的时候有很多区间是重叠的，所以必然存在许多没有必要的重复计算。</p><p>我们考虑一个子串以i为左端点，j为右端点，且s[i..j−1]中不存在重复字符，s[i..j]中存在重复字符（换言之，s[j]和s[i..j−1]中某个字符产生重复）的情况。如下图所示。</p><div data-align="center"><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104152821376.png" width = 40%/></div><p>在上图的情况下，我们没必要再去检测 s[i..j+1], s[i..j+2],…, s[i..n−1]这几个字符串的合法性，因为当前情况s[i..j]是非法的，而这些字符串是完全包含s[i..j]的，所以它们必然也是不合法的。</p><p>那么我们可以把枚举的左端点i自增，即：i=i+1，这时，按照朴素算法的实现，右端点需要重置，即j=i，实际上这里的右端点可以不动。</p><p>可以这么考虑，由于s[j]这个字符和s[i..j−1]中的某个字符s[k](k值未知)产生了重复，那么如果现在必须要加入s[j]且整个串不能产生重复字符，也就意味着s[x]必须要出局，即i 必须在位置x的右侧，即满足 i&gt;k ，换言之， i可以一直自增，直到i=k+1，如下图所示：</p><div data-align="center"><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104153650717.png" width = 40%/></div><p>利用上述思路，我们重新实现 最长不重复子串 的算法， c++代码（改进，AC，超过70%）实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>            <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">-1</span>, len;   <span class="hljs-comment">// i=0, j=i-1代表 s[i:j] 为一个空串，从空串开始枚举</span><br>            <span class="hljs-type">int</span> h[<span class="hljs-number">50005</span>]= &#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-keyword">while</span> (j++ &lt; n - <span class="hljs-number">1</span>) &#123;              <span class="hljs-comment">// 外层循环看快指针j，快指针j右移前进，拓宽区间</span><br>                ++h[ s[j] ];<br>                <span class="hljs-keyword">while</span> (h[ s[j] ] &gt; <span class="hljs-number">1</span>) &#123;        <span class="hljs-comment">// 如果区间[i,j]不满足指定条件，</span><br>                    --h[ s[i] ];               <span class="hljs-comment">//   就调整慢指针i右移，收窄区间，直到满足指定条件为止</span><br>                    ++i;                       <span class="hljs-comment">//</span><br>                &#125;<br>                len = j - i + <span class="hljs-number">1</span>;               <span class="hljs-comment">// 此时的区间[i,j]是局部最优解，记录</span><br>                <span class="hljs-keyword">if</span>(len &gt; ans)                  <span class="hljs-comment">//        考虑刷新</span><br>                    ans = len;                 <span class="hljs-comment">// 可以在此处记录i和j，以记录最长区间的左右端</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于待定区间[i,j]，如何确定该区间是否符合指定条件（即区间内的字符不重复）呢？其实也很简单。只需要维护h[]和判断h[str[j]]&gt;1，如果判断成立，则表示重复，不符合条件。这是<spanclass="math inline">\(O(1)\)</span>的操作，满足区间的时效性。</p><p>算法执行完毕后，我们就可以得到最长不重复子串的长度为 ans ，并且 i 和j 这两个指针分别只自增 n次。当j右移时，i未动。当i右移时，j未动。两个指针都从未回退过。所以该算法的时间复杂度为<span class="math inline">\(O(n*2)=O(n)\)</span> 。</p><p>可以将第9行处的1改为k，以适应“求字符的重复次数不超过k次的最长子串”问题。</p><p>利用该优化算法优化后的最长不重复子串的求解过程如图所示：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/640%20(1).gif"alt="640 (1)" /><figcaption aria-hidden="true">640 (1)</figcaption></figure><p>对上述内容的简单总结是：当区间中存在重复（红色）字符时，左指针 i自增；否则，右指针 j 自增。</p><h2 id="尺取法双指针法">1.2 尺取法（双指针法）</h2><h3 id="算法定义">1.2.1 算法定义</h3><p>如1.1.3节所述，这种利用问题特性，<strong>通过两个指针，不断调整区间，从而求出问题最优解</strong>的模型就叫"<strong>尺取法</strong>"模型。由于利用的是两个指针，所以又叫 "双指针"模型。</p><p>这里 "尺"的含义，主要还是因为这类问题最终要求解的都是连续的序列（子串），就好比一把尺子一样，故而得名。</p><p><strong>双指针法</strong>（又称为“<strong>尺取法</strong>”）模型，是一个常用的优化技巧，用来解决<strong>序列的区间问题</strong>。</p><p>在双指针法中，会有两个指针i、j分别代表了区间的左右位置下标。它们有两种扫描方向：</p><p>1）反向扫描：i、j方向相反，i从左往右，j从右往左，在中间相会；</p><p>2）同向扫描：i、j方向相同，都从左往右，可以让j跑在i的前面。</p><p>其中，同向扫描的两个指针称为“<strong>快慢指针</strong>”。它们在序列上产生一个大小可变的“<strong>滑动窗口</strong>”，有多种灵活的运用。本帖研究的主要就是这种同向扫描。</p><h3 id="指定条件与代码模板的适用场合">1.2.2“指定条件”与代码模板的适用场合</h3><p>在1.2.1节中曾指出，双指针法，是用来解决序列的区间上的问题。如果问题是“要求从原始序列中抽取分散的多个数据”，这不是区间问题，不能用双指针法模型。如果要求连续区间，但不满足下述的“单调性”，则只能采用普通的办法。反之，如果是要找满足<strong>指定条件(<spanclass="citation" data-cites="1">@1</span>)</strong>的最<strong>短(<spanclass="citation" data-cites="2">@2</span>)</strong>/最<strong>长(<spanclass="citation"data-cites="3">@3</span>)</strong>的连续区间，则可以使用一定的套路模板。该模板会在1.2.3节中详述。</p><p>这里所说的"<strong>指定条件</strong>"的内涵并未明确化。对于本题来说，<strong>指定条件</strong>就是"字符不重复"。当然，其他题也可以是 "每个字符重复次数不超过 k次"，"至少包含 k 种字符"，"求和不大于 k " 等等，千变万化，因题而异。</p><p>如果要使用双指针法的代码模板，那么这个"指定条件"必须要满足以下两点：</p><p>1）待定区间的<strong>单调性</strong></p><p>所谓“单调性”，就是说：任意一个指针的增加，条件满足与否只会出现两种情况，即：【满足 -&gt; 不满足】或者 【不满足 -&gt; 满足】，<strong>不能出现【满足 -&gt; 不满足 -&gt; 满足】这样反复不定的情况。</strong></p><p>2）待定区间的<strong>时效性</strong></p><p><strong>所谓“时效性”，就是说：必须在 <spanclass="math inline">\(O(1)\)</span>或者 <spanclass="math inline">\(O(log_2⁡n)\)</span> 的时间内就能确定出当前区间 [i,j] 是否满足指定条件，否则无法用尺取法求解。</strong></p><h3 id="算法描述">1.2.3 算法描述</h3><p>在1.2.2节中我们提到了求最短<spanclass="math inline">\((@2)\)</span>和最长<spanclass="math inline">\((@3)\)</span>区间这两种情况。这两种情况，算法有差异，下面分开进行阐述。</p><h4 id="求最长区间">1.2.3.1 求最长区间</h4><ul><li><p>1）初始化i=0（数组从0存）/1（数组从1存） ,j=i−1，表示初始区间的长度为 0；</p></li><li><p>2）外层循环为<strong>快</strong>指针j，<strong>右拓宽</strong>区间，（右移j，j++）；</p></li><li><p>3）当区间<font color="red"><strong>不满足</strong></font>条件时，一直<strong>左收窄</strong>（内层循环）该新区间（慢指针i右移,i++),直到区间满足条件，结束内层循环；</p></li><li><p>4）此时的区间是局部最优解，<font color="red"><strong>记录</strong></font>，回到2）；</p></li></ul><p>之所以求最长区间，往往是因为当区间右拓宽之后，会导致区间不合法（否则直接拿[1,n]当答案得了）。所以，在步骤2）之后，需要持续检验新区间并左收窄之，直到新区间合法为止。</p><h4 id="求最短区间">1.2.3.2 求最短区间</h4><ul><li><p>1）初始化i=0（数组从0存）/1（数组从1存） ,j=i−1，表示初始区间的长度为 0；</p></li><li><p>2）外层循环为<strong>快</strong>指针j，<strong>右拓宽</strong>区间，（右移j，j++）；</p></li><li><p>3）当区间<font color="red"><strong>满足</strong></font>条件时，一直<strong>左收窄</strong>（内层循环）该新区间（慢指针i右移,i++),<font color="red"><strong>记录</strong></font>局部最优解，直到区间不满足条件，结束内层循环；</p></li><li><p>4）回到 2）；</p></li></ul><p>之所以求最短区间，往往是因为当区间右拓宽之后，虽然仍然合法（单调性决定），但区间不够短。所以，在步骤2）之后，需要持续检验新区间并左收窄之，尝试优化局部解，直到新区间不合法为止。</p><h1 id="二实战训练">二、实战训练</h1><h2id="视频教学链接"><a href="https://www.bilibili.com/video/BV1Mp4y1E74K/?_blank" target="_blank">视频教学链接：</a></h2><h2 id="最长无重复子串问题最长">2.1 最长无重复子串问题（最长）</h2><p><ahref="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">Leetcode第3题</a></p><p>题解代码见1.1.3节。</p><h2 id="区间和问题最短">2.2 区间和问题（最短）</h2><p><a href="http://poj.org/problem?id=3061"><strong>POJ 3061Subsequence</strong></a></p><p>【中文大意】现在有t组数据，每组数组中给定 <spanclass="math inline">\(n(10&lt;n&lt;10^5)\)</span> 个正数 <spanclass="math inline">\(a_i (0&lt;a_i \leq 10^4)\)</span> 和一个正数 <spanclass="math inline">\(p(0&lt;p&lt;10^8)\)</span>。找到一个最短的连续子序列，满足它的和 <span class="math inline">\(s\geqp\)</span>，输出该区间的长度值。如果全部加起来都不能&gt;=m，则该样例输出0。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">输入样例：<br>2  // 有2组数据<br>10 15                   // 第一组数据有10个正数，阀值p为15<br>5 1 3 5 10 7 4 9 2 8    // 10个数据<br>5 11                    // 第二组数据有5个正数，阀值p为11<br>1 2 3 4 5               // 5个数据<br>输出样例：               <br>2                       // 在第一组数据中，a4+a5=15&gt;=p=15，长度2，且是最短的<br>3                       // 在第二组数据中，a3+a4+a5=12&gt;=p=11，长度3，且是最短的   <br></code></pre></td></tr></table></figure><p>解题分析：</p><p>A. 单调性分析：对于一个连续子序列a[i..j] ，它所有数之和 s[i..j]<spanclass="math inline">\(=\sum_{k=i}^{j}a_k\)</span> 。如果我们已经知道<span class="math inline">\(s[i..j] \geq p\)</span>，那么就没必要再去求s[i..j+1] ( 因为a[j+1]&gt;0，所以s[i..j+1]= s[i..j]+ a[j+1] &gt; s[i..j] <span class="math inline">\(\geq p\)</span>，但题目要求找最短的区间，所以没必要再去求s[i..j+1])。所以基于这点，该题所述的“条件”满足单调性。</p><p>B. 时效性分析：可以定义前缀和数组 ，通过 O(1)的代价计算出给定区间[i..j]之间的连续子序列的和。O(1)的代价，这是具有时效性的。</p><p>C. 本题要求满足指定条件的一个区间[i,j]，但根据题意，有可能不存在这样的区间。（举个反例:"在1..10这个数列中找出一个区间，使得该区间数值和大于等于500万"，根本找不到这样的区间）。所以要留意区间长len=0的可能。</p><div data-align="center"><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240111160121957.png" width = 80%/></div><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//// 方法1：尺取法</span><br><span class="hljs-comment">// 基本题意：给长度为n (10 &lt; n &lt; 1e5)的数组，每个元素&lt;=1e4。另外有一个整数m(m&lt;1e9)，</span><br><span class="hljs-comment">//           求数组中数的总和&gt;=m的连续子序列的最小长度。如果全部加起来都不能&gt;=m，则</span><br><span class="hljs-comment">//           该样例输出 0</span><br><span class="hljs-comment">//  输入：</span><br><span class="hljs-comment">//  2组样例</span><br><span class="hljs-comment">//  n = 10，m = 15</span><br><span class="hljs-comment">//  5 1 3 5 10 7 4 9 2 8</span><br><span class="hljs-comment">//  输出：</span><br><span class="hljs-comment">//  2        (至少要有2个数，即5 10 这个子序列的和满足&gt;=15)</span><br><span class="hljs-comment">//  n = 5，m = 11</span><br><span class="hljs-comment">//  1 2 3 4 5</span><br><span class="hljs-comment">//  输出：</span><br><span class="hljs-comment">//  3        (至少要有3个数，即3 4 5 这个子序列的和满足&gt;=11)</span><br><br><span class="hljs-comment">//#include &lt;bits/stdc++.h&gt;</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br>LL data[maxn], le, ri, n, m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    LL t, i;<br>    cin &gt;&gt;t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        cin &gt;&gt;n &gt;&gt;m;<br>        <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>            cin&gt;&gt;data[i];<br>        &#125;<br>        le=<span class="hljs-number">1</span>;                      <span class="hljs-comment">// 区间左端至少应该是从第一个数开始</span><br>        LL minlen=n+<span class="hljs-number">1</span>;             <span class="hljs-comment">// 求符合条件的数的最小值的套路：先让最小值的初值为一个不可能的极大值，然后打擂台 </span><br>        LL sum=<span class="hljs-number">0</span>, len=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> ( ri=<span class="hljs-number">1</span>; ri&lt;=n; ri++) &#123; <span class="hljs-comment">// 快指针朝前进，作为主循环</span><br>            sum+=data[ri];         <span class="hljs-comment">// 区间已拓宽，处理相关事务（刷新sum和len）</span><br>            len++;<br>            <span class="hljs-comment">// 我们希望找到&quot;最短&quot;区间，所以每次拓宽区间的同时要想着能不能缩短区间(在符合条件的前提下)</span><br>            <span class="hljs-keyword">while</span> (sum-data[le] &gt;= m) &#123; <span class="hljs-comment">// 当区间[le+1, ri]合法时，连续尝试缩短区间</span><br>                sum= sum - data[le];  <span class="hljs-comment">// 缩短区间后，处理相关事务（刷新sum、le指针、len和minlen） </span><br>                le++;<br>                len--;<br>                <span class="hljs-keyword">if</span> (len&lt;minlen) &#123;<br>                    minlen= len;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (minlen==n+<span class="hljs-number">1</span>)       <span class="hljs-comment">// 如果全都不符合题意，即所有数加起来都不够m </span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, minlen);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入样例：</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">10 15</span><br><span class="hljs-comment">5 1 3 5 10 7 4 9 2 8</span><br><span class="hljs-comment">5 11</span><br><span class="hljs-comment">1 5 3 4 2</span><br><span class="hljs-comment">10 1000000</span><br><span class="hljs-comment">5 1 3 5 10 7 4 9 2 8</span><br><span class="hljs-comment">输出样例：</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">0 </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="luogu-p1147-连续自然数和img">2.3 <ahref="https://www.luogu.com.cn/problem/P1147">Luogu P1147连续自然数和</a><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230825170629229-1325480434.png"alt="img" /></h2><p>这个题，咋一看感觉像是“区间和”问题，但仔细分析发现：当区间拓宽或收窄时，都有可能会出现“不符合条件——符合——不符合”的情况。所以上面总结的两个代码模板，不适合本题。只能双指针硬干。</p><p>P1147 AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>,sum=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= m/<span class="hljs-number">2</span>) &#123;     <span class="hljs-comment">// 因为要求区间内至少2个数，所以左端数必然&lt;=m/2</span><br>        <span class="hljs-keyword">if</span>(sum&lt;m) &#123;       <span class="hljs-comment">// 不够就加右 </span><br>            j++;          <span class="hljs-comment">// 右拓宽 </span><br>            sum += j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum&gt;=m) &#123;      <span class="hljs-comment">// 超过就减左</span><br>            <span class="hljs-keyword">if</span>(sum==m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,i,j);<br>            sum -= i;     <span class="hljs-comment">// 左收窄</span><br>            i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一个类似的题目是<ahref="https://www.luogu.com.cn/problem/P1638">P1638</a>。其AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn= <span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> num,minwidth,le,j,ll,rr;<br><span class="hljs-type">int</span> n,m,a[maxn];  <span class="hljs-comment">// a[5]=3 表示第5幅画是3号画家画的</span><br><span class="hljs-type">int</span> cnt[<span class="hljs-number">2005</span>]; <span class="hljs-comment">// cnt[i]表示当前区间[le, j]内画家i的图画数</span><br><span class="hljs-comment">// cnt[10]=2 表示10号画家有2幅画在当前区间【le,j】里</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n, &amp;m);  <span class="hljs-comment">// n 幅画，m个画家</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    le=<span class="hljs-number">1</span>;      <span class="hljs-comment">// 区间左端至少应该是从第一个画家开始</span><br>    num=<span class="hljs-number">0</span>;     <span class="hljs-comment">// 当前区间内画家的人数</span><br>    minwidth=maxn;<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>; j&lt;=n; j++) &#123;  <span class="hljs-comment">// 快指针作为主循环</span><br>        <span class="hljs-comment">// 快指针前进，处理相关事情，尤其是num </span><br>        cnt[ a[j] ]++;      <br>        <span class="hljs-keyword">if</span>(cnt[ a[j] ]==<span class="hljs-number">1</span>) num++;<br><br>        <span class="hljs-keyword">while</span>(num&gt;=m) &#123; <span class="hljs-comment">//本题求最短区间，所以当该区间符合条件时，持续收窄区间</span><br>            <span class="hljs-comment">// 先记录</span><br>            <span class="hljs-keyword">if</span>(minwidth &gt; j-le + <span class="hljs-number">1</span>) &#123;   <br>                minwidth = j-le+<span class="hljs-number">1</span>;      <br>                ll=le;<br>                rr=j;<br>            &#125;<br>            <span class="hljs-comment">// 再收窄</span><br>            cnt[ a[le] ]--;<br>            <span class="hljs-keyword">if</span>(cnt[ a[le] ]==<span class="hljs-number">0</span>) num--;  <span class="hljs-comment">// 收窄时一定会影响到num的值 </span><br>            le++; <br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,ll,rr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入</span><br><span class="hljs-comment">12 5</span><br><span class="hljs-comment">2 5 3 1 3 2 4 1 1 5 4 3</span><br><span class="hljs-comment">输出</span><br><span class="hljs-comment">2 7</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="luogu-p1102-a-b-数对">2.4 <ahref="https://www.luogu.com.cn/problem/P1102">Luogu P1102 A-B数对</a></h2><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230825170629214-1614732805.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>本题已知C，要找有多少对“A-B”对。因为A和B都可能有多个，存在重复，且ABC都是正值，所以A必然大于B。对于每一个B，在排序后，存在连续的多个A符合题意。这多个A形成一个等值区间，用i和j-1来标识这个等值区间的左右端，即慢指针和快指针。当存在多个B时，i和j不变，能在<spanclass="math inline">\(O(1)\)</span>的效率内解决第二个、第三个B等，使得算法保持高效。i和j都不后退，所以算法效率为<spanclass="math inline">\(O(n)\)</span>。但因为需要先sort（sort函数效率<spanclass="math inline">\(O(n*log_2n)\)</span>），所以整体算法效率仍然是<spanclass="math inline">\(O(n*log_2n)\)</span>。</p><p>P1102 AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//  方法2：尺取法  详见“D双指针(尺取法)”  233ms</span><br><span class="hljs-comment">//  该方法和方法1高度相似，只是在for循环内确定i和j时，是采用快慢针前进。</span><br><span class="hljs-comment">//  快慢指针同步向右推进，k表示B，慢指针i指向第一个A，快指针j指向最后一个A的下一个元素 </span><br><span class="hljs-comment">//  因为快慢针并不会后退，所以二重循环的效率实际上是O(n)，优于方法1的O(n*logn) </span><br><span class="hljs-comment">//  </span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7 </span><br><span class="hljs-comment">//  k     i           j                    （1）ans=0+3 =3</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//     k  i           j                    （2）ans=3+3 =6</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//        k               i/j              （3）ans=6+0 =6</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//            k           i/j              （4）ans=6+0 =6</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//                k       i/j              （5）ans=6+0 =6</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//                    k    i          j    （6）ans=6+2 =8</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//                         k         i/j   （7）ans=8+0 =8</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//                              k    i/j   （8）ans=8+0 =8</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//                                    k    i/j=len+1  （9）ans=8+0 =8</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-type">const</span> LL N=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br>LL n,c,a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin&gt;&gt;n&gt;&gt;c;<br><span class="hljs-keyword">for</span>(LL k=<span class="hljs-number">1</span>; k&lt;=n; k++) cin&gt;&gt;a[k];<br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+n);<br><br>LL ans=<span class="hljs-number">0</span>;<br>LL i=<span class="hljs-number">1</span>, j=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(LL k=<span class="hljs-number">1</span>; k&lt;=n; k++) &#123; <span class="hljs-comment">//i&lt;=j</span><br><span class="hljs-keyword">while</span>(i&lt;=n &amp;&amp; a[i]-a[k]&lt; c) i++;   <span class="hljs-comment">// 此处不同于方法1，使用了快慢针 </span><br><span class="hljs-keyword">while</span>(j&lt;=n &amp;&amp; a[j]-a[k]&lt;=c) j++;  <span class="hljs-comment">// j指向相同值区间右端的下一个下标 </span><br>ans+=j-i;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="至少有k个重复字符的最长子串">2.5[至少有K个重复字符的最长子串</h2><p><ahref="https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/description/">Leetcode395</a></p><p>给你一个字符串s和一个整数k，请你找出s中的最长子串，要求该子串内的每一字符出现次数都不少于k。返回这一子串的长度。如果不存在这样的子字符串，则返回0。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：s = &quot;aaabb&quot;, k = 3<br>输出：3<br>解释：最长子串为 &quot;aaa&quot; ，其中 &#x27;a&#x27; 重复了 3 次。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：s = &quot;ababbc&quot;, k = 2<br>输出：5<br>解释：最长子串为 &quot;ababb&quot; ，其中 &#x27;a&#x27; 重复了 2 次， &#x27;b&#x27; 重复了 3 次。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><span class="math inline">\(1 \leq s.length \leq 10^4\)</span></li><li>s仅由小写英文字母组成</li><li><span class="math inline">\(1 \leq k \leq 10^5\)</span></li></ul><p>解题分析：</p><p>A.单调性分析：对于一个连续子序列a[i..j]，假设其区间长度为t，且满足条件（且此时k &gt; 1），那么将该区间长度扩成 t+1时（无论是往左扩还是往右扩）：</p><ol type="a"><li><p>如果新位置的字符在原有区间出现过，那必然还是满足出现次数大于 k次，这时候该新区间仍满足要求；</p></li><li><p>如果新位置的字符在原有区间没出现过，那新字符的出现次数只有 1次，这时候该新区间不满足要求；</p></li></ol><p>所以<strong>该题所要求的“条件”不满足区间的单调性</strong>，即不会随着区间的移动或者变化而肯定出现“不符合<spanclass="math inline">\(\rightarrow\)</span>符合”或者反之的情况。因此我们不能使用「二分答案法」，也<strong>不能直接使用</strong>「滑动窗口」思路的双指针法。</p><p>那么还有什么性质可以利用呢？这时候要留意数据范围「数值小」的内容。</p><p>题目说明了只包含小写字母（26个，为有限数据），如果我们把原题条件（区间内所包含的字符的重复次数至少为k次）<strong>改为新条件（区间内所包含的字符种类数量只能为t <span class="math inline">\((1 \leq t \leq26)\)</span>种）</strong>时，区间重新具有了单调性质。</p><p>当我们使用双指针的时候：</p><ol type="a"><li><p>右端点往右移动必然会导致字符类型数量增加（或不变）</p></li><li><p>左端点往右移动必然会导致字符类型数量减少（或不变）</p></li></ol><p>然后我们可以对t进行暴力枚举，范围从1到26，毕竟这也不大。然后可以看出，原题的答案区间必然会和我们在暴力枚举t的过程中找到的某个区间是一致的。例如s= "aaabb", k = 3的答案区间（子串aaa）必然会在我们枚举t=1时找到，而s ="ababbc", k = 2的答案区间（子串ababb）必然会在我们枚举t=2时找到。</p><p>B.时效性分析：当区间拓宽或收窄时，可以通过计数器数组来识别出从无到有的字符，或者从有到无的字符，通过O(1) 的代价判断出给定区间[i..j]是否符合新条件，具有时效性。</p><p>“搂草”的同时，还要“打兔子”！本题的最终目的是要找每种字符出现至少k次的最长子串，所以在双指针右移的过程中，顺带着还要记录区间内出现的每个字符的次数。这才是我们的最终目的！可以设置<strong>不达标字符（已出现在区间中，但个数不够k个）</strong>的个数less。当新增一个从无到有的字符时less++，若次数达到k次则less--；新减掉一个原本出现仅1次的字符时less--，新减掉一个原本出现了k次的字符时less++。当less==0时意味着区间没有不达标字符，即区间内所有字符都次数&gt;=k，记录该区间。</p><p>C.本题要求满足指定条件的一个区间[i,j]，但根据题意，有可能不存在这样的区间。（举个反例:"在aabbccdef这个字符串中找出一个区间，使得该区间每个字符都出现了至少10次"，根本找不到这样的区间）。所以要留意区间长len=0的可能。</p><p>AC代码如下：（8ms，超过45%）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestSubstring</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;                      <span class="hljs-comment">// 先假设找不到任何合法区间 </span><br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">1</span>; t &lt;= <span class="hljs-number">26</span>; t++) &#123;   <span class="hljs-comment">// 暴力枚举区间内出现的字符种数t </span><br>            <span class="hljs-comment">// 每次新的暴力枚举都需重置相关变量！ </span><br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;             <span class="hljs-comment">//  </span><br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br>            <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;             <br>            <span class="hljs-type">int</span> less = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (r &lt; n) &#123;               <span class="hljs-comment">// 双指针模板，快指针最多只到最后一个字符的下标n-1，</span><br>                <span class="hljs-comment">// 搂草，针对新进字符来处理tot</span><br>                cnt[s[r] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>                <span class="hljs-keyword">if</span> (cnt[s[r] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">1</span>) &#123;<br>                    tot++;                <span class="hljs-comment">// 处理tot </span><br>                    less++;<br>                &#125;<br>                <span class="hljs-comment">// 打兔子 </span><br>                <span class="hljs-keyword">if</span> (cnt[s[r] - <span class="hljs-string">&#x27;a&#x27;</span>] == k) &#123;<br>                    less--;<br>                &#125;<br><br>                <span class="hljs-keyword">while</span> (tot &gt; t) &#123;         <span class="hljs-comment">// 搂草，双指针模板。最长区间，当区间不合法时收窄左端 </span><br>                    cnt[s[l] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                    <span class="hljs-keyword">if</span> (cnt[s[l] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span>) &#123;<br>                        tot--;            <span class="hljs-comment">// 处理tot，模板 </span><br>                        less--;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (cnt[s[l] - <span class="hljs-string">&#x27;a&#x27;</span>] == k - <span class="hljs-number">1</span>) &#123;<br>                        less++;<br>                    &#125;<br>                    l++;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (less == <span class="hljs-number">0</span>) &#123;          <span class="hljs-comment">// 能到这里来，区间肯定合法，此时如果less也==0的话，就找到一个区间满足题意了 </span><br>                    ret = <span class="hljs-built_in">max</span>(ret, r - l + <span class="hljs-number">1</span>);<br>                &#125;<br>                r++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="poj2566-bound-found">2.6 POJ2566 Bound Found</h2><p>原题链接 ：<a href="http://poj.org/problem?id=2566">POJ2566</a></p><p>基本题意：给定一个数组n个元素和一个值t，求一个子区间使得其和的绝对值与t的差值最小，如果存在多个，任意解都可行。1&lt;=n &lt;= 1e5 ; 0&lt;= t &lt;= 1e9;</p><p>样例输入数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5 1             // 第1组样例：n=5个数   t=1次查询<br>-10 -5 0 5 10<br>3               // 查区间和的绝对值最靠近3的区间<br><br>10 2            // 第2组样例：n=10个数  t=2次查询<br>-9 8 -7 6 -5 4 -3 2 -1 0<br>5 11            // 查区间和的绝对值最靠近5的区间，查区间和的绝对值最靠近11的区间<br><br>15 2            // 第3组样例：n=15个数  t=2次查询<br>-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1<br>15 100          // 查区间和的绝对值最靠近15的区间，查区间和的绝对值最靠近100的区间<br>0 0             // 结束<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5 4 4 // 区间和为5，从4号到4号(网页此处写错了！输出测试样例给的是5 2 2，即区间[2,2]，该区间只有-5这个数，绝对值为5，与3的距离为3，最接近了。[4,4]这个5的下标没有[2,2]的小)<br>5 2 8           // 区间和5  从2号 到8号<br>9 1 1           // 区间和9  从1号 到1号<br>15 1 15         // 区间和15  从1号 到15号<br>15 1 15         // 区间和15  从1号 到15号<br></code></pre></td></tr></table></figure><p>分析：</p><p>之前的POJ3061题中，序列都是正数。随着区间拓宽，其sum呈现单调递增的特性。但是现在本题有正数有负数，其区间和不再具备单调性，而取绝对值之后，更不具备单调性了。不能直接用双指针法来做，需要想一下如何重构条件或者数据。</p><p>这个题我们首先能想到的是，既然要求区间之和，我们可以先利用前缀和数组，它能在O(1)的效率实现原区间求和。但必须要解决两个问题：</p><p>1）问题是如何枚举区间的左右端呢？</p><p>2)如何让每一次枚举出的区间更靠近所求的答案区间呢？</p><p>朴素做法就是先求前缀和数组s[]，然后基于该数组，for (ri=1..len)for(le=0..ri-1)这样去暴力枚举（因为前缀和数组有正有负，看似无规律，不单调）区间的左右端，然后用s[ri]-s[le]得到该区间和，然后看差值，求最小值。但这样做，并未解决问题2），每一次枚举都完全无视上一次枚举的比较结果，算法效率注定低下。</p><p>假设一个区间之和sum=data[le..ri]=s[ri]-s[le-1]，且sum&lt;t。那现在该如何调节？肯定是希望能扩大区间之和，即找到一个更大的s[<spanclass="math inline">\(\acute{ri}\)</span>]<font color="red">**(*)**</font>。但扩大区间之和，不能简单地理解为ri++,快指针在data[]上右移一格。因为data[]有正有负，s[]数组不是单调递增。所以不能简单地通过ri++来在data[]上拓宽区间。那我们如何去找一个比原来的s[ri]值更大的s[]值呢？</p><p>我们可以对s[]进行递增排序产生s2[]（也可以原地排序），弃用s[]原来的数据顺序关系，反正这种前后关系没有单调性，已无任何作用。（在排序之前注意要保存元素的原始序号pos，因为我们需要表示最初的data[]中的下标的区间。）因为s2[]是经过排序的，必然是单调递增的（<del>似乎这里是句废话</del>），所以当ri++，在s2[]上右移（<strong>理解的重点：不管是le或ri，都不是在data[]上右移！给一对le和ri，不要想成了data[le..ri]，非也！</strong>）后，s2[ri(新)]必然是&gt;s2[ri(旧)]的（单调性决定）。</p><p>排序之后，s[]单调递增，但其原元素发生了移动，所以s[ri].value -s[le].value 不再代表 sum(data[le+1] .. data[ri])！它代表的是sum(data[1..s[ri].pos]) - sum(data[1..s[le].pos])。虽然ri&gt;le，但是s[ri].pos 不一定大于 s[le].pos !所以在表示时，ll=min(s[ri].pos, s[le].pos)且rr=max(s[ri].pos,s[le].pos)</p><p>可能有人会说：因为s2[]是排序后的前缀和数组，举个例子：s2[4].v可能等于data[0..7]，根本就不等于s2[3].v+data[4]！但仔细一想，其实这个问题根本就不是什么问题。我们只需要找到比原来的s2[3].v更大一点的s2[7].v就达到<font color="red">**(*)**</font>处所述的“让sum变大”的目的了!看似好像在跳跃性地胡乱枚举，但实际上是递增地枚举。</p><p>1）当sum&lt;t时，ri在s2[]上右移；</p><p>2）当sum&gt;t时，此时再去ri++岂不是区间和更大？人家要最接近t值的区间和，你搞个越来越远是什么意思？果断不再ri++！此时意味着该le++，让le在s2[]上右移一格，换一个更大一点的s[<spanclass="math inline">\(\acute{le}\)</span>]，从而让sum变小一点。这样才能让sum越来越靠近t，算法高效！</p><p>原题链接中提供的三个样例都不太具有一般性，本帖重新列举一个更具一般性的输入样例和输出样例如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">输入样例：<br>10 1             //10个数，1次查询 <br>20 -25 10 5 -10 25 15 -10 15 5 <br>22               // 查找区间和绝对值最接近22的那个区间<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240119091130982.png" alt="image-20240119091130982" style="zoom:80%;" /></p><p>当ri=6，le=3时s2[6].v-s2[3].v= 20-5=15;这个结果15代表的是data[0..1]-data[0..3]=s[1]-s[3]= 20-5=15。虽然6&gt;3，但s2[6].pos=1 &lt; s2[3].pos=3！所以(&amp;1)<strong>此处data[0..1]-data[0..3]无法表达成data[2..3]，所以在data[]上表示这个区间时，假设区间为[ll+1,rr]，那么ll=<font color="red">min(1, 3)</font>=1 =min(s2[6].pos,s2[3].pos)，且rr= <font color="red">max(1, 3)</font>=3 =max(s2[6].pos,s2[3].pos)</strong>。然后把ll+1，得到2，最终得到区间为[2..3]，即data[2..3]。</p><p>但此时因为15&lt;22，需继续找个更大的区间，ri++，因为s2[7].v=s2[6].v=20，所以继续ri++，ri=8。</p><p>当ri=8，le=3时s2[8].v-s2[3].v= 30-5 =25;这个结果25代表的是data[0..7]-data[0..3]=s[7]-s[3]= 30-5 =25。ll= min(3,7)=3，且rr=max(3,7)=7。然后把ll+1，得到4，最终得到区间为[4..7]，即data[4..7]，其和25更接近22。</p><p>不管是sum&gt;t或者sum&lt;t，都无法预知下一次尝试是否更接近t，所以都需要记录和考虑刷新。但如果当sum==t时，没有什么区间比这更优了，首次遇到就不再尝试后续，结束程序。</p><p>需要注意的是：</p><ol type="1"><li><p>我们需要将下标为0的元素的id和sum字段都设置为0，并将该元素参与排序。这样当遇到类似s[7]-s[0]时，表示的是data[0..7]-data[0..0]=data[1..7]。</p></li><li><p>因为sum[j]-sum[i]表示的是[i+1,j]，此外在最后得到的答案左区间都 +1</p></li><li><p>网页上输出样例的第一组数据有毒，写错了。但其OJ系统的测试数据没问题，应该就是网页上写错了而已。</p></li><li><p>s[0]的初始化每次都要做，而且要先做，因为后面求前缀和时会用到s[0]</p></li><li><p>long long类型求绝对值需要用 llabs(long long)函数</p></li></ol><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>     <span class="hljs-comment">// sort()需要 </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span>         <span class="hljs-comment">// llabs()需要 </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>LL value;<br>LL pos;<br>&#125;;<br>LL data[maxn];<br>node s[maxn];<br>LL le, ri, n, t, k;<br>LL sum, ll, rr;<br>LL mindis;     <span class="hljs-comment">// 记录区间和与k之间的最近距离值（绝对值，正）</span><br>LL ans;        <span class="hljs-comment">// 记录具有这个最近距离值的区间之和值</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node x1, node x2)</span> </span>&#123;<br><span class="hljs-keyword">return</span> x1.value &lt; x2.value;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;t), !(n==<span class="hljs-number">0</span>&amp;&amp;t==<span class="hljs-number">0</span>)) &#123;<br>    s[<span class="hljs-number">0</span>].pos=<span class="hljs-number">0</span>;                 <span class="hljs-comment">// 别忘了先做初始化这个，排序后元素顺序会打乱，s[0]将可能会不再是(0,0)  </span><br>    s[<span class="hljs-number">0</span>].value=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(LL i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;    <span class="hljs-comment">// 需要先初始化好s[0]之后才能for，因为此处用到了原s[0] </span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;data[i]);<br>        s[i].value = s[i<span class="hljs-number">-1</span>].value + data[i];  <span class="hljs-comment">// 此时，s[ri].value - s[le].value代表sum(data[le+1] .. data[ri])，前缀和基本定义 </span><br>        s[i].pos = i;<br>        &#125;<br>        <br>    <span class="hljs-built_in">sort</span>(s, s+<span class="hljs-number">1</span>+n, cmp);        <span class="hljs-comment">// 需要把s[0]也参与排序</span><br>        <br>    <span class="hljs-keyword">while</span>( t-- ) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;k);<br>        le=<span class="hljs-number">0</span>;                   <span class="hljs-comment">// 因为s[ri].value - s[le].value代表sum(data[le+1] .. data[ri])，所以le应从0号开始，这样区间左端从1开始 </span><br>        ri=<span class="hljs-number">1</span>;<br>        mindis = <span class="hljs-number">1e17</span>+<span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">while</span>( ri&lt;=n ) &#123;        <span class="hljs-comment">// 也可以用for(ri=1; ri&lt;=n; ri++)  </span><br>            LL sum = s[ri].value - s[le].value; <span class="hljs-comment">// sum=sum(data[1..s[ri].pos]) - sum(data[1..s[le].pos])  &gt;0 </span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">llabs</span>(sum-k) &lt; mindis) &#123;        <span class="hljs-comment">// 如果le和ri表示的这个区间更优（更贴近 k），则更新mindis、ans、ll和rr  </span><br>                mindis = <span class="hljs-built_in">llabs</span>(sum-k);          <span class="hljs-comment">// </span><br>                ans = sum;<br>                ll=<span class="hljs-built_in">min</span>(s[ri].pos, s[le].pos)+<span class="hljs-number">1</span>; <span class="hljs-comment">// 此处解释见题解的(&amp;1)处 </span><br>                rr=<span class="hljs-built_in">max</span>(s[ri].pos, s[le].pos);<br>                &#125;<br>                <span class="hljs-comment">// 排序后的s[]是单调递增的，所以s[ri+1].value &gt;= s[ri].value  &gt;= s[le+1].value &gt;= s[le].value的，</span><br>                <span class="hljs-comment">// 也就是说，sum(data[1..s[ri+1].pos])必然是大于等于sum(data[1..s[ri].pos])的 </span><br>                <span class="hljs-comment">// 如果区间之和值sum少于k，应想办法增大sum值。故而选择了这个s[ri+1].value。</span><br>                <span class="hljs-comment">// s[ri+1].value - s[le].value  &gt; s[ri].value - s[le].value</span><br>            <span class="hljs-keyword">if</span> (sum &lt; k)        <br>                ri++;<br>                <span class="hljs-comment">// 如果区间和值sum在k的右侧，应想办法减小sum值。故而选择更大一点的s[le+1].value。</span><br>                <span class="hljs-comment">// s[ri].value - s[le+1].value  &lt; s[ri].value - s[le].value</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; k)<br>                le++;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;          <span class="hljs-comment">// 没有比这更完美的了，不必再算后续，跳出循环，输出 </span><br>                <br>            <span class="hljs-keyword">if</span> (le == ri)       <span class="hljs-comment">// 不允许也不考虑空区间，所以不允许le==ri，一旦相等，ri强行前进一格 </span><br>                ri++; <br>            &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld %lld\n&quot;</span>, ans, ll, rr);<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">5 1</span><br><span class="hljs-comment">-10 -5 0 5 10</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">10 2</span><br><span class="hljs-comment">-9 8 -7 6 -5 4 -3 2 -1 0</span><br><span class="hljs-comment">5 11</span><br><span class="hljs-comment">15 2</span><br><span class="hljs-comment">-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1</span><br><span class="hljs-comment">15 100</span><br><span class="hljs-comment">0 0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输出</span><br><span class="hljs-comment">5 2 2  // 网页数据有误！测试数据没问题 </span><br><span class="hljs-comment">5 2 8</span><br><span class="hljs-comment">9 1 1</span><br><span class="hljs-comment">15 1 15</span><br><span class="hljs-comment">15 1 15</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="poj2739-sum-of-consecutive-prime-numbers">2.7 POJ2739 Sum ofConsecutive Prime Numbers</h2><p><ahref="http://poj.org/problem?id=2739">POJ2739</a>的AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    一个整数分解为连续的素数之和，有多少种分法? 这是一个“区间和精确相等”的问题，</span><br><span class="hljs-comment">    因为“精确相等”不满足单调性，但“正数的累加和”是有单调性的，所以可在模板基础</span><br><span class="hljs-comment">    上微调即可。 </span><br><span class="hljs-comment">    思路：</span><br><span class="hljs-comment">    1. 打表，先打出素数表</span><br><span class="hljs-comment">    2. 然后用尺取法查询是否精确等？若s&lt;num就继续ri++，若s&gt;num就le++，若s==num就统计 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxn 10000+16        <span class="hljs-comment">// 1万以内求素数 </span></span><br>vector&lt;<span class="hljs-type">int</span>&gt; primes;<br>vector&lt;<span class="hljs-type">bool</span>&gt; is_prime;<br><br><span class="hljs-comment">// 暴力打表，也可以把这个代码单独开一个cpp文件来写，然后把打印结果复制为POJ2739的全局数组。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_prime</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化vector的前10000个元素均为true</span><br>    is_prime = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(maxn + <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 0和1都不是素数</span><br>    is_prime[<span class="hljs-number">0</span>] = is_prime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 埃氏筛法求素数，填入primes[]中。此处也可以换成欧拉筛法</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; maxn; i++) &#123;<br>        <span class="hljs-keyword">if</span> (is_prime[i]) &#123;<br>            primes.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i * <span class="hljs-number">2</span>; j &lt; maxn; j += i) &#123;<br>                is_prime[j] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-built_in">init_prime</span>();<br>    <span class="hljs-type">int</span> size = primes.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; num &amp;&amp; num) &#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>, s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>,r = <span class="hljs-number">0</span>; r&lt;size;  ) &#123;<br>            <span class="hljs-comment">// s没加够，且右边还有数可以继续加，那就一直加（因为正数的累加和是有单调性的）</span><br>            <span class="hljs-keyword">while</span> (r&lt;size &amp;&amp; s&lt;num)<br>                s = s + primes[r++];<br>            <span class="hljs-keyword">if</span> (s == num)  <span class="hljs-comment">// 找到一个方案，记上</span><br>                result++;<br>            <span class="hljs-comment">// 不管找没找到一个方案，如果r还没走到底而s已经超过num，就砍掉左端l++,s-=，然后循环上去继续r右移</span><br>            s -= primes[l++];<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, result);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入1： </span><br><span class="hljs-comment">17</span><br><span class="hljs-comment">输出1： </span><br><span class="hljs-comment">2     （2+3+5+7，17） </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="poj2100-graveyard-design">2.8 POJ2100 Graveyard Design</h2><p><a href="http://poj.org/problem?id=2100">POJ2100</a>的AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">给一个数 n （1 &lt;= n &lt;= 10^14）。</span><br><span class="hljs-comment">求一段连续的数的数字，使得其平方和等于n。</span><br><span class="hljs-comment">输出的时候，先输出有多少组解，然后换行，每一行输出一组解内的元素个数，及这些元素的数值。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    学习本代码，需要预先掌握尺取法的基本思想。本题思路和POJ2739很相似</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">注意typedef的这种写法，要学会</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">注意pair的使用，虽然本题还可以用其他结构来实现，但建议学会pair的使用。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;    <span class="hljs-comment">//  基本上等效于 #define LL long long</span><br>vector&lt;pair&lt;LL, LL&gt; &gt; ans;    <span class="hljs-comment">// 这里一定要注意这个&quot;&gt; &gt;&quot;之间要有空格</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(LL n)</span> </span>&#123;<br>    LL l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>, sq;<br>    <span class="hljs-comment">// 这里写成死循环比较方便一些！ </span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// r是否要右移。不在外层循环中决定，而是在内层循环中决定</span><br>        <span class="hljs-keyword">while</span> (sum &lt; n) &#123; <span class="hljs-comment">//当sum不够n时，因为区间平方和是单调的，所以右移r以扩大区间，从而扩大sum</span><br>            sq = r * r;<br>            sum += sq;<br>            r++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sq &gt; n)   <span class="hljs-comment">// 如果一个数的平方和都已经超过n，那后面不可能再有符合要求的区间了。可以输结果了 </span><br><span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// 当sum&gt;=n时走到这里来</span><br>        <span class="hljs-keyword">if</span> (sum == n)<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(l, r));    <span class="hljs-comment">// 注意，这里表示的是[l, r-1],因为r在while里多加了一次</span><br>        <span class="hljs-comment">// 不管有没有找到一个解，都需要慢指针右移，慢指针前行</span><br>        sum -= l * l;<br>        l++;<br>    &#125;<br><br>    <span class="hljs-comment">// 下面的代码都在凑输出</span><br>    LL size = ans.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, size);<br>    <span class="hljs-keyword">for</span> (LL i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        LL ansr = ans[i].second;<br>        LL ansl = ans[i].first;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,ansr-ansl);              <span class="hljs-comment">// 因为ansr偏大了1，所以这里算区间长度不需要再加1了</span><br>        <span class="hljs-keyword">for</span> (LL j=ansl; j&lt;ansr; j++)           <span class="hljs-comment">// ansr偏大了1，所以j最多到ansr-1就可以了</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %lld&quot;</span>, j);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);      //读入数据生成器造出来的数据</span><br><span class="hljs-comment">//    freopen(&quot;test.txt&quot;, &quot;w&quot;, stdout);   //输出答案</span><br>    <br>    LL n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;n);<br>    <span class="hljs-built_in">solve</span>(n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p1381-单词背诵">2.9 P1381 单词背诵</h2><p>视频链接：<ahref="https://www.bilibili.com/video/BV1MP411W7tk">双指针P1381（单词背诵）</a></p><p>原题链接：<ahref="https://www.luogu.com.cn/problem/P1381">P1381（单词背诵）</a></p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230825182436716-225604155.png" alt="img" style="zoom: 67%;" /></p><p>题意表述不太准确，需要澄清：文章由 <em>m</em>个单词构成，在该文章中找出连续的一段，其中包含<strong>最多种类</strong>（允许不包含完目标单词表的所有目标单词）的目标单词（重复的单词只算一种），且允许子串内包含其他非目标单词。并且在目标单词种类尽量多的前提下，还要使选出的文章区间尽量短。</p><p>举个例子：假如现在目标单词为A，B，C,D（为了表述方便，特意将每个目标单词假设为单字母大写，非目标单词假设为单字母小写），文章为hACnnBgC。其中“AC”是“包含两种目标单词”的最短子串，但“hACnnBgC”中存在有子串“ACnnB”和“ACnnBgC”这两个子串（不止这两个）包含了三种目标单词。根据题意，种类较多的胜出（哪怕长度值大于“AC”），所以最终答案在这些包含了三种目标单词的子串中选择，很明显最终答案是“ACnnB”，更短。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240121173427411.png"alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    基本题意：求文章中出现单词种数最多且最短的连续区间</span><br><span class="hljs-comment">    如果种数不是最多的，不是答案！ 如果不够短，不是答案！ </span><br><span class="hljs-comment">    如果该区间内有非单词表的单词，允许！</span><br><span class="hljs-comment">*/</span> <br><span class="hljs-type">int</span> n,m;<br>string s[<span class="hljs-number">100005</span>],s1;    <span class="hljs-comment">//s[] 记录文章中的所有单词</span><br>map&lt;string,<span class="hljs-type">bool</span>&gt; wordmp;<span class="hljs-comment">//wordmp[] 记录目标单词表中的所有单词</span><br>map&lt;string,<span class="hljs-type">int</span>&gt; cntmp;  <span class="hljs-comment">//cntmp[] 记录文章当前区间内各个目标单词出现的次数</span><br><span class="hljs-type">int</span> sum;                <span class="hljs-comment">//sum 记录文章中出现单词表的单词数（不算重复的）</span><br><span class="hljs-type">int</span> len;                <span class="hljs-comment">//len 记录包含表中单词最多的区间的最短长度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    cin&gt;&gt;s1,wordmp[s1]=<span class="hljs-number">1</span>;<br>cin&gt;&gt;m;                   <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>,i=<span class="hljs-number">1</span>; j&lt;=m; j++) &#123; <span class="hljs-comment">//i&lt;=j</span><br>    cin&gt;&gt;s[j];<br>        <span class="hljs-comment">// 处理快指针j的相关事务 </span><br>    <span class="hljs-keyword">if</span>(wordmp[s[j]])        <span class="hljs-comment">//如果新进单词是目标单词表里的单词，就累加其出现次数 </span><br>        cntmp[s[j]]++;<br>    <span class="hljs-keyword">if</span>(cntmp[s[j]]==<span class="hljs-number">1</span>)      <span class="hljs-comment">//如果新进单词是第一次出现，更新sum和len </span><br>        sum++, len=j-i+<span class="hljs-number">1</span>;   <span class="hljs-comment">//重难点！区间出现新单词时，放弃原来的len值，重新存新的区间长度，因为新区间内的目标单词“更多”，但不够精简 </span><br>            <br>        <span class="hljs-comment">// 本题求最短区间，所以考虑收窄区间</span><br>        <span class="hljs-comment">// 应收窄的情况1. 左端单词出现多次，则可以放弃1次左端单词，不影响区间内单词种数</span><br>        <span class="hljs-comment">// 应收窄的情况2. 左端单词不是目标单词表内的单词，直接无视，收窄 </span><br>    <span class="hljs-keyword">while</span>(i&lt;=j &amp;&amp; (cntmp[s[i]]&gt;=<span class="hljs-number">2</span> || !wordmp[s[i]])) &#123;<br>        <span class="hljs-keyword">if</span>(cntmp[s[i]]&gt;=<span class="hljs-number">2</span>)     <span class="hljs-comment">// 如果区间左端的单词在区间内有重复，则可以把它忽视掉，毕竟右侧还有它的其他副本 </span><br>            cntmp[s[i]]--,i++; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!wordmp[s[i]]) <span class="hljs-comment">// 如果当前区间左端的单词是目标单词表里的单词，直接无视，收缩区间 </span><br>            i++; <br>        &#125;<br>    len=<span class="hljs-built_in">min</span>(len,j-i+<span class="hljs-number">1</span>);     <span class="hljs-comment">//收窄，更新len </span><br>    &#125;<br>cout&lt;&lt;sum&lt;&lt;endl&lt;&lt;len&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="abc098d-xor-sum-2">2.10 [ABC098D] Xor Sum 2</h2><p>视频链接：<ahref="https://www.bilibili.com/video/BV1h14y117rq">[ABC098D] Xor Sum2</a></p><p>原题链接：<ahref="https://www.luogu.com.cn/problem/AT_arc098_b">[ABC098D] Xor Sum2</a></p><p>大致题意：</p><p>给你一串数a[]，求出满足<spanclass="math inline">\(a_l+a_{l+1}+...+a_r=a_l \enspace xor\enspace  a_{l+1}\enspace...\enspace xor \enspace a_r (l \leqr)\)</span>的<span class="math inline">\((i,j)\)</span>的数量。已知<spanclass="math inline">\(1 \leq n\leq2*10^5,\quad 1\leq i\leq n,\quad 0\leqa_i\leq2^{20}\)</span>。</p><p>预备知识：本题涉及到了“异或”操作，这是一个按位进行的操作。</p><p>初步分析：这个题求"有多少个符合题意要求的连续区间"，并不求"最长区间"，也不求"最短区间"，不能用1.2.3节总结出来的套路模板,但因为是求连续区间，所以仍可以用普通的双指针法。下面做1.2.2节中讲到的单调性分析和时效性分析。</p><p>1）单调性分析：本题求区间的个数，有点类似于“求逆序对的个数”这种风格，必然会涉及到对两个数的暴力枚举。但如果是无脑枚举，<spanclass="math inline">\(O(n^2)\)</span>的效率，复杂度为4e10，是会TLE的。不可取。题目涉及到的是连续区间。也就是说，区间内的所有数，代入公式，条件成立。如果遇到区间[l,r]内的某一个数<span class="math inline">\(a_k\)</span>代入该公式后<spanclass="math inline">\(a_l+...+a_k+...+a_r \neq a_l \enspace xor...\enspace xor\enspace  a_k\enspace...\enspace xor \enspace a_r (l &lt;k\le r)\)</span>，则需放弃该区间[l,r]。对于[l,r]，假设l固定不动，随着r的右移，区间变宽，只会出现“符合<spanclass="math inline">\(\Rightarrow\)</span>不符合”的情况，而不会出现“符合<spanclass="math inline">\(\Rightarrow\)</span>不符合<spanclass="math inline">\(\Rightarrow\)</span>符合”的情况。<strong>所以本题的“条件”具备单调性</strong>。一旦出现了上述这个<spanclass="math inline">\(a_k\)</span>，则k右侧的所有端点不必再枚举了，区间必定是不符合条件的。所以这里不应该盲目地采用<spanclass="math inline">\(O(n^2)\)</span>的效率去无脑枚举。</p><p>2）时效性分析：对于一个给定的区间[l,r]，假设该区间已经符合公式，有sum[l..r]=sumxor[l..r]。现在r尝试右移，仍然可以在O(1)的效率内计算出sum[l..r]+data[r+1]的值，以及sumxor[l..r]xor data[r+1]的值，进而判断是否相等。即该条件的判定具有时效性。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230826095827743-1068963304.png" alt="img" style="zoom:80%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230826095827887-317965124.png" alt="img" style="zoom:80%;" /></p><p>在上图的样例中，一共有9个区间符合公式条件。i不动的前提下，j指针每次尝试右移前先判定，符合就右移，答案数+1，换句话说，j右移一次，答案数加1，直到不符合条件。所以当i不动的前提下，贡献的答案数其实就是不符合之前的区间宽度，即j-i+1。然后i右移，j归位到i，再周而复始，直到i到最右侧。所以“j到最右侧”并不是外层循环的结束条件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL; <span class="hljs-comment">// 或者#define LL long long</span><br>LL a[<span class="hljs-number">200005</span>];<br>LL s1,s2,ans;<br><span class="hljs-comment">//s1:算术和, s2:异或和, ans:方案数</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) cin&gt;&gt;a[i];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>; i&lt;=n; ) &#123; <span class="hljs-comment">//外层循环以慢指针i到最右为止。可以看出，双指针法需要具体情况具体分析</span><br>        <span class="hljs-comment">// 当i不变时，让j走到不符合条件之前停下来</span><br>        <span class="hljs-keyword">while</span>(j+<span class="hljs-number">1</span>&lt;=n&amp;&amp;s1+a[j+<span class="hljs-number">1</span>]==(s2^a[j+<span class="hljs-number">1</span>])) &#123; <span class="hljs-comment">//预判，这里不能先改j的值！</span><br>            j++;<br>            s1+=a[j];    <span class="hljs-comment">// 累加和</span><br>            s2^=a[j];    <span class="hljs-comment">// 累异或和</span><br>        &#125;<br>        ans += j-i+<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 慢指针i前进，刷新</span><br>        s1-=a[i];<br>        s2^=a[i];<br>        i++;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 线性结构基础算法 </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
