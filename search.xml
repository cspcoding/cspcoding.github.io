<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>区间分段dp（“萝卜填坑”）模型</title>
      <link href="/2024/07/21/%E5%8C%BA%E9%97%B4%E5%88%86%E6%AE%B5dp%EF%BC%88%E2%80%9C%E8%90%9D%E5%8D%9C%E5%A1%AB%E5%9D%91%E2%80%9D%EF%BC%89%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/07/21/%E5%8C%BA%E9%97%B4%E5%88%86%E6%AE%B5dp%EF%BC%88%E2%80%9C%E8%90%9D%E5%8D%9C%E5%A1%AB%E5%9D%91%E2%80%9D%EF%BC%89%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="模型说明">1.1 模型说明</h2><p>　　现在有K个数据依次排成一条线，不允许移动。给定这一条线上任意两个位置之间（形成了一个区间）的收益值<spanclass="math inline">\(value[\ le\ ][\ ri\]\)</span>，现在需要将这K个数据的线分割成<span class="math inline">\(P(1\leq P \leqK)\)</span>段，求分割后的收益最大值/最小值（为了讲解方便，在第一章中我们统一用“最大值”）。</p><p>　　这种题型看上去有点像是区间DP，不过和正规的区间DP在dp数组定义、求解思路等方面都有一些差别。因为这种题型还是涉及到了“在区间中进行决策”，所以我们把它归于“区间DP”这个大类中来了。</p><h2 id="分析">1.2 分析</h2><p>　　因为我们需要将K个数据分割成N段，所以我们完全可以把这N段设置为N个阶段，这种划分满足“局部最优”和“无后效性”这两大特点，所以这种题型可以用dp这种大模型来搞定。</p><ol type="1"><li>状态数组定义</li></ol><p>　　我们用状态数组dp来存放最大收益值。既然如此，我们的dp数组的维度就要能够准确地描述出一个唯一的状态，或者说是一种划分。划分不仅和“数据”有关，也和划分的“段”有关。所以有如下的二维数组定义：</p><p>　　dp[p][k]：<strong>把前k个数据划分成p段后得到的最大收益值；</strong></p><ol start="2" type="1"><li><p>所求目标</p><p>dp[P][K]：把K个数据划分成P段后得到的最大收益值；</p></li><li><p>状态转移方程</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240721150540525.png" alt="image-20240721150540525" style="zoom:80%;" /><span class="math display">\[dp[p][k]= dp[p-1][c]\ \ \ + value[c+1][k] \tag{1}\]</span><font color="red"><strong>把前k个数据划分成p段的收益值　=　把前c个数据划分成p-1段的收益值　+　在从[c+1..k]这1段数据中获得的收益值（假设是求和值）</strong></font></p><p>上面的公式，只是一次划分或者一次“决策”。根据定义，还需要所有决策值比较，获得最大值。所以状态转移方程如下：<span class="math display">\[\begin{align}dp[p][k]=max(dp[p-1][c]+value[c+1][k]) \tag{2} \\(1 \leq p \leq P,\quad p \leq k \leq K,\quad p-1 \leq c \leq k-1 )\tag{}\end{align}\]</span></p><p>　　上面的公式（2）只是一个数学简式，并不是一个真正的C++代码。如果要转成代码，需要考虑max函数和循环的特点。伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[p][k]= -INF;  <span class="hljs-comment">// 初值设为负无穷，为“无解”状态的初始值， 以方便max运算出正确的结果</span><br><span class="hljs-keyword">for</span> (p)          <span class="hljs-comment">// 省略了部分代码</span><br>    <span class="hljs-keyword">for</span>(k)<br>        <span class="hljs-keyword">for</span>(c)<br>            dp[p][k]= <span class="hljs-built_in">max</span>(dp[p][k], dp[p<span class="hljs-number">-1</span>][c]+value[c+<span class="hljs-number">1</span>][k]);<br></code></pre></td></tr></table></figure><p>　　这里我们假设了整个划分方案的收益值是每个分段收益值之和，所以方程中出现了“dp<font color="red"><strong>+</strong></font>value”。这是一个假设，并不绝对。同学们不必死背公式，一定要理解着来推。</p></li><li><p>循环顺序和循环边界</p></li></ol><p>　　在公式（2）的状态转移方程中有3个变量，分别为p、k、c。第p行依赖于第p-1行，而c&lt;k。这里我们需要分析一下变量k和变量c的取值范围。</p><p>1）k：因为这种题型基本上都要求每段至少要有1个数据，所以要把k个数据划分成p段，必然要求<spanclass="math inline">\(k \geqp\)</span>，所以<strong>k的循环取值范围是[p..K]</strong>；对于状态[p][0..p-1]，一律视为“无解”的状态，赋予他们“无解”该有的初值即可。</p><p>2）c：<strong>决策点c值的循环取值范围是[p-1..k-1]</strong>，其详细推导过程如下，请展开阅读。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">假设现在有8个数据，需要分成3段。如果要求每段至少要有1个数据的话，划分结果只能是如下几种：<br>    1)　&#123;[1..1]、  [2..2（第3段的决策点c值）]、  [3..8]&#125;<br>    2)　&#123;[1..1]、  [2..3（第3段的决策点c值）]、  [4..8]&#125;<br>    3)　&#123;[1..2]、  [3..3（第3段的决策点c值）]、  [4..8]&#125;<br>          ......// 太多了，这里不全列出来了，<br>    *)　&#123;[1..4]、  [5..7（第3段的决策点c值）]、  [8..8]&#125;<br>    *)　&#123;[1..6]、  [7..7（第3段的决策点c值）]、  [8..8]&#125;<br>对于第2段的右端点（即划分第3段的决策点c值），只可能是2、3、4、5、6、7。<br>我们把上面的结果推广一下，如果有k个数据需要划分成p段，那么决策点c值的取值范围是[p-1..k-1]。记住这个结论。<br></code></pre></td></tr></table></figure><p>　　所以循环顺序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// P 个阶段，每个阶段划分出一段，必须增序</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p=<span class="hljs-number">1</span>; p&lt;=P; p++)             <span class="hljs-comment">// [1..P]</span><br>    <span class="hljs-comment">// 增序、降序均可，数据来源于上一行</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=p; k&lt;=K; k++)          <span class="hljs-comment">// [p..K]或者[K..p]</span><br>        <span class="hljs-comment">// 必须增序，从左往右填</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=p<span class="hljs-number">-1</span>; c&lt;=k<span class="hljs-number">-1</span>; c++)  <span class="hljs-comment">// [p-1..k-1]</span><br></code></pre></td></tr></table></figure><p>　　可以看出，这是一个时间复杂度为<spanclass="math inline">\(O(P*K^2)\)</span>的算法。</p><ol start="5" type="1"><li>初始化和特例</li></ol><p>　　整个dp[0..P][0..K]数组并不会全部被填写。循环没有遍历到的网格，必然就是不可能出现的状态（例如dp[10][3]，把3个数据划分成10段，这没法搞，直接“无解”），所以整个dp数组需要初始化成“无解”状态对应的值。</p><p>　　对于特例，</p><p>　　dp[0][0]表示把前0个数据划分成0段后得到的最大收益值；这里没有提供任何数据，要求0段（即不划分），很简单，什么都不做即为合理的做法，收益值为0.</p><p>　　dp[0][1]表示把前1个数据划分成0段后得到的最大收益值；把1个数据划分为0段，描述不合理，无法实现，无解，收益值为“无解”对应的取值INF。</p><p>　　从上面两条可以看出，特例只有<strong>dp[0][0]=0</strong>,而dp[0][1..K]则和其他行的数据一样，不是特例，应初始化为"无解"。</p><p>　　个别题可能会把dp[i][i]归于特殊情况，需要酌情考虑给予恰当的值。</p><h1 id="二实战训练">二、实战训练</h1><h2 id="p1281">2.1 1278/P1281</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1278">1278：【例9.22】复制书稿(book)</a>/<ahref="https://www.luogu.com.cn/problem/P1281">P1281 书的复制</a></p><h3 id="分析-1">2.1.2 分析</h3><p>　　要求把K本书分给P个人，每个人分到的书必须是连续的，这实际上就是一个“线性有序条件下的分段”的问题。每个分段内所需时间为该分段内每一本书所需时间之和，而整个划分方案的收益值为该方案中所有分段内部所需时间的最大值。现在要求整个方案的最小所耗时间。看上去有点像个min(max(sum()))的架构，挺吓人的，哈哈～</p><ol type="1"><li><p>状态数组定义</p><p>　　dp[p][k]：把前k本书划分给p段（每个人1段）后得到的最小时间值；</p></li><li><p>所求目标</p><p>　　dp[P][K]：把前K本书划分给P段（每个人1段）后得到的最小时间值；</p></li><li><p>状态转移方程</p><p>　　我们再来看这张图，</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240721150540525.png" alt="image-20240721150540525" style="zoom:80%;" /></p><p>　　根据题意，dp[p][k]和dp[p-1][c]及value[c+1][k]之间并不是“求和”的关系，而是“取最大值”的关系。也就是说，dp[p][k]=<font color="red">max</font>(dp[p-1][c],value[c+1][k])。1个方案的值等于每个人所需时间的最大值。注意，这只是一个方案的值，并不是我们要求的“最优方案”。那最优方案该怎么求呢？题目说了，值最小的就是最优。所以：<span class="math display">\[dp[p][k]=min(\ max(dp[p-1][c],\ \ value[c+1][k])\ ) \tag{3}\]</span> 　　<spanclass="math inline">\(value[c+1][k]\)</span>原本表示的是把第[c+1..k]个数设为1个段而得到的收益值，在本题中其实就是第[c+1..k]本书所需时间之和。我们现在已知每本书所需的时间，而本题又需要频繁求任意两本书位置区间之和，所以最好的办法就是新建一个前缀和数组，采用sum[k]-sum[c]来表示出value[c+1][k]。所以状态转移方程进一步转化为：<span class="math display">\[\begin{align}dp[p][k]=min(\ max(dp[p-1][c],\ \ sum[k]-sum[c])\ ) \tag{4}\\(1 \leq p \leq P,\quad p \leq k \leq K,\quad p-1 \leq c \leq k-1 )\tag{}\end{align}\]</span></p><p>　　上面的公式（4）只是一个数学简式，并不是一个真正的C++代码。如果要转成代码，需要考虑max函数和循环的特点。伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[p][k]= INF;   <span class="hljs-comment">// 初值设为负无穷，为“无解”状态的初始值， 以方便min运算出正确的结果</span><br><span class="hljs-keyword">for</span> (p)          <span class="hljs-comment">// 省略了部分代码</span><br>    <span class="hljs-keyword">for</span>(k)<br>        <span class="hljs-keyword">for</span>(c)<br>            dp[p][k]= <span class="hljs-built_in">min</span>( dp[p][k],   <span class="hljs-built_in">max</span>( dp[p<span class="hljs-number">-1</span>][c], sum[k]-sum[c]) );<br></code></pre></td></tr></table></figure></li><li><p>循环顺序和边界</p><p>　　和1.2节分析结果相同，照做即可。</p></li><li><p>初始化和特例</p><p>　　公式（4）里面有max，有min，当初始化dp数组为“无解”时，到底应该初始化为“INF”或者“-INF”呢？在公式（4）中我们需要先计算max，再来计算min。但是在做max运算时，所比较的对象中并没有dp[p][k]自身，而是把两个确切的值（dp[p-1][c]和sum[k]-sum[c]）做比较，这跟“赋初值”毫无关系，只是一个干扰项。<strong>真正实现累比的是min操作（因为min操作的其中一个比较对象是dp[p][k]它自己）。所以dp[p][k]的初值应该定义成针对min操作合适的初值对象，即INF</strong>。</p><p>　　关于特例，有dp[0][0]=0。而dp[0][1..K]，因为无法把前k本书划分给0个人，人都没有，怎么划分？所以其最小时间值为“无解”状态。这也是根据1.2节中的第5点分析而来。所以初始化和特例的处理应该是如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;  <span class="hljs-comment">// 在第0行只应对dp[0][0]做特殊处理</span><br></code></pre></td></tr></table></figure></li><li><p>输出方案</p><p>　　根据本题对dp数组的定义，dp[P][K]表示把前K本书划分给P个人后得到的最小时间值。在最优方案中，dp[P][K]又表示每个人所获页数的最大值（根据题目上对任一方案值的定义）。所以我们只需要按序分配书，并且让每个人的页数不超过dp[P][K]即可。可用递归函数来实现，不难。</p></li><li><p>优化</p><p>这个题是可以做平行四边形优化的，具体后面再说。</p></li></ol><h3 id="ac代码">2.1.3 AC代码</h3><h4 id="标准dp数组无优化输出方案">2.1.3.1标准dp数组，无优化，输出方案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法1. 可AC1278和P1281， 标准dp数组，无优化，输出方案</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 501</span><br><span class="hljs-type">int</span> K, P;<br><span class="hljs-type">int</span> page[N];         <span class="hljs-comment">// 存储每本书的页数</span><br><span class="hljs-type">int</span> dp[N][N];        <span class="hljs-comment">// dp[p][k]表示前 k 本书分给前 p 个人抄写的最短复制时间</span><br><span class="hljs-type">int</span> sum[N];          <span class="hljs-comment">// 用前缀和数组sum[]来方便处理，sum[p]表示前p本书的总页数</span><br><span class="hljs-comment">//打印输出把前k本书分给前p个人抄写的划分方案</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> c, s;<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 1278题允许P为0，P1281要求p至少为1。加本行才可以过1278题，否则只能过P1281 </span><br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-number">1</span>) &#123;         <span class="hljs-comment">// 如果只有1个人，把所有前k本书都给他吧</span><br>        cout &lt;&lt;<span class="hljs-number">1</span> &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt;k &lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    c = k;<br>    s = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 从第k本书开始，在dp[P][K]范围内往左一直分配，尽量多分配书给第p个人</span><br>    <span class="hljs-keyword">while</span>( s + page[c] &lt;= dp[P][K] ) &#123;<br>        s = s + page[c];<br>        c--;<br>    &#125;<br>    <span class="hljs-comment">// [c+1, k]之间的书已经分配给第p个人了，</span><br>    <span class="hljs-comment">// 下面接着分配[1, c]的书给剩下的p-1个人</span><br>    <span class="hljs-built_in">print</span>( p<span class="hljs-number">-1</span>, c );<br>    <span class="hljs-comment">// 为了体现正序，所以这里应该先追溯递归，然后再cout本次函数的分配方案</span><br>    cout &lt;&lt;c+<span class="hljs-number">1</span>  &lt;&lt;<span class="hljs-string">&quot; &quot;</span>  &lt;&lt;k  &lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> k, p;<br>    cin &gt;&gt;K &gt;&gt;P;           <span class="hljs-comment">// K本书，P个人</span><br>    <span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=K; k++) &#123;  <span class="hljs-comment">// K本书</span><br>        cin &gt;&gt;page[k];<br>        sum[k] = sum[k<span class="hljs-number">-1</span>] + page[k];<br>    &#125;<br>    <span class="hljs-comment">// 先要算出dp[P][K]，这样print函数才能用得上</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=<span class="hljs-number">1</span>; p&lt;=P; p++)      <span class="hljs-comment">// p个人</span><br><span class="hljs-comment">//      for(k=K; k&gt;=p; k--)  // k本书 增序降序均可 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=p; k&lt;=K; k++)  <span class="hljs-comment">// k本书</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=p<span class="hljs-number">-1</span>; c&lt;=k<span class="hljs-number">-1</span>; c++) <span class="hljs-comment">//</span><br>                dp[p][k] = <span class="hljs-built_in">min</span> (dp[p][k] , <span class="hljs-built_in">max</span>( dp[p<span class="hljs-number">-1</span>][c], sum[k]-sum[c] ));<br><br>    <span class="hljs-comment">// 这个题不光是要最短时间dp[P][K]，也要分配方案</span><br>    <span class="hljs-built_in">print</span>(P, K);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>样例对应的dp数组如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240722151409997.png" alt="image-20240722151409997" style="zoom:50%;" /></p><h4 id="滚动dp数组无优化输出方案">2.1.3.2滚动dp数组，无优化，输出方案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法2. 可AC1278和P1281，滚动dp数组，无优化，输出方案</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 501</span><br><span class="hljs-type">int</span> K, P;<br><span class="hljs-type">int</span> page[N];         <span class="hljs-comment">// 存储每本书的页数</span><br><span class="hljs-type">int</span> dp[N];           <span class="hljs-comment">// dp[k]表示前 k 本书分给前 p 个人抄写的最短复制时间</span><br><span class="hljs-type">int</span> sum[N];          <span class="hljs-comment">// 用前缀和数组sum[]来方便处理，sum[p]表示前p本书的总页数</span><br><span class="hljs-comment">//打印输出把前k本书分给前p个人抄写的划分方案</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> c, s;<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 1278题允许P为0，P1281要求p至少为1。加本行才可以过1278题，否则只能过P1281 </span><br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-number">1</span>) &#123;         <span class="hljs-comment">// 如果只有1个人，把所有前k本书都给他吧</span><br>        cout &lt;&lt;<span class="hljs-number">1</span> &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt;k &lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    c = k;<br>    s = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 从第k本书开始，在dp[K]范围内往左一直分配，尽量多分配书给第p个人</span><br>    <span class="hljs-keyword">while</span>( s + page[c] &lt;= dp[K] ) &#123;<br>        s = s + page[c];<br>        c--;<br>    &#125;<br>    <span class="hljs-comment">// [c+1, k]之间的书已经分配给第p个人了，</span><br>    <span class="hljs-comment">// 下面接着分配[1, c]的书给剩下的p-1个人</span><br>    <span class="hljs-built_in">print</span>( p<span class="hljs-number">-1</span>, c );<br>    <span class="hljs-comment">// 为了体现正序，所以这里应该先追溯递归，然后再cout本次函数的分配方案</span><br>    cout &lt;&lt;c+<span class="hljs-number">1</span>  &lt;&lt;<span class="hljs-string">&quot; &quot;</span>  &lt;&lt;k  &lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> k, p;<br>    cin &gt;&gt;K &gt;&gt;P;               <span class="hljs-comment">// K本书，P个人</span><br>    <span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=K; k++) &#123;  <span class="hljs-comment">// K本书</span><br>        cin &gt;&gt;page[k];<br>        sum[k] = sum[k<span class="hljs-number">-1</span>] + page[k];<br>    &#125;<br>    <span class="hljs-comment">// 先要算出dp[K]，这样print函数才能用得上</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=<span class="hljs-number">1</span>; p&lt;=P; p++)      <span class="hljs-comment">// p个人</span><br>        <span class="hljs-keyword">for</span>(k=K; k&gt;=p; k--)      <span class="hljs-comment">// k本书 滚动数组只能降序 </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=p<span class="hljs-number">-1</span>; c&lt;=k<span class="hljs-number">-1</span>; c++) <span class="hljs-comment">//</span><br>                dp[k] = <span class="hljs-built_in">min</span> (dp[k] , <span class="hljs-built_in">max</span>( dp[c], sum[k]-sum[c] ));<br><br>    <span class="hljs-comment">// 这个题不光是要最短时间dp[K]，也要分配方案</span><br>    <span class="hljs-built_in">print</span>(P, K);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p4677">2.2 1197/P4677</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1197">1197：山区建小学</a>/<ahref="https://www.luogu.com.cn/problem/P4677">P4677 山区建小学</a></p><h3 id="分析-2">2.2.2 分析</h3><p>　　题目比较难懂，先把测试样例的结果搞明白，往往有助于理解题意。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724103511313.png"alt="image-20240724103511313" /><figcaption aria-hidden="true">image-20240724103511313</figcaption></figure><p>　　把2个学校分别设置在2号村庄和7号村庄的话，各个村庄到附近学校的距离之和达到最小，为18。</p><h4 id="动态规划多步分析">2.2.2.1 动态规划多步分析</h4><p>　　理解了基本题意之后，我们来观察这张图，感觉这个题像是在“k个村庄中选择p个小学”的选择策略问题，而且每个小学会涵盖一个区间范围。所有K个小学被分割成了P个区间范围。每个区间范围内的村庄都去对应的小学上学。区间之间互不影响。下面我们用动态规划的分析思路来进行整理和细化。</p><ol type="1"><li>状态数组定义</li></ol><p>dp[p][k]:把前k个村庄分成p段，每1段内建立1个小学后,每段内每个村庄到各自段内小学的最短路程之总和</p><ol start="2" type="1"><li>所求目标</li></ol><p>dp[P][K]:把K个村庄分成P段，每1段内建立1个小学后,每段内每个村庄到各自段内小学的最短路程之总和</p><ol start="3" type="1"><li>状态转移方程</li></ol><p>　　这个内容比较复杂，下面需要用较多的篇幅来讲述。</p><p>　　首先我们要意识到这是一个“把K个数据分为P段”策略问题，可以用dp来求最优解。</p><p>　　我们现在要计算dp[p][k]，也就是要填表格中第p行第k列的值。我们现在能利用的，就是已经填过值的数据，也就是表格中dp[p][k]所处位置以左或以上的数据，也就是例如dp[p-1][k]、dp[p-1][k-1]、dp[p-2][k]、dp[p-3][k-1]、dp[p-2][k-2]、...等这些数据。</p><p>　　为了方便说明，我们下面暂时以dp[3][6]为例，即在前6个村庄中选3个位置来作为学校，求所有村庄到附近小学的最短路径之和。很多时候，当我们在推导状态转移方程时，可以假设一些具体的数据，便于快速找到方法，再推广到普通的情况。</p><p>　　<strong>1）传统dp做法，让dp[p][k]去和dp[p][k-1]、dp[p-1][k-1]或者dp[p-1][k]等产生关联（不可行）</strong></p><p>　　如下图所示，先算出这6个点“ABCDEF”到其中2个点“B”和“D”的最短距离之和，即dp[2][6]。其中B和D是假定的学校位置，具有随机性。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723141319295.png" alt="image-20240723141319295" style="zoom:67%;" /></p><p>　　然后再在剩下的4个点中新增第3个学校F，调整参与求和的距离，使得总和最小。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723141456308.png" alt="image-20240723141456308" style="zoom:67%;" /></p><p>　　可以看出，在把F点设置为学校之后，上面两个图在计算距离之和这方面，参与计算求和的多个距离值存在较大的不同。这样划分，使得上一个步骤计算出来的各种距离值化为乌有，不可再用，很多距离值都需要重新计算，会使得程序更难理解和处理，复杂度暴涨，放弃！而且这样设计，并没有体现出“把K个数据分为P段”当中的“段”的思想。</p><p>　　2）<strong>改进做法（可行，但需调整）</strong></p><p>　　当村庄和学校的位置都确定时，每个村庄都会到附近最近的学校去上学，这实际上已经形成了以多个学校为中心的片区。每个片区可以看成一个段。段与段之间的村庄不产生相互的联系。这实际上更像是“线性结构上分段”的类型。　　</p><p>　　如果要计算dp[3][6]，可以先算出前5个点“ABCDE”到其中2个点“B”和“D”的最短距离之和，即dp[2][5]（注意，“B”和“D”仍然是随便假定的学校位置）。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723141808078.png" alt="image-20240723141808078" style="zoom:67%;" /></p><p>　　然后再在剩下的6-5=1个点中新增第3个学校“F”，<strong>并且要求前5个村庄不得到新增点的学校来上课（体现出了“段”的思想，不同段内的数据相互不产生任何联系）</strong>。这样可以保持之前已有的数据关系和数据值不变（可以使得划分具有“无后效性”和“局部最优”的特点，满足动态规划的基本要求），得到“在前6个点中设置3个学校的距离之和”的<strong>一个（注意，并不是唯一的）</strong>计算公式。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723142122884.png" alt="image-20240723142122884" style="zoom:67%;" /></p><p>　　当然，这个公式肯定是存在一定问题的。从上面的图中可以看出，E点如果要去学校D，明显会比去学校F更远。也就是说，这种划分，虽然能很方便地利用之前dp数组的数据，但其结果却是不对的，还需要进一步修正。</p><p>　　上面这个结果的错误之处，在于这种划分不对。我们不应该划分成“ABCDE+F”的组合，这样会使得E点的孩子去学校D上学而不去更近的学校F。那除了“ABCDE+F”这种划分之外，还可以有其他的划分方法，即“空+ABCDEF”，“A+BCDEF”，“AB+CDEF”，“ABC+DEF”，“ABCD+EF”这五种。</p><p>　　<font color="red">正确的划分方法，肯定就在这六种划分方式中。我们可以遍历一遍，找出其中的最小值。哪个组合的距离之和最小，那对应的划分方法自然就是正确答案。</font></p><ul><li><del>空+ABCDEF—— dp[3][6] = dp[2][0] +“ABCDEF中选一个点作为学校后其他5个点到该点的距离之和的最小值”</del>(无法在0个村庄中选2个学校，dp[2][0]必然无解，本策略无效，不必参与min比较)</li><li><del>A+BCDEF　—— dp[3][6] = dp[2][1] + “BCDEF中选一个点作为学校后其他4个点到该点的距离之和的最小值”</del>(无法在1个村庄中选2个学校，dp[2][1]必然无解，本策略无效，不必参与min比较)</li><li>AB+CDEF　—— dp[3][6] = dp[2][2] + “CDEF中选一个点作为学校后其他3个点到该点的距离之和的最小值”</li><li>ABC+DEF　—— dp[3][6] = dp[2][3] + “DEF中选一个点作为学校后其他2个点到该点的距离之和的最小值”</li><li>ABCD+EF　—— dp[3][6] = dp[2][4] + “EF中选一个点作为学校后其他1个点到该点的距离之和的最小值”</li><li>ABCDE+F　—— dp[3][6] = dp[2][5] + “F中选一个点F作为学校后的距离的最小值（其实就是0了，自己到自己的距离）”</li></ul><p>　　从上面的6个式子可以看出，有一种信息需要频繁求取，而我们还没有对应的数据结构来表示它。那就是“在一段连续的村庄（假设为从第i个村庄到第j个村庄）中选一个点作为学校后，该段内其他所有点到该点的距离之和的最小值”。该如何表示这个信息呢？其实只需要把i和j表示出来即可。该信息表示的是最小值，所以不应该在数据结构中指定学校的位置。所以该结构只需要2个信息即可，就是i和j，我们可以<strong>用一个二维数据Cost[i][j]来表示从第i个村庄到第j个村庄这一个区间中选1个点作为学校后，该区间内其他点到该学校点的距离之和的最小值</strong>。</p><p>　　关于Cost[][]的值，怎么计算出来呢？这是本题比其他同类型题复杂的地方。题面上并没有直接给出Cost[][]的值，需要我们去计算出来。具体分析和计算过程，因为内容较多，为了避免冲淡主题，把这部分内容单独做成2.2.2.2小节，请同学们注意学习。下面的分析假设该数组C的值已经获得。</p><p>　　根据上面红色文字的叙述，我们可以总结出下面的公式来。 <spanclass="math display">\[\begin{align}dp[3][6]=min(\ &amp;dp[2][\textcolor{red}2]+Cost[3][6],\tag{}\\ &amp;dp[2][\textcolor{red}3]+Cost[4][6],\tag{}\\&amp;dp[2][\textcolor{red}4]+Cost[5][6], \tag{}\\&amp;dp[2][\textcolor{red}5]+Cost[6][6]\ \ ) \tag{1}\end{align}\]</span></p><p>　　把公式（1）翻译成代码，那就是如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 公式1对应的代码如下：</span><br>dp[<span class="hljs-number">3</span>][<span class="hljs-number">6</span>]= INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=<span class="hljs-number">3</span><span class="hljs-number">-1</span>; c&lt;=<span class="hljs-number">6</span><span class="hljs-number">-1</span>; c++)  <span class="hljs-comment">// c表示公式（1）中的红色数字，代表了不同的分割策略</span><br>    dp[<span class="hljs-number">3</span>][<span class="hljs-number">6</span>]= <span class="hljs-built_in">min</span>( dp[<span class="hljs-number">3</span>][<span class="hljs-number">6</span>],  dp[<span class="hljs-number">3</span><span class="hljs-number">-1</span>][c] + Cost[c+<span class="hljs-number">1</span>][<span class="hljs-number">6</span>] );<br></code></pre></td></tr></table></figure><p>　　所以状态转移方程就是： <span class="math display">\[dp[p][k]=min(dp[p][k],\ dp[p-1][c]\ + \ Cost[c+1][k]\ ) \\(1 \leq p \leq P;\quad p \leq k \leq K;\quad p-1 \leq c\leq k-1)\]</span></p><ol start="4" type="1"><li><p>循环顺序和边界</p><p>p:dp[p][k]的求解，需要且只需要用到上一行的数据，所以p只能增序，[1..P]；</p><p>k:既然是只用到上一行的数据，所以k可以增序，也可以降序。在本题中，如果村庄数k少于学校数p，是不合理的，无解，所以只需要填写<spanclass="math inline">\(k \geqp\)</span>的情况。所以循环顺序和边界为[p..K]，或者[K..p];</p><p>c:策略c在dp的第二维，对于状态[p-1][c]来说，第二维的数字c不能小于第一维的数字p-1（否则该状态无解，不应参与比较，即使参与了也是白比），所以c的范围是[p-1,k-1]。增序降序均可。先比哪个策略，后比哪个策略，这个顺序并不重要，最终都要比完所有的策略。</p></li><li><p>初始化和特例</p></li></ol><p>　　因为状态可能存在无解，所以dp数组初始化为无解，在本题中对应的就是INF。</p><p>　　根据1.2节第5点的分析，dp[0][0]=0。而对于dp[0][1..K]，在k个村庄中设置0个学校，把k个数据划分为0段，描述不合理，无解。</p><h4 id="推导cost数组">2.2.2.2 推导Cost数组</h4><p>　　Cost数组是状态转移方程中非常重要的一个数据结构。Cost[le][ri]来表示从第le个村庄到第ri个村庄这一个区间中选1个点作为学校后，该区间内其他点到该学校点的距离之和的最小值。该如何找规律来计算呢？老规矩，草稿纸上画样例，先看看样例具有什么样的规律。下面以6个村庄中找1个学校为例来分析。</p><p>1）以1号点为学校，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724114648838.png" alt="image-20240724114648838" style="zoom:50%;" /></p><p>2）以2号点为学校，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724114610444.png" alt="image-20240724114610444" style="zoom:50%;" /></p><p>3）以3号点为学校，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724113906535.png" alt="image-20240724113906535" style="zoom:50%;" /></p><p>4）以4号点为学校，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724114049227.png" alt="image-20240724114049227" style="zoom:50%;" /></p><p>5）以5号点为学校，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724114250586.png" alt="image-20240724114250586" style="zoom:50%;" /></p><p>6）以6号点为学校，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724114501124.png" alt="image-20240724114501124" style="zoom:50%;" /></p><p>　　把上面6种方案的距离值进行对比，可以发现，不管红黄绿蓝紫的路径值为多少，必然会有：</p><p>　　5红4黄3绿2蓝1紫(以1号为学校) &gt;= 1红4黄3绿2蓝1紫(以2号为学校)&gt;= <strong>1红2黄3绿2蓝1紫(以3号为学校)==1红2黄3绿2蓝1紫(以4号为学校)</strong> &lt;= 1红2黄3绿4蓝1紫(以5号为学校)&lt;= 1红2黄3绿4蓝5紫(以6号为学校)</p><p>　　也就是说，在这串村庄组成的线性结构中，<strong>取区间中点位置的点作为村庄，总距离之和是最小的，不管各个点之间的线性距离是多少。</strong>当这些点为奇数个时，直接取中点作为学校；当这些点为偶数个时，取中间两个点都能得到最小值。</p><p>　　搞清楚了这一点，我们就能确定任意一个指定区间[le,ri]中学校的位置为(le+ri)/2。</p><p>　　下一步要做什么呢？下一步就是计算该区间内所有点到该学校点的距离之和了。这里有一个小问题需要解决，在确定好学校点之后，如何以最快捷方便的办法计算出该区间内所有点到学校点的距离之和呢？题目上只告知了每相邻2个点之间的距离值。其实方法很简单，因为所有点都正好在一个线形上，任意两点之间的距离值，就变成了两点之间所有相邻点距离值之和，这实际上是个“区间和”的问题，所以用前缀和数组就能搞定了。</p><p>　　相关的局部代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=K; i++)  <span class="hljs-comment">// 村庄从1开始编号，sum[1]=0 </span><br>   cin &gt;&gt;sum[i], sum[i]+= sum[i<span class="hljs-number">-1</span>];<br><span class="hljs-comment">// cost[i][j]：第i~j个村庄之间建立1所小学，这几个村庄到这个小学的最小距离之和。 </span><br>   <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> le=<span class="hljs-number">1</span>; le&lt;=K; le++)<br>   <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> ri=le; ri&lt;=K; ri++)&#123;<br>       <span class="hljs-type">int</span> mid = (le+ri) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// 把这所小学定在第mid个村庄，使得第i~j个村庄到这个小学距离之和最小  </span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=le; k&lt;=ri; k++)<br>       cost[le][ri] += <span class="hljs-built_in">abs</span>(sum[mid] - sum[k]); <span class="hljs-comment">// 算出这个距离之和，然后填表cost </span><br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="ac代码-1">2.2.3 AC代码</h3><p>　　在不考虑平行四边形优化的前提下，本题的朴素代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//dp，标准状态数组，无优化</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 法1： 朴素做法，标准状态数组dp[][]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1001</span><br><span class="hljs-type">int</span> K, P;<br><span class="hljs-type">int</span> sum[N];     <span class="hljs-comment">// 距离的前缀和数组， </span><br><span class="hljs-type">int</span> cost[N][N]; <span class="hljs-comment">// cost[10][20]=400表示从第[10..20]个小学内设置一个学校后，这11个村庄到这所小学的最短距离之和 </span><br><span class="hljs-type">int</span> dp[N][N];   <span class="hljs-comment">//前 k个村庄放 p 个小学时的“村校最小距离和”（即: 所有小学到附近村庄的最小距离之和）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i, j, p, k, le, rt;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); <br><span class="hljs-comment">// K村庄数     P小学数 </span><br>    cin &gt;&gt;K &gt;&gt;P;<br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">2</span>; i&lt;=K; i++)  <span class="hljs-comment">// 村庄从1开始编号，sum[1]=0 </span><br>    cin &gt;&gt;sum[i], sum[i]+= sum[i<span class="hljs-number">-1</span>];<br>    <br>    <span class="hljs-comment">// 根据上面的数组(任意两村之间的距离)，填数组cost[][]的右上部分，对角线上全0 </span><br><span class="hljs-comment">// cost[i][j]：第i~j个村庄之间建立1所小学，这几个村庄到这个小学的最小距离之和。 </span><br>    <span class="hljs-keyword">for</span>( le=<span class="hljs-number">1</span>; le&lt;=K; le++)<br>    <span class="hljs-keyword">for</span>( rt=le; rt&lt;=K; rt++)&#123;<br>        <span class="hljs-type">int</span> mid = (le+rt) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// 把这所小学定在第mid个村庄，使得第i~j个村庄到这个小学距离之和最小  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=le; k&lt;=rt; k++)<br>        cost[le][rt] += <span class="hljs-built_in">abs</span>(sum[mid] - sum[k]); <span class="hljs-comment">// 算出这个距离之和，然后填表cost </span><br>   &#125;<br>    <br><span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp)); <br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <br>    <span class="hljs-keyword">for</span>( p=<span class="hljs-number">1</span>; p&lt;=P; p++)       <span class="hljs-comment">// p个小学   1&lt;=p&lt;=P</span><br>    <span class="hljs-keyword">for</span>( k=p; k&lt;=K; k++)   <span class="hljs-comment">// k个村庄 , p&lt;=k&lt;=K    </span><br><span class="hljs-comment">//    for( k=K; k&gt;=p; k--)   // 标准数组，k增序降序都可以  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=k<span class="hljs-number">-1</span>; c&gt;=p<span class="hljs-number">-1</span>; c--)  <span class="hljs-comment">// c个分隔点（策略），p-1&lt;= c &lt;=k-1, 增序降序都可以！ </span><br>            dp[p][k] = <span class="hljs-built_in">min</span>(dp[p][k],  dp[p<span class="hljs-number">-1</span>][c] + cost[c+<span class="hljs-number">1</span>][k]);<br><br>    cout &lt;&lt;dp[P][K]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 区间dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三种分组背包的处理</title>
      <link href="/2024/07/02/%E4%B8%89%E7%A7%8D%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E7%9A%84%E5%A4%84%E7%90%86/"/>
      <url>/2024/07/02/%E4%B8%89%E7%A7%8D%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E7%9A%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="分组背包的题型和分类">1.1 分组背包的题型和分类</h2><p>　　一个背包的总约束量为YS1，有n个物品，约束量分别为<spanclass="math inline">\(ys1[1]、ys1[2]、...、ys1[n]\)</span>,收益量分别为<spanclass="math inline">\(value[1]、value[2]、...、value[n]\)</span>,这n个物品被划分为了若干组，在选择物品时每个组遵循一个共同的<font color="red">规则要求</font>，求解在这种规则要求下选出来的物品的约束量之和不超过YS1的情况下，其物品组合的<strong>最大收益值</strong>。</p><p>　　上述的<font color="red">规则要求</font>，可分为以下三类，分别对应着三种类型的分组背包题型：</p><ol type="1"><li>每组物品选的物品个数<font color="red">&lt;=</font>1个：每组内的物品之间相互冲突，最多只能选一个，允许不选；</li><li>每组物品选的物品个数<font color="red">==</font>1个：每组内的物品之间相互冲突，只能选一个，不能多，也不能少；</li><li>每组物品选的物品个数<font color="red">&gt;=</font>1个：每组内的物品之间不冲突，至少选一个，可以多选，但不允许不选；</li></ol><p>　　需要指出的是，分组背包支持多维费用，求解时也并不一定是“&lt;=YS1”情况下的最大收益值，也支持其他情况，求解方式大同小异。同学们可以自己去思考拓展。</p><h2 id="题型1每组物品选的物品个数1个">1.2题型1：每组物品选的物品个数<font color="red">&lt;=</font>1个</h2><p>　　这种题型在普及组中出现得较多，是最基础的分组背包题型。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240716100733859.png"alt="image-20240716100733859" /><figcaption aria-hidden="true">image-20240716100733859</figcaption></figure><p>　　我们来分析一下上面的样例数据，看看怎么破解这种题型。YS1=10，6个物品，一共被分为了3组。我们需要针对每一组内的物品来做考虑，但是录入的时候，物品编号是全局的编号值，并非组内的序号，这会给我们遍历每一组内的所有物品带来不便。所以我们需要用idx[][]数组来转换一下全局编号和组内序号之间的关系。这个数组的填写过程可以在录入所有物品的同时就完成。idx[2][0]=2表示第2组一共有2个物品；idx[2][2]=4表示第2组的第2个物品的编号是4号。在这种结构下，我们可以使用如下的代码来遍历访问第g组所有物品的ys1[]值和value[]值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)&#123;<br>cout &lt;&lt; ys1[ idx[g][k] ] &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt;value[ idx[g][k] ] &lt;&lt;endl; <span class="hljs-comment">// 注意idx[g][k]返回的是i值，即物品的全局编号值i</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240716111815053.png" alt="image-20240716111815053" style="zoom:80%;" /></p><p>　　我们用dp[][]数组来表示物品组合的最大收益值，<strong>但因为有分组的约束，所以这里第一维不能是全局编号i了，而应该是组号g</strong>。第二维仍然是约束总量j。所以<strong>dp[g][j]表示“前g组中所选物品在不超过总约束量为j的前提下，物品组合的最大收益值”</strong>。根据这个定义，本题的所求目标就是dp[maxg][YS1]了（假设一共有maxg组物品）。</p><p>　　既然是分组背包，那我们就只能一组一组地来做选择，所以在填写dp[][]数组时，第一层循环应该是for(intg=1; g&lt;=maxg;g++)了。处理完一组的所有物品之后，再去处理下一组的所有物品。这里遇到一个问题：请问第二层循环应该是什么呢？是forj呢，或者是for组内物品k？其实两种方法都是可以的，但要小心在初始化或者if语句或者循环边界上的一些微小的差别。</p><h3 id="先for-组内物品k再for-j重点掌握">1.2.1 先for 组内物品k，再forj（重点掌握）</h3><p>　　第一层是forg，针对每一组进行循环，在所有题型中都一样，这里就不专门去写了，我们重点分析第二层和第三层。第二层循环是for组内物品k，即针对第g组的所有物品去做第三层循环的操作（只能是forj了，即遍历填写dp[g][0..YS1]），即如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（1），组内最多选1件，先for 组内物品k 再 for j，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br><span class="hljs-comment">// 开始循环填写</span><br>......<span class="hljs-comment">// k=1 针对该组的第1个物品，j的循环范围为[YS1..ys1[ idx[g][1]] ]</span><br>dp[g][<span class="hljs-number">50</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">50</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] );  <span class="hljs-comment">// j=50，如果50&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">51</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">51</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] );  <span class="hljs-comment">// j=51，如果51&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">52</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">52</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] );  <span class="hljs-comment">// j=52，如果52&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">53</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">53</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">53</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] );  <span class="hljs-comment">// j=53，如果53&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>...<br>......<span class="hljs-comment">// k=2 针对该组的第2个物品，j的循环范围为[YS1..ys1[ idx[g][2]] ]</span><br>dp[g][<span class="hljs-number">50</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">50</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] );  <span class="hljs-comment">// j=50，如果50&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">51</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">51</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] );  <span class="hljs-comment">// j=51，如果51&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">52</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">52</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] );  <span class="hljs-comment">// j=51，如果51&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">53</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">53</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">53</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] );  <span class="hljs-comment">// j=53，如果53&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>...<br>......<span class="hljs-comment">// k=3 针对该组的第3个物品，j的循环范围为[YS1..ys1[ idx[g][3]] ]</span><br>dp[g][<span class="hljs-number">50</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">50</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] );  <span class="hljs-comment">// j=50，如果50&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">51</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">51</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] );  <span class="hljs-comment">// j=51，如果51&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">52</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">52</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] );  <span class="hljs-comment">// j=52，如果52&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">53</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">53</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">53</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] );  <span class="hljs-comment">// j=53，如果53&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>...<br><br></code></pre></td></tr></table></figure><p>　　上面的代码（1）整合之后的等效代码（2）如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（2），等效于代码（1），组内最多选1件，先for 组内物品k 再 for j，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br><span class="hljs-comment">// 开始循环填写</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[idx[g][k]]] + value[idx[g][k]] );<br></code></pre></td></tr></table></figure><p>　　上面的代码（2）是针对“第g组为‘组内最多选择1件物品’”的情况。如果所有组的物品都是“组内最多选择1件物品”的话，则在代码（2）的外面套一个对所有组的循环即可，得到如下的代码（3）.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（3），所有组都只能组内最多选1件，先for 组内物品k 再 for j，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=maxg; g++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>    dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>    dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[idx[g][k]]] + value[idx[g][k]] );<br>&#125;<br></code></pre></td></tr></table></figure><p>　　如果对dp[][]采用滚动数组，看上去好像可以把代码（3）进一步演变为如下代码（4）所示，但实际上这个代码是错误的!</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（4），错误代码！错误代码！所有组都只能组内最多选1件，先for 组内物品k 再 for j，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=maxg; g++)<br>    <span class="hljs-comment">// 不需要再“照抄上一行数据”了，下面的写法已经隐含地包括了对“不选任何物品”这个选择的max比较了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 必须只能倒序！</span><br>    dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dp[j-ys1[idx[g][k]]] + value[idx[g][k]] );<br></code></pre></td></tr></table></figure><p>　　错误的原因就在于在代码（4）的第5、6行执行时，可能会把一些dp[]值进行更改为新值（选择了当前组的某个物品价值更大），这会使得对该组后续的其他物品进行选择考虑时，本应该做dp[g][j]=max( dp[g][j], dp[g-1][j-ys1[idx[g][k]]] + value[idx[g][k]]);，但因为dp[j]被改过，所以它表达的实际上已经是dp[g][j]的值，而不是dp[g-1][j]的值了，如果此时再去选，会造成该组同时选择2个或多个物品。举个例子：</p><p>　　假如第1组现在有2个物品，成本分别是2斤、3斤，收益对应分别为1元和3元。如果我们按照代码（4）来做的话，当第1个物品处理结束后，dp[0..YS1]值会是{0,0,1,1,1,1,1,1,...}。在这种情况下，去处理第二个物品时，dp[0..YS1]会是{0,0,1,3,3,4,4,4,4,....}。这是错误的。实际上dp[0..YS1]的正确答案应该是{0,0,1,3,3,3,3,....}。之所以出现这种情况，是因为代码（4）在处理第二个物品时，做了dp[5]=max(dp[5],dp[2]+3)=max(1,1+3)=4，而实际上应该是dp[5]=max(dp[5],dp[2]+3)=max(1,0+3)=3。这里的dp[2]错误地取成了1（表示已选了第1个物品），本应该是0。</p><p>　　找到问题之后，解决方法如下代码（５）所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（５），正确代码！所有组都只能组内最多选1件，先for 组内物品k 再 for j，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=maxg; g++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--) <br>        dptmp[j]=dp[j];     <span class="hljs-comment">// 用dptmp[0..YS1]来存dp[g-1][0..YS1] </span><br>    <span class="hljs-comment">// 不需要再“照抄上一行数据”了，下面的写法已经隐含地包括了对“不选任何物品”这个选择的max比较了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 必须只能倒序！</span><br>            <span class="hljs-comment">// dptmp[]表示的是dp[g-1][] !!</span><br>    dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dptmp[j-ys1[idx[g][k]]] + value[idx[g][k]] );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="先for-j再for-组内物品k">1.2.2 先for j，再for 组内物品k</h3><p>　　第二层循环是forj，即针对所有的总约束量j去做第三层循环的操作（只能是for组内物品k了，即遍历该组的每个物品），即如下代码（6）所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（6），所有组都只能组内最多选1件，先for j 再 for 组内物品k，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br>......<span class="hljs-comment">// j=50</span><br>dp[g][<span class="hljs-number">50</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] ); <span class="hljs-comment">// k=1，如果50&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">50</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] ); <span class="hljs-comment">// k=2，如果50&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">50</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] ); <span class="hljs-comment">// k=3，如果50&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>...<br>......<span class="hljs-comment">// j=51</span><br>dp[g][<span class="hljs-number">51</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] ); <span class="hljs-comment">// k=1，如果51&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">51</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] ); <span class="hljs-comment">// k=2，如果51&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">51</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] ); <span class="hljs-comment">// k=3，如果51&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>...<br>......<span class="hljs-comment">// j=52</span><br>dp[g][<span class="hljs-number">52</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] ); <span class="hljs-comment">// k=1，如果52&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">52</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] ); <span class="hljs-comment">// k=2，如果52&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">52</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] ); <span class="hljs-comment">// k=3，如果52&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>...<br></code></pre></td></tr></table></figure><p>　　仔细把代码（1）和上面的代码（6）进行比对，你会发现其实他们是等效的，只是语句的顺序不太一样而已。把上面的代码（6）整合，得到等效的代码（7）如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（7），等效于代码（6），所有组都只能组内最多选1件，先for j 再 for 组内物品k，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] )  <span class="hljs-comment">// 因为在第4行还没有k，无法写出j&gt;=ys1[ idx[g][k] ]，所以只能在这里写！</span><br>            dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br></code></pre></td></tr></table></figure><p>　　注意，代码（7）中的第2、3行代码，其实是可以整合到下面的循环中去的，得到等效的代码（8）如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（8），等效于代码（7），所有组都只能组内最多选1件，先for j 再 for 组内物品k，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>    dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];     <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] )  <span class="hljs-comment">// 因为在第4行还没有k，无法写出j&gt;=ys1[ idx[g][k] ]，所以只能在这里写！</span><br>            dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br>&#125;<br></code></pre></td></tr></table></figure><p>　　如果对dp[][]采用滚动数组，则可以把代码（8）进一步演变为如下代码（9）所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（9），等效于代码（8），所有组都只能组内最多选1件，先for j 再 for 组内物品k，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>    <span class="hljs-comment">// 不需要再“照抄上一行数据”了，下面的写法已经隐含地包括了对“不选任何物品”这个选择的max比较了</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] )  <span class="hljs-comment">// 因为在第2行还没有k，无法写出j&gt;=ys1[ idx[g][k] ]，所以只能在这里写！</span><br>            dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dp[j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br>&#125;<br></code></pre></td></tr></table></figure><p>　　上面的代码（9）是针对“第g组为‘组内最多选择1件物品’”的情况。如果所有组的物品都是“组内最多选择1件物品”的话，则在代码（9）的外面套一个对所有组的循环即可，得到如下的代码（10）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（10），所有组都只能组内最多选1件，先for j 再 for 组内物品k，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=maxg; g++)   <span class="hljs-comment">// 对每一组进行</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>            <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] ) <br>                dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dp[j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br>    &#125;<br></code></pre></td></tr></table></figure><p>　　我们现在可以来比较这两种方法，会发现各种版本的代码都各有千秋，不存在哪个版本绝对精简。希望同学们尽量都能推导，要懂得灵活处理，理解原理，没必要死记硬背，很容易背错。滚动数组看起来虽然方便，但理解困难，容易出错。标准数组理解起来方便一些，但涉及初值赋予，多占空间。鉴于分组背包的复杂性和易错，建议基础薄弱的同学们最好是首先考虑标准状态数组。</p><h2 id="题型2每组物品选的物品个数-1个">1.3题型2：每组物品选的物品个数<font color="red">= =</font>1个</h2><p>题型2和题型1的区别在于：每一组必须要选择一个物品。这种区别会带来一些变化如下：</p><ol type="1"><li><p>因为每一组要求必须要选择一个物品，在“总成本量&lt;=j”的这个限制条件下，有可能无法选择任何一个物品，即无解。例如假设第g组所有物品的成本量都超过了100，则dp[g][0..99]都肯定是无解的，无法选出，只能无解。</p></li><li><p>既然要求每组不能不选物品，那么就不能再用dp[g][j]=dp[g-1][j]了，因为这行代码表示“本组不选任何物品”。因为可能存在本组无解的情况，所以dp[g][j]的初值应该对应着“无解”。如果在计算的过程中发现有解，则应该替换覆盖原来的初值。</p></li></ol><p>　　对于“无解”的处理，在<a href="">《背包问题的初始化问题》</a>中的1.3节中专门讨论过各种题型对“无解”这个状态的理解。同学们可以回看一下。</p><p>　　<strong>分组背包模型中，对“无解”的处理，总结出来如下三点：</strong></p><p>　　1.<strong>首先应该看当前题型是否可能存在“无解”的状态（在分组背包中，只有"当前组必须要选1个或者至少选1个"的题型才存在“无解（如果选不出来就意味着无解）”的状态）。如果可能存在，那么</strong></p><p>　　　　1）<strong>如果dp表示最大值，则初始化时dp[1..gcnt][<font color="red">0</font>..YS1]=-INF；</strong></p><p>　　　　2）<strong>如果dp表示方案数，则初始化时dp[1..gcnt][<font color="red">1</font>..YS1]=0,dp[0][0]=1；</strong></p><p>　　　　3）<strong>如果dp表示最小值，则初始化时dp[1..gcnt][<font color="red">0</font>..YS1]=INF。</strong></p><p>　　2.<strong>不管当前题型是否存在无解的情况，dp[<font color="red">0</font>][0..YS1]都应该要设置为全0（若表示方案数，dp[0][0]=1,dp[0][1..YS1]=0）！因为在任何情况下，如果连组都没有（g==0，表示“尚未开始选择”），那肯定收益值是0，方案数是1（“什么都不做”）。从另外一个角度来看，如果第0行全是-INF或者INF的话，就没法更新dp数组下面的每行数据（因为每组题型的dp[g][]都依赖于dp[g-1][]）了。</strong></p><p>　　3.这里需要小心容易被同学们忽略的地方，那就是“对第0列的处理”。虽然第0行属于特例，需要单独处理，但是第0列并不是特例！当dp数组表示最大值或者最小值，并且在题型2或者题型3中时，dp[g][0]=0表示对第g组的选择是合理合法的，但如果dp[g][0]=无解，这表示对第g组的选择已经无法按规定要求正确进行。在这种情况下，去处理第g+1行的数据，一旦需要使用到dp[g][0]则必然会出现问题！从公式上来看，右侧的式子一旦是无解的状态，则由它来推导出左侧的状态值，这显然是不合理的！有部分同学把dp[1..gcnt][0]设置为了全0，似乎也能AC某些题，这纯粹是因为测试数据太弱的缘故，在考试时肯定会出问题。总结起来，记住一点，<strong>对dp数组的第0列不要做特殊处理。初始化第g行所有数据时，一定要把dp[g][0]的初始化包含在内</strong>。</p><p>　　在1.2节中的“先for 组内物品k，再for j”和“先for j，再for组内物品k”这两个不同的策略，同样适用于1.3节这种题型。同学们可以选择自己熟悉的策略来重点掌握（<strong>建议掌握“先for组内物品k，再for j”这种策略的做法，适用范围更广</strong>）。</p><h3 id="先for-组内物品k后for-j重点掌握">1.3.1 先for 组内物品k，后forj（重点掌握）</h3><p>1.标准状态数组下的做法</p><p>　　在代码（2）的基础之上演变得到如下的代码（11）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（11），组内必须选1件，先for 组内物品k 再 for j，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>dp[g][j]= -INF;    <span class="hljs-comment">// 默认针对每个j，当前组都暂时无解，值为-INF。当然，也可以用memset或者直接设置为全局数组以自动清0，这样就可以不用写这个for循环了</span><br><span class="hljs-comment">// 开始循环填写dp</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[idx[g][k]]] + value[idx[g][k]] );<br><span class="hljs-comment">// 填完整个dp数组之后，如果某个dp[g][j]的值仍然是-INF，说明这个状态是无解的。</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>滚动状态数组下的做法</li></ol><p>　　在代码（5）的基础之上演变得到如下的代码（12）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（12），组内必须选1件，先for 组内物品k 再 for j，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123; <br>    dptmp[j]=dp[j];   <span class="hljs-comment">// 用dptmp[0..YS1]来存dp[g-1][0..YS1]</span><br>    dp[j]= -INF;      <span class="hljs-comment">// dp[j]现在要去存放dp[g][j]了，以“无解”（收益值为-INF）来作为该状态([g][j])的初始值</span><br>&#125;<br><span class="hljs-comment">// 不再“照抄上一行数据”，每个dp[0..YS1]的初值设为了-INF，在第一次执行dp[j]=max(dp[j], ...)时，等效于执行了“dp[j]=max(-INF, ...)”，意味着本组的所有策略中没有包含“本组什么物品都不选”。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 必须只能倒序，表示每个物品不能多选！</span><br>         <span class="hljs-comment">// dptmp[]表示的是dp[g-1][] !!</span><br>    dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dptmp[j-ys1[idx[g][k]]] + value[idx[g][k]] );<br></code></pre></td></tr></table></figure><h3 id="先for-j后for-组内物品k">1.3.2 先for j，后for 组内物品k</h3><ol type="1"><li>标准状态数组下的做法</li></ol><p>　　在代码（8）的基础之上演变得到如下的代码（13）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（13），组内必须选1件，先for j 再 for 组内物品k，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>    dp[g][j]= -INF;     <span class="hljs-comment">// 以“无解”（收益值为-INF）来作为该状态的初始值。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] )  <span class="hljs-comment">// 因为在第2行还没有k，无法写出j&gt;=ys1[ idx[g][k] ]，所以只能在这里写！</span><br>            dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>滚动状态数组下的做法</li></ol><p>　　在代码（9）的基础之上演变得到如下的代码（14）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（14），组内必须选1件，先for j 再 for 组内物品k，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>    dp[j]=-INF;<span class="hljs-comment">// 以“无解”（收益值为-INF）来作为[g][j]状态的初始值。即使dp全数组在for g之前已全都置为了-INF，本行代码也必须要写！</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] )  <br>            dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dp[j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题型3每组物品选的物品个数-1个">1.4题型3：每组物品选的物品个数<font color="red">&gt; =</font>1个</h2><p>　　题型3仍然存在题型2中面临的“可能存在无解”的情况。所以，题型2中关于dp[g][0..YS1]初值的设定，对于题型3仍然适用。为了降低初学难度，我们还是以“<strong>在&lt;=YS1的前提下求最大收益值</strong>”为例，来讲解“每组物品选的物品个数&gt;=1个”这种要求的应对策略。</p><p>　　dp[g][j] 表示选前 g 组物品（每组至少选1个）并且限制量不超过j的最大收益值。所求目标为dp[gcnt][YS1]。有两种情况可以转到当前状态[g][j]：</p><ol type="1"><li>在“<strong>第g组还没选择任何物品</strong>”的前提下，第一次选择了第g组的编号为x的物品，则会有:</li></ol><p><span class="math display">\[dp[g][j]= max(\ dp[g][j], \quad dp[g-1][j-ys1[x] ] + value[x]\ );\tag{1}\]</span></p><ol start="2" type="1"><li>在“<strong>已经选择了第g组的某个或者某些物品</strong>”的前提下，现在选择编号为x的物品，则会有:<span class="math display">\[dp[g][j]= max(\ dp[g][j], \quad dp[g][j-ys1[x] ] + value[x]\ );\tag{2}\]</span>既然这两种情况都可能发生，那么最终策略就看哪种方案的值最大，就选哪种方案了。所以最终的状态转移方程是：<span class="math display">\[dp[g][j]= max(\ dp[g][j], \quad dp[g-1][j-ys1[x] ] + value[x]\ , \quaddp[g][j-ys1[x] ] + value[x]\ ); \tag{3}\]</span></li></ol><p>　　公式（3）在转成代码的时候，需要小心！对于编号为x的物品，情况1和情况2是不可能同时存在的。所以公式（3）中的<span class="math inline">\(dp[g-1][j-ys1[x] ] + value[x]\)</span> 和<span class="math inline">\(dp[g][j-ys1[x] ] +value[x]\)</span>这两个策略不可能都执行，在写代码的时候建议采用A=max(max(A,B),C)的方式来写。而且，第1次执行公式（1）时，公式右侧的dp[g][j]存放的应该是该状态的初值“无解”，即-INF。而后续执行该公式时，右侧的dp[g][j]纯粹只是为了实现“多个数据之间的<strong>累计比较</strong>”的效果而已。</p><h3 id="先for-组内物品k再for-j掌握">1.4.1 先for 组内物品k，再forj（掌握）</h3><p>　　下面我们看一个例子，用“先for 组内物品k，后forj”的思路来进一步来加深对公式（３）的理解。</p><p>　　1)处理第1组的1号物品</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723170245209.png"alt="image-20240723170245209" /><figcaption aria-hidden="true">image-20240723170245209</figcaption></figure><p>　　可以看到，第一次填写dp[g][j]时，等式右边的dp[g][j]为“无解”的状态，值为-INF，以方便max运算。</p><p>　　2）处理第1组的4号物品</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723170855857.png"alt="image-20240723170855857" /><figcaption aria-hidden="true">image-20240723170855857</figcaption></figure><p>　　3)处理第2组的2号物品</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723171222171.png"alt="image-20240723171222171" /><figcaption aria-hidden="true">image-20240723171222171</figcaption></figure><p>　　后续对剩余2个物品的处理与上雷同，就不再画图展示了。</p><p>　　需要注意的是，这里j的循环顺序一定是倒序，即从YS1到ys1[i]。这是因为对于每个物品来说，最多只能被选择一次，不能被连续选择2次。这和“一个组内允许选择多个物品”，是不相关的。如下图所示。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723172427927.png"alt="image-20240723172427927" /><figcaption aria-hidden="true">image-20240723172427927</figcaption></figure><p>　　题型3的代码模板如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g &lt;= gcnt; g++ )            <span class="hljs-comment">// 历所有组数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++ ) &#123;   <span class="hljs-comment">// 遍历每组的物品</span><br>        <span class="hljs-type">int</span> i=idx[g][k];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j&gt;=ys1[i]; j--) <span class="hljs-comment">// 此处必须只能倒序，因为有dp[g][...] </span><br><span class="hljs-comment">//      for(int j = ys1[i]; j&lt;=YS1; j++) // 错误！ 每个物品只能被选1次！ 右侧公式里有dp[g][...] ！见帖子说明</span><br>            <span class="hljs-comment">//dp[g][j] = max ( dp[g][j] , max(dp[g-1][j-ys1[i]]+value[i] , dp[g][j-ys1[i]]+value[i]) ); // 和下一行等效，可AC</span><br>            dp[g][j] = <span class="hljs-built_in">max</span> ( <span class="hljs-built_in">max</span>(dp[g][j] , dp[g<span class="hljs-number">-1</span>][j-ys1[i]]+value[i] ), dp[g][j-ys1[i]]+value[i] );<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="先for-j再for-组内物品k-1">1.4.2 先for j，再for 组内物品k</h3><p>　　从公式（3）中可以看到一个我们需要注意的东西，那就是dp[g][j]的值，依赖于dp[g][j-...]的值。换句话说，当前格子的填写，依赖于同行左侧某个格子的填写。这是之前题型1和题型2所没有的情况（这两种题型都是依赖于上一行的值，已确定）。在这种情况下，就需要我们必须要从左往右填写每一排数据，否则左侧格子的值肯定是-INF或者0这种初始值，这样会导致dp[g][j-...]失去对max的参与，无法发挥作用（这一项的作用就是“在已选本组某物品的情况，再选择本组的其他物品”。一旦失效，意味着dp[g][j]无法存放多个物品的累加和）。但是，如果从左往右填写，会带来另外一个问题，那就是“同一个物品，被选择了2次或者无限次”（这是完全背包的典型特征）。</p><p>　　鉴于上面的情况，<strong>请同学们对本题型放弃“先for j，后for组内物品k”的做法</strong>。</p><h1 id="二实战练习">二、实战练习</h1><h2 id="每组最多选1个物品">2.1 1272（每组最多选1个物品）</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1272">1272：【例9.16】分组背包</a></p><h3 id="ac代码">2.1.2 AC代码</h3><p>1.先for j，再for 组内物品k，标准dp数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法2，每组最多选1个，先for j，再for 组内物品k，标准dp数组  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    参考帖子代码（8） </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxYS1 201</span><br><span class="hljs-type">int</span> dp[<span class="hljs-number">11</span>][maxYS1];    <span class="hljs-comment">// dp应该是物品组g和背包容量YS1的函数，所以定义为dp[g][YS1] </span><br><span class="hljs-type">int</span> YS1, n, gcnt;<br><span class="hljs-type">int</span> tot[maxYS1], ys1[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>], value[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>]; <span class="hljs-comment">// ys1[2][4]：第2组的第4个物品的ys1值，value同理 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 录入背包总重量YS1， 物品件数n个，种类gcnt种 </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;YS1, &amp;n, &amp;gcnt);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> W, C, g;         <span class="hljs-comment">//group组 </span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;W, &amp;C, &amp;g);  <span class="hljs-comment">// 重量W，价值C，组号g </span><br>        tot[g]++;                     <span class="hljs-comment">// 第g组的物品个数增加1个 </span><br>        ys1[g][tot[g]] = W;             <span class="hljs-comment">// 第g组的最新个的重量值为W </span><br>        value[g][tot[g]] = C;           <span class="hljs-comment">// 第g组的最新个的价值值为C </span><br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]= <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 每组最多选1个，所以按组来划分阶段。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g = <span class="hljs-number">1</span>; g &lt;= gcnt; g++) <br><span class="hljs-comment">//      for(int j = YS1; j &gt;= 0; j--)   // 标准dp数组，正序逆序都可以 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= YS1; j++)&#123; <br>dp[g][j] = dp[g<span class="hljs-number">-1</span>][j];       <span class="hljs-comment">// 允许本组一个都不选，所以先假定一个都没选  </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= tot[g]; k++) <br>                <span class="hljs-keyword">if</span> ( j &gt;= ys1[g][k] )<br>                    dp[g][j] = <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j - ys1[g][k]] + value[g][k] );<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[gcnt][YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>先for j，再for 组内物品k，滚动dp数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"> <span class="hljs-comment">//// 方法1；每组最多选1个，先for j，再for 组内物品k，滚动dp数组 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    参考帖子代码（10） </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxYS1 201</span><br><span class="hljs-type">int</span> dp[maxYS1];<br><span class="hljs-type">int</span> YS1, n, gcnt;<br><span class="hljs-type">int</span> tot[maxYS1], ys1[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>], value[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <br><span class="hljs-comment">// 录入背包总重量YS1， 物品件数n个，种类gcnt种 </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;YS1, &amp;n, &amp;gcnt);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123; <br>        <span class="hljs-type">int</span> W, C, g;       <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;W, &amp;C, &amp;g);  <span class="hljs-comment">// 重量W，价值C，组号g </span><br>        tot[g]++;                     <span class="hljs-comment">// 第g组的物品个数增加1个 </span><br>        ys1[g][tot[g]] = W;             <span class="hljs-comment">// 第g组的最新个的重量值为W </span><br>        value[g][tot[g]] = C;           <span class="hljs-comment">// 第g组的最新个的价值值为C </span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 每一组物品 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g = <span class="hljs-number">1</span>; g &lt;= gcnt; g++)<br>      <span class="hljs-comment">// dp[g][j]需要用到dp[g-1][...]，且每个物品最多只被选1次，所以若用滚动数组的话，这里必须倒序  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= <span class="hljs-number">0</span>; j--)  <span class="hljs-comment">// 这里没法写j&gt;=ys1[k]了；k在内层。 </span><br><span class="hljs-comment">// 第g组的第k个不同的物品 </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= tot[g]; k++) <br>                <span class="hljs-keyword">if</span> ( j &gt;= ys1[g][k] )<br>                    dp[j] = <span class="hljs-built_in">max</span>( dp[j],  dp[j - ys1[g][k]] + value[g][k] );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>先for 组内物品k，再for j，标准dp数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法3，每组最多选1个，先for 组内物品k，再for j，标准dp数组</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    参考帖子代码（3）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxYS1 201</span><br><span class="hljs-type">int</span> dp[<span class="hljs-number">11</span>][maxYS1];    <span class="hljs-comment">// dp应该是物品组g和背包容量YS1的函数，所以定义为dp[g][YS1]</span><br><span class="hljs-type">int</span> YS1, n, gcnt;<br><span class="hljs-type">int</span> tot[maxYS1], ys1[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>], value[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>]; <span class="hljs-comment">// ys1[2][4]：第2组的第4个物品的ys1值，value同理</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 录入背包总重量YS1， 物品件数n个，种类gcnt种</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;YS1, &amp;n, &amp;gcnt);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> W, C, g;         <span class="hljs-comment">//group组</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;W, &amp;C, &amp;g);  <span class="hljs-comment">// 重量W，价值C，组号g</span><br>        tot[g]++;                     <span class="hljs-comment">// 第g组的物品个数增加1个</span><br>        ys1[g][tot[g]] = W;             <span class="hljs-comment">// 第g组的最新个的重量值为W</span><br>        value[g][tot[g]] = C;           <span class="hljs-comment">// 第g组的最新个的价值值为C</span><br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 每组最多选1个，所以按组来划分阶段。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>            dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=tot[g]; k++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[g][k]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>                dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[g][k]] + value[g][k] );<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4d&quot;</span>, dp[g][j]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <br>    <br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[gcnt][YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>先for 组内物品k，再for j，滚动dp数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法4；每组最多选1个，先for 组内物品k，再for j，滚动dp数组</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    参考帖子代码（5）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxYS1 201</span><br><span class="hljs-type">int</span> dp[maxYS1], dptmp[maxYS1];<br><span class="hljs-type">int</span> YS1, n, gcnt;<br><span class="hljs-type">int</span> tot[maxYS1], ys1[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>], value[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 录入背包总重量YS1， 物品件数n个，种类k种</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;YS1, &amp;n, &amp;gcnt);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> W, C, g;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;W, &amp;C, &amp;g);  <span class="hljs-comment">// 重量W，价值C，组号g</span><br>        tot[g]++;                     <span class="hljs-comment">// 第g组的物品个数增加1个</span><br>        ys1[g][tot[g]] = W;             <span class="hljs-comment">// 第g组的最新个的重量值为W</span><br>        value[g][tot[g]] = C;           <span class="hljs-comment">// 第g组的最新个的价值值为C</span><br>    &#125;<br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++) &#123;<br>        <span class="hljs-comment">// 用dptmp[0..YS1]来存dp[g-1][0..YS1] </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>            dptmp[j]= dp[j];<br>        <span class="hljs-comment">// 不需要再“照抄上一行数据”了，下面的写法已经隐含地包括了对“不选任何物品”这个选择的max比较了</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=tot[g]; k++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[g][k]; j--)  <span class="hljs-comment">// 必须只能倒序！</span><br>                <span class="hljs-comment">// dptmp[]表示的是dp[g-1][] </span><br>                dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dptmp[j-ys1[g][k]] + value[g][k] );<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　<a href="https://www.luogu.com.cn/problem/P1757">P1757通天之分组背包</a>和本题几乎完全一样，只是录入稍有差异。可作为复习巩固之用。</p><h2 id="p5322每组最多选1个物品">2.2 P5322（每组最多选1个物品）</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P5322">P5322 [BJOI2019]排兵布阵</a></p><p>　　简明题意如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++">   简明题意<br>       你有m个士兵，可以把它们随意分配到 n 个城堡里，在每个城堡中，你需要挑战城堡内的所有<br>   对手，如果在第 i 个城堡的一次挑战中你的士兵个数 &gt; 对手士兵个数 * <span class="hljs-number">2</span>，该场你就获得了i 分；<br>如果挑战失败，该场你获得<span class="hljs-number">0</span>分。已知对手们在每个城堡的士兵人数，求你能获得的总得分的最大值。<br>样例分析：<br>输入： <br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">10</span>  （除我之外还有<span class="hljs-number">2</span>个玩家，<span class="hljs-number">3</span>个城堡，我有<span class="hljs-number">10</span>个士兵） <br><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span>   （第<span class="hljs-number">1</span>个玩家对三个城堡的出兵数量分别为 <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span>） <br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>   （第<span class="hljs-number">1</span>个玩家对三个城堡的出兵数量分别为 <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>）<br>输出：<br><span class="hljs-number">8</span>分<br>解释：我的对三个城堡的出兵数量分别为 <span class="hljs-number">1</span>人   <span class="hljs-number">5</span>人   <span class="hljs-number">1</span>人 <br>这样的话，和第一个玩家PK，赢第<span class="hljs-number">2</span>个城堡得<span class="hljs-number">2</span>分 <br>  和第二个玩家PK，赢第<span class="hljs-number">1</span>个城堡得<span class="hljs-number">1</span>分、赢第<span class="hljs-number">2</span>个城堡得<span class="hljs-number">2</span>分、 赢第<span class="hljs-number">3</span>个城堡得<span class="hljs-number">3</span>分<br>所以一共得<span class="hljs-number">2</span>+<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3</span>=<span class="hljs-number">8</span>分<br>这是得最高分的策略了 <br></code></pre></td></tr></table></figure><h3 id="分析">2.2.2 分析</h3><p>　　首先我们需要搞清楚一个事情，这个题为什么是分组背包而不是贪心？我们可以来看看如下的反例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">  如果要尽量贪心，那么就应该尽可能获得编号值较大的城堡内的挑战胜利，在该城堡内也尽可能获得较多的胜利场次；<br>  反例（1）输入： <br>2 5 21  （除我之外还有2个对手玩家，3个城堡，我有21个士兵） <br>1 1 1 1 10   （第1个对手对三个城堡的出兵数量分别为 1 1 1 1 10） <br>0 0 0 0 0    （第2个对手对三个城堡的出兵数量分别为 0 0 0 0 0）<br>  错误的贪心策略：在编号最大的第5个城堡安排2×10+1=21个士兵（用光），获得2场胜利，得到2×5=10分；<br>  正确的策略：在1～4号城堡分别安排3个士兵，共12个士兵，获得1～4号城堡的8场胜利，共得2+4+6+8=20分；还剩9个士兵安排在5号城堡，获得一场胜利，得5分。所有共计25分。<br><br>  从这个例子可以看出，虽然想尽可能获得编号值较大的城堡里的挑战胜利，但是否真能如愿，完全取决于该城堡里的各玩家的士兵人数情况。而士兵人数情况是存在很大的不确定性的。有可能很轻松就拿下该城堡内所有场次的胜利，也有可能非常困难，得不偿失。在这种情况下，如果一味地想着去贪这种胜利，绝对是错误的策略。<br><br>  既然如此，那是不是在本题中就完全用不上一点点贪心呢？那也不是。<br>  当你已经在某个城堡里打败了所有的对手，那就没有必要再往这个城堡里安排更多的士兵了，而应该把剩余的士兵安排去征服其他的城堡。<br></code></pre></td></tr></table></figure><p>　　根据上面所述的贪心规则，我们完全可以针对每个城堡内敌方的士兵情况，计算出要获得每场胜利所需的最少士兵人数，作为我们的决策。例如在反例（1）中，我们如果想在第1个城堡打败对手2，只需要派1人入驻即可；但如果我们需要打败对手1，则需要派遣3个士兵入驻（这3个士兵同时也能打败对手2）。</p><p>　　对于城堡1，摆在我们面前的结果其实就3种：躺平放弃；打败对手2；打败对手1和对手2。<strong>这三种策略分别对应着“不派遣士兵；派遣1个士兵；派遣3个士兵”这3种策略，带来的收益则分别是“在城堡1内2场挑战两场全输共得0分；在城堡1内2场挑战一胜一负共得1分；在城堡1内2场挑战两场全胜共得2分；”</strong>分析到这里，可能有些同学已经领悟过来了，这不就是分组背包中的题型1（每组最多选1个）吗？</p><p>　　假设第i个城堡有 5个对手，分别在该城堡里入驻了ys1[1..5]={10,20,5,3,5}个士兵，那么除了“不派遣”这个策略之外，我们面临的其他派遣策略就是{21,41,11,7,11}这一共5个策略。如果我们现在选择“战胜第k=1个对手，即派遣21个士兵”这个策略，那么在第i个城堡里可以赢几场呢？这需要我们拿着21去和{21,41,11,7,11}数组中的每个数去比较，累计而得。这挺麻烦的。一个简单的优化就是：我们可以事先对ys1[]进行递增排序，得到ys1[1..5]={3,5,5,10,20}。在这种情况下，如果我们选择“战胜对手1（派遣7人）”，则可以胜1场，获得1×i=i分；如果我们选择“战胜对手4（派遣21人）”，则可以胜4场（战胜对手1、2、3、4），获得4×i=4i分；如果我们选择“战胜对手k（派遣2*ys1[k]+1人）”，则可以胜k场，获得k×i分。经过排序之后，我们可以很方便地获得一个组内的“获胜场次”值k，从而优化代码。</p><p>　　可能有些同学已经看到了ys1[1..5]={3,5,5,10,20}中有两个5。当我们选择第1个5时，k=2，我们认为我们战胜了对手1和对手2，但实际上我们也战胜了对手3。那获胜场次这样计算是否有误呢？仔细思考，其实不影响答案。因为在dp[g][j]=max(dp[g][j],dp[g][j-(2*5+1)]+1*g, dp[g][j-(2*5+1)]+2*g,...)的运算中，dp[g][j-(2*5+1)]+1*g &lt;dp[g][j-(2*5+1)]+2*g，所以dp[g][j-(2*5+1)]+1*g是不会对dp[g][j]的运算结果产生任何影响的。</p><h3 id="ac代码-1">2.2.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-comment">//#define MAX(A,B) ((A)&gt;(B)?(A):(B))       // 自己打MAX比调用max的确要快一丁点 </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">设 dp[j]表示玩家(在第g个城堡)放j个士兵可以获得的最大分数。a[g][k]表示在第g个</span><br><span class="hljs-comment">    城堡时s个玩家中出兵数量第k大的玩家的出兵数量（这样设计有利于算出得分。一共有gcnt个城堡，</span><br><span class="hljs-comment">    相当于就是gcnt个分组。对于每一个城堡，s个玩家有s个出兵</span><br><span class="hljs-comment">数。在和这s个玩家中的任一个进行两两对决时，我只需要出对方数量的两倍多1即可，也</span><br><span class="hljs-comment">就是说，我面对这个玩家，我的策略是a[g][k] * 2 + 1。一共有s个玩家，也就是说，我有</span><br><span class="hljs-comment">s个策略数量可供我选择。这就是我在这一个城堡（分组）内可供选择的策略的成本。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">与之对应，这些策略的收益是得分。战胜当前玩家，我能获得第g个城堡的g分；同时，</span><br><span class="hljs-comment">因为还有k-1个玩家的出兵数少于当前玩家（因为当前玩家的出兵数是第k小），所以我的</span><br><span class="hljs-comment">这个出兵数还能超过这k-1个玩家出兵数的2倍，故我这个策略能使我在第g个城堡的对抗中</span><br><span class="hljs-comment">面对其他玩家，再得(k-1)*g分，所以我这个策略实际有k*g分的收益。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">归纳地说，gcnt个分组，每组内s个决策，每个决策的成本是a[g][k]*2+1人，收益是k*g分 </span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">dp转移方程即为： </span><br><span class="hljs-comment">dp[j] = max( dp[j - a[g][k]*2 - 1] + k * g,   dp[j]);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> s , gcnt, YS1, ans;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">20002</span>];     <span class="hljs-comment">// 滚动dp[]，玩家(在第i个城堡)放j个士兵可以获得的最大分数</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>];   <span class="hljs-comment">// 第i个城堡时s个玩家中出兵数量第k大的玩家的出兵数量</span><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;s, &amp;gcnt, &amp;YS1);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=s; ++k)         <span class="hljs-comment">// s个玩家 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; ++g)  <span class="hljs-comment">// gcnt个城堡 </span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[g][k]);  <span class="hljs-comment">// 反过来存储，以便于等会对每个城堡，按照玩家来进行增序排序 </span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; ++g)<br><span class="hljs-built_in">sort</span>(a[g]+<span class="hljs-number">1</span>, a[g]+<span class="hljs-number">1</span>+s);     <span class="hljs-comment">// 对每个城堡，让s个玩家的出兵数做递增排序，以便于后续统计得分 </span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; ++g)      <span class="hljs-comment">// 枚举分组：gcnt个城堡，就相当于是gcnt个分组 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; --j) <span class="hljs-comment">// 枚举背包容量：倒序枚举派出的兵数 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=s; ++k) <span class="hljs-comment">// 枚举组内策略：对每个城堡，我可以选择s个玩家出兵数的2倍以上，即对这个分组我有s个策略可以选择 </span><br><span class="hljs-keyword">if</span>( j &gt; a[g][k]*<span class="hljs-number">2</span> ) <span class="hljs-comment">// </span><br><span class="hljs-comment">// 每个决策的成本是a[g][k]*2+1，收益是k*g，详情解释见上面的说明 </span><br>dp[j] = <span class="hljs-built_in">max</span>(dp[j-a[g][k]*<span class="hljs-number">2</span><span class="hljs-number">-1</span>]+k*g, dp[j]);<br><span class="hljs-comment">//for(int g=1;g&lt;=gcnt;g++)</span><br><span class="hljs-comment">//for(int j=YS1;j&gt;=0;j--)&#123;</span><br><span class="hljs-comment">//dp[g][j]=dp[g-1][j];//要在枚举 k 的循环外继承。</span><br><span class="hljs-comment">//for(int k=1;k&lt;=s;k++)</span><br><span class="hljs-comment">//if(j&gt;=a[g][k]*2+1)dp[i][j]=max(dp[i][j],dp[i-1][j-a[i][k]*2-1]+k*i);</span><br><span class="hljs-comment">//&#125;</span><br>    <span class="hljs-comment">// 给我的YS1个士兵，我可以不全部放完。反正求出最大值即可。就算放多了，也不会影响得分。 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=YS1; ++i) <br>ans=<span class="hljs-built_in">max</span>(ans, dp[i]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="p2409每组只能选1个物品不能多不能少">2.3P2409（每组只能选1个物品，不能多、不能少）</h2><h3 id="原题链接-2">2.3.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P2409">P2409Y的积木</a></p><h3 id="分析-1">2.3.2 分析</h3><p>　　这个题要求方案数，dp[g][j] = t表示前g个盒子各抽1个积木凑成==j斤积木的组合方案个数是4种。既然表示的是方案数，所以在转移方程中应该是“累加”，而不应该是“累比”。因为是“恰好等于j”，并且还要求每组必须要选，所以对状态[g][j]可能存在无解的情况，所以所有方案数的初始dp值建议设置为0，表示“暂时认为没有任何方案”，即“无解”。</p><p>　　特例情况是“前0个盒子中各抽1个积木，凑成恰好0斤重量，其组合的方案数为1种（dp[0][0]=1;），即'什么积木都不放'（因为是在0个盒子中选，所以不必遵守‘每个盒子都必须选1个’的规定了，因为连盒子都没有）。”</p><p>　　所求目标：一言难尽，看代码。</p><p>　　关于状态转移方程，因为本题的dp数组存放的是方案数，而不是最大值，所以状态转移方程中并没有max或者min，而是用‘+’。现在不能直接套用1.3节中的代码模板，那该怎么做呢？我们可以用一个实际样例来分析看看。有时候把数字具体化，推导起来会更方便，更容易看到一些关系。样例推导过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//    分组背包，每组必须要放1个物品，不能多，不能少</span><br><span class="hljs-comment">//    dp[3][6] = 4 表示前3个盒子各抽1个积木凑成6斤积木的组合方案个数是4种.</span><br><br>    对于第g组的处理：<br>    <span class="hljs-number">1.</span> 如果先<span class="hljs-keyword">for</span> j，再<span class="hljs-keyword">for</span> k（即针对每个状态[g][j]，去考虑它由哪些数值累加而成）<br>        假设第g组(盒)的物品(积木)的重量分别依次是 <span class="hljs-number">10</span>、 <span class="hljs-number">50</span>、 <span class="hljs-number">100</span>和 <span class="hljs-number">580</span>。那么：<br>        <span class="hljs-number">1</span>）对于[g][<span class="hljs-number">300</span>]    <br>            <span class="hljs-comment">// 重量为580的那个积木无法装入，不考虑它</span><br>            dp[g][<span class="hljs-number">300</span>] = dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">290</span>] +  dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">250</span>] + dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">200</span>] <span class="hljs-comment">// 如果不懂这行的由来，请看本站关于背包方案数的专帖后再回来学本帖。 </span><br>            上面的累加式子演变成代码的话，如下所示：<br>            dp[g][<span class="hljs-number">300</span>] = <span class="hljs-number">0</span>;              <span class="hljs-comment">// 初始化[g][300]为&quot;无解&quot;状态</span><br>            dp[g][<span class="hljs-number">300</span>] += dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">290</span>];  <span class="hljs-comment">// 开始累加, 300&gt;=290</span><br>            dp[g][<span class="hljs-number">300</span>] += dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">250</span>];  <span class="hljs-comment">//   300 &gt;=250</span><br>            dp[g][<span class="hljs-number">300</span>] += dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">200</span>];  <span class="hljs-comment">// 300&gt;=200 </span><br>            <span class="hljs-comment">// ......直到本组内所有j&gt;=ys1[]的积木都考虑完，则结束累加的循环</span><br><br>        <span class="hljs-number">2</span>）对于[g][<span class="hljs-number">5</span>]<br>            <span class="hljs-comment">//因为本组内的4个物品的ys1[]值都&gt;5，所以本组内的所有积木都不考虑装入</span><br>            dp[g][<span class="hljs-number">5</span>] = 空气 + 空气（哈哈）<br>            演变成代码就是    <br>            dp[g][<span class="hljs-number">5</span>] = <span class="hljs-number">0</span>;                <span class="hljs-comment">// 初始化[g][5]为&quot;无解&quot;状态 </span><br>            <span class="hljs-comment">// 累加循环一次都不做，直接略过</span><br><br>        对上面的<span class="hljs-number">1</span>）和<span class="hljs-number">2</span>）进行总结后，得到代码模板如下：<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--) <span class="hljs-comment">// YS1是通过计算而得</span><br>            dp[g][j]= <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化状态[g][j]的方案数为0（即“无解”），而不是来源于dp[g-1][j] ！！ </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=ys1[g][<span class="hljs-number">0</span>]; k++)   <span class="hljs-comment">//组内枚举每个物品，ys1[g][0]表示该组内物品的个数</span><br>                <span class="hljs-keyword">if</span> ( j &gt;= ys1[g][k] ) <span class="hljs-comment">//先判断能不能放</span><br>                    <span class="hljs-comment">// 和以往的背包问题中求最大值最小值不同，本题背包问题是求累加和！</span><br>                    <span class="hljs-comment">// 第一次累加时，dp[g][j]原值为0，表示所有方案数都来自于dp[g-1][ j-ys1[g][...] ] </span><br>                    dp[g][j] = dp[g][j] + dp[g<span class="hljs-number">-1</span>][ j-ys1[g][k] ];<br><br>    <span class="hljs-number">2.</span> 如果先<span class="hljs-keyword">for</span> k，再<span class="hljs-keyword">for</span> j（即针对组内的每<span class="hljs-number">1</span>个物品，去填写或者修正dp数组第g排的所有元素）<br>    对于第g组的第k个物品（假设重量为<span class="hljs-number">580</span>），它不可能装入容量为<span class="hljs-number">300</span>斤或者<span class="hljs-number">5</span>斤的背包中，只可能装入容量&gt;=<span class="hljs-number">580</span>的背包中。所以在填写或者修正dp[g][YS1.<span class="hljs-number">.1</span>]时，不需要<span class="hljs-keyword">for</span>\(<span class="hljs-type">int</span> j=YS1, j&gt;=<span class="hljs-number">1</span>; j--)，只需要<span class="hljs-keyword">for</span>\(<span class="hljs-type">int</span> j=YS1, j&gt;=ys1[idx[g][k]]; j--)即可。假设YS1=<span class="hljs-number">1000</span>， 对于本组内重量为<span class="hljs-number">580</span>的物品，只需要处理dp[g][<span class="hljs-number">1000.</span><span class="hljs-number">.580</span>]即可。而对于dp[g][<span class="hljs-number">1.</span><span class="hljs-number">.579</span>]的这些元素值，仍保留原来的数值即可（不管是为初值<span class="hljs-number">0</span>（无解）或者其他数值，这样处理都是合理的）<br>        代码模板如下：<br>        <span class="hljs-comment">///// 参考本帖代码（11），组内必须选1件，先for K 再 for j，标准dp数组，求方案数，初始化为“无解 ” </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>        dp[g][j]= <span class="hljs-number">0</span>;    <span class="hljs-comment">// 默认[g][j]状态暂时无解，方案数为0。当然，也可以用memset或者直接设置为全局数组以自动清0，这样就可以不用写这个for循环了</span><br>        <span class="hljs-comment">// 开始循环累加</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=ys1[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[g][k]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>        dp[g][j]=  dp[g][j] + dp[g<span class="hljs-number">-1</span>][ j-ys1[g][k] ];<br><br></code></pre></td></tr></table></figure><p>　　本题有个小坑点，那就是关于方案数爆int和longlong的问题。同学们一定要小心，一般来说，方案数都是一个很大的数字。所以一旦题目中涉及到要求方案数，一定要注意爆int或者爆longlong的问题。本题如果不特别处理，最后一个subtask会爆longlong。处理方法也很简单，就是不让dp[g][j]的值超过k。为什么可以这样做呢？因为本题要输出dp最后一排各个元素中非零元素的下标（若dp[g][j]==5，则要输出5个j值），如果某一个dp[g][j]的值&gt;k了，的确没必要再去保存精确数值了，对输出的结果无任何影响。</p><h3 id="ac代码-2">2.3.3 AC代码</h3><h4 id="先for-组内物品k后for-j">2.3.3.1 先for 组内物品k，后for j</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 方法1： 分组背包，每组必须要放1个物品，标准状态数组，先for 组内物品k 再forj，恰好等于，方案数 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// ys1[3][5]=12, 表示第3组的第5个积木的约束1属性值（重量）是12</span><br><span class="hljs-comment">// ys1[3][0]=13, 表示第3组内一共有13个物品，存储本组物品个数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxg=<span class="hljs-number">101</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxYS1=<span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> ys1[maxg][<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> dp[maxg][maxYS1]; <span class="hljs-comment">// dp[3][6] = 4 表示前3个盒子各抽1个积木凑成6斤积木的组合方案个数是4种. </span><br><span class="hljs-type">int</span> K, gcnt, YS1;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;gcnt, &amp;K);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++) &#123;<br>        <span class="hljs-comment">// 第i组的物品个数存于ys1[i][0]</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;ys1[g][<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> maxa = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=ys1[g][<span class="hljs-number">0</span>]; j++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;ys1[g][j]);<br>            maxa = <span class="hljs-built_in">max</span>(maxa, ys1[g][j]);<br>        &#125;<br>        <span class="hljs-comment">// 本题中的YS1没有直接被告知，找出每组内的最大值，加起来</span><br>        <span class="hljs-comment">// 每个盒子抽取1个积木，加起来的总重量肯定不会超过YS1=每组中积木的最大重量之和</span><br>        YS1 += maxa;<br>    &#125;<br>    <span class="hljs-comment">// 前0个盒子各抽1个积木凑成&lt;=0斤积木的组合方案个数是1种（=不抽）.</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++)&#123; <span class="hljs-comment">//控制组数</span><br>        <span class="hljs-comment">///// 参考本帖代码（11），组内必须选1件，先for K 再 for j，标准dp数组，求方案数，初始化为“无解 ” </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>        dp[g][j]= <span class="hljs-number">0</span>;    <span class="hljs-comment">// 默认[g][j]状态暂时无解，方案数为0。当然，也可以用memset或者直接设置为全局数组以自动清0，这样就可以不用写这个for循环了</span><br>        <span class="hljs-comment">// 开始循环填写dp</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=ys1[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[g][k]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>        dp[g][j]=  dp[g][j] + dp[g<span class="hljs-number">-1</span>][ j-ys1[g][k] ], dp[g][j] = <span class="hljs-built_in">min</span>(dp[g][j], K);<br>    &#125;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=YS1; i++)&#123;<br>        <span class="hljs-comment">// 打印dp[gcnt][i]个i（在没数到K个之前）</span><br>        <span class="hljs-keyword">while</span>( dp[gcnt][i])&#123;<br>            cout &lt;&lt;i &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            dp[gcnt][i]--;<br><br>            j++;<br>            <span class="hljs-keyword">if</span> (j==K) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法对应的滚动数组模式的代码，请参看本帖的代码（12），此处略过。</p><h4 id="先for-j-再for-组内物品k">2.3.3.2 先for j 再for 组内物品k</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 方法2： 分组背包，每组必须要放1个物品，标准状态数组，先for j 再for 组内物品k，恰好等于，方案数 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// ys1[3][5]=12, 表示第3组的第5个积木的约束1属性值（重量）是12</span><br><span class="hljs-comment">// ys1[3][0]=13, 表示第3组内一共有13个物品，存储本组物品个数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxg=<span class="hljs-number">101</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxYS1=<span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> ys1[maxg][<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> dp[maxg][maxYS1];  <span class="hljs-comment">// dp[3][6] = 4 表示前3个盒子各抽1个积木凑成6斤积木的组合方案个数是4种.</span><br><span class="hljs-type">int</span> k, gcnt, YS1;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;gcnt, &amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++) &#123;<br>        <span class="hljs-comment">// 第i组的物品个数存于ys1[i][0]</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;ys1[g][<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> maxa = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=ys1[g][<span class="hljs-number">0</span>]; j++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;ys1[g][j]);<br>            maxa = <span class="hljs-built_in">max</span>(maxa, ys1[g][j]);<br>        &#125;<br>        <span class="hljs-comment">// 本题中的YS1没有直接被告知，找出每组内的最大值，加起来</span><br>        <span class="hljs-comment">// 每个盒子抽取1个积木，加起来的总重量肯定不会超过YS1=每组中积木的最大重量之和</span><br>        YS1 += maxa;<br>    &#125;<br>    <span class="hljs-comment">// 前0个盒子各抽1个积木凑成&lt;=0斤积木的组合方案个数是1种（=不抽）.</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++)    <span class="hljs-comment">// 控制组数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--) <span class="hljs-comment">// YS1是通过计算而得</span><br>            dp[g][j]= <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化状态[g][j]的方案数为0（即“无解”），而不是来源于dp[g-1][j] ！！ </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=ys1[g][<span class="hljs-number">0</span>]; k++) <span class="hljs-comment">//组内枚举每个物品k</span><br>                <span class="hljs-keyword">if</span> ( ys1[g][k] &lt;= j )       <span class="hljs-comment">//先判断能不能放</span><br>                    <span class="hljs-comment">// 和以往的背包问题中求最大值最小值不同，本题背包问题是求累加和！</span><br>                    dp[g][j] = dp[g][j] + dp[g<span class="hljs-number">-1</span>][ j-ys1[g][k] ], dp[g][j] = <span class="hljs-built_in">min</span>(dp[g][j], k);;<br><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=YS1; i++)&#123;<br>        <span class="hljs-comment">// 打印dp[gcnt][i]个i（在没数到K个之前）</span><br>        <span class="hljs-keyword">while</span>( dp[gcnt][i])&#123;<br>            cout &lt;&lt;i &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            dp[gcnt][i]--;<br><br>            j++;<br>            <span class="hljs-keyword">if</span> (j==K) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法对应的滚动数组模式的代码，请参看本帖的代码（14），此处略过。</p><h2 id="hdu3033每组至少选择1个物品">2.4HDU3033（每组至少选择1个物品）</h2><h3 id="原题链接-3">2.4.1 原题链接</h3><p>　　<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3033">HDU3033I love sneakers!</a></p><p>题意：</p><p>　　一个人去买运动鞋，他手里拥有的钱为<spanclass="math inline">\(YS1(1 \leq YS1 \leq 10000)\)</span>，运动鞋有<span class="math inline">\(gcnt(1 \leq gcnt \leq10)\)</span>种品牌，每种品牌都可能有多双运动鞋，并且对于每种品牌，他都至少要买一双。</p><p>　　输入的数据包含多组测试样例，直到输入的数据文件结束为止。对于每组测试样例，依次输入<spanclass="math inline">\(n(1 \leq n\leq100)\)</span>双运动鞋，YS1值和gcnt值。后面跟着n行数据，每行数据依次为第<spanclass="math inline">\(\ i\ (1 \leq i \leqn)\)</span>双运动鞋所属的品牌号<span class="math inline">\(g[i](1 \leqg[i]\leq gcnt)\)</span>，价格<span class="math inline">\(ys1[i](0 \leqys1[i]\leq 10^5)\)</span>，价值<span class="math inline">\(value[i](0\leq value[i]\leq10^5)\)</span>。输出能获得的最大价值，如果本测试样例无解，输出"Impossible"。</p><h3 id="分析-2">2.4.2 分析</h3><p>　　1)根据“输入的数据包含多组测试样例，直到输入的数据文件结束为止”，可以得到，代码主框架肯定如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>( <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n, &amp;YS1, &amp;gcnt) != EOF ) &#123;<br>        ........<br>&#125;<br></code></pre></td></tr></table></figure><p>　　2)本题是“组内至少要选择1件物品+求最大收益值”的类型，可能存在无解。所以dp数组应初始化为“无解”，即dp[g][j]=-INF。对于本题来说，因为所有收益值都是正数，所以也可以初始化为0，不影响max函数的运行结果。若初始化为-INF，则需要小心第0行应该是全0。</p><p>　　3）关于“测试样例无解”，该怎么理解呢？如果给你10元钱，让你去买飞机坦克大炮，你能买得回来吗？肯定不行。换句话说，每组都有一个最廉价的物品，如果手里的钱不够买所有组内最廉价的物品，那就是无解了。所以我们可以找出每组内最低的价格，累加得到一个购买所有组物品的的最低价。如果给予的钱YS1少于这个最低价，则必然无法购买所有组的物品，即无解，输出“Impossible”。</p><p>　　4）本题要求支持多组样例。所以在每组样例录入前，一定要记得对各种数组进行复位或者重置。</p><h3 id="ac代码-3">2.4.3 AC代码</h3><p>根据分析，这种题型只能采用“先for 组内物品k，再for j”的思路来做。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 一共100双鞋子以内，1万元以内的成本，最多10个品牌 </span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">101</span>, maxYS1=<span class="hljs-number">10001</span>, maxg=<span class="hljs-number">11</span>;<br><span class="hljs-type">int</span> n, YS1, gcnt;<br><span class="hljs-type">int</span> ys1[maxn], value[maxn];<br><span class="hljs-type">int</span> minys1[maxg];  <span class="hljs-comment">// 每组内最小的物品约束量（每组内最便宜的鞋价） </span><br><span class="hljs-comment">// 分组背包专用的下标转换数组</span><br><span class="hljs-comment">// idx[3][5]=14 表示第3组第5个物品在所有物品列表中的下标是14 </span><br><span class="hljs-type">int</span> idx[maxg][maxn];<br><span class="hljs-comment">// dp[3][200]=480 表示前3组物品按照约束要求（每组至少必须买1个），</span><br><span class="hljs-comment">//       在200元约束范围内能获得的最大价值是480元 </span><br><span class="hljs-type">int</span> dp[maxg][maxYS1];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">while</span>( <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n, &amp;YS1, &amp;gcnt) != EOF ) &#123;<br><span class="hljs-comment">// 因为会有多组案例，所以一定要把历史数据清空干净！ </span><br><span class="hljs-built_in">memset</span>(minys1, INF, <span class="hljs-built_in">sizeof</span>(minys1));  <span class="hljs-comment">// 最小值数组要初始化为最大值 </span><br><span class="hljs-built_in">memset</span>(idx, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(idx));<br><span class="hljs-comment">// 如果嫌弃下面这两行有点罗嗦的话，也可以直接让整个dp数组全0，毕竟所有收益值都是整数，0值已经足够小 </span><br><span class="hljs-built_in">memset</span>(dp, -INF, <span class="hljs-built_in">sizeof</span>(dp));         <br><span class="hljs-built_in">memset</span>(dp[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp[<span class="hljs-number">0</span>]));     <span class="hljs-comment">// dp[0][0..YS1]必须要全0 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-comment">// 录入每双鞋所属的品牌编号，需耗成本和价值 </span><br><span class="hljs-type">int</span> g; <br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;g, &amp;ys1[i], &amp;value[i] );<br>++idx[g][<span class="hljs-number">0</span>];<br>idx[g][ idx[g][<span class="hljs-number">0</span>] ] = i;       <span class="hljs-comment">// 第g组第idx[g][0]个鞋子在所有物品中的下标序号是 i </span><br>minys1[g] = <span class="hljs-built_in">min</span> ( minys1[g], ys1[i]);  <span class="hljs-comment">// 记录第g组最小的需耗成本，这个数据不必初始化为最大 </span><br>&#125;<br><span class="hljs-comment">// x表示要每个品牌买一双鞋最起码一共需要多少钱 </span><br><span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=gcnt; i++) <br>x += minys1[i];<br><br><span class="hljs-comment">// 所带的钱不够每个品牌买1双</span><br><span class="hljs-keyword">if</span> ( YS1 &lt; x ) <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Impossible\n&quot;</span>);<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g &lt;= gcnt; g++ )            <span class="hljs-comment">// 历所有组数 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++ )&#123;    <span class="hljs-comment">// 遍历每组的物品 </span><br><span class="hljs-type">int</span> i=idx[g][k];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j&gt;=ys1[i]; j--) <span class="hljs-comment">// 倒序遍历约束量YS1 </span><br><span class="hljs-comment">//                  for(int j = ys1[i]; j&lt;=YS1; j++) // 错误！ 每个物品只能被选1次！ 右侧公式里有dp[g][...] ！见帖子说明 </span><br><span class="hljs-comment">//dp[g][j] = max ( dp[g][j] , max(dp[g-1][j-ys1[i]]+value[i] , dp[g][j-ys1[i]]+value[i]) ); // 和下一行等效，可AC </span><br>dp[g][j] = <span class="hljs-built_in">max</span> ( <span class="hljs-built_in">max</span>(dp[g][j] , dp[g<span class="hljs-number">-1</span>][j-ys1[i]]+value[i] ), dp[g][j-ys1[i]]+value[i] );<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dp[gcnt][YS1]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">// dp[3][200]=480 表示前3组物品在200元约束范围内能获得的最大价值是480元 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">(1)</span><br><span class="hljs-comment">5 15 3</span><br><span class="hljs-comment">1 4 5</span><br><span class="hljs-comment">2 5 10</span><br><span class="hljs-comment">3 4 100</span><br><span class="hljs-comment">1 5 70</span><br><span class="hljs-comment">2 7 50</span><br><span class="hljs-comment">ans:</span><br><span class="hljs-comment">180</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">(2)</span><br><span class="hljs-comment">3 5 3</span><br><span class="hljs-comment">1 2 5</span><br><span class="hljs-comment">2 2 1</span><br><span class="hljs-comment">3 2 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">3 5 3</span><br><span class="hljs-comment">1 0 5</span><br><span class="hljs-comment">2 0 1</span><br><span class="hljs-comment">3 0 2</span><br><span class="hljs-comment">ans:</span><br><span class="hljs-comment">Impossible</span><br><span class="hljs-comment">8</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">(3)</span><br><span class="hljs-comment">3 5 3</span><br><span class="hljs-comment">1 6 0</span><br><span class="hljs-comment">2 0 0</span><br><span class="hljs-comment">3 0 0</span><br><span class="hljs-comment">3 5 3</span><br><span class="hljs-comment">1 0 5</span><br><span class="hljs-comment">2 0 1</span><br><span class="hljs-comment">3 0 2</span><br><span class="hljs-comment">3 5 3</span><br><span class="hljs-comment">1 0 0</span><br><span class="hljs-comment">2 0 0</span><br><span class="hljs-comment">3 0 0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">ans：</span><br><span class="hljs-comment">Impossible</span><br><span class="hljs-comment">8</span><br><span class="hljs-comment">0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span> <br></code></pre></td></tr></table></figure><p>如果需要用滚动数组来做的话，则需要定义一个dptmp[]来存放上一组的结果。之前已经分析过，这里就不再赘述了。</p><h2 id="hdu3535混合分组背包的典型题">2.5HDU3535(混合分组背包的典型题)</h2><h3 id="原题链接-4">2.5.1 原题链接</h3><p>　　<a href="https://acm.hdu.edu.cn/showproblem.php?pid=3535">hdu3535AreYouBusy</a></p><p>　　题目中文意思和解读如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">问题描述<br>新学期快乐！<br>到了三年级之后，小A意识到她没有太多时间来解决问题，因为她还有其他事情要做，这使她几乎发疯了。<br>而且，老板告诉她，对于某些工作集合（是一个“分组”），她必须选择组内的至少一项工作；但是对于某些工作集合而言，她则最多只能选择组内的一项工作。这对老板来说毫无意义。对于其他的工作集合，她可以尽自己的意愿，不选或者选做其中的任意多项工作。我们只将她可以选择的东西定义为“工作”。每1个工作都需要时间，并给xiaoA带来一些幸福感（这意味着她总是愿意做这些工作）。因此，您可以选择其中的最佳组合来给她带来最大的幸福快乐点，同时也可以成为一个好的初中生。 （这意味着她应该听老板的建议）？<br><br>输入项<br>下面有几套测试用例，每套测试用例都以两个整数n和T（0 &lt;= n，T &lt;= 100）开头，有n组作业供您选择，由T分钟供她完成。然后后面是n个描述集，每个描述都以两个整数m和s（0 &lt;m &lt;= 100）开头，该集合中有m个作业，集合类型为s，（0代表应选择的集合至少要完成1项工作，对于最多应选择1项的集合要进行1项选择，可以自由选择的项要进行2项选择。），然后后面是m对整数ci，gi（0 &lt;= ci，gi &lt;= 100），表示第i个工作成本为ci分钟，可以通过完成它获得幸福感gi。每一项工作只能做一次。<br> 输出量<br>每个测试用例一行包含我们可以从所有工作中选择的最大幸福值。如果她不能完成老板想要的工作，则输出-1。<br> 样本输入<br>3 3     第1套用例内有3组作业，要求在3分钟内完成<br>2 1        第1组作业内有2个作业，分组类型为1（最多选择1个作业）<br>2 5           第1个作业成本2分钟，幸福值5<br>3 8           第2个作业成本3分钟，幸福值8<br>2 0        第2组作业内有2个作业，分组类型为0（至少要选择1个作业）<br>1 0           第1个作业成本1分钟，幸福值0<br>2 1           第2个作业成本2分钟，幸福值1<br>3 2        第3组作业内有3个作业，分组类型为2（随意选择）<br>4 3           第1个作业成本4分钟，幸福值3<br>2 1           第2个作业成本2分钟，幸福值1<br>1 1           第3个作业成本1分钟，幸福值1<br><br><br>3 4    第2套用例内有3组作业，要求在4分钟内完成<br>2 1        第1组作业内有2个作业，分组类型为1（最多选择1个作业）<br>2 5           第1个作业成本2分钟，幸福值5<br>3 7           第2个作业成本3分钟，幸福值7<br>2 0        第2组作业内有2个作业，分组类型为0（至少要选择1个作业）<br>1 1           第1个作业成本1分钟，幸福值1<br>2 8           第2个作业成本2分钟，幸福值8<br>3 2        第3组作业内有3个作业，分组类型为2（随意选择）<br>4 4           第1个作业成本4分钟，幸福值4<br>2 1           第2个作业成本2分钟，幸福值1<br>1 1           第3个作业成本1分钟，幸福值1<br><br><br>1 1   第3套用例内有1组作业，要求在1分钟内完成<br>1 0       第1组作业内有1个作业，分组类型为0（至少要选择1个作业）<br>2 1          第1个作业成本2分钟，幸福值1<br><br><br>5 3   第4套用例内有5组作业，要求在3分钟内完成 <br>2 0       第1组作业内有2个作业，分组类型为0（至少要选择1个作业）<br>1 0           第1个作业成本1分钟，幸福值0<br>2 1           第2个作业成本2分钟，幸福值1<br>2 0       第2组作业内有2个作业，分组类型为0（至少要选择1个作业）<br>2 2           第1个作业成本2分钟，幸福值2<br>1 1           第2个作业成本1分钟，幸福值1<br>2 0       第3组作业内有2个作业，分组类型为0（至少要选择1个作业）<br>3 2           第1个作业成本3分钟，幸福值2<br>2 1           第2个作业成本2分钟，幸福值1<br>2 1       第4组作业内有2个作业，分组类型为1（最多选择1个作业）<br>1 5           第1个作业成本1分钟，幸福值5<br>2 8           第2个作业成本2分钟，幸福值8<br>3 2       第5组作业内有3个作业，分组类型为2（任意选择作业）<br>3 8           第1个作业成本3分钟，幸福值8<br>4 9           第2个作业成本4分钟，幸福值9<br>5 10          第3个作业成本5分钟，幸福值10<br><br>样本输出<br><br>5<br>13<br>-1<br>-1<br></code></pre></td></tr></table></figure><h3 id="分析-3">2.5.2 分析</h3><p>　　这是一个分组背包的题，而且每一组的选择策略还不相同，属于混合分组背包，所以不能统一地对整个dp数组去做初始化，而应该根据当前组的选择策略来分别对当前行赋予不同的初始值。当然，第0行是肯定要清零的，而且，因为是多组测试数据，所以需要反复清零。</p><p>　　本题中有一种分组策略为“可以选择0个或者任意多个”。这种题型在第一章中没有讲到。其实做起来也很简单。它实际上是题型1和题型3的结合。因为允许本组选0个物品，所以本组不会存在‘无解’的情况。既然如此，初始化时直接沿用上一行数据，表示本组暂选0个。dp[g][0..YS1]=dp[g-1][0..YS1]。然后再采用题型3的策略，2个max组合起来即可。</p><p>　　本题中允许ys1[i]和value[i]的值为0。只要在填写dp时采用2个max组合起来填，就没问题。</p><p>　　如果把第0列初始化为0，会造成网页中第4个测试样例错误。本题容易出错的地方就是每一行的初始化问题。小心做好，不要“想当然”。</p><h3 id="ac代码-4">2.5.3 AC代码</h3><p>题目中有些分组要求至少要选择一个物品，为简单和统一，建议全都采用“先for组内物品k，再for j”的代码框架。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-type">int</span> gcnt, n, YS1, type;<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">101</span>],value[<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> g, j, i;<br>    <span class="hljs-keyword">while</span>( ~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;gcnt, &amp;YS1) ) &#123;  <span class="hljs-comment">// 多组数据</span><br><span class="hljs-built_in">memset</span>(dp[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp[<span class="hljs-number">0</span>]));  <span class="hljs-comment">// 做每组数据之前重置第0行为全0。中间的正常格子需要根据分组的类型来决定其初值</span><br><br>        <span class="hljs-keyword">for</span>(g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;type);<br>            <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;ys1[i], &amp;value[i]);<br>            <span class="hljs-keyword">if</span>(type == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 组内要至少选择一项工作</span><br>                <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)  <span class="hljs-comment">// 本组要求必须要选，所以可能存在无解，故初始化为无解对应的值-INF，如果选不出来则造成“无解”</span><br>                    dp[g][j] = -INF;   <span class="hljs-comment">// dp[g][0]的初值也必须是无解，其值不能为0！ </span><br><br>                <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>                    <span class="hljs-keyword">for</span>(j=YS1; j&gt;=ys1[i]; j--)<br>                        dp[g][j] = <span class="hljs-built_in">max</span>( dp[g][j], <span class="hljs-built_in">max</span>( dp[g][j-ys1[i]]+value[i], dp[g<span class="hljs-number">-1</span>][j-ys1[i]]+value[i] ) );<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( type == <span class="hljs-number">1</span> ) &#123; <span class="hljs-comment">// 组内最多选择一项工作，可以不选</span><br>                <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;=YS1; j++) <span class="hljs-comment">// 当前组初始化，因为本组允许不选，不存在无解，初始化为上一组的对应值，表示“本组什么都不选”这个策略</span><br>                    dp[g][j] = dp[g<span class="hljs-number">-1</span>][j];<br><br>                <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>                    <span class="hljs-keyword">for</span>(j=YS1; j&gt;=ys1[i]; j--) <span class="hljs-comment">// 倒序</span><br>                        dp[g][j] = <span class="hljs-built_in">max</span>( dp[g][j] , dp[g<span class="hljs-number">-1</span>][j-ys1[i]] + value[i] );<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( type == <span class="hljs-number">2</span> ) &#123;     <span class="hljs-comment">// 任意选择，可一个都不选，也可选多个不同工作</span><br>                <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>                    dp[g][j] = dp[g<span class="hljs-number">-1</span>][j];  <span class="hljs-comment">// 分析与type==1相同</span><br><br>                <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>                    <span class="hljs-keyword">for</span>(j=YS1; j&gt;=ys1[i]; j--)<br>                        dp[g][j] = <span class="hljs-built_in">max</span>( dp[g][j], <span class="hljs-built_in">max</span>( dp[g][j-ys1[i]]+value[i], dp[g<span class="hljs-number">-1</span>][j-ys1[i]]+value[i] )  );<br>            &#125;<br>        &#125;<br>        dp[gcnt][YS1] = <span class="hljs-built_in">max</span>(dp[gcnt][YS1], <span class="hljs-number">-1</span>); <span class="hljs-comment">//所有“无解”的状态，其值都是远远小于0的，现在做输出调整，输出-1</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[gcnt][YS1]);<br><span class="hljs-comment">//        // 调试专用，省略</span><br><span class="hljs-comment">//        for(int j = 0; j&lt;=YS1; j++)</span><br><span class="hljs-comment">//            printf(&quot;%4d&quot;, j);</span><br><span class="hljs-comment">//        printf(&quot;\n&quot;);</span><br><span class="hljs-comment">//        for(int g=0; g &lt;= gcnt; g++ ) &#123;</span><br><span class="hljs-comment">//            for(int j = 0; j&lt;=YS1; j++)</span><br><span class="hljs-comment">//                printf(&quot;%4d&quot;, max(-1,dp[g][j]));</span><br><span class="hljs-comment">//            printf(&quot;\n&quot;);</span><br><span class="hljs-comment">//        &#125;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">第一套测试样例</span><br><span class="hljs-comment">5 3</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">1 0</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">2 2</span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">1 5</span><br><span class="hljs-comment">2 8</span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">3 8</span><br><span class="hljs-comment">4 9</span><br><span class="hljs-comment">5 10</span><br><span class="hljs-comment">正确输出</span><br><span class="hljs-comment">-1</span><br><span class="hljs-comment">错误输出</span><br><span class="hljs-comment">8 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">第二套测试样例</span><br><span class="hljs-comment">输入：</span><br><span class="hljs-comment">3 3</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">2 5</span><br><span class="hljs-comment">3 8</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">1 0</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">4 3</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">3 4</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">2 5</span><br><span class="hljs-comment">3 7</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">1 3</span><br><span class="hljs-comment">1 8</span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">4 4</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment">1 0</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">5 3</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">1 0</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">2 2</span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">1 5</span><br><span class="hljs-comment">2 8</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">3 8</span><br><span class="hljs-comment">4 9</span><br><span class="hljs-comment">5 10</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">1 4</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">2 5</span><br><span class="hljs-comment">3 7</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">正确输出：</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">16</span><br><span class="hljs-comment">-1</span><br><span class="hljs-comment">-1</span><br><span class="hljs-comment">7</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 背包问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
