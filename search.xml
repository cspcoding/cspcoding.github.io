<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>（三）宽度小于等于m的区间的“最大的和值”问题</title>
      <link href="/2025/01/01/%EF%BC%88%E4%B8%89%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"/>
      <url>/2025/01/01/%EF%BC%88%E4%B8%89%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>　　本帖是“最大子段和”系列问题的第3帖，主要研究固定宽度小于等于m的区间的“最大的和值”这个问题。</p><h1 id="一.-理论教学">一. 理论教学</h1><p>　　教学视频：<ahref="https://www.bilibili.com/video/BV1m54y117uu/?">单调队列连续子序列的最大和</a></p><h1 id="二.实战练习">二.实战练习</h1><h2 id="例-2最大连续和">2.1 1598：【 例 2】最大连续和</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<ahref="https://ybt.ssoier.cn/problem_show.php?pid=1598">1598：【 例2】最大连续和</a></p><h3 id="分析">2.1.2 分析</h3><p>　　之前我们练习过“不限区间宽度”及“区间宽度<spanclass="math inline">\(==m\)</span>”的情况。在“不限区间宽度”时，我们曾经在方法２中的版本２代码中，用单调队列来解决问题。已经记不太清楚的同学请看<a href="/2024/12/24/%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E5%BA%A6%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/#jump1"><font color="red">这里</font></a>。在单调队列进行处理时，因为并没有限制滑窗（即区间）宽度，所以在代码中并不需要处理队头的出队操作。</p><p>　　在本帖的1598这种题中，要求“区间宽度<spanclass="math inline">\(\leqm\)</span>”，只需要在单调队列代码模板里维护好滑窗宽度，做好队头的出队操作即可。单调队列本来就可以处理滑窗宽度<spanclass="math inline">\(\leqm\)</span>的情况。另外需要注意的是，在用单调队列求解时，是针对原始数据的<strong>“前缀和数组s[]”</strong>，在第i个元素<strong>左侧</strong>的宽度为ｍ（当<spanclass="math inline">\(i &lt; m\)</span>时允许滑窗宽度<spanclass="math inline">\(&lt;m\)</span>）的滑窗内求其<strong>最小值</strong>。而这正好也是“单调队列求最值”能做到的事情。</p><p>　　<span id="jump1">假设<spanclass="math inline">\(m=3\)</span>，</span>原始数组为<spanclass="math inline">\(a[1..n]\)</span>，对应的前缀和数组为<spanclass="math inline">\(s[1..n]\)</span>，<spanclass="math inline">\(dpmax[i]\)</span>表示"<strong>在选定<spanclass="math inline">\(a[i]\)</span>的前提下，在<spanclass="math inline">\(a[i-m+1..i]\)</span> 这<spanclass="math inline">\(m\)</span>个元素中选择的连续子段内所有数的最大和值</strong>"，写法"<spanclass="math inline">\(a[3..5]\)</span>"表示"<spanclass="math inline">\(a[3]+a[4]+a[5]\)</span>"，则有 $$ <spanclass="math display">\[\begin{align}dpmax[1]&amp;=max(\ a[1..1]\ ) \tag{1}  \\&amp;=max(s[1]-s[0]) \\&amp;=s[1]-min(s[0])（无它，保持和公式(2..5)一致的公式模式而已）\\&amp;= s[1]-0=s[1] = a[1]\\\\dpmax[2]&amp;=max(\ a[1..2],\ \ a[2..2]\ ) \\&amp;=max(s[2]-s[0],\ s[2]-s[1]) \\&amp;=s[2]-min(\ s[0], s[1])  \tag{2}\\\\dpmax[3]&amp;=max(\ \ a[1..3],\ \ \qquad \quad a[2..3],\ \ \qquad \quada[3..3]\ \ ) \\&amp;=max(\ s[3]-s[0],\ \quad s[3]-s[1],\ \quad s[3]-s[2]\ ) \\&amp;=s3-min(\ s[0],\ s[1],\ s[2]\ ) \tag{3}\\\\dpmax[4]&amp;=max(\ \ a[2..4],\ \ \qquad\quad  a[3..4],\ \ \qquad \quada[4..4]\ \ )  \\&amp;=max(\ s[4]-s[1],\ \quad s[4]-s[2],\ \quad s[4]-s[3]\ ) \\&amp;=s[4]-min(\ s[1],\ s[2],\ s[3]\ ) \tag{4}\\\\dpmax[5]&amp;=max(\ \ a[3..5],\ \ \qquad\quad  a[4..5],\ \ \qquad \quada[5..5]\ \ )  \\&amp;=max(\ s[5]-s[2],\ \quad s[5]-s[3],\ \quad s[5]-s[4]\ ) \\&amp;=s[5]-min(\ s[2],\ s[3],\ s[4]\ ) \tag{5}\\\\\end{align}\]</span> <span class="math display">\[则有一般性公式推导如下：\]</span> <span class="math display">\[\begin{align}dpmax[i]&amp;=max(\ \ a[i-m+1..i],\ \ \quad  a[i-m+2..i],\quad ......\,\ \quad a[i-1..i],\ \qquad \quad a[i..i]\qquad\ )  \\&amp;=max(\ s[i]-s[i-m],\ \quad s[i]-s[i-m+1],\ ......\ ,\quads[i]-s[i-2],\quad s[i]-s[i-1]\ ) \\&amp;=s[i]-\textcolor[RGB]{255,0,0}{min(\ s[i-m],\qquads[i-m+1]\qquad,\  ......\ ,\qquad \quad s[i-2],\qquad s[i-1]\ \qquad\ )}\tag{6}\\\\\end{align}\]</span> $$ 　　从上面的公式（６）可以看出：</p><p>１）我们把一个求最大值的问题，变成了一个求最小值的问题。</p><p>２）原本是求<spanclass="math inline">\(a[]\)</span>的“和值”，现在改成了求<spanclass="math inline">\(s[]\)</span>的最值。</p><p>３）在第<spanclass="math inline">\(i\)</span>轮，对应的滑窗下标是<spanclass="math inline">\(s[i-m..i-1]\)</span>，单调队列考虑进队的新元素为<spanclass="math inline">\(s[i-1]\)</span>，队尾进队的值是<spanclass="math inline">\(i-1\)</span>（存下标）。</p><h3 id="ac代码">2.1.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">求子段长度不大于m的最大子段和</span><br><span class="hljs-comment">用单调队列来进行优化 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>,INF=<span class="hljs-number">1e9</span>,M=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> dq[M];  <span class="hljs-comment">// 单调队列，规模看M即可</span><br><span class="hljs-type">int</span> s[N];   <span class="hljs-comment">// 前缀和数组 </span><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;s[i]), s[i]+=s[i<span class="hljs-number">-1</span>];<span class="hljs-comment">//输入原始数据的同时算出前缀和数组 </span><br>    <span class="hljs-type">int</span> h=<span class="hljs-number">1</span>,t=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> res =-INF;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<span class="hljs-comment">//单调队列保存下标</span><br>     <span class="hljs-comment">//根据方法2的公式6得，用单调队列在第i轮处理min(s[i-m..i-1])这m个前缀和值的最小值 </span><br>        <span class="hljs-keyword">while</span>(h&lt;=t&amp;&amp;s[i<span class="hljs-number">-1</span>]&lt;=s[dq[t]]) t--;<span class="hljs-comment">//如果当前对头元素比当前元素大，并且队列不空就滑出队列</span><br>        dq[++t]=i<span class="hljs-number">-1</span>;        <br><br>        <span class="hljs-keyword">if</span>((i<span class="hljs-number">-1</span>)-dq[h]+<span class="hljs-number">1</span> &gt; m ) h++;<span class="hljs-comment">//如果队尾下标不在m范围的话就划出队列</span><br>        <br>        res=<span class="hljs-built_in">max</span>(res,s[i]-s[dq[h]]);<br>    &#125;<br>    cout&lt;&lt;res&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">6 4</span><br><span class="hljs-comment">1 -3 5 1 -2 3</span><br><span class="hljs-comment">7</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线性结构编程技巧 </category>
          
          <category> 最大子段和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（二）固定宽度为m的区间的“最大的和值”问题</title>
      <link href="/2025/01/01/%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9B%BA%E5%AE%9A%E5%AE%BD%E5%BA%A6%E4%B8%BAm%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"/>
      <url>/2025/01/01/%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9B%BA%E5%AE%9A%E5%AE%BD%E5%BA%A6%E4%B8%BAm%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>　　本帖是“最大子段和”系列问题的第2帖，主要研究固定宽度为m的区间的“最大的和值”问题。内容比较简单，橙标题，就直接上题目了。</p><h1 id="一.-p3353-在你窗外闪耀的星星">一. P3353 在你窗外闪耀的星星</h1><h2 id="原题链接">1.1 原题链接</h2><p>　　<a href="https://www.luogu.com.cn/problem/P3353">P3353在你窗外闪耀的星星</a></p><p>　　概要题意：</p><p>　　录入<spanclass="math inline">\(n\)</span>个数的一维坐标整数值<spanclass="math inline">\(pos\)</span>和整数值<spanclass="math inline">\(w\)</span>，求所有坐标宽度为<spanclass="math inline">\(m\)</span>的区间内（含整数边界点）的数之和的最大值。假设<spanclass="math inline">\(m=3\)</span>，则即求<spanclass="math inline">\(max(sum[1..3],\ sum[2..4],\ sum[3..5], \......)\)</span>。</p><h2 id="分析">1.2 分析</h2><p>　　此题最明显的特征就是区间宽度固定不变，为<spanclass="math inline">\(m\)</span>。用前缀和来解本题最为方便。需要小心的是，根据题意，这<spanclass="math inline">\(n\)</span>个点的坐标是可以重复的，所以需要先叠加好每个坐标上的数值，然后再来做前缀和。在<spanclass="math inline">\(a[i]\)</span>值还没有完全确定时就去做<spanclass="math inline">\(sum[1..i]\)</span>，这样会不准确。</p><p>　　另外，<spanclass="math inline">\(n\)</span>并不是这些数的最大下标值，仅仅只是初始数据规模而已，在填入<spanclass="math inline">\(a[]\)</span>后，建议求出下标的最大值<spanclass="math inline">\(maxp\)</span>，适当简化后续的数据遍历操作。</p><h2 id="ac代码">1.3 AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[maxn];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> pos, w, maxp;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;pos, &amp;w), a[pos]+=w, maxp=<span class="hljs-built_in">max</span>(maxp, pos);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=maxp; i++) a[i]+=a[i<span class="hljs-number">-1</span>];<br><br><span class="hljs-type">int</span> mmax=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=m; i&lt;=maxp; i++)mmax= <span class="hljs-built_in">max</span>(mmax, a[i]-a[i-m]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, mmax);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二.-at_joi2007ho_a-最大の和">二. AT_joi2007ho_a 最大の和</h1><h2 id="原题链接-1">2.1 原题链接</h2><p>　　<ahref="https://www.luogu.com.cn/problem/AT_joi2007ho_a">AT_joi2007ho_a最大の和</a>　／　<ahref="https://atcoder.jp/contests/joi2007ho/tasks/joi2007ho_a"><strong>A- 最大の和</strong></a></p><h2 id="分析-1">2.2 分析</h2><p>　　和P3353基本上类似。</p><h2 id="ac代码-1">2.3 AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">固定区间宽度的最大子段和，用前缀和思想来解决即可 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[maxn];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);<br>a[i]+=a[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-type">int</span> mmax=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=m; i&lt;=n; i++) mmax= <span class="hljs-built_in">max</span>(mmax, a[i]-a[i-m]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, mmax); <span class="hljs-comment">// 此处必须要有\n，ATcoder的变态规则 </span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线性结构编程技巧 </category>
          
          <category> 最大子段和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（七）不限宽的m子段的“最大的和值”问题</title>
      <link href="/2025/01/01/%EF%BC%88%E4%B8%83%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84m%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"/>
      <url>/2025/01/01/%EF%BC%88%E4%B8%83%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84m%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>　　本帖是“最大子段和”系列问题的第7帖，主要研究不限宽的m子段的“最大的和值”问题。</p><h1 id="一.-原题链接">一. 原题链接</h1><p>　　<a href="https://acm.hdu.edu.cn/showproblem.php?pid=1024">HDU1024Max Sum Plus Plus</a></p><p>　　中文大意如下：</p><p>　　给定一个连续的整数序列 <spanclass="math inline">\(a[1:n]=\{a_1、a_2、a_3、a_4、 ... a_i、... a_n\}(1 ≤ i ≤ n ≤ 1,000,000，-32768 ≤ a_i ≤ 32767)\)</span>。有函数 <spanclass="math inline">\(sum(le, ri) = a_{le} + ... + a_{ri} \quad(1 ≤ le ≤ri ≤ n)\)</span>。现在给定一个整数 <span class="math inline">\(m (m &gt;0)\)</span>，你的任务是找出$ m $（不能多，也不能少）对 <spanclass="math inline">\(le\)</span> 和<spanclass="math inline">\(ri\)</span>，使得 $sum(le_1 , ri_1 ) + sum(le_2 ,ri_2 ) + ... + sum(le_m , ri_m ) <spanclass="math inline">\(最大。（不允许\)</span>le_i ≤ le_j ≤ ri_i<spanclass="math inline">\(或\)</span> le_i ≤ ri_j ≤ri_i$，即不允许区间之间有重叠或交叉）。</p><p>　　输入的行数不确定，每一行代表了一个测试样例，该行第１个数是<spanclass="math inline">\(m\)</span>，第２个数是<spanclass="math inline">\(n\)</span>，后续跟着<spanclass="math inline">\(n\)</span>个整数。</p><p>　　输出多行，和输入行数一致，每行为一个测试样例中的ｍ段最大和值。</p><h1 id="二.-分析">二. 分析</h1><p>　　之前我们学过不限宽的２段的最大的和值问题，本题要做的是<spanclass="math inline">\(ｍ(m&gt;0)\)</span>段。感觉这个题是之前旧题的升级版。能不能在原有题型的基础上进行拓展来解决本题型呢？对于２段，我们枚举了分隔点，利用它把整个数组分成了左半段和右半段，然后正推，逆推。但如果是４段、１０段等，明显原来的方法不再适用了。需要重新换思路了，怎么搞？</p><p>　　目前已经学过的方法有贪心、分治、递推（ｄｐ）、深搜、二分等。对于给定的数组<spanclass="math inline">\(a[1..n]\)</span>，原始顺序肯定不能随意改变，否则题解肯定会大变。所以肯定不能排序了。分治和递推实际上是同一种思路，只不过是范围从大到小或从小到大的区别。深搜肯定不行，绝对TLE。二分主要用于在单调性函数中确定一个点的值，这里好像对不上。现在试着来递推一下看看。</p><p>　　递推和ｄｐ是相通的。下面尝试采用ｄｐ的思路来思考。</p><p>　　本题要求在ｎ个数中选择ｍ个连续子段，求其最大子段和。ｎ不同，结果不同；ｍ不同，结果也会不同。所以，ｎ和ｍ都会影响最终的结果值。一个状态由数组元素个数ｊ和子段数ｉ共同确定。鉴于子段数据的连续性，为了方便研究，所以有如下：</p><p>一）状态数组定义</p><p>　　<span class="math inline">\(dp[i][j]\)</span>表示在<spanclass="math inline">\(a[1..j]\)</span>中选择<spanclass="math inline">\(i\)</span>个子段，且<spanclass="math inline">\(a[j]\)</span>属于第<spanclass="math inline">\(i\)</span>个子段后的最大子段和值。（之所以让子段数在第一维，是为后续的dp数组空间优化做准备，这纯属经验；之所以要求<spanclass="math inline">\(a[j]\)</span>必须要在最末子段内，也属经验）</p><p>二）所求目标</p><p>　　<span class="math inline">\(max(\ dp[m][m:n]\ )\)</span></p><p>三）状态转移方程</p><p>　　因为每个子段内的数据必然是连续性的，所以对于每个新元素<spanclass="math inline">\(a[j]\)</span>有如下两种情况：</p><p>　　１）已有<spanclass="math inline">\(i-1\)</span>个子段，新开第<spanclass="math inline">\(i\)</span>个子段，且把<spanclass="math inline">\(a[j]\)</span>作为该新子段的第一个元素；</p><p>　　　　<span class="math inline">\(a[j]\)</span>左侧已经选出了<spanclass="math inline">\(i-1\)</span>个子段，可以模拟个数据来分析一下。假设<spanclass="math inline">\(m=5,n=7\)</span>，现在要求<spanclass="math inline">\(dp[3][5]\)</span>，则在情况１）下，有"前５个数选３个子段的和＝max(前２个数各自成子段且第５个数成第３子段，前３个数选出２子段且第５个数成第３子段，　前４个数选出２个子段且第５个数成第３子段)"，写成公式如下：<span class="math display">\[dp[3][5]=max(\ a[5]+dp[2][2],\ \ \ a[5]+dp[2][3],\ \ \ a[5]+dp[2][4]\ )\]</span> 　　　　将其一般化，有下面的公式（１）： <spanclass="math display">\[dp[i][j]=a[j]\ +\ max(\ dp[i-1][k]\ );\quad(i \in [1:m];\j\in[i:i+n-m];\ k \in[i-1:j-1]\ )\tag{1}\]</span> 　　２）已有<spanclass="math inline">\(i\)</span>个子段，把<spanclass="math inline">\(a[j]\)</span>作为第<spanclass="math inline">\(i\)</span>个子段的元素，总的子段数不变仍为<spanclass="math inline">\(i\)</span>个； <span class="math display">\[dp[i][j]=a[j]+dp[i][j-1];\quad (\ i\in[1:m];\ j\in[i:i+n-m]\ )\tag{2}\]</span> 　　将公式（１）和（２）整合一下，得到最后的状态转移方程如下：<span class="math display">\[dp[i][j]=a[j]+max\textcolor[RGB]{255,0,0}(\ dp[i][j-1]\+\  max\textcolor[RGB]{255,255,0}(\ dp[i-1][k]\\textcolor[RGB]{255,255,0})\ \textcolor[RGB]{255,0,0});\quad(i \in[1:m];\ j\in[i:i+n-m];\ k \in[i-1:j-1]\ )\tag{3}\]</span> 四）循环顺序和边界</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic/img/%EF%BC%88%E4%B8%83%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84m%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%981.png" alt="image-20250101143316213" style="zoom: 80%;" /></p><p>　　对于<span class="math inline">\(i\)</span>，肯定是<spanclass="math inline">\([1:m]\)</span>，根据公式（３），需要用到上一行的内容，所以<spanclass="math inline">\(i\)</span>只能从上往下增序。</p><p>　　对于<spanclass="math inline">\(j\)</span>，我们的目的是要算出<spanclass="math inline">\(dp[m][m:n]\)</span>，例如求<spanclass="math inline">\(dp[4][7]\)</span>，我们没必要去计算和填写<spanclass="math inline">\(dp[1][5]、dp[2][6]\)</span>等数据，为什么呢？因为要想在前７个数中选出４个子段，那么就不可能在前６个数中选出２个子段，因为仅剩７－６＝１个数了，没办法把１个数划分出4－２＝２个子段，也没办法把２个数划分出４－１＝３个子段。所以虽然<spanclass="math inline">\(dp[1][5]、dp[2][6]\)</span>存在，但对我们的所求目标没有任何贡献，自然不需要去计算了（如上图灰色区域格子）。准确地说，剩余的数的个数<spanclass="math inline">\(n-j\)</span>要大于等于剩余的子段数<spanclass="math inline">\(m-i\)</span>，即有<spanclass="math inline">\(n-j\geq m-i\quad \Rightarrow\quad j \leq i+n-m\\)</span>。另外，我们也没必要去填写诸如<spanclass="math inline">\(dp[5][2]\)</span>这类数据（如上图红色区域格子），因为前２个数据不可能被分为５个子段，因为每个子段至少要有１个数据。也就是说，<spanclass="math inline">\(j\geq i\)</span>。归纳一下得<spanclass="math inline">\(j \in[i:i+n-m]\)</span>，每行填写<spanclass="math inline">\(n-m+1\)</span>个数即可。因为需要用到第<spanclass="math inline">\(j-1\)</span>列的数据，所以<spanclass="math inline">\(j\)</span>只能从左往右增序。</p><p>　　对于<spanclass="math inline">\(k\)</span>，来自于公式（３）中的<spanclass="math inline">\(max(dp[i-1][k])\)</span>，对应的<spanclass="math inline">\(dp[][]\)</span>数据来自于上一行，全都已知，故<spanclass="math inline">\(k\)</span>增序降序都可以。假设第<spanclass="math inline">\(i-1\)</span>个子段的最右侧元素下标为<spanclass="math inline">\(k\)</span>，则<spanclass="math inline">\(k\)</span>可能的最小值为<spanclass="math inline">\(i-1\)</span>（前面的每１个元素都自成１个子段，则第<spanclass="math inline">\(i-1\)</span>个子段为<spanclass="math inline">\(a[i-1:i-1]\)</span>）。<spanclass="math inline">\(k\)</span>可能的最大值是<spanclass="math inline">\(j-1\)</span>。总结后<spanclass="math inline">\(k\)</span>的范围就是<spanclass="math inline">\([i-1:j-1]\)</span>。</p><p>五）特例和初始化</p><p>　　对于对角线和第１行的数据，均来自于左侧一列、上一行和<spanclass="math inline">\(a[]\)</span>，当默认数据为０时公式（３）并不冲突，所以直接初始化<spanclass="math inline">\(dp[0:m][0:n]\)</span>为全０即可。</p><p>六）复杂度分析</p><p>　　可以看到，公式（３）的时间复杂度和空间复杂度都是比较高的，时间复杂度为<spanclass="math inline">\(O(m*(n-m)^2)\)</span>，空间复杂度为<spanclass="math inline">\(O(m*n)\)</span>。</p><p>七）时间复杂度优化</p><p>　　对于上图中求红色长方框内区域的最大值，没必要针对每个<spanclass="math inline">\(dp[i][j]\)</span>去循环<spanclass="math inline">\(k\)</span>来重新计算当前的最大值，完全可以利用上一轮计算的结果来刷新最大值。需要注意的是，随着<spanclass="math inline">\(j\)</span>的循环，需要比较最大值的元素是<spanclass="math inline">\(dp[i-1][j-1]\)</span>。这样可以把三重循环降为二重循环，时间复杂度变为<spanclass="math inline">\(O(m*(n-m))\)</span>。</p><p>八）空间复杂度优化</p><p>　　从上图和公式（３）可以看到，每次填写一个网格，只需要用到上一行和当前行左侧一格的数据，但此处不能用滚动数组，因为根据分析，我们必须要从左往右去循环<spanclass="math inline">\(j\)</span>（不能从右往左），且需要用到的是<spanclass="math inline">\(dp[i-1][i-1:j-1]\)</span>，而不是<spanclass="math inline">\(dp[i][i-1:j-1]\)</span>。但所幸的是，只需要用到当前行和上一行的完整数据，所以没必要设定<spanclass="math inline">\(dp[][]\)</span>为<spanclass="math inline">\(m\)</span>行。故而只需要设定<spanclass="math inline">\(dp[2][0..n]\)</span>这２行即可，空间复杂度降为<spanclass="math inline">\(O(2*n)\)</span>。</p><p>　　我们没必要每次填完之后去来回复制整行，这里可以学习一个小的编程技巧。我们知道<spanclass="math inline">\(0\oplus 1=1;1\oplus 1=0;\)</span>（<spanclass="math inline">\(\oplus\)</span>表示“按位异或”），也就是说，不管起初变量a=1或者a=0，在做<spanclass="math inline">\(\oplus1\)</span>操作后的算式值都会恰好相反（即从０变成１，或从１变成０），所以在提取上一行值时可以用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">maxpre=<span class="hljs-built_in">max</span>(maxpre, dp[k^<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]);  <span class="hljs-comment">// k^1表示上一行。当k==0时k^1的值为1,当k==1时k^1的值为0</span><br></code></pre></td></tr></table></figure><p>　　这样设置后，第<spanclass="math inline">\(m\)</span>行的结果最后是存放在<spanclass="math inline">\(dp[0][...]\)</span>或者<spanclass="math inline">\(dp[1][...]\)</span>呢？当<spanclass="math inline">\(m=1\)</span>时最终结果在第１行，当<spanclass="math inline">\(m=2\)</span>时最终结果在第０行，当<spanclass="math inline">\(m=3\)</span>时最终结果在第１行，当<spanclass="math inline">\(m=4\)</span>时最终结果在第０行，当<spanclass="math inline">\(m=5\)</span>时最终结果在第１行，……。可以看出，ｍ若为奇数则在１，ｍ若为偶数则在０。故结果可以写成<spanclass="math inline">\(dp[m\%2][...]\)</span>或者<spanclass="math inline">\(dp[m\&amp;1][...]\)</span>。</p><h1 id="三.-ac代码">三. AC代码</h1><p>　　注意一下，longlong类型的最大值为LLONG_MAX。不过本题数据弱，使用INT_MAX也没报错～～</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>; <br><span class="hljs-type">int</span> n,m;<br>ll a[N],dp[<span class="hljs-number">2</span>][N];   <span class="hljs-comment">//只保存上一行和当前行 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;m,&amp;n))&#123;   <span class="hljs-comment">//n个数字，m子段和 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,a+i);  <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) dp[<span class="hljs-number">0</span>][i]=<span class="hljs-number">0</span>,dp[<span class="hljs-number">1</span>][i]=<span class="hljs-number">0</span>;    <br><span class="hljs-comment">// 仍然需要设定i来标识出j的左右边界值，k只是0或1，无法代替这一个功能，k只在存入和读取dp的时候起作用 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,k=<span class="hljs-number">1</span>; i&lt;=m; i++,k^=<span class="hljs-number">1</span>)&#123;    <span class="hljs-comment">//分为i段，k为两行之间的切换</span><br>        dp[k][i<span class="hljs-number">-1</span>]= -LLONG_MAX;    <span class="hljs-comment">// 让同行左侧的dp[i][i-1]值不去影响dp[i][i]的填写，此时也需用到 k </span><br>            ll maxpre = -LLONG_MAX;    <span class="hljs-comment">// maxpre记录上一行的最大值，在每一行开始时需要重新置初始值 </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n-m+i;j++)&#123;<br>                maxpre=<span class="hljs-built_in">max</span>(maxpre,dp[k^<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]);      <span class="hljs-comment">//随时更新上一行最大值</span><br>                dp[k][j]=<span class="hljs-built_in">max</span>(dp[k][j<span class="hljs-number">-1</span>],maxpre)+a[j]; <span class="hljs-comment">//对应公式３</span><br>            &#125;<br>        &#125;<br>        ll ans= -LLONG_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m;i&lt;=n;i++) ans=<span class="hljs-built_in">max</span>(ans,dp[m&amp;<span class="hljs-number">1</span>][i]);  <span class="hljs-comment">//找到第m行的最大值，即为答案</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>    &#125;  <br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入 </span><br><span class="hljs-comment">4 7 -2 11 -4 13 -5 6 -2</span><br><span class="hljs-comment">输出</span><br><span class="hljs-comment">28 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线性结构编程技巧 </category>
          
          <category> 最大子段和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（六）不限宽的2子段的“最大的和值”问题</title>
      <link href="/2024/12/31/%EF%BC%88%E5%85%AD%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%842%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"/>
      <url>/2024/12/31/%EF%BC%88%E5%85%AD%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%842%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>　　本帖是“最大子段和”系列问题的第6帖，主要研究不限宽的2个子段区间内的“最大的和值”这个问题。要求学生已学过<spanclass="math inline">\(dp\)</span>入门类的题目。本题是后续的“不限宽的ｍ个子段区间内的最大的和值”的特殊情况<spanclass="math inline">\((m=2)\)</span>，可以用比较简单的做法来做，所以本帖先搞定简单的做法。（<del>其实也不简单，若不看题解，可能会搞死一些小朋友的</del>）</p><h1 id="一.-原题链接">一. 原题链接</h1><p>　　<a href="https://www.luogu.com.cn/problem/P2642">P2642双子序列最大和</a></p><h1 id="二.-分析">二. 分析</h1><p>　　我们之前已经学过了“不限宽的区间的“最大的和值”问题”，只需要求１个子段，是本系列的第一个帖子。现在要求２个子段，这该怎么办呢？</p><p>　　我们可以枚举一个分隔点<spanclass="math inline">\(i\)</span>，然后在<spanclass="math inline">\(a[0:i-1]\)</span>和<spanclass="math inline">\(a[i+1:n-1]\)</span>这两个数组中各自选出１个最大子段和，再相加即可。根据题意，<spanclass="math inline">\(a[i]\)</span>不属于左段，也不属于右段。</p><p>　　因为<spanclass="math inline">\(i\)</span>是枚举的变量，是不断在变化的，在求<spanclass="math inline">\(a[0:i-1]\)</span>中的最大子段和时，可以<strong>设定<spanclass="math inline">\(dp1[k]\)</span>为“在选定<spanclass="math inline">\(a[k]\)</span>的前提下，在<spanclass="math inline">\(a[0:k]\)</span>数组中选择１个子段后得到的最大的和值”</strong>，可以在<font color="red">从左往右</font>枚举<spanclass="math inline">\(i\)</span>的时候同步填写<spanclass="math inline">\(dp[k]\)</span>（即<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(k\)</span>同步，不需要专门定义变量<spanclass="math inline">\(k\)</span>），其解决思想和“<ahref="https://www.luogu.com.cn/problem/P1115">P1115最大子段和</a>”很相似，需要用到贪心的思想去递推即可。</p><p>　　但要去求<spanclass="math inline">\(a[i+1:n-1]\)</span>的１个最大子段和时，因为右子段的起始位置不再是０，而是变化的位置<spanclass="math inline">\(i+1\)</span>，这使得程序变得复杂。但如果我们反过来思考，<strong>设定<spanclass="math inline">\(dp2[k]\)</span>为“在选定a[k]的前提下，在<spanclass="math inline">\(a[k:n-1]\)</span>数组中选择１个子段后得到的最大的和值”</strong>，<font color="red">从右端往左端</font>使用贪心的思想来递推即可。这种思想，和以前练过的“<ahref="https://www.luogu.com.cn/problem/P1091">P1091 [NOIP2004 提高组]合唱队形</a>”的思想很相似。</p><p>　　但是，所求的目标并不等于<spanclass="math inline">\(max(dp1[i]+dp2[i])\quad(i\in[0..n-1])\)</span>，也不等于<spanclass="math inline">\(max(dp1[i]+dp2[i]-a[i])\)</span>，为什么呢？请看下图：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic/img/%EF%BC%88%E5%85%AD%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%842%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%981.png" alt="image-20241231161546354" style="zoom: 67%;" /></p><p>　　在上面的图中，我们把整个数组分成了<spanclass="math inline">\(a[0:i-1]、\ \ a[i]、\ \a[i+1:n]\)</span>这三段。红框表示左半段中选择的最大子段，绿框表示右半段中选择的最大子段，橙色表示选中子段的最左／最右的那个元素。根据题意，图（ａ）肯定是不可能的，因为题意说了两个子段必须要分开，至少间隔１个元素，不能视为一个子段。图（ｂ）和图（ｃ）都是符合题意的。但是根据我们对<spanclass="math inline">\(dp1[i]\)</span>和<spanclass="math inline">\(dp2[i]\)</span>的定义，<spanclass="math inline">\(dp1[i]+dp2[i]\)</span>只能表达出图（ａ），是不符合题意规定的；而<spanclass="math inline">\(dp1[i-1]+dp2[i+1]\)</span>也只能表达出图（ｂ）的情况，而无法表达图（ｃ）。那该怎么办呢？</p><p>　　我们仔细看图（ｃ）的左半段，可以发现，<font color="red">红框内元素之和，是<spanclass="math inline">\(a[0:i-1]\)</span>这个左半段中的最大子段和（<strong>不一定要以<spanclass="math inline">\(a[i-1]\)</span>结尾</strong>），设其为<spanclass="math inline">\(dple[i-1]\)</span>；绿框内元素之和，是<spanclass="math inline">\(a[i+1:n-1]\)</span>这个右半段中的最大子段和（<strong>不一定要以<spanclass="math inline">\(a[i+1]\)</span>开头</strong>），设其为<spanclass="math inline">\(dpri[i+1]\)</span></font>。可以发现，这样定义涵盖了图（ｂ）和图（ｃ）这两种情况。最终所求目标就为<spanclass="math inline">\(\textcolor[RGB]{250,250,100}{max(\dple[i-1]+dpri[i+1]\ )\quad(\ i \in[1..n-2]\ )}\)</span>。</p><p>　　现在只剩最后一个问题：如何求出这样定义下的<spanclass="math inline">\(dple[]\)</span>和<spanclass="math inline">\(dpri[]\)</span>？</p><p>　　还记得我们做过的P1115题要求的是什么吗？给定<spanclass="math inline">\(a[0..n-1]\)</span>，求这<spanclass="math inline">\(n\)</span>个数中的最大子段和。该题并没有说一定要以<spanclass="math inline">\(a[n-1]\)</span>为最大子段的末尾元素哦！　我们是怎么求的？　弄了一个前缀和变量<spanclass="math inline">\(sum\)</span>（表示选定<spanclass="math inline">\(a[i]\)</span>的前提下前<spanclass="math inline">\(i\)</span>个数中选出的最大子段和值），不断累加<spanclass="math inline">\(a[i]\)</span>，一旦变负就清零继续累加，同时<strong>搞了一个<spanclass="math inline">\(maxSum\)</span>来保存出现过的<spanclass="math inline">\(sum\)</span>的最大值</strong>，采用的方法是<spanclass="math inline">\(maxSum=max(maxSum, sum)\)</span>。</p><p>　　但此时我们要的并不是一个值，而是<spanclass="math inline">\(dple[0:n-1]\)</span>，即一堆的值。上面提到的<spanclass="math inline">\(maxSum\)</span>就对应着<spanclass="math inline">\(dple[i]\)</span>，而上面提到的<spanclass="math inline">\(sum\)</span>就对应着我们之前已求出的<spanclass="math inline">\(dp1[i]\)</span>。所以有如下的公式（对<spanclass="math inline">\(dpri[]\)</span>的分析类似，只是需要从右往左逆推）：$$ <span class="math display">\[\begin{align}dple[i]=max(\ dple[i-1],\quad dp1[i]\ ) \qquad(\ i \in[\\textcolor[RGB]{255,0,0}1:n-1\ ]\ )\tag{1} \\dpri[i]=max(\ dpri[i+1],\quad dp2[i]\ ) \qquad(\ i \in[\\textcolor[RGB]{255,0,0}{n-2}:0\ ]\ )\tag{2} \\\end{align}\]</span> $$</p><p>#　三. dp归纳总结</p><p>　　下面用<spanclass="math inline">\(dp\)</span>的套路来归纳所有的细节。</p><p>（一）状态数组定义</p><p>　　<span class="math inline">\(dp1[i]\)</span>为“在选定<spanclass="math inline">\(a[i]\)</span>的前提下，在<spanclass="math inline">\(a[0:i]\)</span>数组中选择１个子段后得到的最大的和值”；</p><p>　　<spanclass="math inline">\(dple[i]\)</span>为“在不限制是否选定<spanclass="math inline">\(a[i]\)</span>的前提下，在<spanclass="math inline">\(a[0:i]\)</span>数组中选择１个子段后得到的最大的和值”；</p><p>　　<spanclass="math inline">\(dp2[i]\)</span>为“在选定a[i]的前提下，在<spanclass="math inline">\(a[i:n-1]\)</span>数组中选择１个子段后得到的最大的和值”；</p><p>　　<spanclass="math inline">\(dpri[i]\)</span>为“在不限制是否选定<spanclass="math inline">\(a[i]\)</span>的前提下，在<spanclass="math inline">\(a[0:i]\)</span>数组中选择１个子段后得到的最大的和值”；</p><p>（二）所求目标</p><p>　　<span class="math inline">\(max(\ dple[i]+dpri[i]\ )\qquad (i \in[1..n-2])\)</span> （分隔点不能在两个端点，否则无法分成左右两段 ）</p><p>（三）状态转移方程 <span class="math display">\[\begin{align}dp1[i]&amp;=max(\ dp1[i-1],\quad 0\ )+a[i]\qquad(\ i\in[\textcolor[RGB]{255,0,0}{1}:n-1]\ ) \tag{3}\\dple[i]&amp;=max(\ dple[i-1],\quad dp1[i]\ ) \qquad(\ i \in[\\textcolor[RGB]{255,0,0}1:n-1\ ]\ )\tag{4} \\\\dp2[i]&amp;=max(\ dp2[i\textcolor[RGB]{255,0,0}+1],\quad 0\)+a[i]\qquad(\ i \in[\textcolor[RGB]{255,0,0}{n-2}:0]\ ) \tag{5}\\dpri[i]&amp;=max(\ dpri[i\textcolor[RGB]{255,0,0}+1],\quad dp2[i]\ )\qquad(\ i \in[\ \textcolor[RGB]{255,0,0}{n-2}:0\ ]\ )\tag{6} \\\end{align}\]</span> （四）循环顺序和边界</p><p>　　上面公式的附属条件中已经写得很清楚了。</p><p>（五）特例和初始化</p><p>　　<span class="math inline">\(dp1[0]=a[0];\qquaddp2[n-1]=a[n-1];\)</span></p><p>　　需要注意的是，当<spanclass="math inline">\(i\)</span>位于两个端点坐标时，因为必须要选至少１个数而形成１个子段，所以会有<spanclass="math inline">\(dple[0]=a[0];\ \)</span>。在不限制是否选定<spanclass="math inline">\(a[0]\)</span>的前提下，在<spanclass="math inline">\(a[0:0]\)</span>数组中选择１个子段后得到的最大的和值，这……必须得选<spanclass="math inline">\(a[0]\)</span>啊！否则子段就要为空了（本题要求子段不能为空，否则就不叫做２段了）。同理有<spanclass="math inline">\(dpri[n-1]=a[n-1];\ \)</span>。</p><h1 id="四.-ac代码">四. AC代码　</h1><p>　　注意要设置long long ，不然可能要见祖宗了～</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> a[maxn], n;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp1[maxn], dp2[maxn];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dple[maxn], dpri[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; ++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);<br>dp1[<span class="hljs-number">0</span>]=a[<span class="hljs-number">0</span>], dple[<span class="hljs-number">0</span>]= a[<span class="hljs-number">0</span>];<br>dp2[n<span class="hljs-number">-1</span>]=a[n<span class="hljs-number">-1</span>], dpri[n<span class="hljs-number">-1</span>]= a[n<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++) dp1[i]=<span class="hljs-built_in">max</span>(dp1[i<span class="hljs-number">-1</span>],<span class="hljs-number">0LL</span>)+a[i], dple[i]= <span class="hljs-built_in">max</span>(dple[i<span class="hljs-number">-1</span>], dp1[i]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>; i&gt;=<span class="hljs-number">0</span>; i--) dp2[i]=<span class="hljs-built_in">max</span>(dp2[i+<span class="hljs-number">1</span>],<span class="hljs-number">0LL</span>)+a[i], dpri[i]= <span class="hljs-built_in">max</span>(dpri[i+<span class="hljs-number">1</span>], dp2[i]);;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> mmax=<span class="hljs-number">-1e18</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n<span class="hljs-number">-1</span>; i++) mmax= <span class="hljs-built_in">max</span>(mmax, dple[i<span class="hljs-number">-1</span>]+dpri[i+<span class="hljs-number">1</span>]);<br>cout &lt;&lt; mmax;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">20 50 -10 1300 -900</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线性结构编程技巧 </category>
          
          <category> 最大子段和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（五）环状的不限宽的区间的“最大的和值”问题</title>
      <link href="/2024/12/30/%EF%BC%88%E4%BA%94%EF%BC%89%E7%8E%AF%E7%8A%B6%E7%9A%84%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"/>
      <url>/2024/12/30/%EF%BC%88%E4%BA%94%EF%BC%89%E7%8E%AF%E7%8A%B6%E7%9A%84%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>　　本帖是“最大子段和”系列问题的第5帖，主要研究环状的不限宽的区间的“最大的和值”这个问题。</p><h1 id="一.-理论教学">一. 理论教学</h1><p>　　在学习本题型之前，需要学生先掌握“（一）不限宽的区间的“最大的和值”问题，如果不会，请点击<a href="/2024/12/24/%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E5%BA%A6%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/#jump2"><font color="red">这里</font></a>。</p><p>　　<strong>环形数组</strong>意味着数组的末端将会与开头相连呈环状，给定一个长度为 <spanclass="math inline">\(n\)</span>的<strong>环形整数数组</strong> <spanclass="math inline">\(a[0..n-1]\)</span>，返回<spanclass="math inline">\(a[]\)</span>的非空子数组／子段／子序列的最大可能和 。例如<span class="math inline">\(a[]=\{5,-3,5\}\)</span>，则其环状最大子段和为<spanclass="math inline">\(5+5=10\)</span>。</p><p>　　对于这个题型，有三种方法可以解决。希望同学们尽量看懂下面的三种解法的思路。</p><h2 id="方法一用ｄｐ硬干时间on空间on">1.1 方法一：用ｄｐ硬干（时间<spanclass="math inline">\(O(n)\)</span>，空间<spanclass="math inline">\(O(n)\)</span>）</h2><p>　　总体思路：尽可能用“不限宽区间的最大和值”的思路来解决本题型中的“环状”的问题。因为环状可能会涉及到取余，而且对应的题是用vector来存储原始数据，所以建议最好把原始数组<spanclass="math inline">\(a[]\)</span>从下标０开始存储。在环形情况中，答案可能包括以下两种情况：</p><p>　　１）构成最大子数组和的子数组为 <spanclass="math inline">\(a[le:ri]\)</span>，包括 <spanclass="math inline">\(a[le:ri]\)</span> 共 <spanclass="math inline">\(ri−le+1\)</span> 个元素，其中 <spanclass="math inline">\(0≤le≤ri≤n-1\)</span>。　　２）构成最大子数组和的子数组为 <spanclass="math inline">\(a[0:le]\)</span> 和 <spanclass="math inline">\(a[ri:n-1]\)</span>，其中 <spanclass="math inline">\(0≤le&lt;ri≤n-1\)</span>。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic/img/%EF%BC%88%E4%BA%94%EF%BC%89%E7%8E%AF%E7%8A%B6%E7%9A%84%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%981.png" alt="image-20241230102930185" style="zoom: 80%;" /></p><p>　　对于情况１），可以用以前学过的“（一）不限宽的区间的“最大的和值”问题的解法来做，此处不再赘述。</p><p>　　对于情况２），其最大和值应分为左右两部分，如上图所示，<spanclass="math inline">\(nums[0:le]\)</span>和 <spanclass="math inline">\(nums[ri:n]\)</span>为实际<strong>被选</strong>子段，且有<spanclass="math inline">\(le+1&lt;ri\)</span>，否则就无法同时存在两段数据而蜕变成了情况１）。我们可以在<spanclass="math inline">\([2:n-1]\)</span>范围内枚举 <spanclass="math inline">\(ri\)</span>，故左子段<strong>“备选”</strong>的数据区间就是<spanclass="math inline">\([0..ri-2]\)</span>（因为左右两个子段之间至少要间隔１个数据不能选），而左子段的实际<strong>被选</strong>区间是<spanclass="math inline">\(a[0:le]\)</span>。此时我们很容易算出右子段<strong>“被选”</strong>数据段区间元素之和为<spanclass="math inline">\(sum(a[ri:n])\)</span>(可用“后缀和”的思想，或者用“前缀和相减”也行)，然后算出左子段<spanclass="math inline">\(a[0:ri−2]\)</span>的最大前缀和，将它和右子段的那个“和值”相加后考虑更新答案。</p><p>　　 <span class="math inline">\(leftMax[i]\)</span> 表示<spanclass="math inline">\(a[0:i]\)</span>的最大前缀和。注意，该最大前缀和的选择，不一定会选择到<spanclass="math inline">\(a[i]\)</span>。这就是“<strong>备选</strong>”和“<strong>被选</strong>”的差别。例如<spanclass="math inline">\(a[0:10]\)</span>这段数据的最大前缀和可能只是<spanclass="math inline">\(a[0:6]\)</span>，最后四个数因为是负数而不能选。又例如<spanclass="math inline">\(a[]=\{2,5,-2,4,-4,-2\}\)</span>，则有<spanclass="math inline">\(leftMax[]=\{2,7,7,9,9,9\}\)</span>，在计算<spanclass="math inline">\(leftMax[5]＝2+5-2+4=9\)</span>时，<spanclass="math inline">\(a[0..5]\)</span>都是<strong>备选</strong>元素，但只有<spanclass="math inline">\(a[0..3]\)</span>是<strong>被选</strong>元素。递推方程如下：<span class="math display">\[leftMax[le]=max(leftMax[le−1],\quad sum(nums[0:le])\qquad(le\in[0..n-1])\]</span></p><h2 id="方法二取反-时间on空间o1">1.2 方法二：取反 （时间<spanclass="math inline">\(O(n)\)</span>，空间<spanclass="math inline">\(O(1)\)</span>）</h2><p>　　对于上面1.1节中提到的情况２），我们不一定非要去求绿色区域的和值。我们可以改为求白色区域的最小和值，然后用总和去减它，剩下的自然就是绿色区域的和值了。此时这个白色区域肯定是一个连续块，不会断成首尾两截。</p><p>　　注意：</p><p>　　a）“取反”只适合于解决上面的情况２），并不能解决情况１）。所以，代码中仍然需要处理情况１）。</p><p>　　b）取反只适合于当<spanclass="math inline">\(n&gt;1\)</span>的情况，当<spanclass="math inline">\(a[]\)</span>只有一个元素时，只能取这个数，而其反集为空。而我们目前的做法都没有考虑空集的问题。</p><p>　　c）取反的时候要注意“其反集为全集”的情况。如<spanclass="math inline">\(\{-3,-2,-4\}\)</span>这种情况，其子段的最小和为<spanclass="math inline">\(-3-2-4=-9\)</span>，即所有数据都要选。此时若再用总和去减，则其结果为<spanclass="math inline">\(-9-(-9)=0\)</span>。这意味着不选就是最大。当根据我们的题意，必须要选至少一个数，不符合题意。所以取反求最小子段和的时候，若求出来的是全集，则也会失效，应剔除而不于考虑。</p><h2 id="方法三单调队列数组长度翻倍时间o2n空间o2n">1.3方法三：单调队列＋数组长度翻倍（<spanclass="math inline">\(时间O(2n),空间O(2n)\)</span>）</h2><p>　　我们可以将数组<spanclass="math inline">\(a[0:n-1]\)</span>延长一倍为<spanclass="math inline">\(a[0:2*n-1]\)</span>，即对于延长的区域内的元素，令<span class="math inline">\(a[i]=a[i−n]\quad(i \geqn)\)</span>。然后，对于1.1节中提到的第２）种情况，则左子段和右子段不会再分离，可以组成连续的一段<spanclass="math inline">\(a[ri:n+le]\)</span>。如下图所示：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic/img/%EF%BC%88%E4%BA%94%EF%BC%89%E7%8E%AF%E7%8A%B6%E7%9A%84%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%982.png"alt="image-20241231091109644" /><figcaption aria-hidden="true">image-20241231091109644</figcaption></figure><p>　　至此，我们就把一个“环状”的问题转变成了一个“链状”的问题。这和以前做过的“<ahref="https://www.luogu.com.cn/problem/P1880">P1880　合并石子</a>”的原理相似。剩下的就是按照本站之前讲过的（三）来处理了，有如下递推方程：<span class="math display">\[dpmax[i]=s[i]-\textcolor[RGB]{255,0,0}{min(\ s[i-m],\quads[i-m+1]\quad,\  ......\ ,\quad  s[i-2],\quad s[i-1]\ \quad\ ) }\tag{1}\]</span> 　　红色区域的处理需要用到单调队列来解决，在第<spanclass="math inline">\(i\)</span>轮求出<spanclass="math inline">\(s[i-m:i-1]\)</span>这个滑窗内的最小元素值，从而求出<spanclass="math inline">\(dpmax[i]\)</span>。具体做法若不清楚，请见<a href="/2025/01/01/%EF%BC%88%E4%B8%89%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/#jump1"><font color="red">这里</font></a>。</p><h1 id="二实战练习">二、实战练习</h1><h2 id="leetcode918-环状子数组的最大和">2.1 LeetCode918环状子数组的最大和</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<ahref="https://leetcode.cn/problems/maximum-sum-circular-subarray/description/">LeetCode918环状子数组的最大和</a></p><h3 id="ac代码">2.1.2 AC代码</h3><p>　　按照上面的理论讲解来实现三种代码，分别如下：</p><h4 id="方法１dp硬干">2.1.2.1 方法１：dp硬干</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 版本1： dp硬干 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//  提交内容如下</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubarraySumCircular</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">// leftMax[5]=12 表示nums[0..5]之间选择子段，子段的最大和值为12</span><br><span class="hljs-comment">// sum[5]=10 表示nums[0..5]的总和为10 </span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftMax</span><span class="hljs-params">(n)</span>, <span class="hljs-title">sum</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-comment">// 对坐标为 0 处的元素单独处理，避免考虑子数组为空的情况</span><br>leftMax[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>sum[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>sum[i] = sum[i<span class="hljs-number">-1</span>] + nums[i];<br>leftMax[i] = <span class="hljs-built_in">max</span>(leftMax[i - <span class="hljs-number">1</span>], sum[i]);<br>&#125;<br><br><span class="hljs-comment">// 处理情况2： </span><br><span class="hljs-comment">// 从右到左枚举后缀，固定后缀，选择最大前缀</span><br><span class="hljs-type">int</span> ans=sum[n<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ri = <span class="hljs-number">2</span>; ri &lt; n; ri++) &#123;<br><span class="hljs-comment">// sum[n-1]- sum[ri-1]是a[ri:n-1]的和，即后缀和</span><br><span class="hljs-comment">// 当前以ri为右子段的左边界，则左子段的右边界应为ri-2，两个子段之间必须要空至少一个元素不选 </span><br>ans = <span class="hljs-built_in">max</span>(ans, (sum[n<span class="hljs-number">-1</span>]- sum[ri<span class="hljs-number">-1</span>]) + leftMax[ri - <span class="hljs-number">2</span>]);   <br>&#125;<br><br><span class="hljs-comment">// 处理情况1： </span><br><span class="hljs-type">int</span> ms=nums[<span class="hljs-number">0</span>];ans= <span class="hljs-built_in">max</span>(ans, ms);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++) &#123;<br>ms= <span class="hljs-built_in">max</span>(ms,<span class="hljs-number">0</span>) + nums[i];<br>ans= <span class="hljs-built_in">max</span>(ans, ms);<br>&#125;<br><br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br><span class="hljs-comment">//提交内容如上</span><br>vector&lt;<span class="hljs-type">int</span>&gt; nums= &#123;<span class="hljs-number">-3</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-3</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br>Solution s1;<br>cout &lt;&lt;s1.<span class="hljs-built_in">maxSubarraySumCircular</span>(nums);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法２取反">2.1.2.2 方法２：取反</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 版本2： 取反，求最小 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//  提交内容如下</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubarraySumCircular</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">// 处理情况1： </span><br><span class="hljs-type">int</span> ms=nums[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> preSum=nums[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> ans=nums[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++) &#123;<br>ms= <span class="hljs-built_in">max</span>(ms,<span class="hljs-number">0</span>) + nums[i];<br>ans= <span class="hljs-built_in">max</span>(ans, ms);<br><br>preSum+= nums[i];<br>&#125;<br><br><span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ans;  <span class="hljs-comment">//若只有1个元素，则不适合情况2 </span><br><span class="hljs-comment">// 处理情况2： </span><br><span class="hljs-comment">// 对坐标为 0 处的元素单独处理，避免考虑子数组为空的情况</span><br><span class="hljs-type">int</span> minSum = nums[<span class="hljs-number">0</span>];<br>ans= <span class="hljs-built_in">max</span>(ans, preSum-minSum);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++) &#123;<br>minSum= <span class="hljs-built_in">min</span>(minSum,<span class="hljs-number">0</span>) + nums[i];<br><span class="hljs-keyword">if</span> (preSum != minSum) <br>ans= <span class="hljs-built_in">max</span>(ans, preSum-minSum);<br>&#125;<br><br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br><span class="hljs-comment">//提交内容如上</span><br>vector&lt;<span class="hljs-type">int</span>&gt; nums= &#123;<span class="hljs-number">-3</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-3</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br>Solution s1;<br>cout &lt;&lt;s1.<span class="hljs-built_in">maxSubarraySumCircular</span>(nums);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单调队列翻倍数组">2.1.2.3 单调队列＋翻倍数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 版本3： 单调队列，翻倍延长数组 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">将a[1..n]变成a[1..2*n]，延长一倍后，求a[1..2*n]中窗口宽度&lt;=n的最大和值。</span><br><span class="hljs-comment">需要用单调队列求sum[]中滑窗宽度&lt;=n内元素的最小值，第i轮的新元素是sum[i-1] </span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//  提交内容如下</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubarraySumCircular</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        deque&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q; <span class="hljs-comment">// &lt;pos, value&gt;</span><br>        <span class="hljs-type">int</span> pre = nums[<span class="hljs-number">0</span>], res = nums[<span class="hljs-number">0</span>];<br>        q.<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">0</span>, pre&#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">2</span> * n; i++) &#123;<br>            <span class="hljs-comment">// 根据之前学过的单调队列求最大和的模板，此处求&lt;=n的元素的最小值，pre=sum[i-1]是新元素 </span><br>            <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; pre &lt;= q.<span class="hljs-built_in">back</span>().second ) &#123;<br>                q.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            q.<span class="hljs-built_in">push_back</span>(&#123;i<span class="hljs-number">-1</span>, pre&#125;);<br><br>            <span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; (i<span class="hljs-number">-1</span>) - q.<span class="hljs-built_in">front</span>().first + <span class="hljs-number">1</span> &gt; n) &#123;<br>                q.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>            <span class="hljs-comment">// 计算出sum[i]，在下一轮时pre就是sum[i-1]了 </span><br>            pre += nums[i % n];<br>            <span class="hljs-comment">// 在第i轮，计算出dpmax[i]= sum[i] - min( s[i-m], sum[i-m+1], ...... , sum[i-2], sum[i-1] )</span><br>            res = <span class="hljs-built_in">max</span>(res, pre - q.<span class="hljs-built_in">front</span>().second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//提交内容如上</span><br>vector&lt;<span class="hljs-type">int</span>&gt; nums= &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-2</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br>Solution s1;<br>cout &lt;&lt;s1.<span class="hljs-built_in">maxSubarraySumCircular</span>(nums);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线性结构编程技巧 </category>
          
          <category> 最大子段和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（四）宽度大于等于m的区间的“最大的和值”问题</title>
      <link href="/2024/12/27/%EF%BC%88%E5%9B%9B%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"/>
      <url>/2024/12/27/%EF%BC%88%E5%9B%9B%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>　　本帖是“最大子段和”系列问题的第4帖，主要研究宽度大于等于m的区间的“最大的和值”这个问题。</p><h1 id="一.-理论教学">一. 理论教学</h1><p>　　之前我们练习过“区间宽度<span class="math inline">\(\leqm\)</span>”的情况，用单调队列来解决了问题。已经记不太清楚的同学请看<a href="/2025/01/01/%EF%BC%88%E4%B8%89%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"><font color="red">这里</font></a>。看到当前这个题型，第一反应就是“能不能用之前解决<spanclass="math inline">\(\leq m\)</span>的公式推导过程来解决本题型呢？”</p><p>　　可以试试看！</p><p>　　假设<span class="math inline">\(m=3\)</span>，原始数组为<spanclass="math inline">\(a[1..n]\)</span>，对应的前缀和数组为<spanclass="math inline">\(s[1..n]\)</span>，<spanclass="math inline">\(dpmax[i]\)</span>表示"<strong>在选定<spanclass="math inline">\(a[i]\)</span>的前提下，子段内所有数的最大和值</strong>"，且满足子段宽度<spanclass="math inline">\(\geq m\)</span>，而写法"<spanclass="math inline">\(a[3..5]\)</span>"表示"<spanclass="math inline">\(a[3]+a[4]+a[5]\)</span>"，则有 $$ <spanclass="math display">\[\begin{align}dpmax[1]&amp;=max(\ a[1..1]\ )\qquad(区间宽度均不够3，无解)\tag{1}  \\\\dpmax[2]&amp;=max(\ a[1..2], a[2..2]\ )\qquad(区间宽度仍均不够3，无解)\tag{1}  \\\\dpmax[3]&amp;=max(\ \ a[1..3]　\ \ )\qquad(只有[1..3]这个区间满足:宽度\geq 3)\\&amp;=max(\ s[3]-s[0]\ ) \\&amp;=s3-min(\ s[0]\ ) \tag{3}\\\\dpmax[4]&amp;=max(\ \ a[1..4],\ \ \qquad\quad  a[2..4]\quad ) \qquad(有[1..4]和[2..4]这２个区间满足：宽度\geq 3)\\&amp;=max(\ s[4]-s[0],\ \quad s[4]-s[1]\ ) \\&amp;=s[4]-min(\ s[0],\qquad\ s[1]\qquad\ )\tag{4}\\\\dpmax[5]&amp;=max(\ \ a[1..5],\ \ \qquad\quad  a[2..5],\ \ \qquad \quada[3..5]\ \ )  \\&amp;=max(\ s[5]-s[0],\ \quad s[5]-s[1],\ \quad s[5]-s[2]\ ) \\&amp;=s[5]-min(\ s[0],\quad \qquad s[1],\ \qquad\qquad s[2]\quad\  )\tag{5}\\\\dpmax[6]&amp;=max(\ \ a[1..6],\ \ \qquad\quad  a[2..6],\ \ \qquad \quada[3..6]\ \ ,\ \ \quad \quad a[4..6]\ \ )  \\&amp;=max(\ s[6]-s[0],\ \quad s[6]-s[1],\ \quad s[6]-s[2]\ ,\ \quads[6]-s[3]\ ) \\&amp;=s[6]-min(\ s[0],\quad \qquad s[1],\ \qquad\qquad s[2],\\qquad\qquad s[3]\quad) \tag{6}\\\\\end{align}\]</span> <span class="math display">\[则有一般性公式推导（注：从$\ i-m+1\ $到$\ i\$，一共有$m$个数；从$1$到$i-m+1$，或者从$0$到$i-m$，都是有$i-m+1$个数）如下：\]</span> <span class="math display">\[\begin{align}dpmax[i]&amp;=max(\ \ a[1..i],\ \ \qquad\quad  a[2..i],\quad\ \ ......\,\ \qquad a[i-m..i],\ \qquad\ \  a[i-m+1..i]\ )  \\&amp;=max(\ s[i]-s[0],\ \quad s[i]-s[1],\quad ......\ ,\quads[i]-s[i-m-1],\quad s[i]-s[i-m]\ \ ) \\&amp;=s[i]-\textcolor[RGB]{255,0,0}{min(\ s[0],\qquads[1]\qquad,\  ......\ ,\qquad \quad s[i-m-1],\qquad s[i-m]\ \qquad\ )}\qquad(i \in [m..n])\tag{6}\\\\\end{align}\]</span> $$ 　　从上面的公式（６）可以看出：</p><p>１）我们把一个求最大值的问题，变成了一个求最小值的问题。</p><p>２）原本是求<spanclass="math inline">\(a[]\)</span>的“和值”，现在改成了求<spanclass="math inline">\(s[]\)</span>的最值。</p><p>３）在第<span class="math inline">\(i\)</span>轮，<spanclass="math inline">\(min\)</span>操作的操作数的个数随着<spanclass="math inline">\(i\)</span>的增大而增大，也就是说，本题型并不是固定滑窗求最值，却和“（一）不限宽度的区间的“最大的和值”问题”中的单调队列处理方法比较类似。所以不需出队（因为没有滑窗宽度限制），甚至也可以不用单调队列而直接用变量<spanclass="math inline">\(mmin\)</span>就可搞定。</p><h1 id="二.实战练习">二.实战练习</h1><h2 id="p1404-平均数">2.1 P1404 平均数</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P1404">P1404平均数</a></p><h3 id="分析">2.1.2 分析</h3><p>　　原题的题意是“给一个长度为 <spanclass="math inline">\(n\)</span>的数列，我们需要找出该数列的一个子串，使得子串的平均数最大化，并且子串长度<span class="math inline">\(\geq m\)</span>”，要求输出最大的平均数。</p><p>　　我们可以初步分析一下：</p><p>　　１）要找一个子串，也就是说，要找一个子序列，或者说子段。</p><p>　　２）要想使得子段均值最大，也就意味着并不是子段越宽越好或者越窄越好。假设当前所选子段的均值为５，而新加入的数值为<spanclass="math inline">\(8&gt;5\)</span>，则势必会拉高均值，这是有益的；但如果新加入的数值为<spanclass="math inline">\(2&lt;5\)</span>，则势必会拉低均值，是有害的。但有害的数据并不意味着就不能选，万一在２后面的下一个数是１００呢？所以，这并不是一个简单的贪心策略能搞定的，多半会和暴力枚举所涉及的算法有关。目前已经学过的暴力枚举的算法，除了简单模拟之外，有<spanclass="math inline">\(dfs\)</span>、<spanclass="math inline">\(dp\)</span>和二分答案。<spanclass="math inline">\(dfs\)</span>复杂度太高，基本上放弃。</p><p>　　３）要求子段长度<span class="math inline">\(\geqm\)</span>，这个条件如何利用呢？这个感觉和题型H：“借助单调队列来求子段宽度<spanclass="math inline">\(\geqm\)</span>的最大的和值”很相似啊。但题型H是求和，而当前题型是求平均数，而且还要求最大的平均数。这里需要一个外力点拨。我们可以把原始数组元素都减去一个假定的均值<spanclass="math inline">\(avg\)</span>，然后对数组再来做题型H，这样就解决了“子段长度<spanclass="math inline">\(\geq m\)</span>”的问题。若求出的最大和值<spanclass="math inline">\(&gt;0\)</span>，说明<spanclass="math inline">\(avg\)</span>太小了；若最大的和值<spanclass="math inline">\(&lt;0\)</span>，说明<spanclass="math inline">\(avg\)</span>太大了。这听上去是不是很像“二分答案？的确是的。至此，已经完全分析清楚了。</p><p>　　例如：对于<spanclass="math inline">\(a[10]=\{2,5,7,9,6,1,6,7,4,1\},m=3\)</span>，假设<spanclass="math inline">\(avg=5\)</span>，则<spanclass="math inline">\(a_1^*[10]=\{-3,0,2,4,1,-4,1,2,-1,-4\}\)</span>，对<spanclass="math inline">\(a_1^*[]\)</span>求子段宽度<spanclass="math inline">\(\geq 3\)</span>的最大子段和为<spanclass="math inline">\(2+4+1=7\)</span>，这意味着什么呢？这说明这三个数对应的<spanclass="math inline">\(7,9,6\)</span>原数的真实均值是大于当前的<spanclass="math inline">\(avg=5\)</span>的，换句话说，当前的<spanclass="math inline">\(avg\)</span>太小了，可以再大一点。</p><p>　　二分答案的代码模板就不多说了，若不清楚请复习本站帖"二分查找和二分答案.md"，点击<a href="#jump1"><font color="red">这里</font></a>。注意对check(x)函数的把握。</p><p>　　需要注意的是，本题并不是标准的二分答案，因为题目要求输出的是二分后的结果砍掉末尾后的精确值，而不是四舍五入后的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++">输入样例１：<br><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span><br>正确输出：<br><span class="hljs-number">5000</span><br>错误输出：<br><span class="hljs-number">4999</span><br><br>输入样例２：<br><span class="hljs-number">10</span> <span class="hljs-number">10</span><br><span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">10</span> <span class="hljs-number">3</span> <span class="hljs-number">8</span> <span class="hljs-number">5</span> <span class="hljs-number">9</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><br>正确输出：<br><span class="hljs-number">5200</span><br>错误输出：<br><span class="hljs-number">5199</span>    <br></code></pre></td></tr></table></figure><p>　　鉴于上面的问题，所以需要把输出改为打印<spanclass="math inline">\(\ ri\ \)</span>端值就可以了。</p><h3 id="ac代码">2.1.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> jd=<span class="hljs-number">1e-7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> a[maxn],sum[maxn],le,ri,mid;<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)  sum[i]=sum[i<span class="hljs-number">-1</span>]+a[i]-x;<br><span class="hljs-type">double</span> maxsum=<span class="hljs-number">-1e9</span>, mmin=<span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m; i&lt;=n; i++) &#123;<br>mmin= <span class="hljs-built_in">min</span>(mmin, sum[i-m]);<br>maxsum=<span class="hljs-built_in">max</span>(maxsum,sum[i]-mmin);<br>&#125;<br><span class="hljs-keyword">return</span> (maxsum&gt;=<span class="hljs-number">0</span>);  <span class="hljs-comment">// 若平均化后的子段和&gt;0，则说明该x太小 </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;a[i]);<br>ri=<span class="hljs-built_in">max</span>(ri,a[i]);<br>&#125;<br>le=<span class="hljs-number">0</span>-jd;ri=ri+jd;<br><span class="hljs-keyword">while</span>( le+jd &lt; ri ) &#123;<br>mid =(ri+le) / <span class="hljs-number">2</span>;   <br><span class="hljs-keyword">if</span>( <span class="hljs-built_in">check</span>(mid) )<br>le=mid;    <span class="hljs-comment">// 既然mid太小，就砍掉左半段 </span><br><span class="hljs-keyword">else</span><br>ri=mid;<br>&#125;<br><span class="hljs-comment">//printf(&quot;le=%lf, ri=%lf\n&quot;, le, ri);</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">int</span>(ri*<span class="hljs-number">1000</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">10 10</span><br><span class="hljs-comment">6 4 2 10 3 8 5 9 4 1</span><br><span class="hljs-comment">5200</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2 2</span><br><span class="hljs-comment">5 5</span><br><span class="hljs-comment">5000</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">3 3</span><br><span class="hljs-comment">5 5 5</span><br><span class="hljs-comment">5000</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线性结构编程技巧 </category>
          
          <category> 最大子段和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（一）不限宽度的区间的“最大的和值”问题</title>
      <link href="/2024/12/24/%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E5%BA%A6%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/"/>
      <url>/2024/12/24/%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E5%BA%A6%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>　　本帖是“最大子段和”系列问题的第1帖，主要研究不限宽度的区间的“最大的和值”和“最大的积值”这两个问题。</p><h1 id="一不限宽度的区间子段的最大的和值"><spanid="jump2">一、不限宽度的区间（子段）的"最大的<font color="red">和</font>值"</span></h1><h2 id="原题链接">1.1 原题链接</h2><p>　　<a href="https://www.luogu.com.cn/problem/P1115">P1115最大子段和</a>　／　<ahref="https://leetcode.cn/problems/maximum-subarray/description/">53最大子数组和</a></p><h2 id="分析">1.2 分析</h2><p>　　如果我们用 <span class="math inline">\(dp[i]\)</span> 表示前 i个元素中选择的子段内所有数的最大和值，<spanclass="math inline">\(a[]\)</span>表示题目上对应的数组，那么所求目标即为<spanclass="math inline">\(dp[n]\)</span>。但我们会发现，要根据<spanclass="math inline">\(dp[i-1]\)</span>等来递推出<spanclass="math inline">\(dp[i]\)</span>是很困难的，因为我们不确定<spanclass="math inline">\(a[i-1]\)</span>在<spanclass="math inline">\(dp[i-1]\)</span>的方案中是否被选中。如果<spanclass="math inline">\(a[i-1]\)</span>曾被选中，那现在去计算<spanclass="math inline">\(dp[i]\)</span>就比较简单了，对于<spanclass="math inline">\(a[i]\)</span>无非有“选<spanclass="math inline">\(a[i]\)</span>”或“不选<spanclass="math inline">\(a[i]\)</span>”这两种方案，所以有<spanclass="math inline">\(dp[i]=max(dp[i-1]+a[i],\ \dp[i-1])\)</span>。但如果<spanclass="math inline">\(a[i-1]\)</span>不曾被选中，那根据本题对“子段”的“下标连续性”的要求，就很难去推导了。</p><p>　　此路不通。不通的原因不是因为不该用<spanclass="math inline">\(dp\)</span>，而是因为<spanclass="math inline">\(dp[i]\)</span>的定义不对，因为违背了<spanclass="math inline">\(dp\)</span>的定义并不满足「最优子结构」(即“问题的最优解包含子问题的最优解”。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解)。<strong>而在当前<spanclass="math inline">\(dp[]\)</span>的这种定义下，当前位置的最优解未必是由前一个位置的最优解转移得到的</strong>。</p><p>　　正确的定义应该是用 <span class="math inline">\(dp[i]\)</span>表示"<strong>在选定<span class="math inline">\(a[i]\)</span>的前提下，前i个元素中选择的子段内所有数的最大和值</strong>"。之所以正确，是因为在这种定义下，强制要求选定<spanclass="math inline">\(a[i]\)</span>后，剔除掉了上面段落中所提到的“如果<spanclass="math inline">\(a[i-1]\)</span>不曾被选中”的情况，使得<spanclass="math inline">\(dp\)</span>的定义满足了“最优子结构”的要求。只不过在这样的定义下，所求目标不再是<spanclass="math inline">\(dp[n]\)</span>，而变成了<spanclass="math inline">\(max(dp[1..n])\)</span>。</p><p>　　这个题型，<spanclass="math inline">\(O(n)\)</span>的做法有两种。</p><p>　　１）<span class="math inline">\(dp[i]=max(\ dp[i-1],\ \ 0)+a[i]\)\qquad(i \in[1..n])\)</span></p><p>　　２）<span class="math inline">\(dp[i]=sum[i]-min(\ sum[1..i-1]\)\qquad(\ i \in[1..n]\ )\)</span></p><p>　　第１种方法，在本站《前缀和　二维前缀和》有非常详细的讲述，请点击<a href="/2024/01/03/%E5%89%8D%E7%BC%80%E5%92%8C%20%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/#jump1"><font color="red">这里</font></a>直达讲述位置，内含视频教学和AC代码，此处不再提。下面重点讲解第２种方法的得来。　</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic/img/%E4%B8%8D%E9%99%90%E5%AE%BD%E5%BA%A6%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%981.png" alt="image-20241227150534177" style="zoom:150%;" /></p><p>　　在上图中，我们以<spanclass="math inline">\(i=3\)</span>为例来进行讲解。我们知道<spanclass="math inline">\(dp[i]\)</span>的含义是“在选定<spanclass="math inline">\(a[i]\)</span>的前提下，前<spanclass="math inline">\(i\)</span>个元素中选择的子段内所有数的最大和值”，且用<spanclass="math inline">\(a[1..3]\)</span>表示<spanclass="math inline">\(a[1]+a[2]+a[3]\)</span>的值，则我们可以把<spanclass="math inline">\(dp[1]、dp[2]、dp[3]、dp[4]\)</span>的定义演绎成下面的公式：<span class="math display">\[\begin{align}dp[1]&amp;=max(\ a[1..1]\ ) \tag{1} \\dp[2]&amp;=max(\ a[1..2],\ \ a[2..2]\ ) \tag{2} \\dp[3]&amp;=max(\ a[1..3],\ \ a[2..3],\ \ a[3..3]\ ) \tag{3} \\dp[4]&amp;=max(\ a[1..4],\ \ a[2..4],\ \ a[3..4],\ \ a[4..4]\ ) \tag{4}\\\end{align}\]</span> 　　由（4）推出更加普遍的公式如下： <spanclass="math display">\[dp[i]=max(\ a[1..i],\ \ a[2..i],\ \ ......,\ \ a[i-1..i],\ \ a[i..i]\ )\tag{5}\]</span> 　　假设用<span class="math inline">\(sum[i]\)</span>表示<spanclass="math inline">\(a[1..i]\)</span>，即<spanclass="math inline">\(sum[i]=a[1]+a[2]+...+a[i]\)</span>。用前缀和思想，可以把（５）式进一步演变如下：<span class="math display">\[\begin{align}dp[i]&amp;=max(\\qquad\textcolor[RGB]{50,200,0}{a[1..i]},\qquad\qquad\quad\textcolor[RGB]{0,150,255}{a[2..i]},\ \ \ \quad\quad  ......,\ \\qquad\textcolor[RGB]{255,0,0}{a[i-1..i]},\ \\qquad\qquad\quad\textcolor[RGB]{255,225,0}{a[i..i]}\qquad\qquad)  \tag{}\\&amp;=max(\ \textcolor[RGB]{50,200,0}{sum[i]-sum[0]},\ \\textcolor[RGB]{0,150,255}{sum[i]-sum[1]},\ \ ......\ \ ,\ \\textcolor[RGB]{255,0,0}{sum[i]-sum[i-2]},\ \\textcolor[RGB]{255,225,0}{sum[i]-sum[i-1]}\ ) \tag{}\\&amp;=sum[i]-min(\ sum[0],\ sum[1],\ sum[2],\ ......\ ,\ sum[i-1]\ )\tag{6}\end{align}\]</span>　　从公式（６）中可以看到，我们需要在对应的前缀和数组sum[]中去求多个前缀和的最小值。在本题中因为没有限制子段的区间宽度，所以公式（６）比较简单。但如果要求区间的宽度受限制（<spanclass="math inline">\(==m、\leq m、\geqm\)</span>）等，公式（６）会变得稍微复杂一点，就需要用到单调队列来解决了。要实现方法２中的公式（６），可以有两种版本。</p><p>版本１）：用单变量<spanclass="math inline">\(mmin\)</span>来保存<spanclass="math inline">\(sum[1..i-1]\)</span>中各和值的最小值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> mmin=INT_MAX;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123;<br>    mmin=<span class="hljs-built_in">min</span>(mmin, sum[i<span class="hljs-number">-1</span>]); <br>    dp[i]=sum[i]-mmin;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　为了给后续帖展示复杂区间宽度限制，此处也给同学们展示做法２的过程。</p><p><span id="jump1">版本２）</span>：用单调队列来处理<spanclass="math inline">\(sum[1..i-1]\)</span>中各和值的最小值。需要注意的是，此处是求滑窗区间<spanclass="math inline">\(sum[0..i-1]\)</span>的最小值，基础数组是<spanclass="math inline">\(sum[]\)</span>；而且在第<spanclass="math inline">\(i\)</span>轮处理的是数据是<spanclass="math inline">\(sum[i-1]\)</span>，进队的下标应该是<spanclass="math inline">\(i-1\)</span>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 使用单调队列求sum[0..i-1]区间中的最小值，基础数组是sum[]哦！在第i轮处理的是sum[i-1]！</span><br><span class="hljs-keyword">while</span> (h&lt;=t &amp;&amp; sum[i<span class="hljs-number">-1</span>]&lt;=sum[dq[t]] ) t--;<br>dq[++t]=i<span class="hljs-number">-1</span>;<br><span class="hljs-comment">// 因为不限滑窗宽度，根本就没有滑窗，所以不用考虑队头元素这端被挤出滑窗而出队的情况了</span><br>mmin=sum[dq[h]];  <span class="hljs-comment">//使用“滑窗”内的最小值，即min(sum[0],sum[1],sum[2],sum[3],......,sum[i-1])</span><br></code></pre></td></tr></table></figure><h2 id="ac代码">1.3 AC代码</h2><p>　　用方法１（贪心策略）的代码就不在这里展示了，此处展示的是方法２的两个版本代码。</p><h3 id="不用单调队列">1.3.1 不用单调队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法2，版本1，不用单调队列</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">方法2：dp[i]= sum[i] - min(sum[0],sum[1],sum[2],......,sum[i-1])</span><br><span class="hljs-comment">    版本1： 用 单变量mmin来保存 sum[1..i-1] 中各和值的最小值。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> dp[<span class="hljs-number">200001</span>];   <br><span class="hljs-type">int</span> sum[<span class="hljs-number">200001</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> i,n,a,mmin=INT_MAX, ans=INT_MIN;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a);<br>sum[i]=sum[i<span class="hljs-number">-1</span>]+a;<br>mmin=<span class="hljs-built_in">min</span>(mmin, sum[i<span class="hljs-number">-1</span>]);<br>dp[i]=sum[i]-mmin;<br>ans= <span class="hljs-built_in">max</span>(ans, dpmax[i]);  <span class="hljs-comment">// 可以不定义dpmax[]：ans= max(ans, sum[i]-mmin); </span><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">//// 如果数据全为负数，也应该得到-20，而不是-100000</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">-200 -20 -150 -100 -120</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="用单调队列">1.3.2 用单调队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法2，版本2，用单调队列 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">方法2：dp[i]= sum[i] - min(sum[0],sum[1],sum[2],......,sum[i-1])</span><br><span class="hljs-comment">    版本2： 用 单调队列来保存 sum[1..i-1] 中各和值的最小值。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> dq[<span class="hljs-number">200001</span>];   <br><span class="hljs-type">int</span> sum[<span class="hljs-number">200001</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> i,n,a,mmin=INT_MAX, ans=INT_MIN;<br>cin&gt;&gt;n;<br><span class="hljs-type">int</span> h=<span class="hljs-number">1</span>, t=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a);<br>sum[i]=sum[i<span class="hljs-number">-1</span>]+a;<br><span class="hljs-comment">// 使用单调队列求sum[0..i-1]中的区间最小值，基础数组是sum[]哦！在第i轮处理的是sum[i-1]！ </span><br><span class="hljs-keyword">while</span> (h&lt;=t &amp;&amp; sum[i<span class="hljs-number">-1</span>]&lt;=sum[dq[t]] ) t--;<br>dq[++t]=i<span class="hljs-number">-1</span>;<br><span class="hljs-comment">// 因为不限滑窗宽度，根本就没有滑窗，所以不用考虑队头元素这端被挤出滑窗而出队的情况了 </span><br>mmin=sum[dq[h]];  <span class="hljs-comment">// 使用单调队列方法的成果，即sum[dq[h]]，</span><br>ans= <span class="hljs-built_in">max</span>(ans, sum[i]-mmin);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">//// 如果数据全为负数，也应该得到-20，而不是-100000</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">-200 -20 -150 -100 -120</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1id="二不限宽度的区间子段的最大的积值">二、不限宽度的区间（子段）的“最大的<font color="red">积</font>值”</h1><h2 id="原题链接-1">2.1 原题链接</h2><p>　　<ahref="https://leetcode.cn/problems/maximum-product-subarray/description/">１５２　乘积最大子数组（leetcode）</a></p><h2 id="分析-1">2.2 分析</h2><p>　　如果我们用 <span class="math inline">\(dpmax[i]\)</span> 表示以第i 个元素结尾的子段内所有数的最大乘积值，<spanclass="math inline">\(a[]\)</span>表示题目上对应的数组 <spanclass="math inline">\(nums[]\)</span>，那么根据“<ahref="https://www.luogu.com.cn/problem/P1115">P1115最大子段和</a>”的经验，我们很容易推导出这样的状态转移方程： <spanclass="math display">\[dpmax[i]=max(\ a[i],\quad dpmax[i-1]*a[i]\ )\qquad(i \in[1..n])  \tag{1}\]</span> 　　它表示以第 i 个元素结尾的乘积最大子数组的乘积，可以考虑<span class="math inline">\(a[i]\)</span> 加入前面的 <spanclass="math inline">\(dpmax[i-1]\)</span>对应的一段，或者单独成为一段，且在两种情况下取最大值。最后把 <spanclass="math inline">\(max(dpmax[1..n])\)</span>作为答案。</p><p>　　可是在这里，这样做是错误的（需要孩子们认真仔细地在草稿纸上枚举多个样例，就必然能发现这一点）。为什么呢？</p><p>　　因为这里的定义并不满足「最优子结构」(即“问题的最优解包含子问题的最优解”。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解)。具体地讲，如果<span class="math inline">\(a[]=\{5,\ 6,\ −3,\ 4,\−3\}\)</span>，那么此时<spanclass="math inline">\(dpmax[]\)</span>对应的序列是 <spanclass="math inline">\(\{\ 5,\ 30,\ −3,\ 4,\ −3\\}\)</span>，按照前面的算法我们得到的答案为 30（即<spanclass="math inline">\(5\times6\)</span>），而实际上答案应该是全体数字的乘积。我们来想一想问题出在哪里呢？问题出在最后一个−3 所对应的<span class="math inline">\(dpmax[5]\)</span>的值既不是−3，也不是 <span class="math inline">\(4×(−3)\)</span>，而是 <spanclass="math inline">\(5×6×(−3)×4×(−3)\)</span>。所以我们得到了一个结论：<strong>在这种定义下，当前位置的最优解未必是由前一个或前几个位置的最优解转移得到</strong>。</p><p>　　我们可以根据正负性进行分类讨论。</p><p>　　１）如果<span class="math inline">\(a[i]&lt;0\)</span>，那么我们希望<spanclass="math inline">\(dpmax[i-1]&lt;0\)</span>，这样就可以负负得正，并且我们希望<spanclass="math inline">\(dpmax[i-1]\)</span>尽可能"负得更多"(即尽可能小)。</p><p>　　２）如果<spanclass="math inline">\(a[i]&gt;0\)</span>，我们更希望<spanclass="math inline">\(dpmax[i-1]&gt;0\)</span>，并且希望<spanclass="math inline">\(dpmax[i-1]\)</span>尽可能地大。</p><p>　　于是这里我们可以再维护一个 <spanclass="math inline">\(dpmin[i]\)</span>，它表示以第 i个元素结尾的乘积最小子数组的乘积，那么我们可以得到这样的动态规划转移方程：<span class="math display">\[\begin{align}dpmax[i]&amp;=max(dpmax[i-1]*a[i],\quad dpmin[i-1]*a[i],\quad a[i])\qquad(i \in[2..n]) \tag{2}\\dpmin[i]&amp;=min(dpmax[i-1]*a[i],\quad dpmin[i-1]*a[i],\quad a[i])\qquad(i \in[2..n])\tag{3}\end{align}\]</span> 　　特例值很好分析，<spanclass="math inline">\(dpmax[1]=dpmin[1]=a[1];\)</span></p><p>　　仔细分析公式（２）和（３），可以发现，<spanclass="math inline">\(dpmax[]\)</span>和<spanclass="math inline">\(dpmin[]\)</span>不必开数组，只需要用两个变量<spanclass="math inline">\(dpmax\)</span>和<spanclass="math inline">\(dpmin\)</span>就能搞定了。</p><h2 id="ac代码-1">2.3 AC代码</h2><h3 id="数组版本">2.3.1 数组版本</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 版本2： dp数组版本 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//  提交内容如下 </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector &lt;<span class="hljs-type">long</span>&gt; <span class="hljs-built_in">maxF</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>()), <span class="hljs-built_in">minF</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            maxF[i] = <span class="hljs-built_in">max</span>(maxF[i - <span class="hljs-number">1</span>] * nums[i], <span class="hljs-built_in">max</span>((<span class="hljs-type">long</span>)nums[i], minF[i - <span class="hljs-number">1</span>] * nums[i]));<br>            minF[i] = <span class="hljs-built_in">min</span>(minF[i - <span class="hljs-number">1</span>] * nums[i], <span class="hljs-built_in">min</span>((<span class="hljs-type">long</span>)nums[i], maxF[i - <span class="hljs-number">1</span>] * nums[i]));<br>            <span class="hljs-keyword">if</span>(minF[i]&lt;INT_MIN) &#123;<br>                minF[i]=nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-built_in">max_element</span>(maxF.<span class="hljs-built_in">begin</span>(), maxF.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//提交内容如上</span><br> <br>vector&lt;<span class="hljs-type">int</span>&gt; nums=&#123;<span class="hljs-number">-4</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">-2</span>&#125;; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br>Solution s1;<br>cout &lt;&lt;s1.<span class="hljs-built_in">maxProduct</span>(nums);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">a[i]:-4     -3     -2</span><br><span class="hljs-comment">dpmax[i]    -4     12      6</span><br><span class="hljs-comment">dpmin[i]-4     -3     -24</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">ans=max(-4,12,6) = 12</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="变量版本">2.3.2 变量版本</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 版本1： dp变量版本 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//  提交内容如下 </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> dpmax, dpmin, dpmax11, dpmin11, ans;<br>        dpmax11=dpmin11=ans=nums[<span class="hljs-number">0</span>];<br><span class="hljs-comment">//        printf(&quot;%d %d %d\n&quot;, dpmax11, dpmin11, ans);</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            dpmax = <span class="hljs-built_in">max</span>(dpmax11*nums[i], <span class="hljs-built_in">max</span>((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)nums[i], dpmin11*nums[i]));<br>            dpmin = <span class="hljs-built_in">min</span>(dpmax11*nums[i], <span class="hljs-built_in">min</span>((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)nums[i], dpmin11*nums[i]));<br>            ans=<span class="hljs-built_in">max</span>(dpmax,<span class="hljs-built_in">max</span>(dpmin,ans));<br><span class="hljs-comment">//            printf(&quot;%d %d %d\n&quot;, dpmax, dpmin, ans);</span><br>            dpmax11=dpmax;<br>            dpmin11=dpmin;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//提交内容如上</span><br> <br>vector&lt;<span class="hljs-type">int</span>&gt; nums=&#123;<span class="hljs-number">-4</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">-2</span>&#125;; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 从这里开始...</span><br>Solution s1;<br>cout &lt;&lt;s1.<span class="hljs-built_in">maxProduct</span>(nums);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">a[i]:-4     -3     -2</span><br><span class="hljs-comment">dpmax[i]    -4     12      6</span><br><span class="hljs-comment">dpmin[i]-4     -3     -24</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">ans=max(-4,12,6) = 12</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线性结构编程技巧 </category>
          
          <category> 最大子段和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间dp(环)模型</title>
      <link href="/2024/07/31/%E5%8C%BA%E9%97%B4dp(%E7%8E%AF)%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/07/31/%E5%8C%BA%E9%97%B4dp(%E7%8E%AF)%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="模型说明">1.1 模型说明</h2><p>　　现在有N个数据依次排成<strong>一个圈</strong>，<strong>不允许移动</strong>（即有序），<strong>首尾连接</strong>。现在要对这N个数据进行合并，要求只能合并相邻的两个数据，合并后的数据可以参与下一次合并。现在给定每次数据合并产生的代价，求将所有数据合并成一个数所产生的最小代价/最大代价。这个模型和“区间dp(环)模型”的唯一区别就是“本模型的数据是一个环，首尾元素是相邻的，可以合并”。</p><p>　　<a href="https://www.luogu.com.cn/problem/P1880">P1880 [NOI1995]石子合并</a>是区间dp（环）的标准模板题型。理论上来说，也可以要求每次只能选择相邻的三堆数据。</p><h2 id="分析">1.2 分析</h2><p>　　环路数据合并，可以有两种方法来实现，下面分别进行讲述。</p><h3 id="方法1-割环为链拓展各个数组时间on3空间o4n2重点掌握">2.1.1 方法1割环为链，拓展各个数组（时间<spanclass="math inline">\(O(n^3)\)</span>，空间<spanclass="math inline">\(O(4n^2)\)</span>，重点掌握）</h3><p>　　由环转链，是解决环形区间dp较常用的一种方法。对于n个点，n条边构成的环路来说，每次对当前环路任意位置上相邻的两个点进行合并时，都会消除1个点和1条边，直到最后剩下1个点为止。也就是说，任何合并方案都需要对n个点、n条边的环路做n-1次合并即可。这样看来，必然会存在1条边是用不上的，多余的。换句话说，就算把多余的这1条边删掉，断环为链，也不影响这套合并方案的实施。但问题是我们并不知道哪一条边是多余的。既然如此，就干脆把该环路所有能够产生的链都去枚举处理一遍，然后比较得出最优解即可。那应该如何去“把所有的链都枚举一遍”呢？有一个简单的做法就是：<strong>对于由1-2-3-4-5组成的环路，我们可以将数据延展为：123451234</strong> 。也就是将长度为 n 的环变成了长度为 2n−1的链。那么最优解就在 12345、 23451、 34512、 45123和 51234中。以求最小值为例，那么就有<span class="math inline">\(dp(1,5)_环=min(\dp(1,5)_链,\quad  dp(2,6)_链,\quad dp(3,7)_链,\quad dp(4,8)_链,\quaddp(5,9)_链\ )\)</span>。</p><p>　　将数据拓展翻1倍之后，各个数组的维度长度都需要翻1倍。另外在初始化赋值时，更要小心处理。原始数组需要翻1倍，dp二维数组需要延展1倍，初始化时的对角线也需要延展。另外，关于两个区间进行合并的成本开销，即区间内所有数据之和，在链模型中是采用前缀和的方法来快捷算出的；在割环为链之后，其实这个方法仍然是可行的，但前缀和数组同样需要拓展一倍长度。</p><p>　　本方法虽然空间复杂度稍微较大，但后期可以采用平行四边形优化法，对时间复杂度进行优化，以适应更大的数据量处理。建议同学们重点掌握。</p><h3 id="方法2-利用取余来实现环不拓展数组时间on3空间on2">2.1.2 方法2利用取余来实现环，不拓展数组（时间<spanclass="math inline">\(O(n^3)\)</span>，空间<spanclass="math inline">\(O(n^2)\)</span>）</h3><p>　　在不拓展数组的情况下，如果区间右端点超过了数组的上限，则自动调整到下标0的位置上。对于方法2，因为涉及到取余，强烈建议所有数组都从下标0开始编号和存储数据，以便于代码书写。</p><p>　　需要提醒同学们注意的是，本来对区间（链）dp的填写有“for le, forri”和“for len, forle”这两种写法。在区间（环）的情况下如果不拓展数据，那么<spanclass="math inline">\(le \leq ri\)</span>的这个条件不再肯定成立，<spanclass="math inline">\(k+1\)</span>也不一定肯定会大于k，这会对dp数组的填写顺序造成较大的困扰，增添代码实现难度。所以，<strong>强烈建议如果要采用方法2来做，请最好是用“forlen, forle”的写法</strong>。虽然也会涉及到取余，但写起来相对容易一些。下面是参考的局部代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法2强烈建议用len和le来做循环变量，</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> le=<span class="hljs-number">0</span>; le&lt;n; le++ ) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ri=<span class="hljs-number">0</span>; le &lt;= n<span class="hljs-number">-1</span>; ++le) &#123;<br>        <span class="hljs-type">int</span> ri = le + len - <span class="hljs-number">1</span>;     <span class="hljs-comment">//先暂时不管越界，毕竟没在[]里</span><br>        <span class="hljs-comment">// 老老实实算区间和，用前缀和数组更难处理</span><br>        <span class="hljs-type">int</span> cost=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=le; k&lt;=ri; k++)  <span class="hljs-comment">// k在[]里，可能为ri，需要取余，否则k越界</span><br>            cost += data[k%n];     <span class="hljs-comment">// 因为下标从0开始存储基本数据，无法用前缀和，否则i-1为负数了</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=le; k &lt;= ri<span class="hljs-number">-1</span>; ++k) &#123; <span class="hljs-comment">//决策c</span><br>            <span class="hljs-comment">// 最大值和最小值都列举给同学们看看，注意 k、k+1 和 ri 都有可能数组越界，需要绕回来，取余%</span><br>            dpmin[le][ri%n] = <span class="hljs-built_in">min</span>(dpmin[le][ri%n], dpmin[le][k%n] + dpmin[(k+<span class="hljs-number">1</span>)%n][ri%n] + cost);<br>            dpmax[le][ri%n] = <span class="hljs-built_in">max</span>(dpmax[le][ri%n], dpmax[le][k%n] + dpmax[(k+<span class="hljs-number">1</span>)%n][ri%n] + cost);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　方法2的空间复杂度较小，但代码理解起来稍微困难，取余容易出错，且后期使用平行四边形优化法更为困难，所以建议会写即可。</p><h1 id="二实战训练">二、实战训练</h1><h2 id="p1880-石子合并">2.1 P1880 石子合并</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P1880">P1880 [NOI1995]石子合并</a></p><h3 id="分析-1">2.1.2 分析</h3><p>　　这是一个区间（环）dp的裸题，<spanclass="math inline">\(n\leq1e2\)</span>，不管是采用方法1或者方法2，<spanclass="math inline">\(n^3=1e6 \leq1e7\)</span>，不采用任何优化也能直接AC。cost数组就是区间内的数据之和。</p><h3 id="ac代码">2.1.3 AC代码</h3><h4 id="割环为链不优化">2.1.3.1 割环为链，不优化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法1：区间（环）dp，数组翻倍处理，割环为链，无任何优化 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 102</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NN 2*N</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">区间dp，数据首尾链接成环，求最小值和最大值。</span><br><span class="hljs-comment">需要割环为链，设置2倍的数组空间， </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-type">int</span> data[NN];<br><span class="hljs-type">int</span> dpmin[NN][NN];<br><span class="hljs-type">int</span> dpmax[NN][NN];<br><span class="hljs-type">int</span> sum[NN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i, le, ri, k, n, nn;<br><span class="hljs-built_in">memset</span>(dpmin, INF, <span class="hljs-built_in">sizeof</span>(dpmin));  <span class="hljs-comment">//初值设定为极大值</span><br><span class="hljs-built_in">memset</span>(dpmax, -INF  , <span class="hljs-built_in">sizeof</span>(dpmax));   <span class="hljs-comment">//初值设定为-INF</span><br>cin &gt;&gt;n;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data[i]);<br>data[i+n] = data[i];<br>&#125;<br>nn = <span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=nn;++i)&#123;<br>dpmin[i][i] = <span class="hljs-number">0</span>;<br>dpmax[i][i] = <span class="hljs-number">0</span>;<br>sum[i] = sum[i<span class="hljs-number">-1</span>] + data[i]; <br>&#125;<br><span class="hljs-keyword">for</span>( le=nn; le&gt;=<span class="hljs-number">1</span>; --le ) <br><span class="hljs-keyword">for</span>( ri=le+<span class="hljs-number">1</span>; ri &lt;= nn; ++ri)&#123;<br><span class="hljs-type">int</span> cost= sum[ri] - sum[le<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span>( k=le; k &lt;= ri<span class="hljs-number">-1</span>; ++k)&#123; <span class="hljs-comment">//决策：从哪一个转移过来</span><br>dpmin[le][ri] = <span class="hljs-built_in">min</span>(dpmin[le][ri], dpmin[le][k] + dpmin[k+<span class="hljs-number">1</span>][ri] + cost);<br>    dpmax[le][ri] = <span class="hljs-built_in">max</span>(dpmax[le][ri], dpmax[le][k] + dpmax[k+<span class="hljs-number">1</span>][ri] + cost);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 注意，答案并不存于dpmin[1][nn]。要求左右之间一定是宽度为n的区间</span><br><span class="hljs-comment">// 例如dpmin[1][n], 或者dpmin[2][n+1]、 dpmin[3][n+2]……dpmin[n][2*n-1]等中的最小值 </span><br><span class="hljs-type">int</span> mymin = INF;<br><span class="hljs-type">int</span> mymax = -INF;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; ++i)&#123;<br>       mymin = <span class="hljs-built_in">min</span> ( mymin , dpmin[i][i+n<span class="hljs-number">-1</span>] ) ;<br>   mymax = <span class="hljs-built_in">max</span> ( mymax , dpmax[i][i+n<span class="hljs-number">-1</span>] ) ;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, mymin);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, mymax);<br><br><span class="hljs-comment">//    for(int j=0; j&lt;= nn; j++)</span><br><span class="hljs-comment">//        printf(&quot;%8d&quot;, j);</span><br><span class="hljs-comment">//    printf(&quot;\n&quot;);</span><br><span class="hljs-comment">//for(int i=0; i&lt;=nn; i++)&#123; </span><br><span class="hljs-comment">//   for(int j=0; j&lt;= nn; j++)</span><br><span class="hljs-comment">//       if (dpmax[i][j] &lt; -10000)</span><br><span class="hljs-comment">//           printf(&quot;    -INF&quot;);</span><br><span class="hljs-comment">//        else</span><br><span class="hljs-comment">//           printf(&quot;%8d&quot;, dpmax[i][j]);</span><br><span class="hljs-comment">//    printf(&quot;\n&quot;);</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="不延展数组循环取余硬干">2.1.3.2 不延展数组，循环取余硬干</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法2：区间环dp + 不延长数组</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 102</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">区间dp，数据首尾链接成环，求最小值和最大值。</span><br><span class="hljs-comment">需要割环为链，设置2倍的数组空间， </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-type">int</span> data[N];<br><span class="hljs-type">int</span> dpmin[N][N];<br><span class="hljs-type">int</span> dpmax[N][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i, le, ri, k, n;<br><span class="hljs-built_in">memset</span>(dpmin, INF, <span class="hljs-built_in">sizeof</span>(dpmin));  <span class="hljs-comment">//初值设定为   INF</span><br><span class="hljs-built_in">memset</span>(dpmax, -INF  , <span class="hljs-built_in">sizeof</span>(dpmax));   <span class="hljs-comment">//初值设定为  -INF</span><br>cin &gt;&gt;n;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data[i]);<br>dpmin[i][i] = <span class="hljs-number">0</span>;<br>dpmax[i][i] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 假设n=10，下标分别为0..9 </span><br><span class="hljs-comment">// len=2  0..1  1..2  ...   8..9   9..0 </span><br><span class="hljs-comment">// len=4  0..3  1..4  ...   8..1   9..2 </span><br><span class="hljs-comment">// len=10 0..9  1..0  ...   8..7   9..8  </span><br><span class="hljs-comment">// 可以用len和le来循环 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> le=<span class="hljs-number">0</span>; le&lt;n; le++ )&#123; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ri=<span class="hljs-number">0</span>; le &lt;= n<span class="hljs-number">-1</span>; ++le)&#123;<br><span class="hljs-type">int</span> ri = le + len - <span class="hljs-number">1</span>;     <span class="hljs-comment">// 先暂时不管越界，毕竟没在[]里</span><br><span class="hljs-comment">// 老老实实算区间和，用前缀和数组更难处理 </span><br><span class="hljs-type">int</span> cost=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=le; k&lt;=ri; k++)  <span class="hljs-comment">// k在[]里，可能为ri，需要取余，否则k越界</span><br>    cost += data[k%n];     <span class="hljs-comment">// 因为下标从0开始存储基本数据，无法用前缀和，否则i-1为负数了</span><br>    <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=le; k &lt;= ri<span class="hljs-number">-1</span>; ++k)&#123; <span class="hljs-comment">//决策</span><br><span class="hljs-comment">// 最大值和最小值都列举给同学们看看，注意 k、k+1 和 ri 都有可能数组越界，需要绕回来，取余%</span><br>dpmin[le][ri%n] = <span class="hljs-built_in">min</span>(dpmin[le][ri%n], dpmin[le][k%n] + dpmin[(k+<span class="hljs-number">1</span>)%n][ri%n] + cost);<br>    dpmax[le][ri%n] = <span class="hljs-built_in">max</span>(dpmax[le][ri%n], dpmax[le][k%n] + dpmax[(k+<span class="hljs-number">1</span>)%n][ri%n] + cost);<br>    &#125;<br><span class="hljs-comment">//    printf(&quot;(%d,%d)-%2d-%2d &quot;, le, ri%n, dpmin[le][ri%n], dpmax[le][ri%n] );</span><br>&#125;<br><span class="hljs-comment">//printf(&quot;\n&quot;);</span><br>&#125;<br><span class="hljs-comment">// 注意，答案并不存于dpmin[1][nn]。要求左右之间一定是宽度为n的区间</span><br><span class="hljs-comment">// 例如dpmin[1][n], 或者dpmin[2][n+1]、 dpmin[3][n+2]……dpmin[n][2*n-1]等中的最小值 </span><br><span class="hljs-type">int</span> mymin = INF;<br><span class="hljs-type">int</span> mymax = -INF;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; ++i)&#123;<br>       mymin = <span class="hljs-built_in">min</span> ( mymin , dpmin[i][(i+n<span class="hljs-number">-1</span>)%n] ) ;    <span class="hljs-comment">// 注意要取余 </span><br>   mymax = <span class="hljs-built_in">max</span> ( mymax , dpmax[i][(i+n<span class="hljs-number">-1</span>)%n] ) ;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, mymin);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, mymax);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p1063-能量项链">2.2 P1063 能量项链</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P1063">P1063 [NOIP2006提高组] 能量项链</a></p><h3 id="分析-2">2.2.2 分析</h3><p>　　N个能量珠串成一串，相邻的珠子可以进行合并，旧珠消失，产生新珠，释放能量，求如何选择合并，使得释放的总能量最大。这是个比较明显的区间（环）DP问题。本来没什么难度，但题目中加了一个要素，就是“每个珠子有头标记和尾标记”，合并后的释放能量为<spanclass="math inline">\(m*r*n\)</span>。这个值得我们仔细研究一下，也就是cost[le][ri]=？</p><p>　　现在假设有两个相邻的能量珠（不管是原始的，或者是合并后产生的），珠1是第[le..c]个珠子合并后产生的能量珠，其头标记为m（必然是第le个珠子的头标记值），尾标记为r（必然是第c个珠子的尾标记值，同时根据“珠子相邻衔接”的基本定义，该值也是第c+1个珠子的头标记值）；珠2是第[c+1..ri]个珠子合并后产生的能量珠，其头标记为r（只可能是r，同学们可以想想为什么？然后在纸上画一画看看），尾标记为n（必然是第ri个珠子的尾标记）。那么两个珠子进行合并释放的能量就是：<span class="math display">\[\begin{align}&amp;\quad\ 第[le..c]个珠子合并后的珠子\ 与\第[c+1..ri]个珠子合并后的珠子\ 进行合并产生的能量\\&amp;=m \times r\times n\\ &amp;=第\ le\ 个珠子的头标记值m\ ×\ 第\ c\ 个珠子的尾标记值r\×\ 第\ ri\ 个珠子的尾标记值n\end{align}\]</span>　　剩下的可能的坑点就是结构体数据的录入和数组拓展部分结构体数据的复制了。需要的是同学们的仔细，在纸上画结构体数组的样例结果，然后小心调试。</p><h3 id="ac代码-1">2.2.3 AC代码</h3><p>　　本题以“断环为链”的方法来实现，其他方法请同学们自行研究。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100      </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NN 2*N+5</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">这个题，2个区间合并时，涉及到了3个数，比较麻烦，还是设定每个区间有ll和rr两个数，</span><br><span class="hljs-comment">这样比较容易控制区间编号，不至于造成混乱。 </span><br><span class="hljs-comment">    注意割环为链之后，长度从n变成了2n-1，所有数组都需要延展长度，并且第二层循环left</span><br><span class="hljs-comment">需要以右端不越界为截止点。 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> ll, rr;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> data[NN];<br><span class="hljs-type">int</span> dp[NN][NN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i, len, left, rt, k, n;<br>cin &gt;&gt;n;<br><span class="hljs-comment">//     0     1    2    3       4  |   5    6    7      8</span><br><span class="hljs-comment">//           2    3    5      10  |   2    3    5</span><br><span class="hljs-comment">//    /0   2/3   3/5  5/10   10/2 |  2/3  3/5  5/10  10/ </span><br><span class="hljs-comment">// 处理基本的data数据 </span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data[<span class="hljs-number">1</span>].ll);  <span class="hljs-comment">// 第一个数据单独处理，以便首尾衔接 </span><br>    data[n].rr= data[<span class="hljs-number">1</span>].ll; <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data[i].ll);<br>        data[i<span class="hljs-number">-1</span>].rr = data[i].ll;<br>    &#125;<br>    <span class="hljs-comment">// 处理延展部分的data数据 </span><br>    <span class="hljs-keyword">for</span>(i=n+<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>; i++)&#123;<br>        data[i].ll = data[i-n].ll;<br>        data[i].rr = data[i-n].rr;<br>    &#125;<br>    <span class="hljs-comment">// 初始化和特例处理 </span><br>    <span class="hljs-built_in">memset</span>(dp, -INF, <span class="hljs-built_in">sizeof</span>(dp)); <span class="hljs-comment">// 本例中无负数，初始化为0在本例中也是可以的 </span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>; i++)&#123;<br>        dp[i][i] = <span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-keyword">for</span>(len = <span class="hljs-number">2</span>; len&lt;=n; len++)<br><span class="hljs-comment">// 截止位置的条件是 区间右端下标不能超过2*n-1 </span><br><span class="hljs-keyword">for</span>(left=<span class="hljs-number">1</span>; left+len<span class="hljs-number">-1</span>&lt;=<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>; left++)&#123;<br>rt = left+len<span class="hljs-number">-1</span>;<br><span class="hljs-comment">// k的取值范围不变 </span><br><span class="hljs-keyword">for</span>(k=left; k&lt;=rt<span class="hljs-number">-1</span>; k++)<br><span class="hljs-comment">// 用data[k].rr 去乘，才能衔接得上 </span><br>dp[left][rt] = <span class="hljs-built_in">max</span> (dp[left][rt] , dp[left][k] + dp[k+<span class="hljs-number">1</span>][rt] + data[left].ll*data[k].rr*data[rt].rr );<br>&#125;<br><br><span class="hljs-comment">// 注意跨度值，跨度为n的区间，如果左端是i的话，那么右端应该是i+n-1 </span><br><span class="hljs-type">int</span> ans= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>ans = <span class="hljs-built_in">max</span>(ans, dp[i][i+n<span class="hljs-number">-1</span>]);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 区间dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间dp(链)模型</title>
      <link href="/2024/07/31/%E5%8C%BA%E9%97%B4dp(%E9%93%BE)%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/07/31/%E5%8C%BA%E9%97%B4dp(%E9%93%BE)%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="模型说明">1.1 模型说明</h2><p>　　现在有N个数据依次排成一条线，不允许移动（即有序），首尾不连接。现在要对这N个数据进行合并，要求只能合并相邻的两个数据，合并后的数据可以参与下一次合并。现在给定每次数据合并产生的代价，求将所有数据合并成一个数所产生的最小代价/最大代价。</p><p>　　<strong><ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1274">1274：【例9.18】合并石子</a></strong>是区间dp的标准模板题型。理论上来说，也可以要求每次只能选择相邻的三堆数据。</p><h2 id="分析">1.2 分析</h2><p>　　如果N个数据是无序的，允许任意选择数据来合并的话，整个过程就变成了<ahref="https://www.luogu.com.cn/problem/P1090">P1090 [NOIP2004 提高组]合并果子 / [USACO06NOV] Fence RepairG</a>这种二叉或者K叉哈夫曼树问题，用贪心的思想来解决问题即可。但当前题型要求不能任意选择数据，每次合并只能选择<strong>相邻</strong>的两个数据进行合并。“合并相邻数据”，这是区间dp的一个很典型的特征。下面介绍区间dp的做法（以求最小值为例）。</p><ol type="1"><li><p>状态数组定义</p><p>　　dp[le][ri]表示将编号从le到ri的这个区间内所有数据进行合并所需的最小代价。</p></li><li><p>所求目标</p><p>　　dp[1][n]表示将编号从1到n的这个区间内所有数据进行合并所需的最小代价。</p></li><li><p>状态转移方程</p><p>　　对于这种稍微复杂点的问题，同学们最好是举个例子来分析，拿出你的草稿纸和笔！</p><p>根据状态数据的基本定义，我们可以得到如下： <spanclass="math display">\[dp[1][5]=min\begin{cases} dp\textcolor{red}{[1][1]}+dp[2][5] +\quad合并[1..1]和[2..5]所需代价\\ dp[1][2]+dp[3][5]  +\quad合并[1..1]和[2..5]所需代价\\ dp[1][3]+dp[4][5]  +\quad合并[1..1]和[2..5]所需代价\\ dp[1][4]+dp\textcolor{red}{[5][5]}  +\quad合并[1..1]和[2..5]所需代价\\ \end{cases} \tag{1}\]</span></p><p>　　我们把公式1进一步浓缩一下，得到如下的公式2： <spanclass="math display">\[dp[1][5]=min(dp[1][c]+dp[c+1][5]+\quad合并[1..c]和[c+1..5所需代价])\\(le \leq c \leq \textcolor{red}{ri-1}) \tag{2}\]</span> 　　再把公式2做一般性推广，得到公式3如下： <spanclass="math display">\[dp[le][ri]=min(dp[le][c]+dp[c+1][ri]+\quad合并[le..c]和[c+1..\ri]所需代价)\\(1 \leq le \leq ri\leq n,\quad le \leq c \leq \textcolor{red}{ri-1})\tag{3}\]</span>　　这就是区间dp的公式之一。这个公式有一个假设前提，那就是“假设对区间内的数据进行合并时，是“求和”的模式（注意，也可以求最大值/最小值等，到时候就不是两个dp[][]值相加，而是求max或者min了）”。具体的状态转移方程需要同学们根据实际情况灵活分析和处理，不要死记硬背公式3！</p><p>　　公式3是对多个数据进行比较求最小，在代码实现的时候可以采用<strong>累比</strong>的模式来实现，大致如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> le ... )  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ri ... ) <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c ...)<br>            dp[le][ri] = <span class="hljs-built_in">min</span>(dp[le][ri], dp[][]+dp[][] + 合并所需代价)　<br></code></pre></td></tr></table></figure></li><li><p>循环顺序和边界值</p><p>　　从公式3来进行分析，要求dp[le][ri]的值，就要求dp[le][c]和dp[c+1][ri]的值已知（即已填过），这样才能根据已知数据填写未知元素。根据dp[le][c]以及方程的要求"<spanclass="math inline">\(c \leqri-1\)</span>"可以看出，要求dp[le][ri]，就<strong>必须要知道当前网格<font color="red">左侧</font>的数据</strong>；根据dp[c+1][ri]以及方程的要求"<spanclass="math inline">\(le \leqc\)</span>"可以看出，要求dp[le][ri]，就<strong>必须要知道当前网格<font color="red">下方</font>的数据</strong>。综上所述，要根据当前网格左方和下方的数据来填写当前网格的数据。所以，我们的循环顺序应该是“从下往上，从左往右”或者“从左往右，从下往上”。鉴于绝大部分程序员都采用“逐行填写”的习惯，所以这里<strong>本帖推荐“从下往上，从左往右”的循环顺序</strong>。</p><p>　　关于循环边界，这里首先要注意一个事情，那就是公式3中有一个<spanclass="math inline">\(le\leqri\)</span>，也就是说，不允许出现dp[4][3]或者dp[8][2]这种情况。归纳一下三个循环变量的顺序和边界如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> le=n; le&gt;=<span class="hljs-number">1</span>; le--)       <span class="hljs-comment">// 从下往上</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ri=le; ri&lt;=n; ri++)  <span class="hljs-comment">// 从左往右</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=le; c&lt;= ri<span class="hljs-number">-1</span>; c++) <span class="hljs-comment">// 可增可减，公式1中的4排数据，从上往下min或者从下往上min，都不影响求最终的min值</span><br>            dp[le][ri] = <span class="hljs-built_in">min</span>(dp[le][ri], dp[][]+dp[][] + 合并所需代价)　<br></code></pre></td></tr></table></figure><p>　　从上面的代码可以看到，<strong>整个算法的时间复杂度是<spanclass="math inline">\(O(n^3)\)</span>的，不能处理<spanclass="math inline">\(n \geq200\)</span>的情况</strong>。</p><p>　　其实，除了上面这种最直接地枚举区间左右两端之外，还有第2种枚举方式，时间复杂度相同。对于[1,5]，它是由5个数据经过合并得到的，而它的子问题 [1 ,2] , [2 ,4]等，都是由长度为2~4的区间合并而成。要计算由 n 个数合并而成的区间 [a ,a+n−1]处理的最值dp时，我们要做的是先计算好由长度为 2 至 n−1 的区间[a ,a+c−1]。因为 c 一定小于 n，所以我们可以将区间的长度len作为第一维。只要知道len及left，就能够算出rt的位置。因为长区间都是由短区间的值计算而来，所以，如果短区间的值先计算出来，那么长区间的值的计算自然毫无障碍。大致代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 先计算短区间，然后计算长区间 ，最短长度是2（最少是2个数的合并）</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len= <span class="hljs-number">2</span>; len&lt;=n; len++)<br>    <span class="hljs-comment">// 枚举左端le值，增序降序都能AC</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> le=<span class="hljs-number">1</span>; le+len<span class="hljs-number">-1</span>&lt;=n; le++)&#123; <br>        <span class="hljs-comment">// 先处理区间[10..13]，或者先处理区间[1..4]都无所谓，相互不影响，正序逆序均可</span><br>        <span class="hljs-comment">//for(int le=n-len+1; le&gt;=1; le--)&#123;  // 正反序均可</span><br>        <span class="hljs-type">int</span> ri = le + len - <span class="hljs-number">1</span>;            <span class="hljs-comment">// 根据le和len来计算出ri</span><br>        <span class="hljs-comment">// 上面的双重for顺序无法适用于平行四边形优化</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=le; c&lt;=ri<span class="hljs-number">-1</span>; c++)<br>            dp[le][ri] = <span class="hljs-built_in">min</span>(dp[le][ri] , dp[le][c]+dp[c+<span class="hljs-number">1</span>][ri]+合并所需代价);<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>初始化和特例</p><p>整个dp数组的左下三角部分是不会被填写的，应该是“无解”，因为区间右端必须要大于等于区间左端。整个数组可以初始化为无解。</p><p>既然是要填写dp数组的右上部分，那特例肯定就不像以前那样在第0行或者在dp[0][0]了。同学们可以想一下，整个数组在三重循环时最先填写的是什么位置上的数据？它需要什么特例呢？可以稍微想一下就会知道，在数组的右下位置需要最先填写。主对角线位置是特例，因为dp[i][i]表示从自己到自己这个区间的合并收益，而从自己到自己是不需要合并的，合并收益为0。所以有如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">memset</span>(dp, -INF, <span class="hljs-built_in">sizeof</span>(dp));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++) dp[i][i]= <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li></ol><h1 id="二实战训练">二、实战训练</h1><h2 id="合并石子">2.1 1274 合并石子</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1274">1274：【例9.18】合并石子</a></p><h3 id="分析-1">2.1.2 分析</h3><p>　　裸的区间dp入门题，n个数据是有序的，任何区间进行合并的代价就是区间数据之和，对两个合并对象进行求和之后再加上该合并操作的额外代价即可。n=100，用裸模板的话，时间复杂度为1e6,可AC本题。本题也可以采用平行四边形优化，后面再说。</p><h3 id="ac代码">2.1.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法1：区间dp，链，朴素做法，没有用四边形优化。  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 101</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">区间动态规划， 链，求最小值，最朴素的版本，没有用四边形优化。 </span><br><span class="hljs-comment">本题中两个区间合并，是求和值，故用 &quot; + &quot; 来处理两个子区间的dp值 </span><br><span class="hljs-comment">本题用前缀和数组sum[] </span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> data[N], n;<br><span class="hljs-type">int</span> sum[N]; <br><span class="hljs-type">int</span> dp[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>cin &gt;&gt;n;<br><span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data[i]);<br>sum[i] = sum[i<span class="hljs-number">-1</span>] + data[i];    <span class="hljs-comment">// 用前缀和数组sum[]来快速记录 </span><br>dp[i][i] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> left=n; left&gt;=<span class="hljs-number">1</span>; left--)<br>    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> rt=left+<span class="hljs-number">1</span>; rt&lt;=n; rt++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=left; k&lt;=rt<span class="hljs-number">-1</span>; k++)      <span class="hljs-comment">// 普通做法 </span><br>                dp[left][rt] = <span class="hljs-built_in">min</span>(dp[left][rt] , dp[left][k] + dp[k+<span class="hljs-number">1</span>][rt] + sum[rt] - sum[left<span class="hljs-number">-1</span>] ) ;<br><br>cout &lt;&lt; dp[<span class="hljs-number">1</span>][n] &lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 区间dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间分段dp（“萝卜填坑”）模型</title>
      <link href="/2024/07/21/%E5%8C%BA%E9%97%B4%E5%88%86%E6%AE%B5dp%EF%BC%88%E2%80%9C%E8%90%9D%E5%8D%9C%E5%A1%AB%E5%9D%91%E2%80%9D%EF%BC%89%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/07/21/%E5%8C%BA%E9%97%B4%E5%88%86%E6%AE%B5dp%EF%BC%88%E2%80%9C%E8%90%9D%E5%8D%9C%E5%A1%AB%E5%9D%91%E2%80%9D%EF%BC%89%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="模型说明">1.1 模型说明</h2><p>　　现在有K个数据依次排成一条线，不允许移动。给定这一条线上任意两个位置之间（形成了一个区间）的收益值<spanclass="math inline">\(value[\ le\ ][\ ri\]\)</span>，现在需要将这K个数据的线分割成<span class="math inline">\(P(1\leq P \leqK)\)</span>段，求分割后的收益最大值/最小值（为了讲解方便，在第一章中我们统一用“最大值”）。</p><p>　　这种题型看上去有点像是区间DP，不过和正规的区间DP在dp数组定义、求解思路等方面都有一些差别。因为这种题型还是涉及到了“在区间中进行决策”，所以我们把它归于“区间DP”这个大类中来了。</p><h2 id="分析">1.2 分析</h2><p>　　因为我们需要将K个数据分割成N段，所以我们完全可以把这N段设置为N个阶段，这种划分满足“局部最优”和“无后效性”这两大特点，所以这种题型可以用dp这种大模型来搞定。</p><ol type="1"><li>状态数组定义</li></ol><p>　　我们用状态数组dp来存放最大收益值。既然如此，我们的dp数组的维度就要能够准确地描述出一个唯一的状态，或者说是一种划分。划分不仅和“数据”有关，也和划分的“段”有关。所以有如下的二维数组定义：</p><p>　　dp[p][k]：<strong>把前k个数据划分成p段后得到的最大收益值；</strong></p><ol start="2" type="1"><li><p>所求目标</p><p>dp[P][K]：把K个数据划分成P段后得到的最大收益值；</p></li><li><p>状态转移方程</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240721150540525.png" alt="image-20240721150540525" style="zoom:80%;" /><span class="math display">\[dp[p][k]= dp[p-1][c]\ \ \ + value[c+1][k] \tag{1}\]</span><font color="red"><strong>把前k个数据划分成p段的收益值　=　把前c个数据划分成p-1段的收益值　+　在从[c+1..k]这1段数据中获得的收益值（假设是求和值）</strong></font></p><p>上面的公式，只是一次划分或者一次“决策”。根据定义，还需要所有决策值比较，获得最大值。所以状态转移方程如下：<span class="math display">\[\begin{align}dp[p][k]=max(dp[p-1][c]+value[c+1][k]) \tag{2} \\(1 \leq p \leq P,\quad p \leq k \leq K,\quad p-1 \leq c \leq k-1 )\tag{}\end{align}\]</span></p><p>　　上面的公式（2）只是一个数学简式，并不是一个真正的C++代码。如果要转成代码，需要考虑max函数和循环的特点。伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[p][k]= -INF;  <span class="hljs-comment">// 初值设为负无穷，为“无解”状态的初始值， 以方便max运算出正确的结果</span><br><span class="hljs-keyword">for</span> (p)          <span class="hljs-comment">// 省略了部分代码</span><br>    <span class="hljs-keyword">for</span>(k)<br>        <span class="hljs-keyword">for</span>(c)<br>            dp[p][k]= <span class="hljs-built_in">max</span>(dp[p][k], dp[p<span class="hljs-number">-1</span>][c]+value[c+<span class="hljs-number">1</span>][k]);<br></code></pre></td></tr></table></figure><p>　　这里我们假设了整个划分方案的收益值是每个分段收益值之和，所以方程中出现了“dp<font color="red"><strong>+</strong></font>value”。这是一个假设，并不绝对。同学们不必死背公式，一定要理解着来推。</p></li><li><p>循环顺序和循环边界</p></li></ol><p>　　在公式（2）的状态转移方程中有3个变量，分别为p、k、c。第p行依赖于第p-1行，而c&lt;k。这里我们需要分析一下变量k和变量c的取值范围。</p><p>1）k：因为这种题型基本上都要求每段至少要有1个数据，所以要把k个数据划分成p段，必然要求<spanclass="math inline">\(k \geqp\)</span>，所以<strong>k的循环取值范围是[p..K]</strong>；对于状态[p][0..p-1]，一律视为“无解”的状态，赋予他们“无解”该有的初值即可。</p><p>2）c：<strong>决策点c值的循环取值范围是[p-1..k-1]</strong>，其详细推导过程如下，请展开阅读。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">假设现在有8个数据，需要分成3段。如果要求每段至少要有1个数据的话，划分结果只能是如下几种：<br>    1)　&#123;[1..1]、  [2..2（第3段的决策点c值）]、  [3..8]&#125;<br>    2)　&#123;[1..1]、  [2..3（第3段的决策点c值）]、  [4..8]&#125;<br>    3)　&#123;[1..2]、  [3..3（第3段的决策点c值）]、  [4..8]&#125;<br>          ......// 太多了，这里不全列出来了，<br>    *)　&#123;[1..4]、  [5..7（第3段的决策点c值）]、  [8..8]&#125;<br>    *)　&#123;[1..6]、  [7..7（第3段的决策点c值）]、  [8..8]&#125;<br>对于第2段的右端点（即划分第3段的决策点c值），只可能是2、3、4、5、6、7。<br>我们把上面的结果推广一下，如果有k个数据需要划分成p段，那么决策点c值的取值范围是[p-1..k-1]。记住这个结论。<br></code></pre></td></tr></table></figure><p>　　所以循环顺序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// P 个阶段，每个阶段划分出一段，必须增序</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p=<span class="hljs-number">1</span>; p&lt;=P; p++)             <span class="hljs-comment">// [1..P]</span><br>    <span class="hljs-comment">// 增序、降序均可，数据来源于上一行</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=p; k&lt;=K; k++)          <span class="hljs-comment">// [p..K]或者[K..p]</span><br>        <span class="hljs-comment">// 必须增序，从左往右填</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=p<span class="hljs-number">-1</span>; c&lt;=k<span class="hljs-number">-1</span>; c++)  <span class="hljs-comment">// [p-1..k-1]</span><br></code></pre></td></tr></table></figure><p>　　可以看出，这是一个时间复杂度为<spanclass="math inline">\(O(P*K^2)\)</span>的算法。</p><ol start="5" type="1"><li>初始化和特例</li></ol><p>　　整个dp[0..P][0..K]数组并不会全部被填写。循环没有遍历到的网格，必然就是不可能出现的状态（例如dp[10][3]，把3个数据划分成10段，这没法搞，直接“无解”），所以整个dp数组需要初始化成“无解”状态对应的值。</p><p>　　对于特例，</p><p>　　dp[0][0]表示把前0个数据划分成0段后得到的最大收益值；这里没有提供任何数据，要求0段（即不划分），很简单，什么都不做即为合理的做法，收益值为0.</p><p>　　dp[0][1]表示把前1个数据划分成0段后得到的最大收益值；把1个数据划分为0段，描述不合理，无法实现，无解，收益值为“无解”对应的取值INF。</p><p>　　从上面两条可以看出，特例只有<strong>dp[0][0]=0</strong>,而dp[0][1..K]则和其他行的数据一样，不是特例，应初始化为"无解"。</p><p>　　个别题可能会把dp[i][i]归于特殊情况，需要酌情考虑给予恰当的值。</p><h1 id="二实战训练">二、实战训练</h1><h2 id="p1281">2.1 1278/P1281</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1278">1278：【例9.22】复制书稿(book)</a>/<ahref="https://www.luogu.com.cn/problem/P1281">P1281 书的复制</a></p><h3 id="分析-1">2.1.2 分析</h3><p>　　要求把K本书分给P个人，每个人分到的书必须是连续的，这实际上就是一个“线性有序条件下的分段”的问题。每个分段内所需时间为该分段内每一本书所需时间之和，而整个划分方案的收益值为该方案中所有分段内部所需时间的最大值。现在要求整个方案的最小所耗时间。看上去有点像个min(max(sum()))的架构，挺吓人的，哈哈～</p><ol type="1"><li><p>状态数组定义</p><p>　　dp[p][k]：把前k本书划分给p段（每个人1段）后得到的最小时间值；</p></li><li><p>所求目标</p><p>　　dp[P][K]：把前K本书划分给P段（每个人1段）后得到的最小时间值；</p></li><li><p>状态转移方程</p><p>　　我们再来看这张图，</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240721150540525.png" alt="image-20240721150540525" style="zoom:80%;" /></p><p>　　根据题意，dp[p][k]和dp[p-1][c]及value[c+1][k]之间并不是“求和”的关系，而是“取最大值”的关系。也就是说，dp[p][k]=<font color="red">max</font>(dp[p-1][c],value[c+1][k])。1个方案的值等于每个人所需时间的最大值。注意，这只是一个方案的值，并不是我们要求的“最优方案”。那最优方案该怎么求呢？题目说了，值最小的就是最优。所以：<span class="math display">\[dp[p][k]=min(\ max(dp[p-1][c],\ \ value[c+1][k])\ ) \tag{3}\]</span> 　　<spanclass="math inline">\(value[c+1][k]\)</span>原本表示的是把第[c+1..k]个数设为1个段而得到的收益值，在本题中其实就是第[c+1..k]本书所需时间之和。我们现在已知每本书所需的时间，而本题又需要频繁求任意两本书位置区间之和，所以最好的办法就是新建一个前缀和数组，采用sum[k]-sum[c]来表示出value[c+1][k]。所以状态转移方程进一步转化为：<span class="math display">\[\begin{align}dp[p][k]=min(\ max(dp[p-1][c],\ \ sum[k]-sum[c])\ ) \tag{4}\\(1 \leq p \leq P,\quad p \leq k \leq K,\quad p-1 \leq c \leq k-1 )\tag{}\end{align}\]</span></p><p>　　上面的公式（4）只是一个数学简式，并不是一个真正的C++代码。如果要转成代码，需要考虑max函数和循环的特点。伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[p][k]= INF;   <span class="hljs-comment">// 初值设为负无穷，为“无解”状态的初始值， 以方便min运算出正确的结果</span><br><span class="hljs-keyword">for</span> (p)          <span class="hljs-comment">// 省略了部分代码</span><br>    <span class="hljs-keyword">for</span>(k)<br>        <span class="hljs-keyword">for</span>(c)<br>            dp[p][k]= <span class="hljs-built_in">min</span>( dp[p][k],   <span class="hljs-built_in">max</span>( dp[p<span class="hljs-number">-1</span>][c], sum[k]-sum[c]) );<br></code></pre></td></tr></table></figure></li><li><p>循环顺序和边界</p><p>　　和1.2节分析结果相同，照做即可。</p></li><li><p>初始化和特例</p><p>　　公式（4）里面有max，有min，当初始化dp数组为“无解”时，到底应该初始化为“INF”或者“-INF”呢？在公式（4）中我们需要先计算max，再来计算min。但是在做max运算时，所比较的对象中并没有dp[p][k]自身，而是把两个确切的值（dp[p-1][c]和sum[k]-sum[c]）做比较，这跟“赋初值”毫无关系，只是一个干扰项。<strong>真正实现累比的是min操作（因为min操作的其中一个比较对象是dp[p][k]它自己）。所以dp[p][k]的初值应该定义成针对min操作合适的初值对象，即INF</strong>。</p><p>　　关于特例，有dp[0][0]=0。而dp[0][1..K]，因为无法把前k本书划分给0个人，人都没有，怎么划分？所以其最小时间值为“无解”状态。这也是根据1.2节中的第5点分析而来。所以初始化和特例的处理应该是如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;  <span class="hljs-comment">// 在第0行只应对dp[0][0]做特殊处理</span><br></code></pre></td></tr></table></figure></li><li><p>输出方案</p><p>　　根据本题对dp数组的定义，dp[P][K]表示把前K本书划分给P个人后得到的最小时间值。在最优方案中，dp[P][K]又表示每个人所获页数的最大值（根据题目上对任一方案值的定义）。所以我们只需要按序分配书，并且让每个人的页数不超过dp[P][K]即可。可用递归函数来实现，不难。</p></li><li><p>优化</p><p>这个题是可以做平行四边形优化的，具体后面再说。</p></li></ol><h3 id="ac代码">2.1.3 AC代码</h3><h4 id="标准dp数组无优化输出方案">2.1.3.1标准dp数组，无优化，输出方案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法1. 可AC1278和P1281， 标准dp数组，无优化，输出方案</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 501</span><br><span class="hljs-type">int</span> K, P;<br><span class="hljs-type">int</span> page[N];         <span class="hljs-comment">// 存储每本书的页数</span><br><span class="hljs-type">int</span> dp[N][N];        <span class="hljs-comment">// dp[p][k]表示前 k 本书分给前 p 个人抄写的最短复制时间</span><br><span class="hljs-type">int</span> sum[N];          <span class="hljs-comment">// 用前缀和数组sum[]来方便处理，sum[p]表示前p本书的总页数</span><br><span class="hljs-comment">//打印输出把前k本书分给前p个人抄写的划分方案</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> c, s;<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 1278题允许P为0，P1281要求p至少为1。加本行才可以过1278题，否则只能过P1281 </span><br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-number">1</span>) &#123;         <span class="hljs-comment">// 如果只有1个人，把所有前k本书都给他吧</span><br>        cout &lt;&lt;<span class="hljs-number">1</span> &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt;k &lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    c = k;<br>    s = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 从第k本书开始，在dp[P][K]范围内往左一直分配，尽量多分配书给第p个人</span><br>    <span class="hljs-keyword">while</span>( s + page[c] &lt;= dp[P][K] ) &#123;<br>        s = s + page[c];<br>        c--;<br>    &#125;<br>    <span class="hljs-comment">// [c+1, k]之间的书已经分配给第p个人了，</span><br>    <span class="hljs-comment">// 下面接着分配[1, c]的书给剩下的p-1个人</span><br>    <span class="hljs-built_in">print</span>( p<span class="hljs-number">-1</span>, c );<br>    <span class="hljs-comment">// 为了体现正序，所以这里应该先追溯递归，然后再cout本次函数的分配方案</span><br>    cout &lt;&lt;c+<span class="hljs-number">1</span>  &lt;&lt;<span class="hljs-string">&quot; &quot;</span>  &lt;&lt;k  &lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> k, p;<br>    cin &gt;&gt;K &gt;&gt;P;           <span class="hljs-comment">// K本书，P个人</span><br>    <span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=K; k++) &#123;  <span class="hljs-comment">// K本书</span><br>        cin &gt;&gt;page[k];<br>        sum[k] = sum[k<span class="hljs-number">-1</span>] + page[k];<br>    &#125;<br>    <span class="hljs-comment">// 先要算出dp[P][K]，这样print函数才能用得上</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=<span class="hljs-number">1</span>; p&lt;=P; p++)      <span class="hljs-comment">// p个人</span><br><span class="hljs-comment">//      for(k=K; k&gt;=p; k--)  // k本书 增序降序均可 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=p; k&lt;=K; k++)  <span class="hljs-comment">// k本书</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=p<span class="hljs-number">-1</span>; c&lt;=k<span class="hljs-number">-1</span>; c++) <span class="hljs-comment">//</span><br>                dp[p][k] = <span class="hljs-built_in">min</span> (dp[p][k] , <span class="hljs-built_in">max</span>( dp[p<span class="hljs-number">-1</span>][c], sum[k]-sum[c] ));<br><br>    <span class="hljs-comment">// 这个题不光是要最短时间dp[P][K]，也要分配方案</span><br>    <span class="hljs-built_in">print</span>(P, K);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>样例对应的dp数组如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240722151409997.png" alt="image-20240722151409997" style="zoom:50%;" /></p><h4 id="滚动dp数组无优化输出方案">2.1.3.2滚动dp数组，无优化，输出方案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法2. 可AC1278和P1281，滚动dp数组，无优化，输出方案</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 501</span><br><span class="hljs-type">int</span> K, P;<br><span class="hljs-type">int</span> page[N];         <span class="hljs-comment">// 存储每本书的页数</span><br><span class="hljs-type">int</span> dp[N];           <span class="hljs-comment">// dp[k]表示前 k 本书分给前 p 个人抄写的最短复制时间</span><br><span class="hljs-type">int</span> sum[N];          <span class="hljs-comment">// 用前缀和数组sum[]来方便处理，sum[p]表示前p本书的总页数</span><br><span class="hljs-comment">//打印输出把前k本书分给前p个人抄写的划分方案</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> c, s;<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 1278题允许P为0，P1281要求p至少为1。加本行才可以过1278题，否则只能过P1281 </span><br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-number">1</span>) &#123;         <span class="hljs-comment">// 如果只有1个人，把所有前k本书都给他吧</span><br>        cout &lt;&lt;<span class="hljs-number">1</span> &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt;k &lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    c = k;<br>    s = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 从第k本书开始，在dp[K]范围内往左一直分配，尽量多分配书给第p个人</span><br>    <span class="hljs-keyword">while</span>( s + page[c] &lt;= dp[K] ) &#123;<br>        s = s + page[c];<br>        c--;<br>    &#125;<br>    <span class="hljs-comment">// [c+1, k]之间的书已经分配给第p个人了，</span><br>    <span class="hljs-comment">// 下面接着分配[1, c]的书给剩下的p-1个人</span><br>    <span class="hljs-built_in">print</span>( p<span class="hljs-number">-1</span>, c );<br>    <span class="hljs-comment">// 为了体现正序，所以这里应该先追溯递归，然后再cout本次函数的分配方案</span><br>    cout &lt;&lt;c+<span class="hljs-number">1</span>  &lt;&lt;<span class="hljs-string">&quot; &quot;</span>  &lt;&lt;k  &lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> k, p;<br>    cin &gt;&gt;K &gt;&gt;P;               <span class="hljs-comment">// K本书，P个人</span><br>    <span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=K; k++) &#123;  <span class="hljs-comment">// K本书</span><br>        cin &gt;&gt;page[k];<br>        sum[k] = sum[k<span class="hljs-number">-1</span>] + page[k];<br>    &#125;<br>    <span class="hljs-comment">// 先要算出dp[K]，这样print函数才能用得上</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=<span class="hljs-number">1</span>; p&lt;=P; p++)      <span class="hljs-comment">// p个人</span><br>        <span class="hljs-keyword">for</span>(k=K; k&gt;=p; k--)      <span class="hljs-comment">// k本书 滚动数组只能降序 </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=p<span class="hljs-number">-1</span>; c&lt;=k<span class="hljs-number">-1</span>; c++) <span class="hljs-comment">//</span><br>                dp[k] = <span class="hljs-built_in">min</span> (dp[k] , <span class="hljs-built_in">max</span>( dp[c], sum[k]-sum[c] ));<br><br>    <span class="hljs-comment">// 这个题不光是要最短时间dp[K]，也要分配方案</span><br>    <span class="hljs-built_in">print</span>(P, K);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p4677">2.2 1197/P4677</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1197">1197：山区建小学</a>/<ahref="https://www.luogu.com.cn/problem/P4677">P4677 山区建小学</a></p><h3 id="分析-2">2.2.2 分析</h3><p>　　题目比较难懂，先把测试样例的结果搞明白，往往有助于理解题意。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724103511313.png"alt="image-20240724103511313" /><figcaption aria-hidden="true">image-20240724103511313</figcaption></figure><p>　　把2个学校分别设置在2号村庄和7号村庄的话，各个村庄到附近学校的距离之和达到最小，为18。</p><h4 id="动态规划多步分析">2.2.2.1 动态规划多步分析</h4><p>　　理解了基本题意之后，我们来观察这张图，感觉这个题像是在“k个村庄中选择p个小学”的选择策略问题，而且每个小学会涵盖一个区间范围。所有K个小学被分割成了P个区间范围。每个区间范围内的村庄都去对应的小学上学。区间之间互不影响。下面我们用动态规划的分析思路来进行整理和细化。</p><ol type="1"><li>状态数组定义</li></ol><p>dp[p][k]:把前k个村庄分成p段，每1段内建立1个小学后,每段内每个村庄到各自段内小学的最短路程之总和</p><ol start="2" type="1"><li>所求目标</li></ol><p>dp[P][K]:把K个村庄分成P段，每1段内建立1个小学后,每段内每个村庄到各自段内小学的最短路程之总和</p><ol start="3" type="1"><li>状态转移方程</li></ol><p>　　这个内容比较复杂，下面需要用较多的篇幅来讲述。</p><p>　　首先我们要意识到这是一个“把K个数据分为P段”策略问题，可以用dp来求最优解。</p><p>　　我们现在要计算dp[p][k]，也就是要填表格中第p行第k列的值。我们现在能利用的，就是已经填过值的数据，也就是表格中dp[p][k]所处位置以左或以上的数据，也就是例如dp[p-1][k]、dp[p-1][k-1]、dp[p-2][k]、dp[p-3][k-1]、dp[p-2][k-2]、...等这些数据。</p><p>　　为了方便说明，我们下面暂时以dp[3][6]为例，即在前6个村庄中选3个位置来作为学校，求所有村庄到附近小学的最短路径之和。很多时候，当我们在推导状态转移方程时，可以假设一些具体的数据，便于快速找到方法，再推广到普通的情况。</p><p>　　<strong>1）传统dp做法，让dp[p][k]去和dp[p][k-1]、dp[p-1][k-1]或者dp[p-1][k]等产生关联（不可行）</strong></p><p>　　如下图所示，先算出这6个点“ABCDEF”到其中2个点“B”和“D”的最短距离之和，即dp[2][6]。其中B和D是假定的学校位置，具有随机性。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723141319295.png" alt="image-20240723141319295" style="zoom:67%;" /></p><p>　　然后再在剩下的4个点中新增第3个学校F，调整参与求和的距离，使得总和最小。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723141456308.png" alt="image-20240723141456308" style="zoom:67%;" /></p><p>　　可以看出，在把F点设置为学校之后，上面两个图在计算距离之和这方面，参与计算求和的多个距离值存在较大的不同。这样划分，使得上一个步骤计算出来的各种距离值化为乌有，不可再用，很多距离值都需要重新计算，会使得程序更难理解和处理，复杂度暴涨，放弃！而且这样设计，并没有体现出“把K个数据分为P段”当中的“段”的思想。</p><p>　　2）<strong>改进做法（可行，但需调整）</strong></p><p>　　当村庄和学校的位置都确定时，每个村庄都会到附近最近的学校去上学，这实际上已经形成了以多个学校为中心的片区。每个片区可以看成一个段。段与段之间的村庄不产生相互的联系。这实际上更像是“线性结构上分段”的类型。　　</p><p>　　如果要计算dp[3][6]，可以先算出前5个点“ABCDE”到其中2个点“B”和“D”的最短距离之和，即dp[2][5]（注意，“B”和“D”仍然是随便假定的学校位置）。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723141808078.png" alt="image-20240723141808078" style="zoom:67%;" /></p><p>　　然后再在剩下的6-5=1个点中新增第3个学校“F”，<strong>并且要求前5个村庄不得到新增点的学校来上课（体现出了“段”的思想，不同段内的数据相互不产生任何联系）</strong>。这样可以保持之前已有的数据关系和数据值不变（可以使得划分具有“无后效性”和“局部最优”的特点，满足动态规划的基本要求），得到“在前6个点中设置3个学校的距离之和”的<strong>一个（注意，并不是唯一的）</strong>计算公式。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723142122884.png" alt="image-20240723142122884" style="zoom:67%;" /></p><p>　　当然，这个公式肯定是存在一定问题的。从上面的图中可以看出，E点如果要去学校D，明显会比去学校F更远。也就是说，这种划分，虽然能很方便地利用之前dp数组的数据，但其结果却是不对的，还需要进一步修正。</p><p>　　上面这个结果的错误之处，在于这种划分不对。我们不应该划分成“ABCDE+F”的组合，这样会使得E点的孩子去学校D上学而不去更近的学校F。那除了“ABCDE+F”这种划分之外，还可以有其他的划分方法，即“空+ABCDEF”，“A+BCDEF”，“AB+CDEF”，“ABC+DEF”，“ABCD+EF”这五种。</p><p>　　<font color="red">正确的划分方法，肯定就在这六种划分方式中。我们可以遍历一遍，找出其中的最小值。哪个组合的距离之和最小，那对应的划分方法自然就是正确答案。</font></p><ul><li><del>空+ABCDEF—— dp[3][6] = dp[2][0] +“ABCDEF中选一个点作为学校后其他5个点到该点的距离之和的最小值”</del>(无法在0个村庄中选2个学校，dp[2][0]必然无解，本策略无效，不必参与min比较)</li><li><del>A+BCDEF　—— dp[3][6] = dp[2][1] + “BCDEF中选一个点作为学校后其他4个点到该点的距离之和的最小值”</del>(无法在1个村庄中选2个学校，dp[2][1]必然无解，本策略无效，不必参与min比较)</li><li>AB+CDEF　—— dp[3][6] = dp[2][2] + “CDEF中选一个点作为学校后其他3个点到该点的距离之和的最小值”</li><li>ABC+DEF　—— dp[3][6] = dp[2][3] + “DEF中选一个点作为学校后其他2个点到该点的距离之和的最小值”</li><li>ABCD+EF　—— dp[3][6] = dp[2][4] + “EF中选一个点作为学校后其他1个点到该点的距离之和的最小值”</li><li>ABCDE+F　—— dp[3][6] = dp[2][5] + “F中选一个点F作为学校后的距离的最小值（其实就是0了，自己到自己的距离）”</li></ul><p>　　从上面的6个式子可以看出，有一种信息需要频繁求取，而我们还没有对应的数据结构来表示它。那就是“在一段连续的村庄（假设为从第i个村庄到第j个村庄）中选一个点作为学校后，该段内其他所有点到该点的距离之和的最小值”。该如何表示这个信息呢？其实只需要把i和j表示出来即可。该信息表示的是最小值，所以不应该在数据结构中指定学校的位置。所以该结构只需要2个信息即可，就是i和j，我们可以<strong>用一个二维数据Cost[i][j]来表示从第i个村庄到第j个村庄这一个区间中选1个点作为学校后，该区间内其他点到该学校点的距离之和的最小值</strong>。</p><p>　　关于Cost[][]的值，怎么计算出来呢？这是本题比其他同类型题复杂的地方。题面上并没有直接给出Cost[][]的值，需要我们去计算出来。具体分析和计算过程，因为内容较多，为了避免冲淡主题，把这部分内容单独做成2.2.2.2小节，请同学们注意学习。下面的分析假设该数组C的值已经获得。</p><p>　　根据上面红色文字的叙述，我们可以总结出下面的公式来。 <spanclass="math display">\[\begin{align}dp[3][6]=min(\ &amp;dp[2][\textcolor{red}2]+Cost[3][6],\tag{}\\ &amp;dp[2][\textcolor{red}3]+Cost[4][6],\tag{}\\&amp;dp[2][\textcolor{red}4]+Cost[5][6], \tag{}\\&amp;dp[2][\textcolor{red}5]+Cost[6][6]\ \ ) \tag{1}\end{align}\]</span></p><p>　　把公式（1）翻译成代码，那就是如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 公式1对应的代码如下：</span><br>dp[<span class="hljs-number">3</span>][<span class="hljs-number">6</span>]= INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=<span class="hljs-number">3</span><span class="hljs-number">-1</span>; c&lt;=<span class="hljs-number">6</span><span class="hljs-number">-1</span>; c++)  <span class="hljs-comment">// c表示公式（1）中的红色数字，代表了不同的分割策略</span><br>    dp[<span class="hljs-number">3</span>][<span class="hljs-number">6</span>]= <span class="hljs-built_in">min</span>( dp[<span class="hljs-number">3</span>][<span class="hljs-number">6</span>],  dp[<span class="hljs-number">3</span><span class="hljs-number">-1</span>][c] + Cost[c+<span class="hljs-number">1</span>][<span class="hljs-number">6</span>] );<br></code></pre></td></tr></table></figure><p>　　所以状态转移方程就是： <span class="math display">\[dp[p][k]=min(dp[p][k],\ dp[p-1][c]\ + \ Cost[c+1][k]\ ) \\(1 \leq p \leq P;\quad p \leq k \leq K;\quad p-1 \leq c\leq k-1)\]</span></p><ol start="4" type="1"><li><p>循环顺序和边界</p><p>p:dp[p][k]的求解，需要且只需要用到上一行的数据，所以p只能增序，[1..P]；</p><p>k:既然是只用到上一行的数据，所以k可以增序，也可以降序。在本题中，如果村庄数k少于学校数p，是不合理的，无解，所以只需要填写<spanclass="math inline">\(k \geqp\)</span>的情况。所以循环顺序和边界为[p..K]，或者[K..p];</p><p>c:策略c在dp的第二维，对于状态[p-1][c]来说，第二维的数字c不能小于第一维的数字p-1（否则该状态无解，不应参与比较，即使参与了也是白比），所以c的范围是[p-1,k-1]。增序降序均可。先比哪个策略，后比哪个策略，这个顺序并不重要，最终都要比完所有的策略。</p></li><li><p>初始化和特例</p></li></ol><p>　　因为状态可能存在无解，所以dp数组初始化为无解，在本题中对应的就是INF。</p><p>　　根据1.2节第5点的分析，dp[0][0]=0。而对于dp[0][1..K]，在k个村庄中设置0个学校，把k个数据划分为0段，描述不合理，无解。</p><h4 id="推导cost数组">2.2.2.2 推导Cost数组</h4><p>　　Cost数组是状态转移方程中非常重要的一个数据结构。Cost[le][ri]来表示从第le个村庄到第ri个村庄这一个区间中选1个点作为学校后，该区间内其他点到该学校点的距离之和的最小值。该如何找规律来计算呢？老规矩，草稿纸上画样例，先看看样例具有什么样的规律。下面以6个村庄中找1个学校为例来分析。</p><p>1）以1号点为学校，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724114648838.png" alt="image-20240724114648838" style="zoom:50%;" /></p><p>2）以2号点为学校，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724114610444.png" alt="image-20240724114610444" style="zoom:50%;" /></p><p>3）以3号点为学校，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724113906535.png" alt="image-20240724113906535" style="zoom:50%;" /></p><p>4）以4号点为学校，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724114049227.png" alt="image-20240724114049227" style="zoom:50%;" /></p><p>5）以5号点为学校，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724114250586.png" alt="image-20240724114250586" style="zoom:50%;" /></p><p>6）以6号点为学校，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724114501124.png" alt="image-20240724114501124" style="zoom:50%;" /></p><p>　　把上面6种方案的距离值进行对比，可以发现，不管红黄绿蓝紫的路径值为多少，必然会有：</p><p>　　5红4黄3绿2蓝1紫(以1号为学校) &gt;= 1红4黄3绿2蓝1紫(以2号为学校)&gt;= <strong>1红2黄3绿2蓝1紫(以3号为学校)==1红2黄3绿2蓝1紫(以4号为学校)</strong> &lt;= 1红2黄3绿4蓝1紫(以5号为学校)&lt;= 1红2黄3绿4蓝5紫(以6号为学校)</p><p>　　也就是说，在这串村庄组成的线性结构中，<strong>取区间中点位置的点作为村庄，总距离之和是最小的，不管各个点之间的线性距离是多少。</strong>当这些点为奇数个时，直接取中点作为学校；当这些点为偶数个时，取中间两个点都能得到最小值。</p><p>　　搞清楚了这一点，我们就能确定任意一个指定区间[le,ri]中学校的位置为(le+ri)/2。</p><p>　　下一步要做什么呢？下一步就是计算该区间内所有点到该学校点的距离之和了。这里有一个小问题需要解决，在确定好学校点之后，如何以最快捷方便的办法计算出该区间内所有点到学校点的距离之和呢？题目上只告知了每相邻2个点之间的距离值。其实方法很简单，因为所有点都正好在一个线形上，任意两点之间的距离值，就变成了两点之间所有相邻点距离值之和，这实际上是个“区间和”的问题，所以用前缀和数组就能搞定了。</p><p>　　相关的局部代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=K; i++)  <span class="hljs-comment">// 村庄从1开始编号，sum[1]=0 </span><br>   cin &gt;&gt;sum[i], sum[i]+= sum[i<span class="hljs-number">-1</span>];<br><span class="hljs-comment">// cost[i][j]：第i~j个村庄之间建立1所小学，这几个村庄到这个小学的最小距离之和。 </span><br>   <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> le=<span class="hljs-number">1</span>; le&lt;=K; le++)<br>   <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> ri=le; ri&lt;=K; ri++)&#123;<br>       <span class="hljs-type">int</span> mid = (le+ri) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// 把这所小学定在第mid个村庄，使得第i~j个村庄到这个小学距离之和最小  </span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=le; k&lt;=ri; k++)<br>       cost[le][ri] += <span class="hljs-built_in">abs</span>(sum[mid] - sum[k]); <span class="hljs-comment">// 算出这个距离之和，然后填表cost </span><br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="ac代码-1">2.2.3 AC代码</h3><p>　　在不考虑平行四边形优化的前提下，本题的朴素代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//dp，标准状态数组，无优化</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 法1： 朴素做法，标准状态数组dp[][]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1001</span><br><span class="hljs-type">int</span> K, P;<br><span class="hljs-type">int</span> sum[N];     <span class="hljs-comment">// 距离的前缀和数组， </span><br><span class="hljs-type">int</span> cost[N][N]; <span class="hljs-comment">// cost[10][20]=400表示从第[10..20]个小学内设置一个学校后，这11个村庄到这所小学的最短距离之和 </span><br><span class="hljs-type">int</span> dp[N][N];   <span class="hljs-comment">//前 k个村庄放 p 个小学时的“村校最小距离和”（即: 所有小学到附近村庄的最小距离之和）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i, j, p, k, le, rt;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); <br><span class="hljs-comment">// K村庄数     P小学数 </span><br>    cin &gt;&gt;K &gt;&gt;P;<br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">2</span>; i&lt;=K; i++)  <span class="hljs-comment">// 村庄从1开始编号，sum[1]=0 </span><br>    cin &gt;&gt;sum[i], sum[i]+= sum[i<span class="hljs-number">-1</span>];<br>    <br>    <span class="hljs-comment">// 根据上面的数组(任意两村之间的距离)，填数组cost[][]的右上部分，对角线上全0 </span><br><span class="hljs-comment">// cost[i][j]：第i~j个村庄之间建立1所小学，这几个村庄到这个小学的最小距离之和。 </span><br>    <span class="hljs-keyword">for</span>( le=<span class="hljs-number">1</span>; le&lt;=K; le++)<br>    <span class="hljs-keyword">for</span>( rt=le; rt&lt;=K; rt++)&#123;<br>        <span class="hljs-type">int</span> mid = (le+rt) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// 把这所小学定在第mid个村庄，使得第i~j个村庄到这个小学距离之和最小  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=le; k&lt;=rt; k++)<br>        cost[le][rt] += <span class="hljs-built_in">abs</span>(sum[mid] - sum[k]); <span class="hljs-comment">// 算出这个距离之和，然后填表cost </span><br>   &#125;<br>    <br><span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp)); <br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <br>    <span class="hljs-keyword">for</span>( p=<span class="hljs-number">1</span>; p&lt;=P; p++)       <span class="hljs-comment">// p个小学   1&lt;=p&lt;=P</span><br>    <span class="hljs-keyword">for</span>( k=p; k&lt;=K; k++)   <span class="hljs-comment">// k个村庄 , p&lt;=k&lt;=K    </span><br><span class="hljs-comment">//    for( k=K; k&gt;=p; k--)   // 标准数组，k增序降序都可以  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=k<span class="hljs-number">-1</span>; c&gt;=p<span class="hljs-number">-1</span>; c--)  <span class="hljs-comment">// c个分隔点（策略），p-1&lt;= c &lt;=k-1, 增序降序都可以！ </span><br>            dp[p][k] = <span class="hljs-built_in">min</span>(dp[p][k],  dp[p<span class="hljs-number">-1</span>][c] + cost[c+<span class="hljs-number">1</span>][k]);<br><br>    cout &lt;&lt;dp[P][K]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 区间dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三种分组背包的处理</title>
      <link href="/2024/07/02/%E4%B8%89%E7%A7%8D%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E7%9A%84%E5%A4%84%E7%90%86/"/>
      <url>/2024/07/02/%E4%B8%89%E7%A7%8D%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E7%9A%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="分组背包的题型和分类">1.1 分组背包的题型和分类</h2><p>　　一个背包的总约束量为YS1，有n个物品，约束量分别为<spanclass="math inline">\(ys1[1]、ys1[2]、...、ys1[n]\)</span>,收益量分别为<spanclass="math inline">\(value[1]、value[2]、...、value[n]\)</span>,这n个物品被划分为了若干组，在选择物品时每个组遵循一个共同的<font color="red">规则要求</font>，求解在这种规则要求下选出来的物品的约束量之和不超过YS1的情况下，其物品组合的<strong>最大收益值</strong>。</p><p>　　上述的<font color="red">规则要求</font>，可分为以下三类，分别对应着三种类型的分组背包题型：</p><ol type="1"><li>每组物品选的物品个数<font color="red">&lt;=</font>1个：每组内的物品之间相互冲突，最多只能选一个，允许不选；</li><li>每组物品选的物品个数<font color="red">==</font>1个：每组内的物品之间相互冲突，只能选一个，不能多，也不能少；</li><li>每组物品选的物品个数<font color="red">&gt;=</font>1个：每组内的物品之间不冲突，至少选一个，可以多选，但不允许不选；</li></ol><p>　　需要指出的是，分组背包支持多维费用，求解时也并不一定是“&lt;=YS1”情况下的最大收益值，也支持其他情况，求解方式大同小异。同学们可以自己去思考拓展。</p><h2 id="题型1每组物品选的物品个数1个">1.2题型1：每组物品选的物品个数<font color="red">&lt;=</font>1个</h2><p>　　这种题型在普及组中出现得较多，是最基础的分组背包题型。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240716100733859.png"alt="image-20240716100733859" /><figcaption aria-hidden="true">image-20240716100733859</figcaption></figure><p>　　我们来分析一下上面的样例数据，看看怎么破解这种题型。YS1=10，6个物品，一共被分为了3组。我们需要针对每一组内的物品来做考虑，但是录入的时候，物品编号是全局的编号值，并非组内的序号，这会给我们遍历每一组内的所有物品带来不便。所以我们需要用idx[][]数组来转换一下全局编号和组内序号之间的关系。这个数组的填写过程可以在录入所有物品的同时就完成。idx[2][0]=2表示第2组一共有2个物品；idx[2][2]=4表示第2组的第2个物品的编号是4号。在这种结构下，我们可以使用如下的代码来遍历访问第g组所有物品的ys1[]值和value[]值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)&#123;<br>cout &lt;&lt; ys1[ idx[g][k] ] &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt;value[ idx[g][k] ] &lt;&lt;endl; <span class="hljs-comment">// 注意idx[g][k]返回的是i值，即物品的全局编号值i</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240716111815053.png" alt="image-20240716111815053" style="zoom:80%;" /></p><p>　　我们用dp[][]数组来表示物品组合的最大收益值，<strong>但因为有分组的约束，所以这里第一维不能是全局编号i了，而应该是组号g</strong>。第二维仍然是约束总量j。所以<strong>dp[g][j]表示“前g组中所选物品在不超过总约束量为j的前提下，物品组合的最大收益值”</strong>。根据这个定义，本题的所求目标就是dp[maxg][YS1]了（假设一共有maxg组物品）。</p><p>　　既然是分组背包，那我们就只能一组一组地来做选择，所以在填写dp[][]数组时，第一层循环应该是for(intg=1; g&lt;=maxg;g++)了。处理完一组的所有物品之后，再去处理下一组的所有物品。这里遇到一个问题：请问第二层循环应该是什么呢？是forj呢，或者是for组内物品k？其实两种方法都是可以的，但要小心在初始化或者if语句或者循环边界上的一些微小的差别。</p><h3 id="先for-组内物品k再for-j重点掌握">1.2.1 先for 组内物品k，再forj（重点掌握）</h3><p>　　第一层是forg，针对每一组进行循环，在所有题型中都一样，这里就不专门去写了，我们重点分析第二层和第三层。第二层循环是for组内物品k，即针对第g组的所有物品去做第三层循环的操作（只能是forj了，即遍历填写dp[g][0..YS1]），即如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（1），组内最多选1件，先for 组内物品k 再 for j，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br><span class="hljs-comment">// 开始循环填写</span><br>......<span class="hljs-comment">// k=1 针对该组的第1个物品，j的循环范围为[YS1..ys1[ idx[g][1]] ]</span><br>dp[g][<span class="hljs-number">50</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">50</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] );  <span class="hljs-comment">// j=50，如果50&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">51</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">51</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] );  <span class="hljs-comment">// j=51，如果51&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">52</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">52</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] );  <span class="hljs-comment">// j=52，如果52&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">53</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">53</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">53</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] );  <span class="hljs-comment">// j=53，如果53&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>...<br>......<span class="hljs-comment">// k=2 针对该组的第2个物品，j的循环范围为[YS1..ys1[ idx[g][2]] ]</span><br>dp[g][<span class="hljs-number">50</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">50</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] );  <span class="hljs-comment">// j=50，如果50&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">51</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">51</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] );  <span class="hljs-comment">// j=51，如果51&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">52</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">52</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] );  <span class="hljs-comment">// j=51，如果51&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">53</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">53</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">53</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] );  <span class="hljs-comment">// j=53，如果53&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>...<br>......<span class="hljs-comment">// k=3 针对该组的第3个物品，j的循环范围为[YS1..ys1[ idx[g][3]] ]</span><br>dp[g][<span class="hljs-number">50</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">50</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] );  <span class="hljs-comment">// j=50，如果50&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">51</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">51</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] );  <span class="hljs-comment">// j=51，如果51&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">52</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">52</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] );  <span class="hljs-comment">// j=52，如果52&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">53</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">53</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">53</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] );  <span class="hljs-comment">// j=53，如果53&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>...<br><br></code></pre></td></tr></table></figure><p>　　上面的代码（1）整合之后的等效代码（2）如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（2），等效于代码（1），组内最多选1件，先for 组内物品k 再 for j，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br><span class="hljs-comment">// 开始循环填写</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[idx[g][k]]] + value[idx[g][k]] );<br></code></pre></td></tr></table></figure><p>　　上面的代码（2）是针对“第g组为‘组内最多选择1件物品’”的情况。如果所有组的物品都是“组内最多选择1件物品”的话，则在代码（2）的外面套一个对所有组的循环即可，得到如下的代码（3）.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（3），所有组都只能组内最多选1件，先for 组内物品k 再 for j，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=maxg; g++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>    dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>    dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[idx[g][k]]] + value[idx[g][k]] );<br>&#125;<br></code></pre></td></tr></table></figure><p>　　如果对dp[][]采用滚动数组，看上去好像可以把代码（3）进一步演变为如下代码（4）所示，但实际上这个代码是错误的!</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（4），错误代码！错误代码！所有组都只能组内最多选1件，先for 组内物品k 再 for j，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=maxg; g++)<br>    <span class="hljs-comment">// 不需要再“照抄上一行数据”了，下面的写法已经隐含地包括了对“不选任何物品”这个选择的max比较了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 必须只能倒序！</span><br>    dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dp[j-ys1[idx[g][k]]] + value[idx[g][k]] );<br></code></pre></td></tr></table></figure><p>　　错误的原因就在于在代码（4）的第5、6行执行时，可能会把一些dp[]值进行更改为新值（选择了当前组的某个物品价值更大），这会使得对该组后续的其他物品进行选择考虑时，本应该做dp[g][j]=max( dp[g][j], dp[g-1][j-ys1[idx[g][k]]] + value[idx[g][k]]);，但因为dp[j]被改过，所以它表达的实际上已经是dp[g][j]的值，而不是dp[g-1][j]的值了，如果此时再去选，会造成该组同时选择2个或多个物品。举个例子：</p><p>　　假如第1组现在有2个物品，成本分别是2斤、3斤，收益对应分别为1元和3元。如果我们按照代码（4）来做的话，当第1个物品处理结束后，dp[0..YS1]值会是{0,0,1,1,1,1,1,1,...}。在这种情况下，去处理第二个物品时，dp[0..YS1]会是{0,0,1,3,3,4,4,4,4,....}。这是错误的。实际上dp[0..YS1]的正确答案应该是{0,0,1,3,3,3,3,....}。之所以出现这种情况，是因为代码（4）在处理第二个物品时，做了dp[5]=max(dp[5],dp[2]+3)=max(1,1+3)=4，而实际上应该是dp[5]=max(dp[5],dp[2]+3)=max(1,0+3)=3。这里的dp[2]错误地取成了1（表示已选了第1个物品），本应该是0。</p><p>　　找到问题之后，解决方法如下代码（５）所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（５），正确代码！所有组都只能组内最多选1件，先for 组内物品k 再 for j，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=maxg; g++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--) <br>        dptmp[j]=dp[j];     <span class="hljs-comment">// 用dptmp[0..YS1]来存dp[g-1][0..YS1] </span><br>    <span class="hljs-comment">// 不需要再“照抄上一行数据”了，下面的写法已经隐含地包括了对“不选任何物品”这个选择的max比较了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 必须只能倒序！</span><br>            <span class="hljs-comment">// dptmp[]表示的是dp[g-1][] !!</span><br>    dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dptmp[j-ys1[idx[g][k]]] + value[idx[g][k]] );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="先for-j再for-组内物品k">1.2.2 先for j，再for 组内物品k</h3><p>　　第二层循环是forj，即针对所有的总约束量j去做第三层循环的操作（只能是for组内物品k了，即遍历该组的每个物品），即如下代码（6）所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（6），所有组都只能组内最多选1件，先for j 再 for 组内物品k，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br>......<span class="hljs-comment">// j=50</span><br>dp[g][<span class="hljs-number">50</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] ); <span class="hljs-comment">// k=1，如果50&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">50</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] ); <span class="hljs-comment">// k=2，如果50&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">50</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] ); <span class="hljs-comment">// k=3，如果50&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>...<br>......<span class="hljs-comment">// j=51</span><br>dp[g][<span class="hljs-number">51</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] ); <span class="hljs-comment">// k=1，如果51&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">51</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] ); <span class="hljs-comment">// k=2，如果51&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">51</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] ); <span class="hljs-comment">// k=3，如果51&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>...<br>......<span class="hljs-comment">// j=52</span><br>dp[g][<span class="hljs-number">52</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] ); <span class="hljs-comment">// k=1，如果52&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">52</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] ); <span class="hljs-comment">// k=2，如果52&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">52</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] ); <span class="hljs-comment">// k=3，如果52&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>...<br></code></pre></td></tr></table></figure><p>　　仔细把代码（1）和上面的代码（6）进行比对，你会发现其实他们是等效的，只是语句的顺序不太一样而已。把上面的代码（6）整合，得到等效的代码（7）如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（7），等效于代码（6），所有组都只能组内最多选1件，先for j 再 for 组内物品k，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] )  <span class="hljs-comment">// 因为在第4行还没有k，无法写出j&gt;=ys1[ idx[g][k] ]，所以只能在这里写！</span><br>            dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br></code></pre></td></tr></table></figure><p>　　注意，代码（7）中的第2、3行代码，其实是可以整合到下面的循环中去的，得到等效的代码（8）如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（8），等效于代码（7），所有组都只能组内最多选1件，先for j 再 for 组内物品k，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>    dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];     <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] )  <span class="hljs-comment">// 因为在第4行还没有k，无法写出j&gt;=ys1[ idx[g][k] ]，所以只能在这里写！</span><br>            dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br>&#125;<br></code></pre></td></tr></table></figure><p>　　如果对dp[][]采用滚动数组，则可以把代码（8）进一步演变为如下代码（9）所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（9），等效于代码（8），所有组都只能组内最多选1件，先for j 再 for 组内物品k，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>    <span class="hljs-comment">// 不需要再“照抄上一行数据”了，下面的写法已经隐含地包括了对“不选任何物品”这个选择的max比较了</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] )  <span class="hljs-comment">// 因为在第2行还没有k，无法写出j&gt;=ys1[ idx[g][k] ]，所以只能在这里写！</span><br>            dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dp[j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br>&#125;<br></code></pre></td></tr></table></figure><p>　　上面的代码（9）是针对“第g组为‘组内最多选择1件物品’”的情况。如果所有组的物品都是“组内最多选择1件物品”的话，则在代码（9）的外面套一个对所有组的循环即可，得到如下的代码（10）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（10），所有组都只能组内最多选1件，先for j 再 for 组内物品k，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=maxg; g++)   <span class="hljs-comment">// 对每一组进行</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>            <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] ) <br>                dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dp[j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br>    &#125;<br></code></pre></td></tr></table></figure><p>　　我们现在可以来比较这两种方法，会发现各种版本的代码都各有千秋，不存在哪个版本绝对精简。希望同学们尽量都能推导，要懂得灵活处理，理解原理，没必要死记硬背，很容易背错。滚动数组看起来虽然方便，但理解困难，容易出错。标准数组理解起来方便一些，但涉及初值赋予，多占空间。鉴于分组背包的复杂性和易错，建议基础薄弱的同学们最好是首先考虑标准状态数组。</p><h2 id="题型2每组物品选的物品个数-1个">1.3题型2：每组物品选的物品个数<font color="red">= =</font>1个</h2><p>题型2和题型1的区别在于：每一组必须要选择一个物品。这种区别会带来一些变化如下：</p><ol type="1"><li><p>因为每一组要求必须要选择一个物品，在“总成本量&lt;=j”的这个限制条件下，有可能无法选择任何一个物品，即无解。例如假设第g组所有物品的成本量都超过了100，则dp[g][0..99]都肯定是无解的，无法选出，只能无解。</p></li><li><p>既然要求每组不能不选物品，那么就不能再用dp[g][j]=dp[g-1][j]了，因为这行代码表示“本组不选任何物品”。因为可能存在本组无解的情况，所以dp[g][j]的初值应该对应着“无解”。如果在计算的过程中发现有解，则应该替换覆盖原来的初值。</p></li></ol><p>　　对于“无解”的处理，在<a href="">《背包问题的初始化问题》</a>中的1.3节中专门讨论过各种题型对“无解”这个状态的理解。同学们可以回看一下。</p><p>　　<strong>分组背包模型中，对“无解”的处理，总结出来如下三点：</strong></p><p>　　1.<strong>首先应该看当前题型是否可能存在“无解”的状态（在分组背包中，只有"当前组必须要选1个或者至少选1个"的题型才存在“无解（如果选不出来就意味着无解）”的状态）。如果可能存在，那么</strong></p><p>　　　　1）<strong>如果dp表示最大值，则初始化时dp[1..gcnt][<font color="red">0</font>..YS1]=-INF；</strong></p><p>　　　　2）<strong>如果dp表示方案数，则初始化时dp[1..gcnt][<font color="red">1</font>..YS1]=0,dp[0][0]=1；</strong></p><p>　　　　3）<strong>如果dp表示最小值，则初始化时dp[1..gcnt][<font color="red">0</font>..YS1]=INF。</strong></p><p>　　2.<strong>不管当前题型是否存在无解的情况，dp[<font color="red">0</font>][0..YS1]都应该要设置为全0（若表示方案数，dp[0][0]=1,dp[0][1..YS1]=0）！因为在任何情况下，如果连组都没有（g==0，表示“尚未开始选择”），那肯定收益值是0，方案数是1（“什么都不做”）。从另外一个角度来看，如果第0行全是-INF或者INF的话，就没法更新dp数组下面的每行数据（因为每组题型的dp[g][]都依赖于dp[g-1][]）了。</strong></p><p>　　3.这里需要小心容易被同学们忽略的地方，那就是“对第0列的处理”。虽然第0行属于特例，需要单独处理，但是第0列并不是特例！当dp数组表示最大值或者最小值，并且在题型2或者题型3中时，dp[g][0]=0表示对第g组的选择是合理合法的，但如果dp[g][0]=无解，这表示对第g组的选择已经无法按规定要求正确进行。在这种情况下，去处理第g+1行的数据，一旦需要使用到dp[g][0]则必然会出现问题！从公式上来看，右侧的式子一旦是无解的状态，则由它来推导出左侧的状态值，这显然是不合理的！有部分同学把dp[1..gcnt][0]设置为了全0，似乎也能AC某些题，这纯粹是因为测试数据太弱的缘故，在考试时肯定会出问题。总结起来，记住一点，<strong>对dp数组的第0列不要做特殊处理。初始化第g行所有数据时，一定要把dp[g][0]的初始化包含在内</strong>。</p><p>　　在1.2节中的“先for 组内物品k，再for j”和“先for j，再for组内物品k”这两个不同的策略，同样适用于1.3节这种题型。同学们可以选择自己熟悉的策略来重点掌握（<strong>建议掌握“先for组内物品k，再for j”这种策略的做法，适用范围更广</strong>）。</p><h3 id="先for-组内物品k后for-j重点掌握">1.3.1 先for 组内物品k，后forj（重点掌握）</h3><p>1.标准状态数组下的做法</p><p>　　在代码（2）的基础之上演变得到如下的代码（11）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（11），组内必须选1件，先for 组内物品k 再 for j，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>dp[g][j]= -INF;    <span class="hljs-comment">// 默认针对每个j，当前组都暂时无解，值为-INF。当然，也可以用memset或者直接设置为全局数组以自动清0，这样就可以不用写这个for循环了</span><br><span class="hljs-comment">// 开始循环填写dp</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[idx[g][k]]] + value[idx[g][k]] );<br><span class="hljs-comment">// 填完整个dp数组之后，如果某个dp[g][j]的值仍然是-INF，说明这个状态是无解的。</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>滚动状态数组下的做法</li></ol><p>　　在代码（5）的基础之上演变得到如下的代码（12）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（12），组内必须选1件，先for 组内物品k 再 for j，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123; <br>    dptmp[j]=dp[j];   <span class="hljs-comment">// 用dptmp[0..YS1]来存dp[g-1][0..YS1]</span><br>    dp[j]= -INF;      <span class="hljs-comment">// dp[j]现在要去存放dp[g][j]了，以“无解”（收益值为-INF）来作为该状态([g][j])的初始值</span><br>&#125;<br><span class="hljs-comment">// 不再“照抄上一行数据”，每个dp[0..YS1]的初值设为了-INF，在第一次执行dp[j]=max(dp[j], ...)时，等效于执行了“dp[j]=max(-INF, ...)”，意味着本组的所有策略中没有包含“本组什么物品都不选”。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 必须只能倒序，表示每个物品不能多选！</span><br>         <span class="hljs-comment">// dptmp[]表示的是dp[g-1][] !!</span><br>    dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dptmp[j-ys1[idx[g][k]]] + value[idx[g][k]] );<br></code></pre></td></tr></table></figure><h3 id="先for-j后for-组内物品k">1.3.2 先for j，后for 组内物品k</h3><ol type="1"><li>标准状态数组下的做法</li></ol><p>　　在代码（8）的基础之上演变得到如下的代码（13）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（13），组内必须选1件，先for j 再 for 组内物品k，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>    dp[g][j]= -INF;     <span class="hljs-comment">// 以“无解”（收益值为-INF）来作为该状态的初始值。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] )  <span class="hljs-comment">// 因为在第2行还没有k，无法写出j&gt;=ys1[ idx[g][k] ]，所以只能在这里写！</span><br>            dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>滚动状态数组下的做法</li></ol><p>　　在代码（9）的基础之上演变得到如下的代码（14）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（14），组内必须选1件，先for j 再 for 组内物品k，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>    dp[j]=-INF;<span class="hljs-comment">// 以“无解”（收益值为-INF）来作为[g][j]状态的初始值。即使dp全数组在for g之前已全都置为了-INF，本行代码也必须要写！</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] )  <br>            dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dp[j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题型3每组物品选的物品个数-1个">1.4题型3：每组物品选的物品个数<font color="red">&gt; =</font>1个</h2><p>　　题型3仍然存在题型2中面临的“可能存在无解”的情况。所以，题型2中关于dp[g][0..YS1]初值的设定，对于题型3仍然适用。为了降低初学难度，我们还是以“<strong>在&lt;=YS1的前提下求最大收益值</strong>”为例，来讲解“每组物品选的物品个数&gt;=1个”这种要求的应对策略。</p><p>　　dp[g][j] 表示选前 g 组物品（每组至少选1个）并且限制量不超过j的最大收益值。所求目标为dp[gcnt][YS1]。有两种情况可以转到当前状态[g][j]：</p><ol type="1"><li>在“<strong>第g组还没选择任何物品</strong>”的前提下，第一次选择了第g组的编号为x的物品，则会有:</li></ol><p><span class="math display">\[dp[g][j]= max(\ dp[g][j], \quad dp[g-1][j-ys1[x] ] + value[x]\ );\tag{1}\]</span></p><ol start="2" type="1"><li>在“<strong>已经选择了第g组的某个或者某些物品</strong>”的前提下，现在选择编号为x的物品，则会有:<span class="math display">\[dp[g][j]= max(\ dp[g][j], \quad dp[g][j-ys1[x] ] + value[x]\ );\tag{2}\]</span>既然这两种情况都可能发生，那么最终策略就看哪种方案的值最大，就选哪种方案了。所以最终的状态转移方程是：<span class="math display">\[dp[g][j]= max(\ dp[g][j], \quad dp[g-1][j-ys1[x] ] + value[x]\ , \quaddp[g][j-ys1[x] ] + value[x]\ ); \tag{3}\]</span></li></ol><p>　　公式（3）在转成代码的时候，需要小心！对于编号为x的物品，情况1和情况2是不可能同时存在的。所以公式（3）中的<span class="math inline">\(dp[g-1][j-ys1[x] ] + value[x]\)</span> 和<span class="math inline">\(dp[g][j-ys1[x] ] +value[x]\)</span>这两个策略不可能都执行，在写代码的时候建议采用A=max(max(A,B),C)的方式来写。而且，第1次执行公式（1）时，公式右侧的dp[g][j]存放的应该是该状态的初值“无解”，即-INF。而后续执行该公式时，右侧的dp[g][j]纯粹只是为了实现“多个数据之间的<strong>累计比较</strong>”的效果而已。</p><h3 id="先for-组内物品k再for-j掌握">1.4.1 先for 组内物品k，再forj（掌握）</h3><p>　　下面我们看一个例子，用“先for 组内物品k，后forj”的思路来进一步来加深对公式（３）的理解。</p><p>　　1)处理第1组的1号物品</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723170245209.png"alt="image-20240723170245209" /><figcaption aria-hidden="true">image-20240723170245209</figcaption></figure><p>　　可以看到，第一次填写dp[g][j]时，等式右边的dp[g][j]为“无解”的状态，值为-INF，以方便max运算。</p><p>　　2）处理第1组的4号物品</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723170855857.png"alt="image-20240723170855857" /><figcaption aria-hidden="true">image-20240723170855857</figcaption></figure><p>　　3)处理第2组的2号物品</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723171222171.png"alt="image-20240723171222171" /><figcaption aria-hidden="true">image-20240723171222171</figcaption></figure><p>　　后续对剩余2个物品的处理与上雷同，就不再画图展示了。</p><p>　　需要注意的是，这里j的循环顺序一定是倒序，即从YS1到ys1[i]。这是因为对于每个物品来说，最多只能被选择一次，不能被连续选择2次。这和“一个组内允许选择多个物品”，是不相关的。如下图所示。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723172427927.png"alt="image-20240723172427927" /><figcaption aria-hidden="true">image-20240723172427927</figcaption></figure><p>　　题型3的代码模板如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g &lt;= gcnt; g++ )            <span class="hljs-comment">// 历所有组数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++ ) &#123;   <span class="hljs-comment">// 遍历每组的物品</span><br>        <span class="hljs-type">int</span> i=idx[g][k];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j&gt;=ys1[i]; j--) <span class="hljs-comment">// 此处必须只能倒序，因为有dp[g][...] </span><br><span class="hljs-comment">//      for(int j = ys1[i]; j&lt;=YS1; j++) // 错误！ 每个物品只能被选1次！ 右侧公式里有dp[g][...] ！见帖子说明</span><br>            <span class="hljs-comment">//dp[g][j] = max ( dp[g][j] , max(dp[g-1][j-ys1[i]]+value[i] , dp[g][j-ys1[i]]+value[i]) ); // 和下一行等效，可AC</span><br>            dp[g][j] = <span class="hljs-built_in">max</span> ( <span class="hljs-built_in">max</span>(dp[g][j] , dp[g<span class="hljs-number">-1</span>][j-ys1[i]]+value[i] ), dp[g][j-ys1[i]]+value[i] );<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="先for-j再for-组内物品k-1">1.4.2 先for j，再for 组内物品k</h3><p>　　从公式（3）中可以看到一个我们需要注意的东西，那就是dp[g][j]的值，依赖于dp[g][j-...]的值。换句话说，当前格子的填写，依赖于同行左侧某个格子的填写。这是之前题型1和题型2所没有的情况（这两种题型都是依赖于上一行的值，已确定）。在这种情况下，就需要我们必须要从左往右填写每一排数据，否则左侧格子的值肯定是-INF或者0这种初始值，这样会导致dp[g][j-...]失去对max的参与，无法发挥作用（这一项的作用就是“在已选本组某物品的情况，再选择本组的其他物品”。一旦失效，意味着dp[g][j]无法存放多个物品的累加和）。但是，如果从左往右填写，会带来另外一个问题，那就是“同一个物品，被选择了2次或者无限次”（这是完全背包的典型特征）。</p><p>　　鉴于上面的情况，<strong>请同学们对本题型放弃“先for j，后for组内物品k”的做法</strong>。</p><h1 id="二实战练习">二、实战练习</h1><h2 id="每组最多选1个物品">2.1 1272（每组最多选1个物品）</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1272">1272：【例9.16】分组背包</a></p><h3 id="ac代码">2.1.2 AC代码</h3><p>1.先for j，再for 组内物品k，标准dp数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法2，每组最多选1个，先for j，再for 组内物品k，标准dp数组  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    参考帖子代码（8） </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxYS1 201</span><br><span class="hljs-type">int</span> dp[<span class="hljs-number">11</span>][maxYS1];    <span class="hljs-comment">// dp应该是物品组g和背包容量YS1的函数，所以定义为dp[g][YS1] </span><br><span class="hljs-type">int</span> YS1, n, gcnt;<br><span class="hljs-type">int</span> tot[maxYS1], ys1[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>], value[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>]; <span class="hljs-comment">// ys1[2][4]：第2组的第4个物品的ys1值，value同理 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 录入背包总重量YS1， 物品件数n个，种类gcnt种 </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;YS1, &amp;n, &amp;gcnt);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> W, C, g;         <span class="hljs-comment">//group组 </span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;W, &amp;C, &amp;g);  <span class="hljs-comment">// 重量W，价值C，组号g </span><br>        tot[g]++;                     <span class="hljs-comment">// 第g组的物品个数增加1个 </span><br>        ys1[g][tot[g]] = W;             <span class="hljs-comment">// 第g组的最新个的重量值为W </span><br>        value[g][tot[g]] = C;           <span class="hljs-comment">// 第g组的最新个的价值值为C </span><br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]= <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 每组最多选1个，所以按组来划分阶段。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g = <span class="hljs-number">1</span>; g &lt;= gcnt; g++) <br><span class="hljs-comment">//      for(int j = YS1; j &gt;= 0; j--)   // 标准dp数组，正序逆序都可以 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= YS1; j++)&#123; <br>dp[g][j] = dp[g<span class="hljs-number">-1</span>][j];       <span class="hljs-comment">// 允许本组一个都不选，所以先假定一个都没选  </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= tot[g]; k++) <br>                <span class="hljs-keyword">if</span> ( j &gt;= ys1[g][k] )<br>                    dp[g][j] = <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j - ys1[g][k]] + value[g][k] );<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[gcnt][YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>先for j，再for 组内物品k，滚动dp数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"> <span class="hljs-comment">//// 方法1；每组最多选1个，先for j，再for 组内物品k，滚动dp数组 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    参考帖子代码（10） </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxYS1 201</span><br><span class="hljs-type">int</span> dp[maxYS1];<br><span class="hljs-type">int</span> YS1, n, gcnt;<br><span class="hljs-type">int</span> tot[maxYS1], ys1[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>], value[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <br><span class="hljs-comment">// 录入背包总重量YS1， 物品件数n个，种类gcnt种 </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;YS1, &amp;n, &amp;gcnt);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123; <br>        <span class="hljs-type">int</span> W, C, g;       <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;W, &amp;C, &amp;g);  <span class="hljs-comment">// 重量W，价值C，组号g </span><br>        tot[g]++;                     <span class="hljs-comment">// 第g组的物品个数增加1个 </span><br>        ys1[g][tot[g]] = W;             <span class="hljs-comment">// 第g组的最新个的重量值为W </span><br>        value[g][tot[g]] = C;           <span class="hljs-comment">// 第g组的最新个的价值值为C </span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 每一组物品 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g = <span class="hljs-number">1</span>; g &lt;= gcnt; g++)<br>      <span class="hljs-comment">// dp[g][j]需要用到dp[g-1][...]，且每个物品最多只被选1次，所以若用滚动数组的话，这里必须倒序  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= <span class="hljs-number">0</span>; j--)  <span class="hljs-comment">// 这里没法写j&gt;=ys1[k]了；k在内层。 </span><br><span class="hljs-comment">// 第g组的第k个不同的物品 </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= tot[g]; k++) <br>                <span class="hljs-keyword">if</span> ( j &gt;= ys1[g][k] )<br>                    dp[j] = <span class="hljs-built_in">max</span>( dp[j],  dp[j - ys1[g][k]] + value[g][k] );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>先for 组内物品k，再for j，标准dp数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法3，每组最多选1个，先for 组内物品k，再for j，标准dp数组</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    参考帖子代码（3）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxYS1 201</span><br><span class="hljs-type">int</span> dp[<span class="hljs-number">11</span>][maxYS1];    <span class="hljs-comment">// dp应该是物品组g和背包容量YS1的函数，所以定义为dp[g][YS1]</span><br><span class="hljs-type">int</span> YS1, n, gcnt;<br><span class="hljs-type">int</span> tot[maxYS1], ys1[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>], value[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>]; <span class="hljs-comment">// ys1[2][4]：第2组的第4个物品的ys1值，value同理</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 录入背包总重量YS1， 物品件数n个，种类gcnt种</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;YS1, &amp;n, &amp;gcnt);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> W, C, g;         <span class="hljs-comment">//group组</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;W, &amp;C, &amp;g);  <span class="hljs-comment">// 重量W，价值C，组号g</span><br>        tot[g]++;                     <span class="hljs-comment">// 第g组的物品个数增加1个</span><br>        ys1[g][tot[g]] = W;             <span class="hljs-comment">// 第g组的最新个的重量值为W</span><br>        value[g][tot[g]] = C;           <span class="hljs-comment">// 第g组的最新个的价值值为C</span><br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 每组最多选1个，所以按组来划分阶段。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>            dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=tot[g]; k++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[g][k]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>                dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[g][k]] + value[g][k] );<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4d&quot;</span>, dp[g][j]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <br>    <br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[gcnt][YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>先for 组内物品k，再for j，滚动dp数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法4；每组最多选1个，先for 组内物品k，再for j，滚动dp数组</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    参考帖子代码（5）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxYS1 201</span><br><span class="hljs-type">int</span> dp[maxYS1], dptmp[maxYS1];<br><span class="hljs-type">int</span> YS1, n, gcnt;<br><span class="hljs-type">int</span> tot[maxYS1], ys1[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>], value[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 录入背包总重量YS1， 物品件数n个，种类k种</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;YS1, &amp;n, &amp;gcnt);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> W, C, g;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;W, &amp;C, &amp;g);  <span class="hljs-comment">// 重量W，价值C，组号g</span><br>        tot[g]++;                     <span class="hljs-comment">// 第g组的物品个数增加1个</span><br>        ys1[g][tot[g]] = W;             <span class="hljs-comment">// 第g组的最新个的重量值为W</span><br>        value[g][tot[g]] = C;           <span class="hljs-comment">// 第g组的最新个的价值值为C</span><br>    &#125;<br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++) &#123;<br>        <span class="hljs-comment">// 用dptmp[0..YS1]来存dp[g-1][0..YS1] </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>            dptmp[j]= dp[j];<br>        <span class="hljs-comment">// 不需要再“照抄上一行数据”了，下面的写法已经隐含地包括了对“不选任何物品”这个选择的max比较了</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=tot[g]; k++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[g][k]; j--)  <span class="hljs-comment">// 必须只能倒序！</span><br>                <span class="hljs-comment">// dptmp[]表示的是dp[g-1][] </span><br>                dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dptmp[j-ys1[g][k]] + value[g][k] );<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　<a href="https://www.luogu.com.cn/problem/P1757">P1757通天之分组背包</a>和本题几乎完全一样，只是录入稍有差异。可作为复习巩固之用。</p><h2 id="p5322每组最多选1个物品">2.2 P5322（每组最多选1个物品）</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P5322">P5322 [BJOI2019]排兵布阵</a></p><p>　　简明题意如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++">   简明题意<br>       你有m个士兵，可以把它们随意分配到 n 个城堡里，在每个城堡中，你需要挑战城堡内的所有<br>   对手，如果在第 i 个城堡的一次挑战中你的士兵个数 &gt; 对手士兵个数 * <span class="hljs-number">2</span>，该场你就获得了i 分；<br>如果挑战失败，该场你获得<span class="hljs-number">0</span>分。已知对手们在每个城堡的士兵人数，求你能获得的总得分的最大值。<br>样例分析：<br>输入： <br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">10</span>  （除我之外还有<span class="hljs-number">2</span>个玩家，<span class="hljs-number">3</span>个城堡，我有<span class="hljs-number">10</span>个士兵） <br><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span>   （第<span class="hljs-number">1</span>个玩家对三个城堡的出兵数量分别为 <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span>） <br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>   （第<span class="hljs-number">1</span>个玩家对三个城堡的出兵数量分别为 <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>）<br>输出：<br><span class="hljs-number">8</span>分<br>解释：我的对三个城堡的出兵数量分别为 <span class="hljs-number">1</span>人   <span class="hljs-number">5</span>人   <span class="hljs-number">1</span>人 <br>这样的话，和第一个玩家PK，赢第<span class="hljs-number">2</span>个城堡得<span class="hljs-number">2</span>分 <br>  和第二个玩家PK，赢第<span class="hljs-number">1</span>个城堡得<span class="hljs-number">1</span>分、赢第<span class="hljs-number">2</span>个城堡得<span class="hljs-number">2</span>分、 赢第<span class="hljs-number">3</span>个城堡得<span class="hljs-number">3</span>分<br>所以一共得<span class="hljs-number">2</span>+<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3</span>=<span class="hljs-number">8</span>分<br>这是得最高分的策略了 <br></code></pre></td></tr></table></figure><h3 id="分析">2.2.2 分析</h3><p>　　首先我们需要搞清楚一个事情，这个题为什么是分组背包而不是贪心？我们可以来看看如下的反例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">  如果要尽量贪心，那么就应该尽可能获得编号值较大的城堡内的挑战胜利，在该城堡内也尽可能获得较多的胜利场次；<br>  反例（1）输入： <br>2 5 21  （除我之外还有2个对手玩家，3个城堡，我有21个士兵） <br>1 1 1 1 10   （第1个对手对三个城堡的出兵数量分别为 1 1 1 1 10） <br>0 0 0 0 0    （第2个对手对三个城堡的出兵数量分别为 0 0 0 0 0）<br>  错误的贪心策略：在编号最大的第5个城堡安排2×10+1=21个士兵（用光），获得2场胜利，得到2×5=10分；<br>  正确的策略：在1～4号城堡分别安排3个士兵，共12个士兵，获得1～4号城堡的8场胜利，共得2+4+6+8=20分；还剩9个士兵安排在5号城堡，获得一场胜利，得5分。所有共计25分。<br><br>  从这个例子可以看出，虽然想尽可能获得编号值较大的城堡里的挑战胜利，但是否真能如愿，完全取决于该城堡里的各玩家的士兵人数情况。而士兵人数情况是存在很大的不确定性的。有可能很轻松就拿下该城堡内所有场次的胜利，也有可能非常困难，得不偿失。在这种情况下，如果一味地想着去贪这种胜利，绝对是错误的策略。<br><br>  既然如此，那是不是在本题中就完全用不上一点点贪心呢？那也不是。<br>  当你已经在某个城堡里打败了所有的对手，那就没有必要再往这个城堡里安排更多的士兵了，而应该把剩余的士兵安排去征服其他的城堡。<br></code></pre></td></tr></table></figure><p>　　根据上面所述的贪心规则，我们完全可以针对每个城堡内敌方的士兵情况，计算出要获得每场胜利所需的最少士兵人数，作为我们的决策。例如在反例（1）中，我们如果想在第1个城堡打败对手2，只需要派1人入驻即可；但如果我们需要打败对手1，则需要派遣3个士兵入驻（这3个士兵同时也能打败对手2）。</p><p>　　对于城堡1，摆在我们面前的结果其实就3种：躺平放弃；打败对手2；打败对手1和对手2。<strong>这三种策略分别对应着“不派遣士兵；派遣1个士兵；派遣3个士兵”这3种策略，带来的收益则分别是“在城堡1内2场挑战两场全输共得0分；在城堡1内2场挑战一胜一负共得1分；在城堡1内2场挑战两场全胜共得2分；”</strong>分析到这里，可能有些同学已经领悟过来了，这不就是分组背包中的题型1（每组最多选1个）吗？</p><p>　　假设第i个城堡有 5个对手，分别在该城堡里入驻了ys1[1..5]={10,20,5,3,5}个士兵，那么除了“不派遣”这个策略之外，我们面临的其他派遣策略就是{21,41,11,7,11}这一共5个策略。如果我们现在选择“战胜第k=1个对手，即派遣21个士兵”这个策略，那么在第i个城堡里可以赢几场呢？这需要我们拿着21去和{21,41,11,7,11}数组中的每个数去比较，累计而得。这挺麻烦的。一个简单的优化就是：我们可以事先对ys1[]进行递增排序，得到ys1[1..5]={3,5,5,10,20}。在这种情况下，如果我们选择“战胜对手1（派遣7人）”，则可以胜1场，获得1×i=i分；如果我们选择“战胜对手4（派遣21人）”，则可以胜4场（战胜对手1、2、3、4），获得4×i=4i分；如果我们选择“战胜对手k（派遣2*ys1[k]+1人）”，则可以胜k场，获得k×i分。经过排序之后，我们可以很方便地获得一个组内的“获胜场次”值k，从而优化代码。</p><p>　　可能有些同学已经看到了ys1[1..5]={3,5,5,10,20}中有两个5。当我们选择第1个5时，k=2，我们认为我们战胜了对手1和对手2，但实际上我们也战胜了对手3。那获胜场次这样计算是否有误呢？仔细思考，其实不影响答案。因为在dp[g][j]=max(dp[g][j],dp[g][j-(2*5+1)]+1*g, dp[g][j-(2*5+1)]+2*g,...)的运算中，dp[g][j-(2*5+1)]+1*g &lt;dp[g][j-(2*5+1)]+2*g，所以dp[g][j-(2*5+1)]+1*g是不会对dp[g][j]的运算结果产生任何影响的。</p><h3 id="ac代码-1">2.2.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-comment">//#define MAX(A,B) ((A)&gt;(B)?(A):(B))       // 自己打MAX比调用max的确要快一丁点 </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">设 dp[j]表示玩家(在第g个城堡)放j个士兵可以获得的最大分数。a[g][k]表示在第g个</span><br><span class="hljs-comment">    城堡时s个玩家中出兵数量第k大的玩家的出兵数量（这样设计有利于算出得分。一共有gcnt个城堡，</span><br><span class="hljs-comment">    相当于就是gcnt个分组。对于每一个城堡，s个玩家有s个出兵</span><br><span class="hljs-comment">数。在和这s个玩家中的任一个进行两两对决时，我只需要出对方数量的两倍多1即可，也</span><br><span class="hljs-comment">就是说，我面对这个玩家，我的策略是a[g][k] * 2 + 1。一共有s个玩家，也就是说，我有</span><br><span class="hljs-comment">s个策略数量可供我选择。这就是我在这一个城堡（分组）内可供选择的策略的成本。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">与之对应，这些策略的收益是得分。战胜当前玩家，我能获得第g个城堡的g分；同时，</span><br><span class="hljs-comment">因为还有k-1个玩家的出兵数少于当前玩家（因为当前玩家的出兵数是第k小），所以我的</span><br><span class="hljs-comment">这个出兵数还能超过这k-1个玩家出兵数的2倍，故我这个策略能使我在第g个城堡的对抗中</span><br><span class="hljs-comment">面对其他玩家，再得(k-1)*g分，所以我这个策略实际有k*g分的收益。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">归纳地说，gcnt个分组，每组内s个决策，每个决策的成本是a[g][k]*2+1人，收益是k*g分 </span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">dp转移方程即为： </span><br><span class="hljs-comment">dp[j] = max( dp[j - a[g][k]*2 - 1] + k * g,   dp[j]);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> s , gcnt, YS1, ans;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">20002</span>];     <span class="hljs-comment">// 滚动dp[]，玩家(在第i个城堡)放j个士兵可以获得的最大分数</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>];   <span class="hljs-comment">// 第i个城堡时s个玩家中出兵数量第k大的玩家的出兵数量</span><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;s, &amp;gcnt, &amp;YS1);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=s; ++k)         <span class="hljs-comment">// s个玩家 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; ++g)  <span class="hljs-comment">// gcnt个城堡 </span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[g][k]);  <span class="hljs-comment">// 反过来存储，以便于等会对每个城堡，按照玩家来进行增序排序 </span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; ++g)<br><span class="hljs-built_in">sort</span>(a[g]+<span class="hljs-number">1</span>, a[g]+<span class="hljs-number">1</span>+s);     <span class="hljs-comment">// 对每个城堡，让s个玩家的出兵数做递增排序，以便于后续统计得分 </span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; ++g)      <span class="hljs-comment">// 枚举分组：gcnt个城堡，就相当于是gcnt个分组 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; --j) <span class="hljs-comment">// 枚举背包容量：倒序枚举派出的兵数 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=s; ++k) <span class="hljs-comment">// 枚举组内策略：对每个城堡，我可以选择s个玩家出兵数的2倍以上，即对这个分组我有s个策略可以选择 </span><br><span class="hljs-keyword">if</span>( j &gt; a[g][k]*<span class="hljs-number">2</span> ) <span class="hljs-comment">// </span><br><span class="hljs-comment">// 每个决策的成本是a[g][k]*2+1，收益是k*g，详情解释见上面的说明 </span><br>dp[j] = <span class="hljs-built_in">max</span>(dp[j-a[g][k]*<span class="hljs-number">2</span><span class="hljs-number">-1</span>]+k*g, dp[j]);<br><span class="hljs-comment">//for(int g=1;g&lt;=gcnt;g++)</span><br><span class="hljs-comment">//for(int j=YS1;j&gt;=0;j--)&#123;</span><br><span class="hljs-comment">//dp[g][j]=dp[g-1][j];//要在枚举 k 的循环外继承。</span><br><span class="hljs-comment">//for(int k=1;k&lt;=s;k++)</span><br><span class="hljs-comment">//if(j&gt;=a[g][k]*2+1)dp[i][j]=max(dp[i][j],dp[i-1][j-a[i][k]*2-1]+k*i);</span><br><span class="hljs-comment">//&#125;</span><br>    <span class="hljs-comment">// 给我的YS1个士兵，我可以不全部放完。反正求出最大值即可。就算放多了，也不会影响得分。 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=YS1; ++i) <br>ans=<span class="hljs-built_in">max</span>(ans, dp[i]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="p2409每组只能选1个物品不能多不能少">2.3P2409（每组只能选1个物品，不能多、不能少）</h2><h3 id="原题链接-2">2.3.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P2409">P2409Y的积木</a></p><h3 id="分析-1">2.3.2 分析</h3><p>　　这个题要求方案数，dp[g][j] = t表示前g个盒子各抽1个积木凑成==j斤积木的组合方案个数是4种。既然表示的是方案数，所以在转移方程中应该是“累加”，而不应该是“累比”。因为是“恰好等于j”，并且还要求每组必须要选，所以对状态[g][j]可能存在无解的情况，所以所有方案数的初始dp值建议设置为0，表示“暂时认为没有任何方案”，即“无解”。</p><p>　　特例情况是“前0个盒子中各抽1个积木，凑成恰好0斤重量，其组合的方案数为1种（dp[0][0]=1;），即'什么积木都不放'（因为是在0个盒子中选，所以不必遵守‘每个盒子都必须选1个’的规定了，因为连盒子都没有）。”</p><p>　　所求目标：一言难尽，看代码。</p><p>　　关于状态转移方程，因为本题的dp数组存放的是方案数，而不是最大值，所以状态转移方程中并没有max或者min，而是用‘+’。现在不能直接套用1.3节中的代码模板，那该怎么做呢？我们可以用一个实际样例来分析看看。有时候把数字具体化，推导起来会更方便，更容易看到一些关系。样例推导过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//    分组背包，每组必须要放1个物品，不能多，不能少</span><br><span class="hljs-comment">//    dp[3][6] = 4 表示前3个盒子各抽1个积木凑成6斤积木的组合方案个数是4种.</span><br><br>    对于第g组的处理：<br>    <span class="hljs-number">1.</span> 如果先<span class="hljs-keyword">for</span> j，再<span class="hljs-keyword">for</span> k（即针对每个状态[g][j]，去考虑它由哪些数值累加而成）<br>        假设第g组(盒)的物品(积木)的重量分别依次是 <span class="hljs-number">10</span>、 <span class="hljs-number">50</span>、 <span class="hljs-number">100</span>和 <span class="hljs-number">580</span>。那么：<br>        <span class="hljs-number">1</span>）对于[g][<span class="hljs-number">300</span>]    <br>            <span class="hljs-comment">// 重量为580的那个积木无法装入，不考虑它</span><br>            dp[g][<span class="hljs-number">300</span>] = dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">290</span>] +  dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">250</span>] + dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">200</span>] <span class="hljs-comment">// 如果不懂这行的由来，请看本站关于背包方案数的专帖后再回来学本帖。 </span><br>            上面的累加式子演变成代码的话，如下所示：<br>            dp[g][<span class="hljs-number">300</span>] = <span class="hljs-number">0</span>;              <span class="hljs-comment">// 初始化[g][300]为&quot;无解&quot;状态</span><br>            dp[g][<span class="hljs-number">300</span>] += dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">290</span>];  <span class="hljs-comment">// 开始累加, 300&gt;=290</span><br>            dp[g][<span class="hljs-number">300</span>] += dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">250</span>];  <span class="hljs-comment">//   300 &gt;=250</span><br>            dp[g][<span class="hljs-number">300</span>] += dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">200</span>];  <span class="hljs-comment">// 300&gt;=200 </span><br>            <span class="hljs-comment">// ......直到本组内所有j&gt;=ys1[]的积木都考虑完，则结束累加的循环</span><br><br>        <span class="hljs-number">2</span>）对于[g][<span class="hljs-number">5</span>]<br>            <span class="hljs-comment">//因为本组内的4个物品的ys1[]值都&gt;5，所以本组内的所有积木都不考虑装入</span><br>            dp[g][<span class="hljs-number">5</span>] = 空气 + 空气（哈哈）<br>            演变成代码就是    <br>            dp[g][<span class="hljs-number">5</span>] = <span class="hljs-number">0</span>;                <span class="hljs-comment">// 初始化[g][5]为&quot;无解&quot;状态 </span><br>            <span class="hljs-comment">// 累加循环一次都不做，直接略过</span><br><br>        对上面的<span class="hljs-number">1</span>）和<span class="hljs-number">2</span>）进行总结后，得到代码模板如下：<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--) <span class="hljs-comment">// YS1是通过计算而得</span><br>            dp[g][j]= <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化状态[g][j]的方案数为0（即“无解”），而不是来源于dp[g-1][j] ！！ </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=ys1[g][<span class="hljs-number">0</span>]; k++)   <span class="hljs-comment">//组内枚举每个物品，ys1[g][0]表示该组内物品的个数</span><br>                <span class="hljs-keyword">if</span> ( j &gt;= ys1[g][k] ) <span class="hljs-comment">//先判断能不能放</span><br>                    <span class="hljs-comment">// 和以往的背包问题中求最大值最小值不同，本题背包问题是求累加和！</span><br>                    <span class="hljs-comment">// 第一次累加时，dp[g][j]原值为0，表示所有方案数都来自于dp[g-1][ j-ys1[g][...] ] </span><br>                    dp[g][j] = dp[g][j] + dp[g<span class="hljs-number">-1</span>][ j-ys1[g][k] ];<br><br>    <span class="hljs-number">2.</span> 如果先<span class="hljs-keyword">for</span> k，再<span class="hljs-keyword">for</span> j（即针对组内的每<span class="hljs-number">1</span>个物品，去填写或者修正dp数组第g排的所有元素）<br>    对于第g组的第k个物品（假设重量为<span class="hljs-number">580</span>），它不可能装入容量为<span class="hljs-number">300</span>斤或者<span class="hljs-number">5</span>斤的背包中，只可能装入容量&gt;=<span class="hljs-number">580</span>的背包中。所以在填写或者修正dp[g][YS1.<span class="hljs-number">.1</span>]时，不需要<span class="hljs-keyword">for</span>\(<span class="hljs-type">int</span> j=YS1, j&gt;=<span class="hljs-number">1</span>; j--)，只需要<span class="hljs-keyword">for</span>\(<span class="hljs-type">int</span> j=YS1, j&gt;=ys1[idx[g][k]]; j--)即可。假设YS1=<span class="hljs-number">1000</span>， 对于本组内重量为<span class="hljs-number">580</span>的物品，只需要处理dp[g][<span class="hljs-number">1000.</span><span class="hljs-number">.580</span>]即可。而对于dp[g][<span class="hljs-number">1.</span><span class="hljs-number">.579</span>]的这些元素值，仍保留原来的数值即可（不管是为初值<span class="hljs-number">0</span>（无解）或者其他数值，这样处理都是合理的）<br>        代码模板如下：<br>        <span class="hljs-comment">///// 参考本帖代码（11），组内必须选1件，先for K 再 for j，标准dp数组，求方案数，初始化为“无解 ” </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>        dp[g][j]= <span class="hljs-number">0</span>;    <span class="hljs-comment">// 默认[g][j]状态暂时无解，方案数为0。当然，也可以用memset或者直接设置为全局数组以自动清0，这样就可以不用写这个for循环了</span><br>        <span class="hljs-comment">// 开始循环累加</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=ys1[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[g][k]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>        dp[g][j]=  dp[g][j] + dp[g<span class="hljs-number">-1</span>][ j-ys1[g][k] ];<br><br></code></pre></td></tr></table></figure><p>　　本题有个小坑点，那就是关于方案数爆int和longlong的问题。同学们一定要小心，一般来说，方案数都是一个很大的数字。所以一旦题目中涉及到要求方案数，一定要注意爆int或者爆longlong的问题。本题如果不特别处理，最后一个subtask会爆longlong。处理方法也很简单，就是不让dp[g][j]的值超过k。为什么可以这样做呢？因为本题要输出dp最后一排各个元素中非零元素的下标（若dp[g][j]==5，则要输出5个j值），如果某一个dp[g][j]的值&gt;k了，的确没必要再去保存精确数值了，对输出的结果无任何影响。</p><h3 id="ac代码-2">2.3.3 AC代码</h3><h4 id="先for-组内物品k后for-j">2.3.3.1 先for 组内物品k，后for j</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 方法1： 分组背包，每组必须要放1个物品，标准状态数组，先for 组内物品k 再forj，恰好等于，方案数 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// ys1[3][5]=12, 表示第3组的第5个积木的约束1属性值（重量）是12</span><br><span class="hljs-comment">// ys1[3][0]=13, 表示第3组内一共有13个物品，存储本组物品个数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxg=<span class="hljs-number">101</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxYS1=<span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> ys1[maxg][<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> dp[maxg][maxYS1]; <span class="hljs-comment">// dp[3][6] = 4 表示前3个盒子各抽1个积木凑成6斤积木的组合方案个数是4种. </span><br><span class="hljs-type">int</span> K, gcnt, YS1;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;gcnt, &amp;K);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++) &#123;<br>        <span class="hljs-comment">// 第i组的物品个数存于ys1[i][0]</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;ys1[g][<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> maxa = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=ys1[g][<span class="hljs-number">0</span>]; j++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;ys1[g][j]);<br>            maxa = <span class="hljs-built_in">max</span>(maxa, ys1[g][j]);<br>        &#125;<br>        <span class="hljs-comment">// 本题中的YS1没有直接被告知，找出每组内的最大值，加起来</span><br>        <span class="hljs-comment">// 每个盒子抽取1个积木，加起来的总重量肯定不会超过YS1=每组中积木的最大重量之和</span><br>        YS1 += maxa;<br>    &#125;<br>    <span class="hljs-comment">// 前0个盒子各抽1个积木凑成&lt;=0斤积木的组合方案个数是1种（=不抽）.</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++)&#123; <span class="hljs-comment">//控制组数</span><br>        <span class="hljs-comment">///// 参考本帖代码（11），组内必须选1件，先for K 再 for j，标准dp数组，求方案数，初始化为“无解 ” </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>        dp[g][j]= <span class="hljs-number">0</span>;    <span class="hljs-comment">// 默认[g][j]状态暂时无解，方案数为0。当然，也可以用memset或者直接设置为全局数组以自动清0，这样就可以不用写这个for循环了</span><br>        <span class="hljs-comment">// 开始循环填写dp</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=ys1[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[g][k]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>        dp[g][j]=  dp[g][j] + dp[g<span class="hljs-number">-1</span>][ j-ys1[g][k] ], dp[g][j] = <span class="hljs-built_in">min</span>(dp[g][j], K);<br>    &#125;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=YS1; i++)&#123;<br>        <span class="hljs-comment">// 打印dp[gcnt][i]个i（在没数到K个之前）</span><br>        <span class="hljs-keyword">while</span>( dp[gcnt][i])&#123;<br>            cout &lt;&lt;i &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            dp[gcnt][i]--;<br><br>            j++;<br>            <span class="hljs-keyword">if</span> (j==K) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法对应的滚动数组模式的代码，请参看本帖的代码（12），此处略过。</p><h4 id="先for-j-再for-组内物品k">2.3.3.2 先for j 再for 组内物品k</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 方法2： 分组背包，每组必须要放1个物品，标准状态数组，先for j 再for 组内物品k，恰好等于，方案数 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// ys1[3][5]=12, 表示第3组的第5个积木的约束1属性值（重量）是12</span><br><span class="hljs-comment">// ys1[3][0]=13, 表示第3组内一共有13个物品，存储本组物品个数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxg=<span class="hljs-number">101</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxYS1=<span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> ys1[maxg][<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> dp[maxg][maxYS1];  <span class="hljs-comment">// dp[3][6] = 4 表示前3个盒子各抽1个积木凑成6斤积木的组合方案个数是4种.</span><br><span class="hljs-type">int</span> k, gcnt, YS1;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;gcnt, &amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++) &#123;<br>        <span class="hljs-comment">// 第i组的物品个数存于ys1[i][0]</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;ys1[g][<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> maxa = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=ys1[g][<span class="hljs-number">0</span>]; j++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;ys1[g][j]);<br>            maxa = <span class="hljs-built_in">max</span>(maxa, ys1[g][j]);<br>        &#125;<br>        <span class="hljs-comment">// 本题中的YS1没有直接被告知，找出每组内的最大值，加起来</span><br>        <span class="hljs-comment">// 每个盒子抽取1个积木，加起来的总重量肯定不会超过YS1=每组中积木的最大重量之和</span><br>        YS1 += maxa;<br>    &#125;<br>    <span class="hljs-comment">// 前0个盒子各抽1个积木凑成&lt;=0斤积木的组合方案个数是1种（=不抽）.</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++)    <span class="hljs-comment">// 控制组数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--) <span class="hljs-comment">// YS1是通过计算而得</span><br>            dp[g][j]= <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化状态[g][j]的方案数为0（即“无解”），而不是来源于dp[g-1][j] ！！ </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=ys1[g][<span class="hljs-number">0</span>]; k++) <span class="hljs-comment">//组内枚举每个物品k</span><br>                <span class="hljs-keyword">if</span> ( ys1[g][k] &lt;= j )       <span class="hljs-comment">//先判断能不能放</span><br>                    <span class="hljs-comment">// 和以往的背包问题中求最大值最小值不同，本题背包问题是求累加和！</span><br>                    dp[g][j] = dp[g][j] + dp[g<span class="hljs-number">-1</span>][ j-ys1[g][k] ], dp[g][j] = <span class="hljs-built_in">min</span>(dp[g][j], k);;<br><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=YS1; i++)&#123;<br>        <span class="hljs-comment">// 打印dp[gcnt][i]个i（在没数到K个之前）</span><br>        <span class="hljs-keyword">while</span>( dp[gcnt][i])&#123;<br>            cout &lt;&lt;i &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            dp[gcnt][i]--;<br><br>            j++;<br>            <span class="hljs-keyword">if</span> (j==K) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法对应的滚动数组模式的代码，请参看本帖的代码（14），此处略过。</p><h2 id="hdu3033每组至少选择1个物品">2.4HDU3033（每组至少选择1个物品）</h2><h3 id="原题链接-3">2.4.1 原题链接</h3><p>　　<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3033">HDU3033I love sneakers!</a></p><p>题意：</p><p>　　一个人去买运动鞋，他手里拥有的钱为<spanclass="math inline">\(YS1(1 \leq YS1 \leq 10000)\)</span>，运动鞋有<span class="math inline">\(gcnt(1 \leq gcnt \leq10)\)</span>种品牌，每种品牌都可能有多双运动鞋，并且对于每种品牌，他都至少要买一双。</p><p>　　输入的数据包含多组测试样例，直到输入的数据文件结束为止。对于每组测试样例，依次输入<spanclass="math inline">\(n(1 \leq n\leq100)\)</span>双运动鞋，YS1值和gcnt值。后面跟着n行数据，每行数据依次为第<spanclass="math inline">\(\ i\ (1 \leq i \leqn)\)</span>双运动鞋所属的品牌号<span class="math inline">\(g[i](1 \leqg[i]\leq gcnt)\)</span>，价格<span class="math inline">\(ys1[i](0 \leqys1[i]\leq 10^5)\)</span>，价值<span class="math inline">\(value[i](0\leq value[i]\leq10^5)\)</span>。输出能获得的最大价值，如果本测试样例无解，输出"Impossible"。</p><h3 id="分析-2">2.4.2 分析</h3><p>　　1)根据“输入的数据包含多组测试样例，直到输入的数据文件结束为止”，可以得到，代码主框架肯定如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>( <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n, &amp;YS1, &amp;gcnt) != EOF ) &#123;<br>        ........<br>&#125;<br></code></pre></td></tr></table></figure><p>　　2)本题是“组内至少要选择1件物品+求最大收益值”的类型，可能存在无解。所以dp数组应初始化为“无解”，即dp[g][j]=-INF。对于本题来说，因为所有收益值都是正数，所以也可以初始化为0，不影响max函数的运行结果。若初始化为-INF，则需要小心第0行应该是全0。</p><p>　　3）关于“测试样例无解”，该怎么理解呢？如果给你10元钱，让你去买飞机坦克大炮，你能买得回来吗？肯定不行。换句话说，每组都有一个最廉价的物品，如果手里的钱不够买所有组内最廉价的物品，那就是无解了。所以我们可以找出每组内最低的价格，累加得到一个购买所有组物品的的最低价。如果给予的钱YS1少于这个最低价，则必然无法购买所有组的物品，即无解，输出“Impossible”。</p><p>　　4）本题要求支持多组样例。所以在每组样例录入前，一定要记得对各种数组进行复位或者重置。</p><h3 id="ac代码-3">2.4.3 AC代码</h3><p>根据分析，这种题型只能采用“先for 组内物品k，再for j”的思路来做。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 一共100双鞋子以内，1万元以内的成本，最多10个品牌 </span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">101</span>, maxYS1=<span class="hljs-number">10001</span>, maxg=<span class="hljs-number">11</span>;<br><span class="hljs-type">int</span> n, YS1, gcnt;<br><span class="hljs-type">int</span> ys1[maxn], value[maxn];<br><span class="hljs-type">int</span> minys1[maxg];  <span class="hljs-comment">// 每组内最小的物品约束量（每组内最便宜的鞋价） </span><br><span class="hljs-comment">// 分组背包专用的下标转换数组</span><br><span class="hljs-comment">// idx[3][5]=14 表示第3组第5个物品在所有物品列表中的下标是14 </span><br><span class="hljs-type">int</span> idx[maxg][maxn];<br><span class="hljs-comment">// dp[3][200]=480 表示前3组物品按照约束要求（每组至少必须买1个），</span><br><span class="hljs-comment">//       在200元约束范围内能获得的最大价值是480元 </span><br><span class="hljs-type">int</span> dp[maxg][maxYS1];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">while</span>( <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n, &amp;YS1, &amp;gcnt) != EOF ) &#123;<br><span class="hljs-comment">// 因为会有多组案例，所以一定要把历史数据清空干净！ </span><br><span class="hljs-built_in">memset</span>(minys1, INF, <span class="hljs-built_in">sizeof</span>(minys1));  <span class="hljs-comment">// 最小值数组要初始化为最大值 </span><br><span class="hljs-built_in">memset</span>(idx, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(idx));<br><span class="hljs-comment">// 如果嫌弃下面这两行有点罗嗦的话，也可以直接让整个dp数组全0，毕竟所有收益值都是整数，0值已经足够小 </span><br><span class="hljs-built_in">memset</span>(dp, -INF, <span class="hljs-built_in">sizeof</span>(dp));         <br><span class="hljs-built_in">memset</span>(dp[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp[<span class="hljs-number">0</span>]));     <span class="hljs-comment">// dp[0][0..YS1]必须要全0 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-comment">// 录入每双鞋所属的品牌编号，需耗成本和价值 </span><br><span class="hljs-type">int</span> g; <br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;g, &amp;ys1[i], &amp;value[i] );<br>++idx[g][<span class="hljs-number">0</span>];<br>idx[g][ idx[g][<span class="hljs-number">0</span>] ] = i;       <span class="hljs-comment">// 第g组第idx[g][0]个鞋子在所有物品中的下标序号是 i </span><br>minys1[g] = <span class="hljs-built_in">min</span> ( minys1[g], ys1[i]);  <span class="hljs-comment">// 记录第g组最小的需耗成本，这个数据不必初始化为最大 </span><br>&#125;<br><span class="hljs-comment">// x表示要每个品牌买一双鞋最起码一共需要多少钱 </span><br><span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=gcnt; i++) <br>x += minys1[i];<br><br><span class="hljs-comment">// 所带的钱不够每个品牌买1双</span><br><span class="hljs-keyword">if</span> ( YS1 &lt; x ) <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Impossible\n&quot;</span>);<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g &lt;= gcnt; g++ )            <span class="hljs-comment">// 历所有组数 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++ )&#123;    <span class="hljs-comment">// 遍历每组的物品 </span><br><span class="hljs-type">int</span> i=idx[g][k];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j&gt;=ys1[i]; j--) <span class="hljs-comment">// 倒序遍历约束量YS1 </span><br><span class="hljs-comment">//                  for(int j = ys1[i]; j&lt;=YS1; j++) // 错误！ 每个物品只能被选1次！ 右侧公式里有dp[g][...] ！见帖子说明 </span><br><span class="hljs-comment">//dp[g][j] = max ( dp[g][j] , max(dp[g-1][j-ys1[i]]+value[i] , dp[g][j-ys1[i]]+value[i]) ); // 和下一行等效，可AC </span><br>dp[g][j] = <span class="hljs-built_in">max</span> ( <span class="hljs-built_in">max</span>(dp[g][j] , dp[g<span class="hljs-number">-1</span>][j-ys1[i]]+value[i] ), dp[g][j-ys1[i]]+value[i] );<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dp[gcnt][YS1]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">// dp[3][200]=480 表示前3组物品在200元约束范围内能获得的最大价值是480元 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">(1)</span><br><span class="hljs-comment">5 15 3</span><br><span class="hljs-comment">1 4 5</span><br><span class="hljs-comment">2 5 10</span><br><span class="hljs-comment">3 4 100</span><br><span class="hljs-comment">1 5 70</span><br><span class="hljs-comment">2 7 50</span><br><span class="hljs-comment">ans:</span><br><span class="hljs-comment">180</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">(2)</span><br><span class="hljs-comment">3 5 3</span><br><span class="hljs-comment">1 2 5</span><br><span class="hljs-comment">2 2 1</span><br><span class="hljs-comment">3 2 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">3 5 3</span><br><span class="hljs-comment">1 0 5</span><br><span class="hljs-comment">2 0 1</span><br><span class="hljs-comment">3 0 2</span><br><span class="hljs-comment">ans:</span><br><span class="hljs-comment">Impossible</span><br><span class="hljs-comment">8</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">(3)</span><br><span class="hljs-comment">3 5 3</span><br><span class="hljs-comment">1 6 0</span><br><span class="hljs-comment">2 0 0</span><br><span class="hljs-comment">3 0 0</span><br><span class="hljs-comment">3 5 3</span><br><span class="hljs-comment">1 0 5</span><br><span class="hljs-comment">2 0 1</span><br><span class="hljs-comment">3 0 2</span><br><span class="hljs-comment">3 5 3</span><br><span class="hljs-comment">1 0 0</span><br><span class="hljs-comment">2 0 0</span><br><span class="hljs-comment">3 0 0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">ans：</span><br><span class="hljs-comment">Impossible</span><br><span class="hljs-comment">8</span><br><span class="hljs-comment">0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span> <br></code></pre></td></tr></table></figure><p>如果需要用滚动数组来做的话，则需要定义一个dptmp[]来存放上一组的结果。之前已经分析过，这里就不再赘述了。</p><h2 id="hdu3535混合分组背包的典型题">2.5HDU3535(混合分组背包的典型题)</h2><h3 id="原题链接-4">2.5.1 原题链接</h3><p>　　<a href="https://acm.hdu.edu.cn/showproblem.php?pid=3535">hdu3535AreYouBusy</a></p><p>　　题目中文意思和解读如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">问题描述<br>新学期快乐！<br>到了三年级之后，小A意识到她没有太多时间来解决问题，因为她还有其他事情要做，这使她几乎发疯了。<br>而且，老板告诉她，对于某些工作集合（是一个“分组”），她必须选择组内的至少一项工作；但是对于某些工作集合而言，她则最多只能选择组内的一项工作。这对老板来说毫无意义。对于其他的工作集合，她可以尽自己的意愿，不选或者选做其中的任意多项工作。我们只将她可以选择的东西定义为“工作”。每1个工作都需要时间，并给xiaoA带来一些幸福感（这意味着她总是愿意做这些工作）。因此，您可以选择其中的最佳组合来给她带来最大的幸福快乐点，同时也可以成为一个好的初中生。 （这意味着她应该听老板的建议）？<br><br>输入项<br>下面有几套测试用例，每套测试用例都以两个整数n和T（0 &lt;= n，T &lt;= 100）开头，有n组作业供您选择，由T分钟供她完成。然后后面是n个描述集，每个描述都以两个整数m和s（0 &lt;m &lt;= 100）开头，该集合中有m个作业，集合类型为s，（0代表应选择的集合至少要完成1项工作，对于最多应选择1项的集合要进行1项选择，可以自由选择的项要进行2项选择。），然后后面是m对整数ci，gi（0 &lt;= ci，gi &lt;= 100），表示第i个工作成本为ci分钟，可以通过完成它获得幸福感gi。每一项工作只能做一次。<br> 输出量<br>每个测试用例一行包含我们可以从所有工作中选择的最大幸福值。如果她不能完成老板想要的工作，则输出-1。<br> 样本输入<br>3 3     第1套用例内有3组作业，要求在3分钟内完成<br>2 1        第1组作业内有2个作业，分组类型为1（最多选择1个作业）<br>2 5           第1个作业成本2分钟，幸福值5<br>3 8           第2个作业成本3分钟，幸福值8<br>2 0        第2组作业内有2个作业，分组类型为0（至少要选择1个作业）<br>1 0           第1个作业成本1分钟，幸福值0<br>2 1           第2个作业成本2分钟，幸福值1<br>3 2        第3组作业内有3个作业，分组类型为2（随意选择）<br>4 3           第1个作业成本4分钟，幸福值3<br>2 1           第2个作业成本2分钟，幸福值1<br>1 1           第3个作业成本1分钟，幸福值1<br><br><br>3 4    第2套用例内有3组作业，要求在4分钟内完成<br>2 1        第1组作业内有2个作业，分组类型为1（最多选择1个作业）<br>2 5           第1个作业成本2分钟，幸福值5<br>3 7           第2个作业成本3分钟，幸福值7<br>2 0        第2组作业内有2个作业，分组类型为0（至少要选择1个作业）<br>1 1           第1个作业成本1分钟，幸福值1<br>2 8           第2个作业成本2分钟，幸福值8<br>3 2        第3组作业内有3个作业，分组类型为2（随意选择）<br>4 4           第1个作业成本4分钟，幸福值4<br>2 1           第2个作业成本2分钟，幸福值1<br>1 1           第3个作业成本1分钟，幸福值1<br><br><br>1 1   第3套用例内有1组作业，要求在1分钟内完成<br>1 0       第1组作业内有1个作业，分组类型为0（至少要选择1个作业）<br>2 1          第1个作业成本2分钟，幸福值1<br><br><br>5 3   第4套用例内有5组作业，要求在3分钟内完成 <br>2 0       第1组作业内有2个作业，分组类型为0（至少要选择1个作业）<br>1 0           第1个作业成本1分钟，幸福值0<br>2 1           第2个作业成本2分钟，幸福值1<br>2 0       第2组作业内有2个作业，分组类型为0（至少要选择1个作业）<br>2 2           第1个作业成本2分钟，幸福值2<br>1 1           第2个作业成本1分钟，幸福值1<br>2 0       第3组作业内有2个作业，分组类型为0（至少要选择1个作业）<br>3 2           第1个作业成本3分钟，幸福值2<br>2 1           第2个作业成本2分钟，幸福值1<br>2 1       第4组作业内有2个作业，分组类型为1（最多选择1个作业）<br>1 5           第1个作业成本1分钟，幸福值5<br>2 8           第2个作业成本2分钟，幸福值8<br>3 2       第5组作业内有3个作业，分组类型为2（任意选择作业）<br>3 8           第1个作业成本3分钟，幸福值8<br>4 9           第2个作业成本4分钟，幸福值9<br>5 10          第3个作业成本5分钟，幸福值10<br><br>样本输出<br><br>5<br>13<br>-1<br>-1<br></code></pre></td></tr></table></figure><h3 id="分析-3">2.5.2 分析</h3><p>　　这是一个分组背包的题，而且每一组的选择策略还不相同，属于混合分组背包，所以不能统一地对整个dp数组去做初始化，而应该根据当前组的选择策略来分别对当前行赋予不同的初始值。当然，第0行是肯定要清零的，而且，因为是多组测试数据，所以需要反复清零。</p><p>　　本题中有一种分组策略为“可以选择0个或者任意多个”。这种题型在第一章中没有讲到。其实做起来也很简单。它实际上是题型1和题型3的结合。因为允许本组选0个物品，所以本组不会存在‘无解’的情况。既然如此，初始化时直接沿用上一行数据，表示本组暂选0个。dp[g][0..YS1]=dp[g-1][0..YS1]。然后再采用题型3的策略，2个max组合起来即可。</p><p>　　本题中允许ys1[i]和value[i]的值为0。只要在填写dp时采用2个max组合起来填，就没问题。</p><p>　　如果把第0列初始化为0，会造成网页中第4个测试样例错误。本题容易出错的地方就是每一行的初始化问题。小心做好，不要“想当然”。</p><h3 id="ac代码-4">2.5.3 AC代码</h3><p>题目中有些分组要求至少要选择一个物品，为简单和统一，建议全都采用“先for组内物品k，再for j”的代码框架。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-type">int</span> gcnt, n, YS1, type;<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">101</span>],value[<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> g, j, i;<br>    <span class="hljs-keyword">while</span>( ~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;gcnt, &amp;YS1) ) &#123;  <span class="hljs-comment">// 多组数据</span><br><span class="hljs-built_in">memset</span>(dp[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp[<span class="hljs-number">0</span>]));  <span class="hljs-comment">// 做每组数据之前重置第0行为全0。中间的正常格子需要根据分组的类型来决定其初值</span><br><br>        <span class="hljs-keyword">for</span>(g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;type);<br>            <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;ys1[i], &amp;value[i]);<br>            <span class="hljs-keyword">if</span>(type == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 组内要至少选择一项工作</span><br>                <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)  <span class="hljs-comment">// 本组要求必须要选，所以可能存在无解，故初始化为无解对应的值-INF，如果选不出来则造成“无解”</span><br>                    dp[g][j] = -INF;   <span class="hljs-comment">// dp[g][0]的初值也必须是无解，其值不能为0！ </span><br><br>                <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>                    <span class="hljs-keyword">for</span>(j=YS1; j&gt;=ys1[i]; j--)<br>                        dp[g][j] = <span class="hljs-built_in">max</span>( dp[g][j], <span class="hljs-built_in">max</span>( dp[g][j-ys1[i]]+value[i], dp[g<span class="hljs-number">-1</span>][j-ys1[i]]+value[i] ) );<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( type == <span class="hljs-number">1</span> ) &#123; <span class="hljs-comment">// 组内最多选择一项工作，可以不选</span><br>                <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;=YS1; j++) <span class="hljs-comment">// 当前组初始化，因为本组允许不选，不存在无解，初始化为上一组的对应值，表示“本组什么都不选”这个策略</span><br>                    dp[g][j] = dp[g<span class="hljs-number">-1</span>][j];<br><br>                <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>                    <span class="hljs-keyword">for</span>(j=YS1; j&gt;=ys1[i]; j--) <span class="hljs-comment">// 倒序</span><br>                        dp[g][j] = <span class="hljs-built_in">max</span>( dp[g][j] , dp[g<span class="hljs-number">-1</span>][j-ys1[i]] + value[i] );<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( type == <span class="hljs-number">2</span> ) &#123;     <span class="hljs-comment">// 任意选择，可一个都不选，也可选多个不同工作</span><br>                <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>                    dp[g][j] = dp[g<span class="hljs-number">-1</span>][j];  <span class="hljs-comment">// 分析与type==1相同</span><br><br>                <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>                    <span class="hljs-keyword">for</span>(j=YS1; j&gt;=ys1[i]; j--)<br>                        dp[g][j] = <span class="hljs-built_in">max</span>( dp[g][j], <span class="hljs-built_in">max</span>( dp[g][j-ys1[i]]+value[i], dp[g<span class="hljs-number">-1</span>][j-ys1[i]]+value[i] )  );<br>            &#125;<br>        &#125;<br>        dp[gcnt][YS1] = <span class="hljs-built_in">max</span>(dp[gcnt][YS1], <span class="hljs-number">-1</span>); <span class="hljs-comment">//所有“无解”的状态，其值都是远远小于0的，现在做输出调整，输出-1</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[gcnt][YS1]);<br><span class="hljs-comment">//        // 调试专用，省略</span><br><span class="hljs-comment">//        for(int j = 0; j&lt;=YS1; j++)</span><br><span class="hljs-comment">//            printf(&quot;%4d&quot;, j);</span><br><span class="hljs-comment">//        printf(&quot;\n&quot;);</span><br><span class="hljs-comment">//        for(int g=0; g &lt;= gcnt; g++ ) &#123;</span><br><span class="hljs-comment">//            for(int j = 0; j&lt;=YS1; j++)</span><br><span class="hljs-comment">//                printf(&quot;%4d&quot;, max(-1,dp[g][j]));</span><br><span class="hljs-comment">//            printf(&quot;\n&quot;);</span><br><span class="hljs-comment">//        &#125;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">第一套测试样例</span><br><span class="hljs-comment">5 3</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">1 0</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">2 2</span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">1 5</span><br><span class="hljs-comment">2 8</span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">3 8</span><br><span class="hljs-comment">4 9</span><br><span class="hljs-comment">5 10</span><br><span class="hljs-comment">正确输出</span><br><span class="hljs-comment">-1</span><br><span class="hljs-comment">错误输出</span><br><span class="hljs-comment">8 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">第二套测试样例</span><br><span class="hljs-comment">输入：</span><br><span class="hljs-comment">3 3</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">2 5</span><br><span class="hljs-comment">3 8</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">1 0</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">4 3</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">3 4</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">2 5</span><br><span class="hljs-comment">3 7</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">1 3</span><br><span class="hljs-comment">1 8</span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">4 4</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment">1 0</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">5 3</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">1 0</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">2 2</span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">1 5</span><br><span class="hljs-comment">2 8</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">3 8</span><br><span class="hljs-comment">4 9</span><br><span class="hljs-comment">5 10</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">1 4</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">2 5</span><br><span class="hljs-comment">3 7</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">正确输出：</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">16</span><br><span class="hljs-comment">-1</span><br><span class="hljs-comment">-1</span><br><span class="hljs-comment">7</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 背包问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求背包问题的具体方案</title>
      <link href="/2024/06/24/%E6%B1%82%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%85%B7%E4%BD%93%E6%96%B9%E6%A1%88/"/>
      <url>/2024/06/24/%E6%B1%82%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%85%B7%E4%BD%93%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><p>　　背包问题的具体方案求解，这个问题是背包问题拓展的经典题型，适合于已经学过01普通背包、完全背包、多重背包等基础背包类型之后的同学在拓展阶段学习。</p><p>　　一般来说，背包问题求具体方案，往往是在这些背包模型的基础上，要求输出最终选择的物品的种类编号和个数（若是普通01背包，则只需要输出物品编号）。这里需要注意的一点是，对于最终的最优收益值，其实现的方案往往可能是不唯一的。为了在线判题的方便，往往题目上会要求“输出方案按照字典序来输出”。所谓的字典序，类似于字符串的大小比较顺序，即小的数字或者字符先输出。在C++中，String类型和Vector类型的对象都支持直接比较大小，且按照字典序来比较大小。</p><h2 id="普通01背包不超过ys1输出最优收益值的选择方案">1.1“普通01背包+不超过YS1”，输出最优收益值的选择方案</h2><h3 id="为什么要逆推路径">1.1.1 为什么要逆推路径？</h3><p>　　“普通01背包+不超过YS1”，这是最普通常见的背包入门题型，以1267为例。这种题型，一般做法都是定义dp[i][j]表示“前i个物品在不超过指定容量YS1时的最优收益值”，然后采用从第1行到第n行的顺序来填写dp[][]数组，如下代码所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 代码(1)</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)      <span class="hljs-comment">// 一般做法都是正序向下填写数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++) <span class="hljs-comment">// 因为是标准状态数组，所以逆序也可以（不管是01背包或者完全背包）</span><br>    dp[i][j]= <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i<span class="hljs-number">-1</span>][j-ys1[i]]+value[i] ); <br></code></pre></td></tr></table></figure><p>　　最后再从dp[n][YS1]往上倒推，从而确定出所选物品的编号值序列，如下面的代码所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 代码(2)</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n,j=YS1; i&gt;<span class="hljs-number">0</span>; i--)<br>    <span class="hljs-keyword">if</span> (dp[i][j] == dp[i<span class="hljs-number">-1</span>][j-ys1[i]]+value[i] )&#123;<span class="hljs-comment">// 这种转移，是因为选择了第i个物品而导致。（暂时这么认为）</span><br>        cout &lt;&lt; i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        j-=ys1[i];<br>    &#125;<br></code></pre></td></tr></table></figure><p>　　为什么要采用倒推的方式来找路径呢？或者说，为什么不能从[0][0]开始去往下找路径，直到[n][YS1]为止呢？因为对于每个物品，我们都有“选第i个物品”和“不选第i个物品”这两种选择。理论上来说，每个数组方格都有“往下”和“往右下”这两个分支情况。如果从[0][0..YS1]中每个方格为根节点，往下形成多棵二叉树。如果每个分支情况都要去判断的话，算法复杂度会达到<spanclass="math inline">\(O(2^n)\)</span>指数级别，此法不可取。如下图绿色所示。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240630142301495.png"alt="image-20240630142301495" /><figcaption aria-hidden="true">image-20240630142301495</figcaption></figure><p>　　稍微聪明一点的同学可能已经意识到，既然这是一颗二叉树结构，要寻找根节点到下面某个结点之间的路径，最简单的方式就是“逆推”。因为每个树节点只有唯一的一个父节点。所以可以用<spanclass="math inline">\(O(n)\)</span>的效率，从路径终点往根节点逆推出唯一的路径。<font color="yellow">if(dp[i][j] == dp[i-1][j-ys1[i]]+value[i])，则说明dp[i][j]是因为选择了第i个物品而从dp[i-1][j-ys1[i]]转移过来而得</font>。代码（2）就是这个意思，只不过是逆序输出了而已。想要反过来输出也不难。</p><p>　　看到这里，似乎具体方案已经讲解完了。然则非也！上段的黄色文字的叙述是存在一定问题的。每种状态因为选择或者不选择物品，往下有两种状态转移的可能（只能二选一，不能既选又不选）；反过来思考，每种状态可能因为上一行的两种情况之一而得来，<font color="pink">但有可能存在"dp[i-1][j]==dp[i-1][j-ys1[i]]+value[i]"的情况，也就是说，选第i种物品或者不选，都可能达到相同的dp[i][j]值。如上图中的红色箭头所示，0+6==dp[3][0]+value[4]==dp[3][4]==6==dp[4][4]。总结来说，即这并非一棵树结构，而是图结构！</font></p><p>　　在这种情况下，如果要输出具体方案，则可能存在多条路径。如上图中，如果要达到[4][4]的状态，可以“选4”、“选1-3”和“选1-2”这三种方案。尤其是第三个方案，如果从下往上逆推，只能倒推到[0][1]而非[0][0]，也就是说，“选1-3”的方案，存在一定的成本冗余。根据题目的定义，这是允许且合理的。</p><h3 id="为什么要字典序输出">1.1.2 为什么要字典序输出？</h3><p>　　1.1.1节中我们说过，路径可能存在多条。在最糟糕的情况下（“ys1[1..n]=a，求dp[n][2*a]”，任选其中2个物品，共有<spanclass="math inline">\(A_n^2=n(n+1)/2\)</span>种选法，即路径），路径数为平方级。因路径太多条，更多的输出情况是“输出字典序最小的物品编号序列”，如<ahref="https://www.acwing.com/problem/content/12/">12.背包问题求具体方案</a>。</p><p>　　这里有必要科普一下“字典序”。字典序的比较规则，和字符串的比较规则完全一致。例如：1-4小于2-3；1-4小于4；1-4小于1-4-5。</p><h3 id="方法一为每个状态存储路径可拓展性更强建议掌握">1.1.3方法一：为每个状态存储路径（可拓展性更强，建议掌握！）</h3><p>　　要想表示和输出路径，一个最简单好理解的做法，就是为每一个状态都存储路径，在状态转移时比较路径的字典序，从而得到新状态的路径值。在C++中，String、Vector、map都是按照字典序来进行大小比较的，所以我们可以把路径存为String或者Vector这种结构。</p><p>　　1) 标准状态数组下的代码如代码（3）所示。空间复杂度为<spanclass="math inline">\(O( N * YS1 * N)\)</span>，较高，慎用。在<ahref="https://www.acwing.com/problem/content/12/">12.背包问题求具体方案</a>中使用会MLE！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 代码（3），01背包，标准状态数组，存储路径</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">jc</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>&#125; dp[N][<span class="hljs-number">201</span>];<br>......<br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)            <span class="hljs-comment">// 针对每1个物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++) &#123; <span class="hljs-comment">// 枚举背包总空间j，正序逆序均可！！</span><br>            dp[i][j]= dp[i<span class="hljs-number">-1</span>][j];   <span class="hljs-comment">// value和path都复制</span><br>            <span class="hljs-keyword">if</span> (j&gt;=ys1[i]) &#123;<br>                <span class="hljs-comment">// 先捏造一个临时决策来存储选择第i个物品后的value和path</span><br>                jc tmp=dp[i<span class="hljs-number">-1</span>][j-ys1[i]];  <span class="hljs-comment">// value和path都复制</span><br>                tmp.value+=value[i];       <span class="hljs-comment">// value要增加</span><br>                tmp.path.<span class="hljs-built_in">push_back</span>(i);     <span class="hljs-comment">// path也要增加</span><br>                <span class="hljs-keyword">if</span> (dp[i][j].value &lt; tmp.value || \<br>                        <span class="hljs-comment">// 等值时，若选择i的路径字典序更小，则也需要更新为更小字典序的决策</span><br>                        dp[i][j].value ==tmp.value  &amp;&amp; dp[i][j].path &gt; tmp.path ) &#123;<br>                    dp[i][j] = tmp;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    cout &lt;&lt;dp[n][YS1].value &lt;&lt;endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;dp[n][YS1].path.<span class="hljs-built_in">size</span>(); i++)    <span class="hljs-comment">//// 关掉这段代码，即可AC 1267题</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, dp[n][YS1].path[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　2）滚动状态数组下的代码如代码（4）所示：空间复杂度为<spanclass="math inline">\(O( YS1 * N)\)</span>，Nice！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 代码（4），01背包，滚动状态数组，存储路径</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">jc</span> &#123;           <span class="hljs-comment">// 决策</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> value;  <span class="hljs-comment">// 该决策的收益值</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 决策的具体内容（每个公司选择多少台机器，path长度不超过M）</span><br>&#125; dp[maxYS1];         <span class="hljs-comment">// 滚动数组，空间复杂度达到了O( M * M )</span><br>......<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--) &#123;     <span class="hljs-comment">// 普通01背包，滚动数组需要倒序填写</span><br>            jc tmp;  <span class="hljs-comment">// 暂时捏造一个决策tmp，表示选择第i个物品后的各种值。</span><br>            tmp.value= dp[j-ys1[i]].value + value[i];<br>            tmp.path= dp[j-ys1[i]].path;<br>            tmp.path.<span class="hljs-built_in">push_back</span>(i);      <span class="hljs-comment">// 表示选择第i个物品</span><br>            <span class="hljs-keyword">if</span> (dp[j].value &lt; tmp.value || \<br>                dp[j].value ==tmp.value &amp;&amp; dp[j].path &gt; tmp.path ) <br>            &#123; <span class="hljs-comment">// 如果在等值情况下新方案的路径字典序更小 </span><br>                dp[j] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>　　上述的方法，都需要用到struct jc来定义新类型。那能否就在intdp[][]数组的基础上直接逆推来得到字典序最小的唯一路径呢？</p><h3 id="方法二不存储路径直接逆推出最小字典序的唯一路径">1.1.4方法二：不存储路径，直接逆推出最小字典序的唯一路径</h3><p>　　我们以两个样例来研究一下如何倒推。两张图中，红色虚线圆圈处为逆推时需要抉择分支的状态，绿色箭头为最优路径，红色箭头为其他路径。任何颜色的箭头，从左往右指，表示逆推时需要选择当前物品；往上往下指，表示逆推时不选择当前物品。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240702153952478.png" alt="image-20240702153952478" style="zoom:70%;" /></p><p>　　从上面的两张图可以看出，在逆推遇到圆圈处时，并没有准确的规律该向“左上方”？或者该向“正上方”？这是为什么呢？因为在圆圈处有两种选择的前提下，如果往左上方逆推，意味着选择第i个物品；而如果想正上方逆推，意味着不选择第i个物品。那这为什么无法确定规律呢？</p><p>　　道理其实很简单。因为我们是从4号到1号，倒序来考虑每个物品的。假如当前我们选择4号物品，但我们此时并不确定以后是否会选择1、2、3号物品。<strong>序列越靠前的号码越能决定序列的字典序大小，光确定了中段或者末段的值是无法估算该序列大小的</strong>。光凭序列中有个“4”，并不能肯定该序列就是最小字典序的。例如[1,4]&lt;[2,3]，或者[1]&lt;[1,4]。</p><p>　　上述问题的解决方法其实也很简单。我们只需要<strong>让逆推时先决策的是小编号的物品</strong>即可。我们只要选择了1号物品，那么1开头的序列的字典序是肯定小于2或者3开头的序列的字典序的。例如[1,5,6,7]&lt;[2,4]。</p><p>　　那如何让逆推时先决策的是小编号的物品呢？先决策小编号，意味着先决策第一行。换句话说，我们要从dp[1][YS1]开始，从上往下去“倒推”dp数组，直到倒推到dp[n+1][]为止。</p><p>　　要想实现这个，只有一种可能，即<strong>[1][YS1]就是dp数组的终态</strong>。也就是说，dp数组需要换定义了，<strong>dp[i][j]表示“在第i～n个物品之间选择，不超过成本量j的最大收益值”</strong>。</p><p>　　在这种情况下，我们<strong>在填写dp数组值时，应该从下往上填写</strong>。并且，递推的特例也需要调整为第n+1行，dp[n+1][0..YS1]=0。新的递推方程如下：<span class="math display">\[\begin{align}dp[i][j]=\begin{cases}dp[i+1][j] &amp;(j&lt;ys1[i]) \tag{1}\\max(\ dp[i+1][j],\quad dp[i+1][j-ys1[i]]\ ) &amp;(j \geq ys1[i])\end{cases}\end{align}\]</span>　　可以看出，该公式相比之前传统的01背包公式，只是第一维从<spanclass="math inline">\(i-1\)</span>变成了<spanclass="math inline">\(i+1\)</span>，第二维依旧是<spanclass="math inline">\(j-ys1[i]\)</span>。这意味着，我们在推导公式时，第一维只能从n到1，而第二维则依然是正序逆序均可！若为滚动数组，第二维的顺序要领则依然和以前一样。</p><p>　　在下面的这四张图中，每一排的测试数据都各自相同，一共有两排（组）数据。左侧第一列的两组数据是从1到n的填写顺序，终态（黄色方格）在右下方的位置，且从下往上逆推方案路径。右侧第二列的两张图样例数据分别和左侧同一排的样例数据相同，但采用的是从n到1的填写顺序，终态在右上角的位置，且从上往下逆推方案路径。这四张图中，绿色箭头表示字典序最小的终态路径，是我们想要的答案；而红色箭头也属于终态路径，但字典序偏大。每一个红色虚线圆圈处，代表在逆推时需要对路径分叉进行选择的地方，也是我们研究决策的关键位置。</p><p>　　要想正确地逆推出字典序最小的到达终态的路径，可以看出，左侧第一列的两张图，在不同的样例数据下，分叉的最优选择各自不同，无法看出规律。而右侧第二列的两张图，<strong>在每次往下分叉时，只要选择“尽可能向左”（代表“选择第i个物品”），放弃“竖直向下”的分支（代表“不选第i个物品”），就能达成最优路径</strong>。</p><p>其核心代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// dp[i][j]表示从第i～n个物品之间挑选出不超过指定成本量j的最大收益值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n;i &gt;= <span class="hljs-number">1</span>;i--) &#123;        <span class="hljs-comment">// 倒序填写，从n到1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= YS1;j++) &#123;  <span class="hljs-comment">// 因为是标准状态数组，所以正序逆序都可以</span><br>            dp[i][j] = dp[i+<span class="hljs-number">1</span>][j];      <span class="hljs-comment">// 注意i+1</span><br>            <span class="hljs-keyword">if</span> (j &gt;= ys1[i])<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i+<span class="hljs-number">1</span>][j-ys1[i]]+value[i]);  <span class="hljs-comment">// 注意i+1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j=YS1;i &lt;= n;i++) &#123; <span class="hljs-comment">// 从终态[1][YS1]往下逆推到[0][..]</span><br>    <span class="hljs-comment">// 要一直确保j-ys1[i]为有效的数组下标！这一点别忘了！</span><br>        <span class="hljs-keyword">if</span> (j-ys1[i] &gt;= <span class="hljs-number">0</span> &amp;&amp; dp[i][j] == dp[i+<span class="hljs-number">1</span>][j-ys1[i]]+value[i]) &#123; <span class="hljs-comment">//能选i则选i</span><br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            j -= ys1[i];<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>　　<imgsrc="C:\Users\wangx\AppData\Roaming\Typora\typora-user-images\image-20240702152231395.png"alt="image-20240702152231395" /></p><p>　　从上面的代码中可以看出，<strong>这种算法的时间复杂度和空间复杂度，都是<spanclass="math inline">\(O(n*YS1)\)</span></strong>。因为涉及到要从终态开始逆推，所以dp数组不允许被压缩成滚动数组。</p><h2 id="完全背包不超过ys1输出最优收益值的选择方案">1.2“完全背包+不超过YS1”，输出最优收益值的选择方案</h2><p>　　如果不要求输出方案，则代码模板如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)          <span class="hljs-comment">// 针对每1种物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++) &#123;  <span class="hljs-comment">// 枚举背包总空间j，只能正序</span><br>        dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[i]) &#123;<br>            <span class="hljs-comment">// dp[i-1][j] 表示“能装而不装”，照搬上一行，注意是i-1</span><br>            <span class="hljs-comment">// dp[i][j - ys1[i]] + value[i]是当前行左侧（注意是i），它可能已经装有若干个物品i</span><br>            <span class="hljs-keyword">if</span> (dp[i][j] &lt; dp[i][j - ys1[i]] + value[i] ) &#123; <span class="hljs-comment">// 注意，是[i][j-...]</span><br>                dp[i][j] = dp[i][j - ys1[i]] + value[i];<br>            &#125;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>　　现在要求输出方案，则应该改装dp[][]的定义。在推导时，总体思路不变。代码模板如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++) &#123;<br>        dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>        dp[i][j].path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 先假设第i种物品装0个，即不装</span><br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[i]) &#123;<br>            <span class="hljs-comment">// dp[i][j - ys1[i]] + value[i]是当前行左侧（注意是i），它可能已经装有若干个物品i</span><br>            jc tmp= dp[i][j-ys1[i]];<br>            tmp.value += value[i];   <span class="hljs-comment">// [i][j - ys1[i]]状态再选择1个i号物品</span><br>            tmp.path[i<span class="hljs-number">-1</span>]++;  <span class="hljs-comment">// 第i种物品对应的是path[i-1]（vector从0开始编号），将其加1，表示再选择1个i号物品</span><br>            <span class="hljs-keyword">if</span> (dp[i][j].value &lt; tmp.value || \<br>                    dp[i][j].value == tmp.value &amp;&amp; dp[i][j].path &gt; tmp.path) &#123;<br>                dp[i][j] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="视频参考教程">1.3 视频参考教程</h2><p>　　<ahref="https://www.bilibili.com/video/BV1454y1C7AR/?spm_id_from=333.999.0.0">E20背包DP求具体方案</a>，该视频内容仅供参考，同学们有时间的话可以看看，加深印象。</p><h1 id="二实战训练">二、实战训练</h1><h2 id="acwing-12.-背包问题求具体方案">2.1 Acwing 12.背包问题求具体方案</h2><h3 id="原题链接">2.1.1 原题链接</h3><h3 id="acwing-12.-背包问题求具体方案微信登录">　　　　<ahref="https://www.acwing.com/problem/content/12/">Acwing 12.背包问题求具体方案</a>（微信登录）</h3><p>　　本题要求输出最优方案的具体内容，和 P2066 有相似之处。</p><h3 id="ac代码">2.1.2 AC代码</h3><h4 id="方法一为每个状态存储路径path">2.1.2.1方法一，为每个状态存储路径path</h4><p>　　时间复杂度：<spanclass="math inline">\(O(n*YS1)=1e3*1e3=1e6\)</span></p><p>　　空间复杂度：<spanclass="math inline">\(O(n*YS1)=1e3*1e3=1e6\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法1：01普通背包 + 滚动状态数组 + 路径保存 + 字典序输出具体方案 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    本题的maxn和maxYS1都达到了1e3，如果选择P2066那种标准状态数组，空间复杂度会达到1e9，超过64MB=6.4e7</span><br><span class="hljs-comment">    采用滚动数组后，空间复杂度为 4e6 &lt; 6.4e7</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxYS1=<span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n, YS1;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">jc</span> &#123;           <span class="hljs-comment">// 决策</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> value;  <span class="hljs-comment">// 该决策的收益值</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 决策的具体内容，空间复杂度O(n)。若要极限压缩空间，可设为为Bit类型，用0/1的bit序列来表示决策内容 </span><br>&#125; dp[maxYS1];         <span class="hljs-comment">// 滚动数组，空间复杂度为O(n*YS1)</span><br><span class="hljs-type">int</span> ys1[maxn], value[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;YS1);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;ys1[i], &amp;value[i]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--) &#123;     <span class="hljs-comment">// 普通01背包，滚动数组需要倒序填写</span><br>            jc tmp;  <span class="hljs-comment">// 暂时捏造一个决策tmp，表示选择第i个物品后的各种值。</span><br>            tmp.value= dp[j-ys1[i]].value + value[i];<br>            tmp.path= dp[j-ys1[i]].path;<br>            tmp.path.<span class="hljs-built_in">push_back</span>(i);      <span class="hljs-comment">// 表示选择第i个物品</span><br>            <span class="hljs-keyword">if</span> (dp[j].value &lt; tmp.value || dp[j].value ==tmp.value &amp;&amp; dp[j].path &gt; tmp.path ) &#123; <span class="hljs-comment">// 如果在等值情况下新方案的路径字典序更小 </span><br>                dp[j] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;dp[YS1].path.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        cout&lt;&lt;dp[YS1].path[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">4 5</span><br><span class="hljs-comment">2 4</span><br><span class="hljs-comment">3 4</span><br><span class="hljs-comment">4 6</span><br><span class="hljs-comment">1 2</span><br><span class="hljs-comment">输出</span><br><span class="hljs-comment">1 4</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">4 4</span><br><span class="hljs-comment">2 4</span><br><span class="hljs-comment">1 2</span><br><span class="hljs-comment">3 4</span><br><span class="hljs-comment">4 6</span><br><span class="hljs-comment">正确输出</span><br><span class="hljs-comment">1 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="方法二标准状态数组定义不变逆序填写正序逆推">2.1.2.2方法二，标准状态数组定义不变，逆序填写，正序逆推</h4><p>　　时间复杂度：<spanclass="math inline">\(O(n*YS1)=1e3*1e3=1e6\)</span></p><p>　　空间复杂度：<spanclass="math inline">\(O(n*YS1)=1e3*1e3=1e6\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法2：01普通背包 + 标准状态数组 + 倒序填写、正序逆推 + 字典序输出具体方案 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxYS1=<span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n,YS1;<br><span class="hljs-type">int</span> dp[maxn][maxYS1];<br><span class="hljs-type">int</span> ys1[maxn],value[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; YS1;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)<br>        cin &gt;&gt; ys1[i] &gt;&gt; value[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n;i &gt;= <span class="hljs-number">1</span>;i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= YS1;j++) &#123;<br>            dp[i][j] = dp[i+<span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">if</span> (j &gt;= ys1[i])<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i+<span class="hljs-number">1</span>][j-ys1[i]]+value[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j=YS1;i &lt;= n;i++) &#123;<br>        <span class="hljs-keyword">if</span> (j-ys1[i] &gt;= <span class="hljs-number">0</span> &amp;&amp; dp[i][j] == dp[i+<span class="hljs-number">1</span>][j-ys1[i]]+value[i]) &#123;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            j -= ys1[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p2066-机器分配">2.2 P2066 机器分配</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P2066">P2066机器分配</a> / <ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1266">1266</a></p><h3 id="分析">2.2.2 分析</h3><p>　　这是一个区间dp的题。不仅如此，题目还要求输出方案，且要求字典序最小。区间dp的题，必然是个三重for循环，其最内层循环k中，处理第i个物品在不超过指定成本量j时选择k的决策。决策方案不再是“选i”或者“不选i”，所以2.1节中的方法2（逆序填写，正序逆推）不再适用于本题。本题只能采用2.1节中的方法1，为每个状态加入path成员，随时记录路径，以供比较或运算。</p><p>　　需要指出的是，官方题解的第一篇题解有点问题，不要看。符合下列测试数据的，才有可能是正确题解。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs text">样例1 <br>3 6<br>10 10 1 1 1 1<br>10 1 10 1 1 1<br>10 10 10 1 1 1<br>正确输出   // 可以不选6台，不一定要选满哦！～<br>30<br>1 1<br>2 1<br>3 1<br>错误输出<br>30<br>1 2<br>2 1<br>3 3<br><br>样例2<br>2 5<br>1 1 1 1 1<br>1 1 1 1 2<br>正确输出<br>2<br>1 0<br>2 5   // 0 5比1 1更小<br><br>样例3<br>2 5<br>1 1 1 1 1<br>1 1 1 1 1<br>正确输出<br>2<br>1 1<br>2 1 <br></code></pre></td></tr></table></figure><h3 id="ac代码-1">2.2.3 AC代码</h3><h4 id="重点掌握的版本">2.2.3.1 重点掌握的版本</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    本题要求输出最优方案的具体内容，和acwing12题有相似之处</span><br><span class="hljs-comment">这个是区间DP的题，1266和本题几乎完全相同,1266题上漏了“要求字典序最小”的要求。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">定义状态：</span><br><span class="hljs-comment">dp[i][j]为前i个公司，分配不超过j台机器的最大收益值 （根据题意，可以不分满j台！）</span><br><span class="hljs-comment">        // dp[2][5].value=150表示前2个公司，一共选择5台机器， 其最大收益值是150</span><br><span class="hljs-comment">        // dp[2][5].path=[4,1]表示公司1要选择4台机器，公司2要选择1台机器   4+1 &lt;= 5</span><br><span class="hljs-comment">状态转移：</span><br><span class="hljs-comment">    前2个公司选不超过3台机器的收益dp[2][3]</span><br><span class="hljs-comment">        = max(&#x27;公司1选不超过3台，公司2选0台&#x27;，&#x27;公司1选不超过2台，公司2选1台&#x27;，&#x27;公司1选不超过1台，公司2选2台&#x27;，&#x27;公司1选不超过0台，公司2选3台&#x27;)</span><br><span class="hljs-comment">        = max(          dp[1][3],                    dp[1][2]+data[2][1],         dp[1][1]+data[2][2],              dp[1][0]+data[2][3]  )</span><br><span class="hljs-comment">        整理后得：</span><br><span class="hljs-comment">            dp[2][3]=max(dp[1][3], dp[1][2]+data[2][1], dp[1][1]+data[2][2], dp[1][0]+data[2][3])</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        状态转移方程如下：</span><br><span class="hljs-comment">dp[i][j] = max( dp[i][j] , dp[i-1][j-k] + a[i][k] )</span><br><span class="hljs-comment">(i属于[1..maxn], j属于[1..YS1], k属于[1..j])</span><br><span class="hljs-comment">k：给公司i分配k个机器</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">dp[]初始值和特例：dp数组全0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxn 11     <span class="hljs-comment">// 最大公司数量 </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxYS1 16     <span class="hljs-comment">// 设备最大总台数 </span></span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> data[maxn][maxYS1];<br><span class="hljs-type">int</span> n,YS1;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">jc</span> &#123;           <span class="hljs-comment">// 决策</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> value;  <span class="hljs-comment">// 该决策的收益值</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 决策的具体内容（每个公司选择多少台机器，path长度不超过maxYS1）</span><br>&#125; dp[maxn][maxYS1];  <span class="hljs-comment">// 空间复杂度达到了O( maxn * maxYS1 * maxYS1 ) ，可能会MLE，可考虑用滚动数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;YS1);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=YS1; j++) <span class="hljs-comment">// j ：选择j台机器</span><br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;data[i][j]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++) &#123;<br>            <span class="hljs-comment">// 为编程方便，先让dp[3][7]=dp[2][7]，即第3个公司暂时什么都不选</span><br>            dp[i][j].path= dp[i<span class="hljs-number">-1</span>][j].path;   <span class="hljs-comment">// 先复制下前两个公司选择的台数，2个int</span><br>            dp[i][j].path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);       <span class="hljs-comment">// 第3个公司既然一台都不选，则台数为 0</span><br>            dp[i][j].value= dp[i<span class="hljs-number">-1</span>][j].value; <span class="hljs-comment">// 别忘了值也要复制好</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=j; k++) &#123; <span class="hljs-comment">// 选择0台已经在上面处理过了，此处至少1台，最多j台</span><br>                jc tmp;                       <span class="hljs-comment">// 假设第i个公司选择k台机器，此处捏造状态tmp，以便于if内的运算</span><br>                tmp.value= dp[i<span class="hljs-number">-1</span>][j-k].value + data[i][k];<br>                tmp.path=dp[i<span class="hljs-number">-1</span>][j-k].path;<br>                tmp.path.<span class="hljs-built_in">push_back</span>(k);        <span class="hljs-comment">//</span><br>                <span class="hljs-keyword">if</span> (dp[i][j].value &lt; tmp.value || \<br>                        <span class="hljs-comment">// 等值时，若当前决策tmp.path的字典序更小，则也需要更新为更小字典序的决策</span><br>                        dp[i][j].value ==tmp.value  &amp;&amp; dp[i][j].path &gt; tmp.path ) &#123;<br>                    dp[i][j] = tmp; <span class="hljs-comment">// 1 &lt;= k &lt;= 15</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dp[n][YS1].value);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,i,dp[n][YS1].path[i<span class="hljs-number">-1</span>]);  <span class="hljs-comment">// 别忘了vector是从0开始编号的</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">3 6</span><br><span class="hljs-comment">10 10 1 1 1 1</span><br><span class="hljs-comment">10 1 10 1 1 1</span><br><span class="hljs-comment">10 10 10 1 1 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">正确输出   // 可以不选6台，不一定要选满哦！～</span><br><span class="hljs-comment">30</span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">3 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">错误输出</span><br><span class="hljs-comment">30</span><br><span class="hljs-comment">1 2</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">3 3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="精简版本学习操作符重载的可以进来看看优秀的代码">2.2.3.2精简版本（学习操作符重载的可以进来看看！优秀的代码）</h4><p>　　上面的代码是可以精简的，精简后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 写法2： 结构体操作符重载，可以大量节省码量，适合高手，建议看懂，学好！  lyyi2003的代码 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxYS1 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxn 16</span><br><span class="hljs-type">int</span> data[maxYS1][maxn];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">jc</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-comment">// 用字符来表示每个位置，有安全隐患，虽然也能存10以上的编号，</span><br>    <span class="hljs-comment">// 但无法存超过127的编号。意味着YS1不能超过127</span><br>    string path;<br>    <span class="hljs-comment">// 算术操作符的重载</span><br>    jc <span class="hljs-keyword">operator</span> +(<span class="hljs-type">int</span> y)  <span class="hljs-keyword">return</span> &#123;value+y,path&#125;;<br>    jc <span class="hljs-keyword">operator</span> +(<span class="hljs-type">char</span> c) <span class="hljs-keyword">return</span> &#123;value  ,path+c&#125;;<br>    <span class="hljs-comment">// 比较操作符的重载</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(jc a) <span class="hljs-type">const</span><br>        <span class="hljs-keyword">return</span> value&lt;a.value||value==a.value&amp;&amp;path&gt;a.path;<br>&#125; dp[maxYS1][maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n,YS1,i,j,k;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;YS1);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>; j&lt;=YS1; j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;data[i][j]);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;=YS1; j++) &#123;<br>            <span class="hljs-comment">// 别忘了value要复制过去，path+‘0’的值也要复制过去</span><br>            dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]+<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>; k&lt;=j; k++)<br>                <span class="hljs-comment">// 此处隐含了&#x27;&lt;&#x27;操作符的操作，且有value和path的操作</span><br>                dp[i][j]=<span class="hljs-built_in">max</span>(dp[i][j],dp[i<span class="hljs-number">-1</span>][j-k]+data[i][k]+(<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;0&#x27;</span>+k));<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dp[n][YS1].value);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,i,dp[n][YS1].path[i<span class="hljs-number">-1</span>]<span class="hljs-number">-48</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section">2.3 1268</h2><h3 id="原题链接-2">2.2.1 原题链接</h3><p>　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1268">1268</a></p><h3 id="分析-1">2.2.2 分析</h3><p>　　这个题的题解，我们之前已经研究过了。在这里主要是说一下完全背包的最优方案的字典序输出。其实总体思路并没有变化，但这里最好是采用“为每个状态存储路径”的方法。</p><h3 id="非ac代码">2.2.3 非AC代码</h3><p>　　下面的代码，只要去掉输出方案的部分，就能AC掉1268题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法5， 非AC代码, 标准状态数组 + 2重for + 增序 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">jc</span>&#123;<br>    <span class="hljs-type">int</span> value;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>&#125;dp[<span class="hljs-number">35</span>][<span class="hljs-number">211</span>], tmp;<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">35</span>], value[<span class="hljs-number">35</span>];<br><span class="hljs-type">int</span> YS1, n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin &gt;&gt;YS1 &gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>cin &gt;&gt;ys1[i] &gt;&gt;value[i];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)       <span class="hljs-comment">// 针对每1种物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举背包总空间j，只能正序 </span><br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];   <br>dp[i][j].path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 先假设第i种物品装0个，即不装 </span><br><span class="hljs-keyword">if</span> (j&gt;=ys1[i])&#123;  <br>                <span class="hljs-comment">// dp[i][j - ys1[i]] + value[i]是当前行左侧（注意是i），它可能已经装有若干个物品i </span><br>                jc tmp= dp[i][j-ys1[i]];<br>                tmp.value += value[i];<br>                tmp.path[i<span class="hljs-number">-1</span>]++;  <span class="hljs-comment">// 第i种物品对应的是path[i-1]（vector从0开始编号），将其加1，表示再选择1个i号物品 </span><br>                <span class="hljs-keyword">if</span> (dp[i][j].value &lt; tmp.value || \<br>                dp[i][j].value == tmp.value &amp;&amp; dp[i][j].path &gt; tmp.path)&#123;<br>    dp[i][j] = tmp;<br>    &#125;<br>    &#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max=%d\n&quot;</span>, dp[n][YS1].value);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;dp[n][YS1].path.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        cout &lt;&lt; dp[n][YS1].path[i] &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">样例1 </span><br><span class="hljs-comment">10 4</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">3 3</span><br><span class="hljs-comment">4 5</span><br><span class="hljs-comment">4 9</span><br><span class="hljs-comment">正确输出</span><br><span class="hljs-comment">max=19</span><br><span class="hljs-comment">1 0 0 2</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 背包问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完全背包问题</title>
      <link href="/2024/05/11/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2024/05/11/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学　　</h1><h2 id="模型引入">1.1 模型引入</h2><p>　　总约束量为YS1，n<font color="red"><strong>种</strong></font>可待选择的物品需要装入，每种物品有无限个，它们都有各自的重量和价值，你需要从中选择合适的组合来使得总约束量内的物品总价值最大（<strong>每种物品可以装0个，也可以装任意多个；不需要刚好装满，允许不"刚好"装满</strong>）</p><p>　　上面这段就是完全背包最常见的题面。</p><h2 id="完全背包和普通01背包之间的关系">1.2完全背包和普通01背包之间的关系</h2><p>　　从上面的模型可以看到，普通01背包是“有n个物品”可选“0个或者1个”，而完全背包是“有n种物品，每种物品可选0个或者任意个”。也就是说，完全背包可以对一种物品选任意个。虽然理论上来说是任意个，但实际上个数肯定不能超过总约束量的约束，即不能超过YS1/ys1[i]个（否则背包撑爆了）。</p><p>　　那这种“可以选任意个数”该如何处理呢？我们需要先想想之前的普通01背包模型中选1个是如何处理的？我们先看看之前01背包的分析，并稍微换一下措辞：</p><p>　　对于第i种物品：</p><ul><li><p>1）如果背包的总容量j不足以容纳第i种物品的1个，此时只能被迫放弃第i种物品，价值没有一点增加。所以有：<span class="math display">\[dp[i][j]=dp[i-1][j] \tag{1}\]</span></p></li><li><p>2）如果背包的总容量j能够容纳第i种物品的1个，此时可以有2种选择：“装0个”、“装1个”第i种物品。此时需要对这2种决策进行比较判断，选出价值最大的决策。</p><ul><li><p>a)如果<strong>装0个</strong>第i种物品，则有:</p><p><span class="math display">\[dp[i][j]=dp[i-1][j] \tag{2}\]</span>　　既然决定对第i种物品一个都不装，那么总价值不会增加，仍然和“前i-1种物品对于总容量j的策略”是一致的。</p></li><li><p>b)如果<strong>装1个</strong>第i种物品，则有:</p><p><span class="math display">\[dp[i][j]=dp[i-1][j-ys1[i]]+value[i] \tag{3}\]</span></p></li></ul></li><li><p>综上情况1）和情况2），则有状态转移方程为：</p></li></ul><p><span class="math display">\[dp[i][j]=\begin{cases}dp[i-1][j] &amp; (j&lt;ys1[i]) \\max(\ dp[i-1][j], \quad dp[i-1][j-ys1[i]]\ +\ value[i]\ ) &amp; (j\geqys1[i])\end{cases} \tag{4}\]</span></p><p>　　以上就是01背包的分析过程。当允许装同一种物品的多个时，我们发现，只需要把其中的第2）点分析稍微调整一下即可。调整后的内容如下：</p><ul><li><p>2）如果背包的总容量j能够容纳第i种物品的<strong>任意</strong>个，此时可以有<strong>多</strong>种选择：“装0个”、“装1个”<strong>、“装2个”、……“装j/ys1[i]个”</strong>第i种物品。此时需要对<strong>多</strong>种决策进行比较判断，选出价值最大的决策。维持a）和b）决策不变，并在后面加入其他决策，如下：</p><ul><li><p>c)如果<strong>装<font color="red">2</font>个</strong>第i种物品，此时可以把这2个第i种物品捆绑起来视为1个物品，其约束量为2*ys1[i]，其收益为2*value[i]，则有:</p><p><span class="math display">\[dp[i][j]=dp[i-1][j-2*ys1[i]]\ +\ 2*value[i] \tag{5}\]</span></p></li><li><p>d)如果<strong>装<font color="red">3</font>个</strong>第i种物品，此时可以把这3个第i种物品捆绑起来视为1个物品，其约束量为3*ys1[i]，其收益为3*value[i]，则有:</p><p><span class="math display">\[dp[i][j]=dp[i-1][j-3*ys1[i]]\ +\ 3*value[i] \tag{6}\]</span></p></li><li><p>……以此类推</p></li><li><p>如果<strong>装<spanclass="math inline">\(\textcolor{red}{\lfloor} j/ys1[i]\textcolor{red}{\rfloor}\quad(\lfloor  \ \rfloor表示向下取整)\)</span>个</strong>第i种物品，此时可以把这<spanclass="math inline">\(\lfloor j/ys1[i]\rfloor\)</span>个第i种物品捆绑起来视为1个物品，其约束量为<spanclass="math inline">\(\mathbf{ \textcolor{red}{\lfloor} j/ys1[i]\textcolor{red}{\rfloor}}\ *\ ys1[i]\)</span>，其收益为<spanclass="math inline">\(\mathbf{\lfloor j/ys1[i] \rfloor}\ *\value[i]\)</span>，则有:</p><p><span class="math display">\[dp[i][j]=dp[i-1]\textcolor[RGB]{0,225,0}[j-\textcolor[RGB]{225,0,0}\lfloorj/ys1[i]\textcolor[RGB]{225,0,0}\rfloor*ys1[i]\textcolor[RGB]{0,225,0}]\+\ \textcolor[RGB]{225,0,0}\lfloorj/ys1[i]\textcolor[RGB]{225,0,0}\rfloor*value[i] \tag{7}\]</span></p></li></ul><p>　　这里一共有<span class="math inline">\(\lfloor j/ys1[i]\rfloor+1\)</span>种决策（举个例子：整个背包总容量为20，当前要处理的总约束量j=10斤。对于第i种物品，ys1[i]=3斤，一共有<spanclass="math inline">\(\lfloor 10/3 \rfloor+1=4\\)</span>种决策，分别是“装0个第i种物品”、“装1个第i种物品”、“装2个第i种物品”、“装3个第i种物品”）。</p><p>　　因为dp[i][j]表示总容量为j时前i种物品能装入的最大价值，所以需要对这<spanclass="math inline">\(\lfloor j/ys1[i]\rfloor+1\)</span>​个决策的结果取其最大值。对于上述2种情况，多个决策（第1、2、3、5、6、7式）取最大值，数学公式整理如下：<span class="math display">\[dp[i][j]=\begin{cases}dp[i-1][j] &amp; (j&lt;ys1[i]) \\max(dp[i-1][j],\quaddp[i-1][j-ys1[i]]+value[i],\quad dp[i-1][j-2*ys1[i]]+2*value[i], \quaddp[i-1][j-3*ys1[i]]+3*value[i], \quad ......,dp[i-1]\textcolor[RGB]{0,225,0}[j-\textcolor[RGB]{225,0,0}\lfloorj/ys1[i]\textcolor[RGB]{225,0,0}\rfloor*ys1[i]\textcolor[RGB]{0,225,0}]+\textcolor[RGB]{225,0,0}\lfloorj/ys1[i]\textcolor[RGB]{225,0,0}\rfloor*value[i] \ &amp; (j\geq ys1[i]))\end{cases} \tag{8}\]</span></p><p>　　可以看到，完全背包实际上就是在01普通背包的基础上，对更多的决策取最大值而已。下面展示针对公式8的多种代码实现方法。</p></li></ul><h2 id="代码实现方法">1.3 代码实现方法</h2><h3 id="三重for-标准状态数组-正序逆序效率一般">1.3.1 三重for +标准状态数组 + 正序/逆序（效率一般）</h3><p>　　<strong>在标准状态数组和三重for的前提下</strong>，对于公式8不需做任何改动，直接照搬即可。实现代码如下：　　</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    //// 标准状态数组，三重for</span><br><span class="hljs-comment">    // 该代码尚未优化，不必硬背，只需对照着公式(8)来看即可</span><br><span class="hljs-comment">    for(int i=1; i&lt;=n; i++)        // 针对每1种物品</span><br><span class="hljs-comment">    for(int j=0; j&lt;=YS1; j++)&#123;   // 枚举填写背包总容量j，正序逆序均可，j=0也需要填写 </span><br><span class="hljs-comment">            if (j &lt; ys1[i])         </span><br><span class="hljs-comment">                dp[i][j]= dp[i-1][j];</span><br><span class="hljs-comment">            else&#123;</span><br><span class="hljs-comment">                dp[i][j]= dp[i-1][j];</span><br><span class="hljs-comment">                dp[i][j]= max(dp[i][j], dp[i-1][j-ys1[i]] + value[i]);</span><br><span class="hljs-comment">                dp[i][j]= max(dp[i][j], dp[i-1][j-2*ys1[i]] + 2*value[i]);</span><br><span class="hljs-comment">                dp[i][j]= max(dp[i][j], dp[i-1][j-3*ys1[i]] + 3*value[i]);</span><br><span class="hljs-comment">                ......</span><br><span class="hljs-comment">            &#125;  // end if</span><br><span class="hljs-comment">        &#125; // end for</span><br><span class="hljs-comment">*/</span><br><br>    <span class="hljs-comment">//// 对上面注释的代码进行优化后的代码如下：</span><br>    <span class="hljs-comment">//// 标准状态数组，三重for</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)        <span class="hljs-comment">// 针对每1种物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举填写背包总容量j，正序逆序均可，j=0也需要填写 </span><br>            dp[i][j]= dp[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">if</span> (j &gt;= ys1[i])<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=j/ys1[i]; k++) <br>                <span class="hljs-comment">//for (int k=1; k*ys1[i]&lt;=j; k++)  //这样写也是等效的 </span><br>                    dp[i][j]= <span class="hljs-built_in">max</span>(dp[i][j],  dp[i<span class="hljs-number">-1</span>][j-k*ys1[i]] + k*value[i] );<br>        &#125;<br></code></pre></td></tr></table></figure><p>　　这种实现方式，时间复杂度为<spanclass="math inline">\(O(n*YS1*k)\)</span>，空间复杂度为<spanclass="math inline">\(O(n*YS1)\)</span>。可以看到，不管是时间或是空间，该方法都是比较差的，无法应对n或者YS1较大的情况。但要求同学们还是要掌握该方法，因为它是后续多个改进版本的理论基石，有助于理解和掌握后续版本。</p><h3 id="三重for-滚动状态数组-逆序效率一般">1.3.2 三重for +<font color="red">滚动</font>状态数组 + 逆序（效率一般）</h3><p>　　<strong>在<font color="red">滚动</font>状态数组和三重for的前提下</strong>，需要对1.3.1节的代码做数组压缩。实现的关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    for(int i=1; i&lt;=n; i++)        </span><br><span class="hljs-comment">    for(int j=YS1; j&gt;=0; j--)&#123;   // 枚举填写背包总容量j，逆序，j=0也需要填写 </span><br><span class="hljs-comment">            dp[j]= dp[j];</span><br><span class="hljs-comment">            if (j &gt;= ys1[i])</span><br><span class="hljs-comment">                for (int k=1; k&lt;=j/ys1[i]; k++) </span><br><span class="hljs-comment">                //for (int k=1; k*ys1[i]&lt;=j; k++)  //这样写也是等效的 </span><br><span class="hljs-comment">                    dp[j]= max(dp[j],  dp[j-k*ys1[i]] + k*value[i] );</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    上面这个代码存在大量冗余，优化后的代码如下：</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)        <span class="hljs-comment">// 针对每1种物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)&#123;   <span class="hljs-comment">// 枚举填写背包总容量j，只能逆序，j=0也需要填写 </span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=j/ys1[i]; k++) <br>                <span class="hljs-comment">//for (int k=1; k*ys1[i]&lt;=j; k++)  //这样写也是等效的 </span><br>                    dp[j]= <span class="hljs-built_in">max</span>(dp[j],  dp[j-k*ys1[i]] + k*value[i] );<br>        &#125;<br></code></pre></td></tr></table></figure><p>　　其实上面的代码，枚举j也可以用正序，只不过这样一来，就变成带冗余循环的方法四了。</p><p>　　上面的这种实现方式，时间复杂度为<spanclass="math inline">\(O(n*YS1*k)\)</span>，空间复杂度为<spanclass="math inline">\(O(\textcolor[RGB]{225,0,0}{YS1})\)</span>。</p><p>　　可以看到，1.3.1和1.3.2节的代码都是三重for，这是阻碍算法效率的瓶颈。有没有什么办法进一步优化呢？还真有。请看下节。</p><h3 id="二重for-标准状态数组-正序较优掌握是下一节的铺垫">1.3.3<font color="red">二重</font>for + 标准状态数组 +正序（较优，掌握，是下一节的铺垫）</h3><p>　　本节内容建议同学们还是应该掌握，以便于加深对背包问题的理解。有些题解是采用这种方法和结构来写代码的。看懂本节后有利于同学们读懂这些题解代码。而且，标准状态数组能够记录路径，能倒推出具体的决策内容，这是滚动数组无法比拟的。</p><h4 id="分析">1.3.3.1 分析</h4><p>　　之前在普通01背包的处理时，对于标准状态数组枚举总容量j时顺序是可正可逆的。因为dp[i][j]完全依赖于dp[i-1][0..YS1]的数据，即依赖于上一行的数据，和本行数据无关，所以第i行的填写顺序可正可逆。dp[i][j]和dp[i][j-ys1[i]]之间会有什么关系吗？请看下图：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240515101440755.png"alt="image-20240515101440755" /><figcaption aria-hidden="true">image-20240515101440755</figcaption></figure><p>　　在右图中，当i=2，更新dp[2][5]时，dp[2][5]=max(dp[1][5],dp[2][3]+10)=max(5,10+10)=20。这里需要注意到一点：<strong>dp[1][3]之前已经针对物品B而更新过了，其值为10，表示背包总容量为3斤时的最优决策是“只装入了一个物品B”。在这种情况下，dp[2][5]选择了dp[2][3]+10这个决策，表示“在dp[2][3]对应决策的基础上，再装入第二个物品B”，</strong>也就是说，dp[2][5]对应的决策是“只装入两个物品B”。这就体现了完全背包的含义。其关键动作在于“一定要从左往右更新dp[i][]”。<strong>只有这样，才能在之前已针对第i个物品做过决策的基础上，再次针对第i个物品做当前的决策</strong>，这样就体现出完全背包的“重复选择”含义。</p><h4 id="关键代码">1.3.3.2 关键代码</h4><p>　　关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)       <span class="hljs-comment">// 针对每1种物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举背包总空间j，必须只能正序，不能逆序！</span><br><span class="hljs-keyword">if</span> ( j &lt; ys1[i] )<br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];   <span class="hljs-comment">// 别忘了公式8是两种情况，不够装时只能放弃物品i，照抄即可 </span><br><span class="hljs-keyword">else</span>  <br>    <span class="hljs-comment">// dp[i-1][j] 表示“能装而不装”，照抄上一行数据，注意是[i-1] </span><br>               <span class="hljs-comment">// dp[i][j - ys1[i]] + value[i]是当前行左侧（注意是[i]），它可能已经装有若干个物品i </span><br>dp[i][j] = <span class="hljs-built_in">max</span>( dp[i<span class="hljs-number">-1</span>][j] , dp[i][j - ys1[i]] + value[i] );<br>&#125;<br><br></code></pre></td></tr></table></figure><p>　　上述代码中的if语句和普通01背包的标准状态数组实现代码中的if语句只有一个地方不一样，那就是dp[<font color="red"><strong>i</strong></font>][j-ys1[i]]+value[i]，其他都完全一样。另外，完全背包要求枚举背包空间j必须只能正序！不能再“正序逆序均可（适用于普通01背包）”了。</p><h4 id="路径管理和输出不常考有时间建议还是看看">1.3.3.3路径管理和输出（不常考，有时间建议还是看看）</h4><p>　　在这个模型下，背包决策路径如何记录和输出呢？即如何看出来每个物品选择了多少个？</p><ol type="1"><li>方法一（不额外定义路径数组，直接从dp[][]倒推决策）</li></ol><p>　　其实很简单，原理和普通01背包的处理是一样的。如果dp[i][j]!=dp[i-1][j]，则背包里必然有物品i，水平往左跳转到dp[i][j-ys1[i]]，再和其上一行数据dp[i-1][j-ys1[i]]相比：如果相同，说明物品i只选择了1个，该处理物品i-1了；如果值不相同，说明还选择了第二个物品i，继续水平往左跳到dp[i][j-2*ys1[i]]，以此类推。通过这样的方式就能找到所有的决策。</p><p>　　举个例子，如下图所示：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240515113238734.png"alt="image-20240515113238734" /><figcaption aria-hidden="true">image-20240515113238734</figcaption></figure><ol start="2" type="1"><li>方法二（定义专门的路径数组ppre[][]来实现）</li></ol><p>　　在二维数组中如果存在多条树状路径，每个点的位置标记为(x,y)，且有唯一的前驱。这种模型下要记录路径，可以采用如下的模式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> r, c;<br>&#125;path[maxn][maxYS1];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pri</span><span class="hljs-params">(node cur)</span></span>&#123;<br><span class="hljs-keyword">if</span> (cur.r==<span class="hljs-number">-1</span> &amp;&amp; cur.c==<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">pri</span>( ppre[cur.r][cur.c] );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;选择物品%d\n&quot;</span>, cur.r);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)       <span class="hljs-comment">// 针对每1种物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举背包总空间j，必须只能正序，不能逆序！</span><br><span class="hljs-keyword">if</span> ( j &lt; ys1[i] )&#123;<br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];   <span class="hljs-comment">// 别忘了公式8是两种情况，不够装时只能放弃物品i，照抄即可</span><br>                ppre[i][j]=(node)&#123;i<span class="hljs-number">-1</span>, j&#125;;<br>            &#125;<br><span class="hljs-keyword">else</span>  <br>    <span class="hljs-comment">// dp[i-1][j] 表示“能装而不装”，照抄上一行数据，注意是[i-1] </span><br>                <span class="hljs-comment">// dp[i][j - ys1[i]] + value[i]是当前行左侧（注意是[i]），它可能已经装有若干个物品i </span><br>                <span class="hljs-keyword">if</span> (dp[i<span class="hljs-number">-1</span>][j] &lt;= dp[i][j - ys1[i]] + value[i]) <br>   dp[i][j] = dp[i][j - ys1[i]] + value[i] , ppre[i][j]=(node)&#123;i, j-ys1[i]&#125;;<br>            <span class="hljs-keyword">else</span><br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j], ppre[i][j]=(node)&#123;i<span class="hljs-number">-1</span>, j&#125;;<br>&#125;<br><span class="hljs-comment">/////// 上面代码可以简化一下。此处为了让同学们理解其根源，所以没去简化。</span><br></code></pre></td></tr></table></figure><h3 id="二重for-滚动状态数组-正序最优做法背">1.3.4<font color="red">二重</font>for + <font color="red">滚动</font>状态数组+ 正序（最优做法，背）</h3><h4 id="分析-1">1.3.4.1 分析</h4><p>　　之前在普通01背包的处理时，对于滚动数组，要求从右往左枚举总容量j，以顺利完成新旧数据的读取和更新。那如果非要从左往右更新，会出现什么情况呢？请看下图：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240515091316889.png"alt="image-20240515091316889" /><figcaption aria-hidden="true">image-20240515091316889</figcaption></figure><p>　　在右图中，当i=2，更新dp[5]时，dp[5]=max(dp[5],dp[3]+10)=max(5,20)=20。这里需要注意到一点：<strong>dp[3]之前已经针对物品B而更新过了，其值为10，表示背包总容量为3斤时的最优决策是“装入了一个物品B”。在这种情况下，dp[5]选择了dp[3]+10这个决策，表示“装入第二个物品B”</strong>，也就是说，dp[5]对应的决策是“在dp[2][3]对应决策的基础上，再装入两个物品B”。这就体现了完全背包的含义。其关键动作在于“一定要从左往右更新dp[]，才能体现出完全背包的‘重复选择’含义”。</p><h4 id="关键代码-1">1.3.4.2 关键代码</h4><p>　　关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//版本3. AC代码, 一维状态数组 + 2重for + 增序 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)       <span class="hljs-comment">// 针对每1种物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=ys1[i]; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举背包总容量j，正序，j的取值范围是[ys1[i], YS1] </span><br>dp[j] = <span class="hljs-built_in">max</span>( dp[j] , dp[j - ys1[i]] + value[i] );<br>&#125;<br><span class="hljs-comment">// 或者如下，等效，但不如上述代码更优 </span><br><span class="hljs-comment">//for(int j=0; j&lt;=YS1; j++)&#123;   </span><br><span class="hljs-comment">//if ( ys1[i] &lt;= j ) </span><br><span class="hljs-comment">//dp[j] = max( dp[j] , dp[j - ys1[i]] + value[i] );</span><br><span class="hljs-comment">//&#125;</span><br></code></pre></td></tr></table></figure><h4 id="路径管理和输出不常考有时间建议还是看看-1">1.3.4.3路径管理和输出（不常考，有时间建议还是看看）</h4><p>　　在滚动状态数组模型下，无法根据状态数组来倒推路径，所以1.3.3.3节的方法一不再适用，但方法二是可以的。同学们可以自行调整其代码，此处不再多说。</p><h2 id="彩蛋">1.4 彩蛋</h2><p>　　如果现在有一个题如下：</p><p>　　总背包容量YS1，2种物品，第1种只能选0个或者1个，而第2种物品可以选无限个，求最大价值。分别给出ys1[1..2]和value[1..2]。</p><p>　　这样的题，怎么破？同学们可以思考一下。后续帖会给出答案。</p><h1 id="二.-实战练习">二. 实战练习</h1><h2 id="section">2.1 1268</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1268">1268：【例9.12】完全背包问题</a></p><h3 id="分析-2">2.1.2 分析</h3><p>　　这是一个裸的完全背包的题目，maxn=30，maxYS1=200，这么小的数据量，适合新手用来练习上面的四种方法。本题不需要输出路径。同学们要求掌握四种方法，并重点掌握第四种。</p><h3 id="ac代码">2.1.3 AC代码</h3><h4 id="二维状态数组-3重for-增序降序">2.1.3.1 二维状态数组 + 3重for +增序/降序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 1. AC代码, 二维状态数组 + 3重for + 增序/降序 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">35</span>][<span class="hljs-number">211</span>];<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">35</span>], value[<span class="hljs-number">35</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> YS1, n;<br>cin &gt;&gt;YS1 &gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>cin &gt;&gt;ys1[i] &gt;&gt;value[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)       <span class="hljs-comment">// 针对每1种物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举背包总空间j，正序逆序均可，和第i行数据无关</span><br><span class="hljs-comment">// 这里不是判断放不放了，而是判断放几个！！</span><br><span class="hljs-comment">// k表示放入物品i的个数，把dp[i-1][j]和放不同个数的几种情况都拿来比一比，找到一个最大值！ </span><br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br><span class="hljs-keyword">if</span> ( ys1[i] &lt;= j ) <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k * ys1[i] &lt;= j; k++ ) <br>dp[i][j] = <span class="hljs-built_in">max</span>( dp[i<span class="hljs-number">-1</span>][j - k * ys1[i]] + k*value[i],     dp[i][j]  );<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max=%d&quot;</span>, dp[n][YS1]); ;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一维状态数组-3重for-降序">2.1.3.2 一维状态数组 + 3重for +降序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 2. AC代码, 一维状态数组 + 3重for + 降序 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">201</span>], ys1[<span class="hljs-number">31</span>], value[<span class="hljs-number">31</span>];<br><span class="hljs-type">int</span> YS1, n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin &gt;&gt;YS1 &gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>cin &gt;&gt;ys1[i] &gt;&gt;value[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)              <span class="hljs-comment">// 针对每1个物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)   <span class="hljs-comment">// </span><br><span class="hljs-comment">// 这里不是判断放不放了，而是判断放几个！！</span><br><span class="hljs-comment">// k表示放入物品i的个数，把几种情况都拿来比一比，找到一个最大值！ </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k*ys1[i]&lt;=j; k++) <br>dp[j] = <span class="hljs-built_in">max</span>( dp[j - k*ys1[i]] + k*value[i],  dp[j]);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max=%d&quot;</span>, dp[YS1]); <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="二维状态数组-2重for-正序">2.1.3.3 二维状态数组 + 2重for +正序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//3. AC代码, 二维状态数组 + 2重for + 增序 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">35</span>][<span class="hljs-number">211</span>];<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">35</span>], value[<span class="hljs-number">35</span>];<br><span class="hljs-type">int</span> YS1, n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin &gt;&gt;YS1 &gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>cin &gt;&gt;ys1[i] &gt;&gt;value[i];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)       <span class="hljs-comment">// 针对每1种物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举背包总空间j，只能正序 </span><br><span class="hljs-keyword">if</span> ( j &lt; ys1[i] )<br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];   <span class="hljs-comment">// 别忘了公式8是两种情况，不够装时只能放弃物品i，照抄即可 </span><br><span class="hljs-keyword">else</span>  <br>    <span class="hljs-comment">// dp[i-1][j] 表示“能装而不装”，照搬上一行，注意是i-1 </span><br>                <span class="hljs-comment">// dp[i][j - ys1[i]] + value[i]是当前行左侧（注意是i），它可能已经装有若干个物品i </span><br>dp[i][j] = <span class="hljs-built_in">max</span>( dp[i<span class="hljs-number">-1</span>][j] , dp[i][j - ys1[i]] + value[i] );<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max=%d&quot;</span>, dp[n][YS1]); ;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="一维状态数组-2重for-正序">2.1.3.4 一维状态数组 + 2重for +正序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//4. AC代码, 一维状态数组 + 2重for + 增序 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">211</span>];<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">35</span>], value[<span class="hljs-number">35</span>];<br><span class="hljs-type">int</span> YS1, n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin &gt;&gt;YS1 &gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>cin &gt;&gt;ys1[i] &gt;&gt;value[i];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)               <span class="hljs-comment">// 针对每1种物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=ys1[i]; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举背包总容量j，只能正序，j的取值范围是[ys1[i], YS1] </span><br>dp[j] = <span class="hljs-built_in">max</span>( dp[j] , dp[j - ys1[i]] + value[i] );<br>&#125;<br><span class="hljs-comment">// 或者如下，等效。 </span><br><span class="hljs-comment">//for(int j=0; j&lt;=YS1; j++)&#123;   </span><br><span class="hljs-comment">//if ( ys1[i] &lt;= j ) </span><br><span class="hljs-comment">//dp[j] = max( dp[j] , dp[j - ys1[i]] + value[i] );</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max=%d&quot;</span>, dp[YS1]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="p1616-疯狂的采药">2.2 P1616 疯狂的采药</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P1616">P1616疯狂的采药</a></p><h3 id="分析-3">2.2.2 分析</h3><p>　　所有草药可以无限采摘，这是完全背包的题。</p><p>　　本题数据规模与约定中明确指出了“$1 n*YS1 ^7 <spanclass="math inline">\(”，所以时间复杂度并不会有问题。但是因为\)</span>n^4，YS1^7$，如果定义成标准状态数组，则二维数组空间达到了1e11，这必然会造成MLE。本题只能使用本帖的方法四来破。</p><p>　　从数据规模和约定中看到，每个草药的价值最大可到1e4，最少可1秒内搞定，而且最大可有1e7秒的背包总容量，所以总价值可能达到1e11，故为稳妥起见，开longlong类型。</p><h3 id="ac代码-1">2.2.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">二重for + 一维滚动状态数组 + 正序</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">（1）状态数组定义</span><br><span class="hljs-comment">intdp[i]：在j时间之内能采摘的最大价值</span><br><span class="hljs-comment">（2）所求目标</span><br><span class="hljs-comment">       dp[YS1]</span><br><span class="hljs-comment">（3）状态转换方程</span><br><span class="hljs-comment">A. 时间j内不够，不装第i种草药</span><br><span class="hljs-comment">假设前i-1轮处理中，在时间j内的总价值是dp[j]，既然不采摘第i种草药，</span><br><span class="hljs-comment">所以前i种草药在时间j内的最大总价值dp[j] 和前i-1种草药在时间j内的最大总价值dp[j]是一样的，</span><br><span class="hljs-comment">dp[j] = dp[j]  简单地说，就是什么都不改即可</span><br><span class="hljs-comment">B. 时间j内够装第i种草药  j &gt;= ys[i]</span><br><span class="hljs-comment">a. 装上</span><br><span class="hljs-comment">如果前i-1种草药在时间j-ys1[i]内的最大总价值是dp[j-ys1[i] ]，</span><br><span class="hljs-comment">那么我们可以用剩下的ys1[i]这个时间来装第i种草药的1个，所以有下式：</span><br><span class="hljs-comment">dp[j] = dp[j-ys1[i] ] + value[i];</span><br><span class="hljs-comment">b. 不装 （能装但不装，我当然可以不装，谁说我看到一种草药就非得装啊？要懂策略嘛！）</span><br><span class="hljs-comment">如果不装，那么在j时间内，我面对前i种草药在时间j内能获得的最大价值</span><br><span class="hljs-comment">和 我面对前i-1种草药在时间j内获得的最大价值是一样的</span><br><span class="hljs-comment">dp[j] = dp[j];    这种处理，和前面的A相似</span><br><span class="hljs-comment">归纳汇总：</span><br><span class="hljs-comment">dp[j] = max(dp[j], dp[j-ys1[i] ] + value[i]);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">（4）循环边界和循环顺序</span><br><span class="hljs-comment">j: [ys1[i]..YS1] ys1[i] --&gt; YS1必须增序，这样才能体现出重复背包的含义</span><br><span class="hljs-comment">（5）状态初始化值和特例</span><br><span class="hljs-comment">当value都为0时，不管怎么采，最大价值都为 0, 所以 dp[] 初始化为 0 最合适；</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">动态规划的题，变量众多，请严格遵守命名规则和风格，不要乱取名字</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 10001</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T 10000001</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[T];         <span class="hljs-comment">// 不开long long真的是要见祖宗的，哈哈！～</span><br><span class="hljs-type">int</span> n, YS1;<br><span class="hljs-type">int</span> ys1[N], value[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;YS1, &amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;ys1[i], &amp;value[i]);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=ys1[i]; j&lt;= YS1; j++)<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-ys1[i]] + value[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, dp[YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p2722-总分">2.3 P2722 总分</h2><h3 id="原题链接-2">2.3.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P2722">P2722 [USACO3.1]总分 Score Inflation</a></p><h3 id="分析-4">2.3.2 分析</h3><p>　　每一种题可以无限出多个题，这是完全背包的题。</p><p>　　本题数据规模与约定中明确指出<span class="math inline">\(n \leq10^4，YS1 \leq10^4\)</span>，每个题的收益最大也可到1e4，最少可1秒内搞定，总价值可能达到1e8。本题可用来训练本帖的四种方法。<strong>想练习的同学可以书写四种方法，不必拘泥本帖给出的AC代码。</strong></p><h3 id="ac代码-2">2.3.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 一维状态数组 + 二重for + 正序</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 10001</span><br><span class="hljs-type">int</span> n, YS1, ys1[N], value[N], dp[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;YS1, &amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;value[i], &amp;ys1[i]);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=ys1[i]; j&lt;=YS1; j++)<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-ys1[i]] + value[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dp[YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-1"></h2>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 背包问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>其他的线性DP（简单）</title>
      <link href="/2024/05/04/%E5%85%B6%E4%BB%96%E7%9A%84%E7%BA%BF%E6%80%A7DP%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/"/>
      <url>/2024/05/04/%E5%85%B6%E4%BB%96%E7%9A%84%E7%BA%BF%E6%80%A7DP%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><p>　　因为dp的本质是递推，所以普通的线性dp，本质上就是线性递推的题，同学们只要定义好状态数组和递推方程等，严格做好六点分析，就能破之。</p><h1 id="二.-实战训练">二. 实战训练</h1><h2 id="城市交通网最短路径">2.1 1261 城市交通网——最短路径</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1261"><strong>1261：【例9.5】城市交通路网</strong></a></p><h3 id="分析">2.1.2 分析</h3><p>　　该题需要在带权的网中，求<strong>指定的两个点之间的最短路径</strong>。最短路径问题的各个解法，本质上就是动态规划。本题可以作为最短路径的入门题，虽然不是最短路径的最优算法，但属于朴素级的算法，简单易懂。</p><ol type="1"><li>状态数组定义</li></ol><p>　　dp[i]：从出发点A走到点i的最短路径值</p><ol start="2" type="1"><li>所求目标</li></ol><p>　　dp[n]，目标点是编号值最大的第n点（即E点）。</p><ol start="3" type="1"><li>状态转换方程</li></ol><p>　　动态规划的本质是递推，现在要找关于dp[i]的状态转移方程，就需要假设dp[i-1]、dp[i-2]……等已知，然后找dp[i]和dp[i-1]、dp[i-2]……等之间的关系式。“A点到i号点的最短路径值”，和“A点到i-1号点的最短路径值”、“A点到i-2号点的最短路径值”等之间有什么关系吗？</p><p>　　以8号点为例，从图上可以看到，从5号点和6号点都能走到8号点，且长度已知。要想从A点走到8号点，必然要经过5号点或者6号点，这是必经之路。只要我们求出“从A点走到5号点的最短路径值”，以及“从A点走到6号点的最短路径值”，分别加上<spanclass="math inline">\(5-&gt;8\)</span>的权值<spanclass="math inline">\(mapp_{5-&gt;8}\)</span>和<spanclass="math inline">\(6-&gt;8\)</span>的权值<spanclass="math inline">\(mapp_{6-&gt;8}\)</span>，两个<strong>和值</strong>比较，取最小值（因为是求最短路）即可。</p><p>　　<strong>我们用mapp[i][j]来表示从i号点<font color="red">直接</font>走到j号点的边弧长度值，如果从i号点不能走到j号点，则该值用INF（一个极大值，表示“无穷大”）表示。这是图论中的“邻接矩阵存储表示法”。</strong>因为较为简单，所以同学们可以记下该方法。</p><p>　　我们根据上面的样例分析，可以得出状态转移方程如下： <spanclass="math display">\[dp[i]=min(dp[from]+mapp[from][i])  \qquad \ (from: mapp[from][i]\ \!=INF)\]</span>　　from号点，为“能直接走到i号点的所有点”（这些点到i号点有一条<strong>或者多条</strong>直接的边弧），通过循环筛选，多次取min值，找到最小值。</p><ol start="4" type="1"><li>循环顺序和边界</li></ol><p>　　递推的核心，是“填数组，即根据已知填写未知”。本题有一个很重要的特点，那就是“所有点的编号都是从图的左侧往右侧进行编号的，所以所有能直接走到i号点的点，其编号值都肯定比i小”。可以看到样例数据的这个邻接矩阵，是一个上三角矩阵（矩阵右下部分为全0）所以要找所有能直接走到i号点的点from，只需要搜[1..i-1]这个范围编号的所有点即可。至于当前点i的循环顺序，只能从左往右填。总结如下：</p><p>　　 i：2 ---&gt; n增序（1号点就不必填了，自己到自己的路径长度值肯定是0了）</p><p>　　from：1 &lt;---&gt; i-1增减序均可（按什么序去比最小值都可以，只要找到了就行）</p><ol start="5" type="1"><li>特例</li></ol><p>　　状态转移方程中并没有出现dp[i-1]这种东西，所以不太直观。仔细思考，可以发现，有点是不需要算的，比如dp[1]，1号点到1号点自己的最短路径长度值，那肯定是0咯！</p><p>　　dp[1]=0;</p><ol start="6" type="1"><li>初始化值</li></ol><p>　　除了特例位置dp[1]上的值之外，dp[2..n]应该给什么初值呢？另外一个数组mapp[][]应该给什么初值呢？</p><ul><li>关于mapp[][]：我们仔细观察样例数据可以发现，如果i号点到j号点不可直达，样例数据是以0来表示两点之间的距离。对于标准的邻接矩阵来说，这是不规范的处理。为了方便和杜绝后患，在录入mapp[][]时，建议最好是把0更改为INF。当然，也可以不处理，但在后续二重dor里对dp[]更新时，一定就要预先筛选剔除掉“不可直达”的情况。鉴于本题在录入邻接矩阵时，已提供了完整的n*n个数据，所以mapp[][]不需要在录入之前做初始化了。</li><li>关于dp[]：从状态转移方程中可以看出，dp[i]的值，需要先找到符合条件（<spanclass="math inline">\(mapp[from][i]\ \!=INF\)</span>）的from点。如果没有找到这样的from点，if语句的判断条件不符合，则dp[i]并不会被修改。换句话说，如果没有任何点能直接走到i号点，那么从1号点走到i号点的最短路径长度值，必然只能是“无穷大”，千万不能赋值为0。</li></ul><p>　　所以：dp[2..n]=INF</p><ol start="7" type="1"><li>关于无穷大（INF）在图论算法中的特别说明</li></ol><p>　　需要注意的是，无穷大“INF”在图论算法中的处理非常重要，不同的图论算法对无穷大的处理是不同的，需要小心处理。否则容易形成坑点，难以拿到全分。详情请见本站专门的帖子，看这里。</p><ol start="8" type="1"><li>输出最短路径</li></ol><p>　　首先需要意识到一点，从一个点到另一个点的最短路径，可能不止一条。从地图上来看，我们从左往右求解从1号点到其他每一个点的最短路径值，在计算或更新每个dp[to]值时，from和to的值都是知道的，只需要同步地记录下from和to之间的这个选择关系即可。</p><p>　　1）该采用什么样的方式来记录路径呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> to=<span class="hljs-number">2</span>; to&lt;=n; to++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> from=<span class="hljs-number">1</span>; from&lt;=to<span class="hljs-number">-1</span>; from++)<br><span class="hljs-keyword">if</span>( dp[to] &gt; dp[from] + mapp[from][to] )&#123; <br>    dp[to] = dp[from] + mapp[from][to];<br>    ？？？？？ <span class="hljs-comment">// 此处该如何记录from和to之间的关系？？？</span><br>&#125;<br></code></pre></td></tr></table></figure><p>　　我们知道每个from都可以指向多个to点，也知道每个to点可以被多个from点指过来。我们可以用pre[to]=from或者nxt[from]=to来记录from和to之间的关系。但在此用nxt[from]=to是错误的！为什么呢？因为上面二重循环的代码是给定一个to值，找出与该to值最符合条件的from值（即找出to点的路径前驱节点）。要记录也应该是记录to点的前驱节点，而不应该记录from点的后继节点，否则会引起数据记录混乱。</p><p>　　举个例子，就拿本题的样例数据来说吧，看4号点的更新过程，它只有1个from点（即1号点）可供筛选，需要更新，dp[4]=1，但若记录为nxt[1]=4，这是错误的。因为实际上的最短路径是1号点走向3号点。那为什么1号点的后继结点会被改为4号点呢？仅仅只是因为4比3大，先更新3号点的dp值，nxt[1]=3，然后更新4号点的dp值。nxt[1]=4，这是绝对谬误的。</p><p>　　<strong>归纳总结</strong>：从左往右更新每个点的dp[]值时，根据当前点选择其正确的前驱节点，那么就应该用pre[to]=from的方式来记录前驱节点信息即可。反过来，如果是从右往左处理每个点，根据当前点选择其正确的后继结点，则应该用nxt[from]=to来记录from的后继结点即可。</p><p>　　<strong>结论</strong>：定义pre[]表示每个节点在最短路径中的上一个（即前驱）节点的编号值。</p><p>　　2）如何输出路径？</p><p>　　需要明白一点，上述的这种方式，只能存一条路径，并不能输出多条最短路径。</p><p>　　对于pre[]数组，要想输出路径很简单，只需要从终点倒推到起点即可。可以采用递归函数来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>( k!=<span class="hljs-number">1</span> )<br><span class="hljs-built_in">find</span>( pre[k] );<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, k);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ac代码">2.1.3 AC代码</h3><p>　　1261题的AC代码如下：</p><p>　　1) “mapp[][]初值不改为INF”的版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span>                                                                 </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;                                                               <span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1010</span><br><span class="hljs-type">int</span> mapp[N][N],n;<br><span class="hljs-comment">// dp[5] = 10: 从出发点到5号点的最短路径值为 10 </span><br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-type">int</span> pre[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>( k!=<span class="hljs-number">1</span> )<br><span class="hljs-built_in">find</span>( pre[k] );<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, k);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-comment">// 因为每条弧都是从编号小的点指向编号大的点，</span><br><span class="hljs-comment">// 所以在邻接矩阵中的值，是一个上三角矩阵(主对角线以下都是0) </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;mapp[i][j]);<br>    <span class="hljs-comment">// 既然是对dp[]进行收缩，求min，所以这里需要先赋初值为INF </span><br><span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br><span class="hljs-comment">// 出发点1到自己的最短路径值 是 0 </span><br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;  <br><span class="hljs-comment">// 因为状态转换方程里是根据dp[]左侧来计算dp[]右侧的值，</span><br><span class="hljs-comment">// 所以from需要从1到n-1循环，to无所谓。 </span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> to=<span class="hljs-number">2</span>; to&lt;=n; to++)          <span class="hljs-comment">// 因为是根据dp左边算dp右边，所以必须是升序 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> from=<span class="hljs-number">1</span>; from&lt;=to<span class="hljs-number">-1</span>; from++)   <span class="hljs-comment">// 正序逆序均可，上三角矩阵，from的范围是[1..to-1]</span><br>            <span class="hljs-keyword">if</span> ( mapp[from][to] != <span class="hljs-number">0</span> )&#123;   <span class="hljs-comment">// 单独先剔除掉“不可直达的边弧”情况 </span><br>            <span class="hljs-comment">// 如果从from到to有弧，并且从出发点到to的距离 大于 从出发点到点from的距离 加上 从点from到点to的弧长值 </span><br>                <span class="hljs-keyword">if</span>( dp[to] &gt; dp[from] + mapp[from][to] )&#123; <span class="hljs-comment">// 本代码中mapp[from][to]没有初始化为INF，所以不会爆int </span><br>                    dp[to] = dp[from] + mapp[from][to];<br>                    <span class="hljs-comment">// 因为是根据左边来计算右边，所以下面只能用pre[to]=left，而不能用next[from]=to; </span><br>                    pre[to] = from;<br>                &#125;<br>            &#125;<br><span class="hljs-comment">// 打印最短路径值 </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;minlong=%d\n&quot;</span>, dp[n]);<br>    <span class="hljs-comment">// 打印路径上各个点 </span><br>    <span class="hljs-built_in">find</span>( n );<br>&#125;<br></code></pre></td></tr></table></figure><p>　　2）“mapp[][]改为INF”的版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span>                                                                 </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f   <span class="hljs-comment">// 可能存在无穷大+无穷大，应定义为0x3f3f3f3f</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1010</span><br><span class="hljs-type">int</span> mapp[N][N],n;<br><span class="hljs-comment">// dp[5] = 10: 从出发点到5号点的最短路径值为 10</span><br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-type">int</span> pre[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>( k!=<span class="hljs-number">1</span> )<br>        <span class="hljs-built_in">find</span>( pre[k] );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, k);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;mapp[i][j]);<br>            <span class="hljs-keyword">if</span> (mapp[i][j] == <span class="hljs-number">0</span>)   <span class="hljs-comment">// 和上一个版本不同的地方</span><br>                mapp[i][j] = INF;<br>        &#125;<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> to=<span class="hljs-number">2</span>; to&lt;=n; to++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> from=<span class="hljs-number">1</span>; from&lt;=to<span class="hljs-number">-1</span>; from++)<br>            <span class="hljs-keyword">if</span>( dp[to] &gt; dp[from] + mapp[from][to] ) &#123; <span class="hljs-comment">// 和上一个版本不同的地方</span><br>                dp[to] = dp[from] + mapp[from][to];<br>                pre[to] = from;<br>            &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;minlong=%d\n&quot;</span>, dp[n]);<br>    <span class="hljs-built_in">find</span>( n );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="挖地雷最长路径">2.2 1262 挖地雷——最长路径</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><h3 id="例9.6挖地雷">　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1262">1262：【例9.6】挖地雷</a></h3><h3 id="分析-1">2.2.2 分析</h3><p>　　模型精简：在一个有向无环图中，点带权，边弧不带权，不规定起点和终点，求该图中带权路径最长的路径长度值及路径经过的点序列。</p><p>　　题目中有一句非常重要的信息：“且保证都是小序号地窖指向大序号地窖”。也就是说，边弧只能从编号小的点指向编号大的点。所以，该图不存在环路。如果以i号点为某一条路径的终点，则这些路径的起点编号必然是小于i号点的。题目中样例数据得出如下图所示：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240507152015118.png"alt="image-20240507152015118" /><figcaption aria-hidden="true">image-20240507152015118</figcaption></figure><p>　　这个题，和1261在某些地方上是相似的，例如它也是需要求路径，也需要锚定一个当前点，然后在当前点的所有“前驱”或者“后继”点中去做选择。但本题并没有规定起点和终点，我们该如何定义状态数组呢？</p><p>　　稍加思考，可以发现，我们可以设定“dp[i]表示以当前点i作为路径起点（或者终点）的最长路径值”，也就是说，有两种方法。事实上，本题用这两种方法都可以解出来。下面分别分析之。两种方法都需要同学们学会掌握，通过本题学会如何在dp中进行正推，或逆推。</p><h4 id="以当前点为路径起点">2.2.2.1以当前点为<font color="red"><strong>路径起点</strong></font></h4><ol type="1"><li>状态数组定义</li></ol><p>　　dp[i]表示从当前点<strong>出发</strong>（含），最多能挖到的地雷个数</p><ol start="2" type="1"><li>所求目标</li></ol><p>　　带权最长路径的终点不一定是n号点，所以有： <spanclass="math display">\[max(dp[i])\quad(1\leq i \leq n)\]</span></p><ol start="3" type="1"><li>状态转移方程</li></ol><p>　　以上图中的5号点为例进行分析：从5号点出发最多能挖到的地雷个数，肯定与以6号点、7号点等右侧的点出发挖到的地雷数密切相关。只要右侧的dp值确定，则dp[5]可以很容易算出。所以有：<span class="math display">\[dp[from]=w[from] + max(dp[to]) \quad(to:mapp[from][to]!=INF)\]</span></p><ol start="4" type="1"><li>循环顺序和边界</li></ol><p>　　from: 1 &lt;---- n 逆序（右侧点的dp值先算，根据右侧填左侧）</p><p>　　to：from + 1 &lt;---&gt; n正序、逆序均可（只要筛完from的所有邻接点就行，什么顺序不重要）</p><ol start="5" type="1"><li>特例</li></ol><p>　　因为from必须从右往左填写，所以dp[n]必须是已知的特定值。根据dp[]的定义，我们可以知道，从n号点出发往右走，是没法走的，后面一个点都没有了。所以该路径只能包含n号点自己。</p><p>　　故有dp[n]=w[n]。</p><ol start="6" type="1"><li>初始化值</li></ol><p>　　本题有dp[]和mapp[][]这两个数组需要考虑初始化的问题。</p><p>　　对于mapp[][]，因为本题是“点带权值且边弧无权值的有向图”，所以mapp[][]只需要填写1/0或者true/false即可。根据样例提供的数据形式，我们可以默认最初mapp[][]为全false/0即可。</p><p>　　对于dp[]，可能很多同学会认为初值应该是0（毕竟很多题中dp[]的初值都是0，写习惯了）。我们仔细看状态转移方程，对于每个from点的dp[]值，当找到合适的to值时，会去取最大值，更新dp[from]。但同学们务必要小心这种状态转移方程的写法，因为它暗含了一个假设前提：你得先能够找到满足条件的to值。那万一不存在或者没找到符合条件的to值呢？（例如from号点在图中是一个<strong>汇点，没有任何边弧从from点出去</strong>，例如n号点就肯定是一个汇点）这种情况下，dp[from]无法被更新，最终结果仍然会是其初值。那这个初值应该是多少呢？当from点为汇点时，从from点出发的路径是没有后续节点的，只有from号地窖的地雷可挖，故dp[1..n]的初值应该就是w[1..n]。</p><p>　　注意，这里的初值设置，正好涵盖了本题对特例的处理。所以就不再单独处理特例了。</p><ol start="7" type="1"><li>路径输出</li></ol><p>　　1）路径如何表示或记录？</p><p>　　因为外层循环变量from是从右往左填写的，而to在其右侧，所以<strong>只能用next[from]=to的方式来记录</strong>，而不能用pre[to]=from来记录。<strong>同学们可以配合着2.1.2节第8点中的分析来学习，体会两种情况下的不同处理方式，归纳总结好。</strong></p><p>　　2）最长路径如何输出？</p><p>　　首先应找到最长路径的起点。鉴于dp[]的基本定义，我们可以先找到max(dp[1..n])，然后从该点位置开始，不断去next，就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> k = startpos;<br><span class="hljs-keyword">while</span> ( next[k] != <span class="hljs-number">0</span> )&#123;  <span class="hljs-comment">// 如果最长路径有下一个节点，就一直输出打印下一个节点，直到没有下一个点（==0）为止</span><br>    k = next[k];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-%d&quot;</span>, k);<br>&#125;<br></code></pre></td></tr></table></figure><p>　　当然，上面的这个代码，也可以通过递归函数来实现。同学们可以自行思考一下。</p><ol start="8" type="1"><li>AC代码</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 模型提炼： 求整个有向图中的最长路径的长度值，不规定起点和终点。</span><br><span class="hljs-comment">// 1262 和P2196是高度类似的题，只是图的输入方式不同，图结点规模不同</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*                             o</span><br><span class="hljs-comment">方法一： 用dp动态规划</span><br><span class="hljs-comment">（1）状态数组定义</span><br><span class="hljs-comment">dp[i]：从第i号点出发，最多能挖到的地雷个数（和方法二含义不同）</span><br><span class="hljs-comment">e.g.   dp[3]=20 表示 从3号点出发最多能挖到20个地雷</span><br><span class="hljs-comment">（2）所求目标</span><br><span class="hljs-comment">       max(dp[i])：   i:[1..n]， 需要找出dp[i]的最大值</span><br><span class="hljs-comment">（3）状态转换方程</span><br><span class="hljs-comment">dp[from] = w[from] + max(dp[to]);</span><br><span class="hljs-comment">（4）循环边界和循环顺序</span><br><span class="hljs-comment">from: [1..n-1]        n-1  --&gt;  1从右往左降序（方程是根据右边决定左边）</span><br><span class="hljs-comment">    to: [from+1..n]      from+1 &lt;--&gt; n增减均可</span><br><span class="hljs-comment">（5）状态初始化值和特例</span><br><span class="hljs-comment">dp[i] = w[i]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   本题两种方法，希望学生都要掌握，并认真体会如果获得pre[]和next[]，编写tonext()来表达和输出一条路径</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 201</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> w[N];         <span class="hljs-comment">// 每个点上具有的地雷，  w[3]=10 表示第3号点上有10个地雷</span><br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-type">int</span> next[N];      <span class="hljs-comment">// 最长路径中，当前点的下一个点编号</span><br><span class="hljs-type">bool</span> mapp[N][N];  <span class="hljs-comment">// 0-1邻接矩阵</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>( <span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i] );<br>        dp[i] = w[i];  <span class="hljs-comment">// 就算一条边都不走，最起码能够获得出发点的地雷个数</span><br>        next[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-keyword">while</span> ( <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), x != <span class="hljs-number">0</span> )<br>        mapp[x][y] = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 如果从点x能到点y，则mapp数组对应元素值标记为true</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> from = n<span class="hljs-number">-1</span>; from &gt;= <span class="hljs-number">1</span> ; from-- )   <span class="hljs-comment">// from的填写顺序是从右往左</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> to = from+<span class="hljs-number">1</span>; to&lt;=n; to++)      <span class="hljs-comment">// to的顺序可正可逆！ </span><br>            <span class="hljs-keyword">if</span> ( mapp[from][to] &amp;&amp; dp[from] &lt; w[from] + dp[to] ) &#123;<br>                dp[from] = w[from] + dp[to];<br>                <span class="hljs-comment">// 因为from是从右往左填写，所以此处敲定的应该是from号点的信息，而不是to号点的信息</span><br>                next[from] = to;   <span class="hljs-comment">// 此处只能用next[]，不能用pre[]来表示 </span><br>            &#125;<br>    <span class="hljs-comment">//找到maxx= max(dp[i])并找出其最长路径起点的下标值startpos</span><br>    <span class="hljs-type">int</span> startpos =<span class="hljs-number">1</span>, maxx = dp[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++ )<br>        <span class="hljs-keyword">if</span> ( dp[i] &gt; maxx )&#123;<br>            maxx = dp[i];<br>            startpos = i;<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, startpos); <span class="hljs-comment">//输出最长路径的第一个点下标值</span><br>    <span class="hljs-type">int</span> k = startpos;<br>    <span class="hljs-keyword">while</span> ( next[k] != <span class="hljs-number">0</span> )&#123;  <span class="hljs-comment">// 如果最长路径有下一个节点，就一直输出打印下一个节点</span><br>        k = next[k];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-%d&quot;</span>, k);<br>    &#125;<br>    <span class="hljs-comment">// 打印路径的权值和</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>, maxx);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="以当前点为终点">2.2.2.2以当前点为<font color="red"><strong>终点</strong></font></h4><ol type="1"><li>状态数组定义</li></ol><p>　　dp[i]表示以当前点<strong>为终点</strong>，最多能挖到的地雷个数</p><ol start="2" type="1"><li>所求目标</li></ol><p>　　最长路径的起点不一定是1号点，所以有： <spanclass="math display">\[max(dp[i])\quad(1\leq i \leq n)\]</span></p><ol start="3" type="1"><li>状态转移方程</li></ol><p>　　以上图中的5号点为例进行分析：从5号点为终点，最多能挖到的地雷个数，肯定与以3号点、4号点等以左侧点结束而挖到的地雷数密切相关。只要左侧的dp值确定，则dp[5]可以很容易算出。所以有：<span class="math display">\[dp[to]=w[to] + max(dp[from]) \quad(from:mapp[from][to]!=INF)\]</span></p><ol start="4" type="1"><li>循环顺序和边界</li></ol><p>　　to: 1 ----&gt; n 正序（左侧点的dp值先算，根据左侧填右侧）</p><p>　　from： 1 &lt;---&gt; to-1正序、逆序均可（只要筛完to的所有逆邻接点就行，什么顺序不重要）</p><ol start="5" type="1"><li>特例</li></ol><p>　　因为to必须从左往右填写，所以dp[1]必须是已知的特定值。根据dp[]的定义，我们可以知道，以1号点结束的路径，其左端肯定是没有节点的。所以该路径只能包含1号点自己。</p><p>　　故有dp[1]=w[1]。</p><ol start="6" type="1"><li>初始化值</li></ol><p>　　初始化方法和2.2.2.1节中的处理是一样的。此处不再赘述。　　</p><ol start="7" type="1"><li>路径输出</li></ol><p>　　1）路径如何表示或记录？</p><p>　　因为外层循环变量to是从左往右填写的，而from在其左侧，所以<strong>只能用pre[to]=from的方式来记录</strong>，而不能用next[from]=to来记录。<strong>同学们可以配合着2.1.2节第8点中的分析来学习，体会两种情况下的不同处理方式，归纳总结好。</strong></p><p>　　2）最长路径如何输出？</p><p>　　鉴于pre[]的定义，所以应找到最长路径的终点。鉴于dp[]的基本定义，我们可以先找到max(dp[1..n])，然后从该点位置开始，不断去pre，就可以了。方法可以采用递归函数来实现。</p><ol start="8" type="1"><li>AC代码</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">方法二： 用dp动态规划，dp[]含义和路径表示及推导的方法一刚好相反</span><br><span class="hljs-comment">（1）状态数组定义</span><br><span class="hljs-comment">dp[i]：从任意点出发到第i号点结束，最多能挖到的地雷个数（和方法一含义不同）</span><br><span class="hljs-comment">e.g.   dp[3]=20 表示从任意点出发到3号点结束，最多能挖到20个地雷</span><br><span class="hljs-comment">（2）所求目标</span><br><span class="hljs-comment">       max(dp[i])：   i:[1..n]， 需要找出dp[i]的最大值</span><br><span class="hljs-comment">（3）状态转换方程</span><br><span class="hljs-comment">dp[to] = w[to] + max(dp[from]);</span><br><span class="hljs-comment">（4）循环边界和循环顺序</span><br><span class="hljs-comment">    to:   [1..n] 1 &lt;--&gt; n必须增序（方程是根据左边决定右边）</span><br><span class="hljs-comment">    from: [1..to-1]        1 &lt;--&gt; to-1    增减均可</span><br><span class="hljs-comment">（5）状态初始化值和特例</span><br><span class="hljs-comment">dp[i] = w[i]</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 201</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> w[N];       <span class="hljs-comment">// 每个点上具有的地雷，  w[3]=10 表示第3号点上有10个地雷</span><br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-type">int</span> pre[N];     <span class="hljs-comment">// 权值和最长的路径中，当前点的上一个点编号</span><br><span class="hljs-type">int</span> next[N];<br><span class="hljs-type">bool</span> mapp[N][N];<br><span class="hljs-comment">// 根据pre[]数组来得到next[]数组的值，以方便后续输出打印</span><br><span class="hljs-comment">// 注意递归函数的写法，本函数中“先递归，后特例”，这是有向路径从尾到头倒序访问的标准做法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tonext</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br><span class="hljs-comment">// 先递归</span><br><span class="hljs-type">int</span> pp = pre[k];<br><span class="hljs-keyword">if</span> ( pp != <span class="hljs-number">0</span> )  <span class="hljs-comment">// 如果最长路径有下一个节点，就一直输出打印下一个节点</span><br><span class="hljs-built_in">tonext</span>( pre[k] );<br><span class="hljs-comment">// 后特例</span><br>next[ pp ] = k; <span class="hljs-comment">//输出最长路径的第一个点下标值</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">1</span>; i&lt;= n; i++) &#123;<br><span class="hljs-built_in">scanf</span>( <span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i] );<br>dp[i] = w[i];  <span class="hljs-comment">// 就算一条边都不走，最起码能够获得出发点的地雷个数</span><br>pre[i] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> x, y;<br><span class="hljs-keyword">while</span> ( <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), x != <span class="hljs-number">0</span> )<br>mapp[x][y] = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 如果从点x能到点y，则mapp数组对应元素值标记为true</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> to=<span class="hljs-number">2</span>; to&lt;=n; to++)    <span class="hljs-comment">// 从1开始也可以，反正是会空转 </span><br><span class="hljs-comment">// 根据不同的from来决定dp[to]的值，决定出pre[to]的值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> from=<span class="hljs-number">1</span>; from&lt;=to<span class="hljs-number">-1</span>; from++) &#123;<br><span class="hljs-comment">// from点必须是指向to点的弧尾点，即mapp[from][to]要==true</span><br><span class="hljs-keyword">if</span>( mapp[from][to] &amp;&amp;  dp[to] &lt; dp[from] + w[to] ) &#123;<br>dp[to] = dp[from] + w[to];<br><span class="hljs-comment">// 既然是根据左侧来决定右侧的值，next[from]=to这样写在此处，</span><br><span class="hljs-comment">// 无法确定出next[from]的最终值，所以next[from]=to这个写法就不正确了！</span><br><span class="hljs-comment">// 此处必须要用pre[]这样写，。后续需要根据pre[]来决定next[]的值！</span><br>pre[to] = from;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//找到maxx= max(dp[i])并找出其最长路径的终点下标值startpos</span><br><span class="hljs-type">int</span> lastpos =<span class="hljs-number">1</span>, maxx = dp[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (  i = <span class="hljs-number">2</span>; i &lt;= n; i++ )<br><span class="hljs-keyword">if</span> ( dp[i] &gt; maxx ) &#123;<br>maxx = dp[i];<br>lastpos = i;<br>&#125;<br>    <span class="hljs-comment">// 根据pre[]计算出next[]的值，以方便输出</span><br><span class="hljs-built_in">tonext</span>(lastpos);<br><span class="hljs-comment">//根据next[]来输出路径</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, next[<span class="hljs-number">0</span>]);<br><span class="hljs-type">int</span> k = next[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">while</span> ( next[k] != <span class="hljs-number">0</span> ) &#123;<br>k = next[k];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-%d&quot;</span>, k);<br>&#125;<br><span class="hljs-comment">// 打印路径的权值和</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d\n&quot;</span>, maxx);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p2196-挖地雷">2.3 P2196 挖地雷</h2><h3 id="原题链接-2">2.3.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P2196">P2196 [NOIP1996提高组] 挖地雷</a></p><h3 id="分析-2">2.3.2 分析</h3><p>　　本题和1262高度相似，只是图的录入方式稍有变化。本题可作为同学们复习巩固1262的一个题，稍等一段时间再来复习，效果会更好。</p><h3 id="ac代码-1">2.3.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 模型提炼： 求整个有向图中的最长路径的长度值，不规定起点和终点。</span><br><span class="hljs-comment">// 1262 和P2196是高度类似的题，只是图的输入方式不同，图结点规模不同</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">方法一： 用dp动态规划</span><br><span class="hljs-comment">（1）状态数组定义</span><br><span class="hljs-comment">dp[i]：从第i号点出发，最多能挖到的地雷个数（和方法二含义不同）</span><br><span class="hljs-comment">e.g.   dp[3]=20 表示 从3号点出发最多能挖到20个地雷</span><br><span class="hljs-comment">（2）所求目标</span><br><span class="hljs-comment">       max(dp[i])：   i:[1..n]， 需要找出dp[i]的最大值</span><br><span class="hljs-comment">（3）状态转换方程</span><br><span class="hljs-comment">dp[from] = w[from] + dp[to];</span><br><span class="hljs-comment">（4）循环边界和循环顺序</span><br><span class="hljs-comment">from: [1..n-1]        n-1  --&gt; 1从右往左降序（方程是根据右边决定左边）</span><br><span class="hljs-comment">   to: [from+1..n] from+1 &lt;--&gt; n增减均可</span><br><span class="hljs-comment">（5）状态初始化值和特例</span><br><span class="hljs-comment">dp[i] = w[i]</span><br><span class="hljs-comment">   本题两种方法，希望学生都要掌握，并认真体会如果获得pre[]和next[]，编写tonext()来表达和输出一条路径</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 201</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> w[N];       <span class="hljs-comment">// 每个点上具有的地雷，  w[3]=10 表示第3号点上有10个地雷</span><br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-type">int</span> next[N];    <span class="hljs-comment">// 权值和最长的路径中，当前点的下一个点编号</span><br><span class="hljs-type">bool</span> mapp[N][N];  <span class="hljs-comment">// 0-1邻接矩阵</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-comment">// 录入原始数据，每个点上的地雷个数（给每个点赋权值）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>( <span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i] );<br>        dp[i] = w[i];  <span class="hljs-comment">// 就算一条边都不走，最起码能够获得出发点的地雷个数</span><br>        next[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-comment">// 录入 弧的关系，根据题意，不用考虑 r &lt; c 的情况</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r=<span class="hljs-number">1</span>; r&lt;=n; r++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c=r+<span class="hljs-number">1</span>; c&lt;=n; c++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>            mapp[r][c] = x;<br>        &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> from = n<span class="hljs-number">-1</span>; from &gt;= <span class="hljs-number">1</span> ; from-- )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> to = from+<span class="hljs-number">1</span>; to&lt;=n; to++)<br>            <span class="hljs-keyword">if</span> ( mapp[from][to] &amp;&amp; dp[from] &lt; w[from] + dp[to] ) &#123;<br>                dp[from] = w[from] + dp[to];<br>                <span class="hljs-comment">// 外层循环变量是from，故此处左侧应该是from </span><br>                next[from] = to;<br>            &#125;<br>    <span class="hljs-comment">//找到maxx= max(dp[i])并找出其最长路径起点的下标值startpos</span><br>    <span class="hljs-type">int</span> startpos =<span class="hljs-number">1</span>, maxx = dp[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++ )<br>        <span class="hljs-keyword">if</span> ( dp[i] &gt; maxx )&#123;<br>            maxx = dp[i];<br>            startpos = i;<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, startpos); <span class="hljs-comment">//输出最长路径的第一个点下标值</span><br>    <span class="hljs-type">int</span> k = startpos;<br>    <span class="hljs-keyword">while</span> ( next[k] != <span class="hljs-number">0</span> )&#123;  <span class="hljs-comment">// 如果最长路径有下一个节点，就一直输出打印下一个节点</span><br>        k = next[k];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>, k);<br>    &#125;<br>    <span class="hljs-comment">// 打印路径的权值和</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>, maxx);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">//#include &lt;cstdio&gt;</span><br><span class="hljs-comment">//#include &lt;cstring&gt;</span><br><span class="hljs-comment">//#include &lt;iostream&gt;</span><br><span class="hljs-comment">//using namespace std;</span><br><span class="hljs-comment">///*</span><br><span class="hljs-comment">//方法二： 用dp动态规划，dp[]含义和路径表示及推导的方法一刚好相反</span><br><span class="hljs-comment">//（1）状态数组定义</span><br><span class="hljs-comment">//dp[i]：从任意点出发到第i号点结束，最多能挖到的地雷个数（和方法一含义不同）</span><br><span class="hljs-comment">//e.g.   dp[3]=20 表示从任意点出发到3号点结束，最多能挖到20个地雷</span><br><span class="hljs-comment">//（2）所求目标</span><br><span class="hljs-comment">//       max(dp[i])：   i:[1..n]， 需要找出dp[i]的最大值</span><br><span class="hljs-comment">//（3）状态转换方程</span><br><span class="hljs-comment">//dp[to] = w[to] + dp[from];</span><br><span class="hljs-comment">//（4）循环边界和循环顺序</span><br><span class="hljs-comment">//   to: [1..n] 1 &lt;--&gt; n必须增序（方程是根据左边决定右边）</span><br><span class="hljs-comment">//from: [1..to-1]    1 &lt;--&gt; to-1增减均可</span><br><span class="hljs-comment">//（5）状态初始化值和特例</span><br><span class="hljs-comment">//dp[i] = w[i]</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//*/</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//#define N 201</span><br><span class="hljs-comment">//#define INF 0x7f7f7f7f</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//int n;</span><br><span class="hljs-comment">//// 每个点上具有的地雷，  w[3]=10 表示第3号点上有10个地雷</span><br><span class="hljs-comment">//int w[N];</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//int dp[N];</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//// 权值和最长的路径中，当前点的上一个点编号</span><br><span class="hljs-comment">//int pre[N];</span><br><span class="hljs-comment">//int next[N];</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//bool mapp[N][N];</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//// 根据pre[]数组来得到next[]数组的值，以方便后续输出打印</span><br><span class="hljs-comment">//// 注意递归函数的写法，本函数中“先递归，后特例”，这是有向路径从尾到头倒序访问的标准做法</span><br><span class="hljs-comment">//void tonext(int k) &#123;</span><br><span class="hljs-comment">//// 先递归</span><br><span class="hljs-comment">//int pp = pre[k];</span><br><span class="hljs-comment">//if ( pp != 0 )  // 如果最长路径有下一个节点，就一直输出打印下一个节点</span><br><span class="hljs-comment">//tonext( pre[k] );</span><br><span class="hljs-comment">//// 后特例</span><br><span class="hljs-comment">//next[ pp ] = k; //输出最长路径的第一个点下标值</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//int main() &#123;</span><br><span class="hljs-comment">//int i;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//scanf(&quot;%d&quot;, &amp;n);</span><br><span class="hljs-comment">//// 录入原始数据，每个点上的地雷个数（给每个点赋权值）</span><br><span class="hljs-comment">//for ( i = 1; i&lt;= n; i++) &#123;</span><br><span class="hljs-comment">//scanf( &quot;%d&quot;, &amp;w[i] );</span><br><span class="hljs-comment">//dp[i] = w[i];  // 就算一条边都不走，最起码能够获得出发点的地雷个数</span><br><span class="hljs-comment">//pre[i] = 0;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//int x;</span><br><span class="hljs-comment">//// 录入 弧的关系，根据题意，不用考虑 r &lt; c 的情况</span><br><span class="hljs-comment">//for (int r=1; r&lt;=n; r++)</span><br><span class="hljs-comment">//for (int c=r+1; c&lt;=n; c++)&#123;</span><br><span class="hljs-comment">//scanf(&quot;%d&quot;, &amp;x);</span><br><span class="hljs-comment">//mapp[r][c] = x;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//for(int to=2; to&lt;=n; to++)</span><br><span class="hljs-comment">//// 根据不同的from来决定dp[to]的值，决定出pre[to]的值</span><br><span class="hljs-comment">//for(int from=1; from&lt;=to-1; from++) &#123;</span><br><span class="hljs-comment">//// from点必须是指向to点的弧尾点，即mapp[from][to]要==true</span><br><span class="hljs-comment">//if( mapp[from][to] &amp;&amp;  dp[to] &lt; dp[from] + w[to] ) &#123;</span><br><span class="hljs-comment">//dp[to] = dp[from] + w[to];</span><br><span class="hljs-comment">//// 既然是根据左侧来决定右侧的值，next[from]=to这样写在此处，</span><br><span class="hljs-comment">//// 无法确定出next[from]的最终值，所以next[from]=to这个写法就不正确了！</span><br><span class="hljs-comment">//// 此处必须要用pre[]这样写，。后续需要根据pre[]来决定next[]的值！</span><br><span class="hljs-comment">//pre[to] = from;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">////找到maxx= max(dp[i])并找出其最长路径的终点下标值startpos</span><br><span class="hljs-comment">//int lastpos =1, maxx = dp[1];</span><br><span class="hljs-comment">//for (  i = 2; i &lt;= n; i++ )</span><br><span class="hljs-comment">//if ( dp[i] &gt; maxx ) &#123;</span><br><span class="hljs-comment">//maxx = dp[i];</span><br><span class="hljs-comment">//lastpos = i;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//    // 根据pre[]计算出next[]的值，以方便输出</span><br><span class="hljs-comment">//tonext(lastpos);</span><br><span class="hljs-comment">////根据next[]来输出路径</span><br><span class="hljs-comment">//printf(&quot;%d&quot;, next[0]);</span><br><span class="hljs-comment">//int k = next[0];</span><br><span class="hljs-comment">//while ( next[k] != 0 ) &#123;</span><br><span class="hljs-comment">//k = next[k];</span><br><span class="hljs-comment">//printf(&quot;-%d&quot;, k);</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//// 打印路径的权值和</span><br><span class="hljs-comment">//printf(&quot;\n%d\n&quot;, maxx);</span><br><span class="hljs-comment">//return 0;</span><br><span class="hljs-comment">//&#125;   </span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 线性DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>普通的01背包问题</title>
      <link href="/2024/05/04/%E6%99%AE%E9%80%9A%E7%9A%8401%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2024/05/04/%E6%99%AE%E9%80%9A%E7%9A%8401%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><p>　　背包问题是动态规划中的一个大类知识点，也是csp的普及组或提高组几乎必考的内容，非常重要。要学习背包问题，<strong>首先需要必须掌握递推、递归，</strong>同时强烈建议也掌握深搜、广搜、贪心、分治等。<strong>背包问题具有较强的模板特性，所以这部分的内容是可以通过多个不同的模板来快速拿下的。</strong>希望同学们务必认真学习每个题型及其变化和拓展。</p><p>　　因为这个大类知识点具有较强的模板性，所以<strong>强烈建议同学们在学习模板时对分析流程（7点步骤）和变量命名规则进行固化，以应对变化各异的应用</strong>。不必理睬题目中五花八门的变量命名，而统一采用一套命名规则来写代码，以方便自己在以后的复习和归纳总结。具体的命名规则请参看本帖以及后面关于背包问题的AC代码的命名规则。</p><h2 id="模型引入和变量命名规则约定">1.1 模型引入和变量命名规则约定</h2><p>　　背包问题主要求解的是<strong>带约束的收益最优化问题</strong>。其所使用的方法主要就是递推填表，用动态规则的方法来解决。而01背包问题则是背包问题的入门题型。</p><p>　　有一个总装量为YS1（约束1，<strong>y</strong>ue<strong>s</strong>hu，取两个字的拼音首字母ys）的背包，有n个可待选择的物品需要装入，每个物品<strong>只有一件</strong>，它们都有各自的重量和价值，你需要从中选择合适的组合来使得你背包中的物品总价值最大（<strong>每个物品不能拆分，且不需要刚好装满，允许不"刚好"装满</strong>）</p><p>　　上面这段就是普通01背包最常见的题面。强烈要求每个同学都按照下面的命名规则来写代码：</p><ul><li>背包一共能装多少斤的物品，在本题中这是总约束（<strong>命名为YS1</strong>，区别于以后的二维费用背包，第二维总约束可以命名为YS2，注意全大写表示总量）。</li><li>第<span class="math inline">\(\ i\ (1 \leq i \leqn)\)</span>个物品的“重量”是约束量，命名为ys1[i]。可能有些同学对这种命名不太适应，但其实在后续题型中可能会出现“每个物品有多个属性都是约束量”，故可能出现ys2[i]、ys3[i]等）。而且物品的重量并不绝对就是约束量，可能在其他题中重量变成是收益。所以，同学们不要固化自己的思维，不要根据物品属性来决定，而必须要根据抽象出来的题型来决定谁是约束、谁是收益。</li><li>第<span class="math inline">\(\ i\ (1 \leq i \leqn)\)</span>个物品的“价值”是收益量，命名为value[i]。</li><li>状态数组命名统一为dp[]或者dp[][]等。</li></ul><h2 id="dp和深搜贪心等的关系分析">1.2 dp和深搜、贪心等的关系分析</h2><p>　　为了方便下面的阐述，我们可以假定一些样例数据来帮我们更方便准确地说明问题。</p><p>　　现在假设背包总容量为YS1=10斤，有n=4个物品，重量ys1[]和价格value[]分别如下：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240510093216861.png" /></p><h3 id="为什么不能用暴力深搜">1.2.1 为什么不能用暴力深搜</h3><p>　　4个物品，每个物品都有“选择”和“不选择”两种结果，故一共有<spanclass="math inline">\(2^4=16\)</span>种结果。如果用暴力深搜的方法把16种结果一一枚举，时间复杂度呈现指数级增长，一旦n较大，即使能够及时剪枝，复杂度仍然很大。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240510134036335.png" alt="image-20240510134036335" style="zoom:60%;" /></p><h3 id="为什么不能用贪心算法">1.2.2 为什么不能用贪心算法</h3><p>　　可能有些同学会认为，对于n个物品，按照性价比进行排序，然后依次选择，直到装不下为止。这就是贪心算法的思路。但实际上这种做法是错误的。性价比并不能完全等价于总价值。</p><p>　　下面举个例子：假设背包容量为10斤，3个物品分别为A：6斤8元，B：5斤5元，C：5斤5元。如果按照性价比来排序，物品A的性价比最高，应该先选择物品A装入背包。然后，就没有然后了，因为剩下4斤容量，装不下任何第二个物品了。这种“装入A”的方案，总价值就为8元。</p><p>　　但如果选择不装A而装B和C，则总价值为5+5=10元。所以最优方案是“装BC”。</p><p>　　那贪心算法的问题出在哪里呢？问题就出在“物品不可分割”。在“装入A”的方案中，当只剩4斤容量时，如果物品可分割，那么大可以把物品B切下4斤来装入，就能达到最大价值8+4=12元。“<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1225">1225：金银岛</a>”就可以用贪心算法破解。但现在因为不可分割，没，为了贪那一点点的性价比，结果让背包空闲浪费了4斤的容量没有装任何物品，从而使得整个方案低效。</p><h2 id="标准状态数组">1.3 标准状态数组</h2><h3 id="六步分析">1.3.1 六步分析</h3><ol type="1"><li><p>状态数组定义</p><p>　　dp[i][j]：代表当背包的总容量为 j 时，前 i个物品选择一部分物品放入后，背包内物品的最大总价值；</p></li><li><p>所求目标</p><p>　　dp[n][YS1]：代表背包的总容量为YS1时，前 n个物品选择一部分物品放入后，背包内物品的最大总价值；</p></li><li><p>状态转移方程</p><p>我们这里暂时假设从1到n，依次考虑每个物品。（有些时候我们必须要逆序来考虑，请参看《求背包问题的具体方案》。初学的同学暂时可以不看）</p><p>对于第i个物品：</p></li></ol><ul><li><p>1）如果背包的总容量j不足以容纳第i个物品，此时“心有余而力不足”，只能被迫放弃第i个物品，价值没有一点增加。所以有：<span class="math display">\[dp[i][j]=dp[i-1][j] \tag{1}\]</span></p></li><li><p>2）如果背包的总容量j能够容纳第i个物品，此时可以有两种选择：“装”或者“不装”第i个物品。此时需要进行比较判断，因为装了当前的第i个物品，不一定能使最后组合达到最大价值。</p><ul><li><p>a)如果<strong>能装但不装</strong>第i个物品，则有:</p><p><span class="math display">\[dp[i][j]=dp[i-1][j] \tag{2}\]</span>　　既然决定不装入第i个物品，那么总价值不会增加，仍然和“前i-1个物品对于总容量j的策略”是一致的。</p></li><li><p>b)如果<strong>能装且装入</strong>第i个物品，则有:</p><p><span class="math display">\[dp[i][j]=dp[i-1][j-ys1[i]]+value[i] \tag{3}\]</span> 　　为什么会有这样的等式呢？</p><p>　　如果已经处理完前i-1个物品，且总容量没有超过j-ys1[i]，其最大总价值为dp[i-1][j-ys1[i]]。在这种情况下，选择装入第i个物品，那么总容量不会超过j-ys1[i]+ys1[i]=j，而总价值为dp[i-1][j-ys1[i]]+value[i]。</p><p>　　我们可以从公式（2）和（3）中选择较大值，来作为情况2）的决策。</p></li></ul></li></ul><p>　　综上情况1）和情况2），则有状态转移方程为： <spanclass="math display">\[dp[i][j]=\begin{cases}dp[i-1][j] &amp; (j&lt;ys1[i]) \\max(\ dp[i-1][j], \quad dp[i-1][j-ys1[i]]\ +\ value[i]\ ) &amp; (j\geqys1[i])\end{cases} \tag{4}\]</span></p><ol start="4" type="1"><li><p>循环顺序和边界</p><ul><li><p>i：1 -----&gt; n 只能增序</p></li><li><p>j：0 <font color ="red"><strong>&lt;-----&gt;</strong> </font>YS1<strong>增序、降序都可以</strong></p><p>　　虽然第j列的数据需要来自于第j-ys1[i]列，但却是上一排的第j-ys1[i]列。所以，只要上一排的数据全部已知，那么对于当前第i排，从左往右填写，或者从右往左填写，都是正确的！</p></li></ul></li><li><p>特例</p><p>　　当i=1时，i-1=0，所以需要把第0行当做特例来处理。当任何物品都还没处理时，总价值肯定是0，故有</p><p>dp[0][0..YS1]=0。</p></li><li><p>初始化值</p><p>　　从转移方程可以看出，dp数组的每个值都来自于以前的dp值或者value数组，会被完整覆盖。所以dp数组可以不初始化。一个简单做法就是“将dp数组定义为全局数组，自动初始化为全0”。这样也能自动搞定特例。</p></li></ol><h3 id="关键代码">1.3.2 关键代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)            <span class="hljs-comment">// 针对每1个物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)   <span class="hljs-comment">// 背包剩余空间j，注意，j的取值范围是[0, YS1]</span><br>     <span class="hljs-comment">//for(int j=YS1; j&gt;=0; --j)   // 正反序，在普通01背包中，都是可以的 </span><br><span class="hljs-comment">// 如果背包剩余空间够放第i个物品， </span><br><span class="hljs-keyword">if</span> ( ys1[i] &lt;= j )<br><span class="hljs-comment">// 需要判断放与不放，到底哪个更划算！ </span><br>dp[i][j]= <span class="hljs-built_in">max</span>( dp[i<span class="hljs-number">-1</span>][j-ys1[i]] + value[i],  dp[i<span class="hljs-number">-1</span>][j]);<br><span class="hljs-keyword">else</span><br><span class="hljs-comment">// 如果背包剩余空间不够放第i个物品，然并卵，肯定就不放进去了哈！上下照抄不变 </span><br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j]; <br></code></pre></td></tr></table></figure><p>　　需要注意一下的就是，内层循环的代码也可以写成如下的形式，是等效的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 背包剩余空间j，注意，j的取值范围是[0, YS1]</span><br>           dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];   <span class="hljs-comment">// 不管三七二十一，先照抄上一行的数据下来</span><br><span class="hljs-keyword">if</span> ( ys1[i] &lt;= j )       <span class="hljs-comment">// 如果背包剩余空间够放第i个物品， </span><br><span class="hljs-comment">// 需要判断放与不放，到底哪个更划算！ 此时赋值式右侧的dp[i][j]值实际上是dp[i-1][j]值</span><br>dp[i][j]= <span class="hljs-built_in">max</span>( dp[i][j], dp[i<span class="hljs-number">-1</span>][j-ys1[i]] + value[i]);<br>      &#125;<br></code></pre></td></tr></table></figure><h3 id="决策输出">1.3.3 决策输出</h3><p>　　我们可以以1267这个题为例来做分析决策。其样例数据对应的dp[][]初始化值如下图所示。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240510162522771.png" /></p><p>　　为了巩固对状态转移方程公式的理解深度，同学们可以自行拿出草稿纸来填写该表的所有数据，模拟程序实现过程，强化理解填表的步骤。其正确答案如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240510163109884.png" alt="image-20240510163109884" style="zoom:80%;" /></p><p>　　从这张表中我们可以看出，dp[4][10]=12元，是本样例的答案。但如果我想知道到底选择了哪些物品？该如何解决这个问题呢？</p><p>　　其实标准状态数组已经给我们暗示出了所有的决策。</p><ol type="1"><li>dp[4][10]=12元 !=9元=dp[3][10]，所以必然是因为选择了物品4。因为物品4重7斤，所以从当前的10斤扣除物品4的7斤，还剩3斤，找到dp[3][3]。</li><li>因为dp[3][3]=3=dp[2][3]，上下格子的值相等，这说明没有选择第3个物品。</li><li>因为dp[2][3]=3!=1=dp[1][3]，上下格子的值不相等，这说明选择了第2个物品。因为物品2重3斤，所以从当前的3斤扣除物品2的3斤，还剩0斤，找到dp[1][0]。</li><li>因为dp[1][0]=0=dp[0][0]，上下格子的值相等，这说明没有选择第1个物品。</li></ol><p>　　结论：选择了第2、4个物品，总重量10斤，总价值12元。</p><ul><li><p>如果从当前行往 <font color ="red"><strong>上</strong></font>走，说明<font color ="red"><strong>不选</strong></font>当前行的物品；</p></li><li><p>如果从当前行往 <font color ="green"><strong>左上</strong></font>走，说明 <font color ="green"><strong>选</strong></font>当前行的物品。</p></li></ul><h3 id="复杂度分析">1.3.4 复杂度分析</h3><p>　　上述的标准状态数组的AC代码，影响程序时间复杂度的关键在于那个二重for，复杂度为<spanclass="math inline">\(O(n*YS1)\)</span>，空间复杂度为状态数组的容量，也是<spanclass="math inline">\(O(n*YS1)\)</span>。</p><h2 id="滚动数组压缩数组">1.4 滚动数组/压缩数组</h2><p>　　从1.3.4节可以看到，标准状态数组的解法需要空间复杂度为<spanclass="math inline">\(O(n*YS1)\)</span>。当YS1较大时，可能会造成整个程序MLE。我们在本节提出“滚动状态数组”（有的地方也叫做“压缩状态数组”）的概念，并对空间复杂度进行优化，而时间复杂度不变。</p><p>　　从1.3.3节中的图上可以看到，表里大部分的内容都是上下照抄，并没有发生值的改变，这表示存在空间精简压缩的可能性。仔细观察上一节的填表过程，我们填写每一个网格（第i行，第j列）的数据时，都只依赖于第i-1行的数据，而不需要访问第i-2行、i-3行等。为了更直观的理解，下面再画一张图，并以i=3为例，详细展示一维数组的更新细节：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240511112403158.png" style="zoom:150%;" /></p><p>　　在填写一趟一维数组时，需要从右往左更新每个格子的数据。因为更新需要读取当前位置左侧的旧数据来进行比对，此时旧数据尚未被更新，仍然存储的是“上一行”的数据，所以这种更新是没有问题的。只是需要注意，这里必须只能“从右往左”更新每个格子！</p><p>因此，我们可以将求解空间进行优化，将二维数组压缩成一维数组。</p><h3 id="六步分析-1">1.4.1 六步分析</h3><ol type="1"><li><p>状态数组定义</p><p>　　dp[j]：代表当背包的总容量为 j时，前若干个物品选择一部分物品放入后，背包内物品的最大总价值；</p></li><li><p>所求目标</p><p>　　dp[YS1]：代表背包的总容量为YS1时，前若干个物品选择一部分物品放入后，背包内物品的最大总价值；</p></li><li><p>状态转移方程</p><p>对于第i个物品：</p></li></ol><ul><li>原有的状态转移方程为：</li></ul><p><span class="math display">\[dp[i][j]=\begin{cases}dp[i-1][j] &amp; (j&lt;ys1[i]) \\max(\ dp[i-1][j], \quad dp[i-1][j-ys1[i]]\ +\ value[i]\ ) &amp; (j\geqys1[i])\end{cases} \tag{1}\]</span></p><ul><li>经过滚动状态数组设计后的状态转移方程为：</li></ul><p><span class="math display">\[\begin{align*}dp[j]&amp;=\begin{cases}dp[j] &amp; (j&lt;ys1[i]) \\max(\ dp[j], \quad dp[j-ys1[i]]\ +\ value[i]\ ) &amp; (j\geq ys1[i])\end{cases} \tag{2}\\\end{align*}\]</span></p><ol start="4" type="1"><li><p>循环顺序和边界</p><ul><li><p>i： 1 -----&gt; n 只能增序</p></li><li><p>j： ys1[i] <font color ="red"><strong>&lt;-----</strong></font>YS1 <strong>只能降序</strong></p><ul><li><p>1）为什么必须降序？</p><p>　　dp[j]的更新需要读取dp[j-ys1[i]]，但要求dp[j-ys1[i]]必须是旧数据（因为（1）式中是<spanclass="math inline">\(dp[i-1][j-ys1[i]]\)</span>，是第i-1行的，是旧数据）。所以dp[j]必须比dp[j-ys1[i]]先更新，即必须从右往左更新。</p></li><li><p>2）从右往左，只需要到ys1[i]就可以了。为什么不能到0呢？</p><p>　　原因很简单，因为当j在[0..ys1[i]-1]这个范围内时，根据公式（2）有dp[j]=dp[j]。这实际上是一句废话，意思就是“什么都不需要做”。既然什么都不做，那干嘛还循环这个范围？所以只需要循环到ys1[i]就行了。</p><p>　　从另一个角度来思考，在公式（2）中的dp[j-ys1[i]]，当j&lt;ys1[i]时，j-ys1[i]&lt;0，这下标怎么能小于0？那还不乱套，爆一个RE？</p></li></ul></li></ul></li><li><p>特例</p><p>　　dp[0]=0</p></li><li><p>初始化值</p><p>　　在标准状态数组中的特例是dp[0][0..YS1]=0，所以在滚动状态数组结构下的特例应该是dp[0..YS1]=0。</p></li></ol><h3 id="关键代码-1">1.4.2 关键代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)  <span class="hljs-comment">// 针对每1个物品</span><br>    <span class="hljs-comment">// 这里j应该从右往左推，千万要注意！！注意是&gt;=ys1[i]截止，因为下标[j-ys1[i]]不可能为负数！</span><br>    <span class="hljs-comment">// 对于那些小于ys1[i]的j，在这里就不去处理（默认等于前值）了，也就是说，等效于dp[i][j] = dp[i-1][j]了！</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)<br>        <span class="hljs-comment">// 需要判断放与不放，到底哪个更划算！</span><br>        dp[j] = <span class="hljs-built_in">max</span>( dp[j - ys1[i]] + value[i],  dp[j]);<br></code></pre></td></tr></table></figure><p>　　需要注意一下的就是，第17～19行代码也可以写成如下的形式，是等效的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)  <span class="hljs-comment">// 针对每1个物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)<br><span class="hljs-keyword">if</span> (j &gt;= ys1[i])<br>            dp[j] = <span class="hljs-built_in">max</span>( dp[j - ys1[i]] + value[i],  dp[j]);<br></code></pre></td></tr></table></figure><h3 id="决策输出-1">1.4.3 决策输出</h3><p>　　以1267这个题为例来看，其标准状态数组的值如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240510163109884.png" alt="image-20240510163109884" style="zoom:80%;" /></p><p>　　如果改为滚动数组后，只剩最底层一排的数值，无法找其他排数据，自然也无法找到决策。　　</p><h3 id="复杂度分析-1">1.4.4 复杂度分析</h3><p>　　影响程序时间复杂度的关键在于那个二重for，复杂度为<spanclass="math inline">\(O(n*YS1)\)</span>，空间复杂度为<spanclass="math inline">\(O(YS1)\)</span>。</p><h2 id="其他重要资料学习">1.5 其他重要资料学习</h2><p>　　如果对上述资料学习之后，还觉得不够尽兴的，可以看下面的资料。</p><h3 id="视频链接">1.5.1 视频链接</h3><p>　　<ahref="https://www.bilibili.com/video/BV1kp4y1e794/?spm_id_from=333.999.0.0&amp;vd_source=0e7cc4e4bbbb67e5c3c2a3e7d967f075">E08【模板】背包DP01背包</a></p><h3 id="背包九讲">1.5.2 背包九讲</h3><p>　　非常经典牛逼的“背包九讲”，请看<a href="https://www.kancloud.cn/kancloud/pack/70124" target="_blank">这里</a>。</p><h1 id="二实战训练">二、实战训练</h1><h2 id="背包问题">2.1 1267 01背包问题</h2><h3 id="原题链接">2.1.1 原题链接</h3><h3 id="例9.1101背包问题">　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1267">1267：【例9.11】01背包问题</a></h3><h3 id="ac代码">2.1.2 AC代码</h3><h4 id="标准状态数组版本">2.1.2.1 标准状态数组版本</h4><p>　　时间复杂度：<spanclass="math inline">\(O(n*YS1)=30*200=6000\)</span></p><p>　　空间复杂度：<spanclass="math inline">\(O(n*YS1)=30*200=6000\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 0-1背包模型， 二维dp[][]， 的解法！</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 31</span><br><span class="hljs-comment">// dp[5][100] = 50  前5个物品装在背包容量为100斤的背包中的最大价值为50元</span><br><span class="hljs-type">int</span> dp[N][<span class="hljs-number">201</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i, YS1, n;<br>    <span class="hljs-type">int</span> ys1[N], value[N];<br>    <span class="hljs-comment">// 输入背包总重量YS1限制，及提供的物品总个数n</span><br>    cin &gt;&gt;YS1 &gt;&gt;n;<br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        cin &gt;&gt;ys1[i] &gt;&gt;value[i];<br><br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)            <span class="hljs-comment">// 针对每1个物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)   <span class="hljs-comment">// 背包剩余空间j，注意，j的取值范围是[0, YS1]</span><br>            <span class="hljs-comment">//for(int j=YS1; j&gt;=0; --j)   // 正反序，在标准状态数组中，都是可以的</span><br>            <span class="hljs-keyword">if</span> ( ys1[i] &lt;= j )<br>                dp[i][j]= <span class="hljs-built_in">max</span>( dp[i<span class="hljs-number">-1</span>][j-ys1[i]] + value[i],  dp[i<span class="hljs-number">-1</span>][j]);<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 如果背包剩余空间不够放第i个物品，然并卵，肯定就不放进去了哈！上下照抄不变</span><br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br><br>    cout &lt;&lt;dp[n][YS1];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="滚动状态数组版本">2.1.2.2<font color="red">滚动</font>状态数组版本</h4><p>　　时间复杂度：<spanclass="math inline">\(O(n*YS1)=30*200=6000\)</span></p><p>　　空间复杂度：<span class="math inline">\(O(YS1)=200\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//0-1背包，一维dp[] 的解法</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 31</span><br><span class="hljs-type">int</span> YS1, n;<br><span class="hljs-type">int</span> ys1[N], value[N];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">201</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 输入背包总重量YS1限制，及提供的物品总个数n</span><br>    cin &gt;&gt;YS1 &gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        cin &gt;&gt;ys1[i] &gt;&gt;value[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)  <span class="hljs-comment">// 针对每1个物品</span><br>        <span class="hljs-comment">// 这里j应该从右往左推，千万要注意！！注意是&gt;=ys1[i]截止，因为下标[j-ys1[i]]不可能为负数！</span><br>        <span class="hljs-comment">// 对于那些小于ys1[i]的j，在这里就不去处理（默认等于前值）了，也就是说，等效于dp[i][j] = dp[i-1][j]了！</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)<br>            <span class="hljs-comment">// 需要判断放与不放，到底哪个更划算！</span><br>            dp[j] = <span class="hljs-built_in">max</span>( dp[j - ys1[i]] + value[i],  dp[j]);<br><br>    cout &lt;&lt;dp[YS1];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p1048-采药">2.2 P1048 采药</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　下面两个题，基本上完全一样。</p><ul><li><h3 id="p1048-noip2005-普及组-采药">　　<ahref="https://www.luogu.com.cn/problem/P1048">P1048 [NOIP2005 普及组]采药</a></h3></li><li><a href="https://www.luogu.com.cn/problem/P2871">P2871 [USACO07DEC]Charm Bracelet S</a></li></ul><h3 id="ac代码-1">2.2.2 AC代码</h3><h4 id="标准状态数组版本-1">2.2.2.1 标准状态数组版本</h4><p>　　时间复杂度：<spanclass="math inline">\(O(n*YS1)=100*1000=1e5\)</span></p><p>　　空间复杂度：<spanclass="math inline">\(O(n*YS1)=100*1000=1e5\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 101</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T 1001</span><br><span class="hljs-type">int</span> dp[N][T]; <br><span class="hljs-type">int</span> n, YS1;<br><span class="hljs-type">int</span> ys1[N], value[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;YS1, &amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;ys1[i], &amp;value[i]);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;= YS1; j++)<br><span class="hljs-comment">//for(int j=YS1; j&gt;= 0; j--)   // 逆序在标准状态数组结构中也是可以的 </span><br><span class="hljs-keyword">if</span> (ys1[i] &lt;= j)<br>dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i<span class="hljs-number">-1</span>][j-ys1[i]] + value[i]);<br><span class="hljs-keyword">else</span><br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dp[n][YS1]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="滚动状态数组版本-1">2.2.2.2 滚动状态数组版本</h4><p>　　时间复杂度：<spanclass="math inline">\(O(n*YS1)=100*1000=1e5\)</span></p><p>　　空间复杂度：<span class="math inline">\(O(YS1)=1000\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 法2，滚动状态</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 101</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T 1001</span><br><span class="hljs-type">int</span> dp[T]; <br><span class="hljs-type">int</span> n, YS1;<br><span class="hljs-type">int</span> ys1[N], value[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;YS1, &amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;ys1[i], &amp;value[i]);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;= ys1[i]; j--)   <span class="hljs-comment">// 逆序在标准状态数组结构中也是可以的 </span><br>dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-ys1[i]] + value[i]);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dp[YS1]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 背包问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长公共子串问题</title>
      <link href="/2024/04/30/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
      <url>/2024/04/30/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="视频教学链接">1.1 视频教学链接</h2><p>　　<ahref="https://www.bilibili.com/video/BV1hv41117gC/?vd_source=0e7cc4e4bbbb67e5c3c2a3e7d967f075">最长公共子串</a></p><h2 id="理论分析">1.2 理论分析</h2><h3 id="什么是子串">1.2.1 什么是子串？</h3><p>　　如图所示:</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240430094645379.png" style="zoom: 50%;" /></p><p>　　它的子串示例：{c,d,e,f}即连续元素c,d,e,f组成的串是给定序列的子串。同理，{a,b,c,d},{g,h}等都是它的子串。</p><p>　　两个序列的最长公共子串的长度值是唯一的，但<strong>公共子串在两个序列中的字符选择，可能是不唯一的</strong>。例如S1="AABAA",S2="AA"，则S2的字符AA和S1中的两个AA都分别构成最长公共子串，长度值都为2。</p><h3 id="动态规划的六步分析">1.2.2 动态规划的六步分析</h3><p>　　1）定义状态数组</p><p>　　假设有两个字符串a[1..lena]和b[1..lenb]，状态数组肯定是一个二维数组无疑。一个直觉是“定义dp[i][j]为‘a[1..i]和b[1..j]的最长公共子串的长度值’”。<strong>但实际上这个定义是错误的</strong>，因为它违反了动态规划方法所要求的第二个前提，即“无后效性”。下面我们举个例子来说明：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240430180913104.png" style="zoom: 70%;" /></p><p>　　上图是两个序列a[]="ABACCB"和b[]="AACCAB"按照“dp[i][j]为a[1..i]和b[1..j]的最长公共子串的长度值”的规定而填写的。仔细研究每一个红圈处，可以发现，都是“a[i]==b[j]且a[i-1]==b[j-1]且a[i-2]==b[j-2]且......”直到“a值和b值不相等”为止。而每一个篮圈处，都是“a[i]==b[j]且a[i-1]!=b[j-1]”的情况，不能简单地加1。<strong>当我们固定a[1..i]，已填好dp[i][j-1]，并且打算填写dp[i][j]时，我们无法确定a[i]在两个序列a[1..i]和b[1..j-1]的公共子串中是否已经被选中过了（若a[i]已用过，则不能再用来和b[j]匹配）。</strong></p><p>　　例如从dp[4][2]开始填写dp[4][3]时，b[3]为字符C，与a[4]相等，且a[4]在a[1..4]和b[1..2]的公共子串"A"中从未出现过，故可用来和b[3]相配，延长子串为“AC”。而填写dp[4][4]时，b[4]为字符C，与a[4]相等，但a[4]在a[1..4]和b[1..3]的公共子串"AC"中已经用过，不能再用来和b[4]相配，故不可加1。</p><p>　　仔细思考，可以发现<strong>因为要求子串必须连续，而“dp[i][j]为a[1..i]和b[1..j]的最长公共子串的长度值”这样的设计，并不能体现和预判出这种“连续性”。这就是问题产生的根源</strong>。</p><p>　　但如果把设计改为“dp[i][j]为a[1..i]和b[1..j]中a[i]==b[j]且a[i]为公共子串的末尾字符时的最长子串长度值”，问题就迎刃而解了。听起来有点长，实际上就是在原来定义的基础上，加上“要求必须两个子串的末尾字符相等，且等于a[i]和b[j]”即可。</p><p>　　按照新的定义，则dp[][]的值如下：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240430204356117.png"alt="image-20240430204356117" /><figcaption aria-hidden="true">image-20240430204356117</figcaption></figure><p>　　从上图中可以看出，<strong>当a[i]==b[j]时，既然不能确定a[i]是否之前已用过，那干脆直接从dp[i-1][j-1]推过来就可以了。这样的话a[i]就肯定没用过了，而b[j]也没用过，正好相配，成为子串的新成员。</strong></p><p>　　2）所求目标</p><p>　　在这种情况下，dp[lena][lenb]不一定是最大值了。所求目标应该是max(dp[1..lena][1..lenb])。</p><p>　　3）状态转移方程：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240430143937061.png" style="zoom: 50%;" /></p><p>　　a）若a[i]==b[j],则至少有它们两个可以构成长度值为1的公共子串。对于a[1..i-1]和b[1..j-1]，根据dp的定义，dp[i-1][j-1]表示它们的最长公共子串的长度值。再尾续上a[i]，长度值应+ 1。</p><p>　　b）若a[i]!=b[j],则不管a[1..i-1]和b[1..j-1]能否构成公共子串，因为必须要以a[i]或者b[j]作为子串的最后一个字符，现在二者不等，所以dp[i][j]=0。</p><p>　　整合a）和b），得状态转移方程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (a[i]==b[j])  <br>    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <br>    dp[i][j] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>　　4）循环顺序和循环边界</p><p>　　　　肯定是需要从上往下、从左往右填写</p><p>　　　　i: 1-----&gt;lena 增序</p><p>　　　　j：1&lt;----&gt;lenb 增序降序均可</p><p>　　5）特例</p><p>　　　　dp[0][j]=dp[i][0]= 0;</p><p>　　　　注意：<del>dp[1][j]=dp[i][1]= 1</del>;是错误的！</p><p>　　6）数组初始化值</p><p>　　　　不需要专门处理普通位置上的初值，都会被覆盖的。</p><h1 id="二.-实战训练">二. 实战训练</h1><h2 id="or15-最长公共子串的长度值">2.1 OR15 最长公共子串的长度值</h2><p>　　原题链接：</p><p>　　　　<ahref="https://www.nowcoder.com/practice/02e7cc263f8a49e8b1e1dc9c116f7602?dayCountBigMember=%E8%BF%9E%E7%BB%AD%E5%8C%85%E6%9C%88&amp;tpId=0&amp;difficulty=&amp;judgeStatus=&amp;tags=&amp;title=%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2&amp;sourceUrl=&amp;gioEnter=menu"><strong>最长公共子串</strong></a>（微信扫码登录)</p><p>　　分析：</p><p>　　dp[i][j]表示str1[0..i-1]和str2[0..j-1]的<strong>以str1[i-1]结尾</strong>的最长公共子串的长度，本题的关键是在于错位存储。因为两个字符串必须以下标0开始存储，所以dp[i][j]表示的不是str1[0..i]和str2[0..j]的子串，换句话说，要在原来1.2.2节分析的基础上，把dp数组的数据区整体往右下方向移动1格即可。</p><p>　　另外，还需要注意一下用vector定义二维数组的写法。</p><p>　　AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LongestSubstring</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLongest</span><span class="hljs-params">(string A, <span class="hljs-type">int</span> n, string B, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> max_len = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//用vector来定义二维数组，长度为[n + 1][m + 1]，默认值为0</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                <span class="hljs-keyword">if</span> (A[i] == B[j]) &#123;<br>                    <span class="hljs-comment">// 递推方程。因为是从00开始，所以把dp的数据区域往右下的方向挪一下而已</span><br>                    <span class="hljs-comment">// dp[i][j]表示a[1..i-1]和b[1..j-1]中a[i-1]==b[j-1]且a[i-1]为公共子串的末尾字符时的最长子串长度值</span><br>                    <span class="hljs-comment">// dp[i+1][j+1]表示a[1..i]和b[1..j]中a[i]==b[j]且a[i]为公共子串的末尾字符时的最长子串长度值</span><br>                    dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = dp[i][j] + <span class="hljs-number">1</span>;<br>                    <span class="hljs-comment">// 找二维数组的最大值</span><br>                    <span class="hljs-keyword">if</span> (max_len &lt; dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 如果不记录下标，&lt;和&lt;=就没区别</span><br>                        max_len = dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max_len;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="cd33-最长公共子串的长度值和子串值">2.2 cd33最长公共子串的长度值和子串值</h2><p>　　原题链接：</p><p>　　　　<ahref="https://www.nowcoder.com/practice/210741385d37490c97446aa50874e62d?dayCountBigMember=%E8%BF%9E%E7%BB%AD%E5%8C%85%E6%9C%88&amp;tpId=0&amp;difficulty=&amp;judgeStatus=&amp;tags=&amp;title=%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2&amp;sourceUrl=&amp;gioEnter=menu"><strong>最长公共子串</strong></a>（微信扫码登录)</p><p>　　分析：</p><p>　　dp[i][j]表示str1[0..i-1]和str2[0..j-1]的以str1[i-1]结尾的最长公共子串的长度，本题在2.1节基础上增加了对“输出子串内容”的要求。所以本题的关键是在dp遍历的过程中记录最长公共子串的结尾下标epos，根据结尾下标以及长度就可以求出子串。</p><p>　　AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>string s1, s2;<br><span class="hljs-comment">//用vector来定义二维数组，长度为[len1 + 1][len2 + 1]，默认值为0</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt;s1 &gt;&gt;s2;<br>    <span class="hljs-type">int</span> len1=s1.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> len2=s2.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> max_len=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> epos=<span class="hljs-number">-1</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len1+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len2+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len1; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;len2; j++) &#123;<br>            <span class="hljs-keyword">if</span>(s1[i]==s2[j]) &#123;<br>                <span class="hljs-comment">// 递推方程。因为是从00开始，所以把dp的数据区域往右下的方向挪一下而已</span><br>                <span class="hljs-comment">// dp[i][j]表示a[1..i-1]和b[1..j-1]中a[i-1]==b[j-1]且a[i-1]为公共子串的末尾字符时的最长子串长度值</span><br>                <span class="hljs-comment">// dp[i+1][j+1]表示a[1..i]和b[1..j]中a[i]==b[j]且a[i]为公共子串的末尾字符时的最长子串长度值</span><br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=dp[i][j] + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 找二维数组的最大值</span><br>                <span class="hljs-keyword">if</span>(max_len &lt; dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 既然要记录下标，此处表示从左往右“第1个”长度为max_len的公共子串的结束下标。如果改为&lt;=，则表示“最后1个”</span><br>                    max_len = dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>];<br>                    epos = i;  <span class="hljs-comment">// 公共子串在s1的结束下标</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> spos=epos - max_len + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 根据“结束下标”和子串长度，算出子串的“起始下标”spos</span><br>    <span class="hljs-keyword">if</span> (epos==<span class="hljs-number">-1</span>)<br>        cout &lt;&lt; <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; s1.<span class="hljs-built_in">substr</span>(spos, max_len);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="hj65-最长公共子串的长度值">2.3 hj65 最长公共子串的长度值</h2><p>　　原题链接：</p><p>　　　　<ahref="https://www.nowcoder.com/practice/02e7cc263f8a49e8b1e1dc9c116f7602?dayCountBigMember=%E8%BF%9E%E7%BB%AD%E5%8C%85%E6%9C%88&amp;tpId=0&amp;difficulty=&amp;judgeStatus=&amp;tags=&amp;title=%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2&amp;sourceUrl=&amp;gioEnter=menu"><strong>查找两个字符串a,b中的最长公共子串</strong></a>（微信扫码登录)</p><p>　　分析：</p><p>　　　　本题在2.2节基础上，加入了“输出在较短串中最先出现的那个”。首先我们需要明白，最长公共子串，是有可能有多个解的。例如s1=“AAXXXXXXXBB”和s2=“BBYAA”就有“AA”和“BB”这两个最长公共子串，长度都是2，都最长。如果按照本题的意思，则应该输出较短的串（即s2）中的“BB”，因为它先出现。</p><p>　　我们需要先比较两串长度，用swap让s1成为最短的串，以方便后面的代码书写。至于“最先出现”该如何搞定呢？只需要在子串最大长度值进行刷新时规定当长度值相等时仍然不刷新对应下标，仍然保留第一次出现长度值为max_len的子串的下标epos。</p><p>　　AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function">string <span class="hljs-title">LCS</span><span class="hljs-params">(string str1, string str2)</span> </span>&#123;<br>    <span class="hljs-comment">// write code here</span><br>    <span class="hljs-keyword">if</span> (str1.<span class="hljs-built_in">size</span>() &gt; str2.<span class="hljs-built_in">size</span>())  <span class="hljs-comment">// 确保str1是最短的串</span><br>        <span class="hljs-built_in">swap</span>(str1, str2);<br>    <span class="hljs-type">int</span> m = str1.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> n = str2.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// dp[i][j] str1前i个字符和str2前j个字符（以其为尾字符）的最长公共子串长度</span><br>    <span class="hljs-type">int</span> dp[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> maxlen = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//base case</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; ++j) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (str1[i - <span class="hljs-number">1</span>] == str2[j - <span class="hljs-number">1</span>]) <br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                dp[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (dp[i][j] &gt; maxlen) &#123; <span class="hljs-comment">// 这里不能写&gt;=，必须是&gt;，确保了“首次出现”</span><br>                maxlen = dp[i][j];<br>                end = i - <span class="hljs-number">1</span>;         <span class="hljs-comment">// 记录i-1，而i对应着str1（短串），所以确保了是短串中的结束下标</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (maxlen == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;-1&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> str1.<span class="hljs-built_in">substr</span>(end - maxlen + <span class="hljs-number">1</span>, maxlen);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s1, s2;<br>    cin &gt;&gt; s1 &gt;&gt; s2；<br>    cout &lt;&lt; <span class="hljs-built_in">LCS</span>(s1, s2) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 线性DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子段和</title>
      <link href="/2024/03/20/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/"/>
      <url>/2024/03/20/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="一-基本题型">一、 基本题型</h1><h2 id="题型内容">1.1 题型内容</h2><p>一维数组，不限区间长度，求其中连续且非空的区间最大和值。</p><h2 id="样题p1115-最大子段和">1.2 样题（<ahref="https://www.luogu.com.cn/problem/P1115">P1115最大子段和</a>）</h2><h3 id="分析">1.2.1 分析</h3><ol type="1"><li><p>首先应该做的事情是仔细研究输入样例1的数据，准确理解样例输出的4是从何而来。通过这样的方法，进一步准确理解题意。</p></li><li><p>其次，也是最重要的一步，就是破题，找出解法。关于这个步骤，同学们需要拿出草稿纸和笔，在草稿纸上把输入样例1的数据仔细研究，先用模拟的方法来推导，需要在纸上写写划划，摸索方法的细节内容。本步骤切忌“只观望而不动笔”，除非你做过类似的题或者自信非常的聪明。</p><p>　　　　通过分析题意，我们知道需要去求一个区间，使得区间内的数据之和值最大。如果数组内的数据全都是正数（因为正数会越加越大）的话，那这个题就完全没有难度了，因为区间并未限定长度，所以数据肯定是“多多益善”，所以直接求整个数组的总和即可。但我们查看该题<spanclass="math inline">\(a_i\)</span>的数据范围，发现是<spanclass="math inline">\(-10^4 \leq a_i \leq10^4\)</span>，也就是说，允许元素值为负数。在“允许为负”的影响下，上面的想法就肯定行不通了。</p><p>　　为了验证刚才的想法，我们可以尝试举例来试试看（应该在草稿纸上用笔耐心想着写，切忌只看不写）。例如如下样例｛１，２，３，－１０００｝，很明显答案是１＋２＋３＝６，此时肯定不能把最后那个－１０００也算进去。而对于样例｛１，－１０００，２，３，－１｝，则应该是２＋３＝５。</p><p>　　可能有些同学根据上面的２个样例，会断章取义地认为目标区间内的数据必须全为正数。更加细心的同学会发现在｛１，－１００，２，３，－１，４｝这个样例中，正确答案并不是２＋３＝５，而应该是２＋３－１＋４＝８。也就是说，区间内实际上是可以有负数的，并不能简单粗暴地排除负数。所以希望同学们在草稿纸上自己写样例时，应更加有目的性和针对性，而不是随便乱写。例如有些同学写的样例是｛１，２，３｝（没有负数，不够全面）、｛３２１，５４３，－６２６３，３２７４，３６４２｝（过于随意，且计算麻烦，数值过于接近而显得无特征）</p><p>　　这个时候我们需要仔细研究答案的特征。</p><p>　　例如对于例题中的样例１｛２，－４，<font color="red" >３，－１，２</font>，－４，３｝，正确区间是选择｛３，－１，２｝这个子段。之所以会选择－１，是因为后面有个２足够补偿－１对累加和ｓｕｍ造成的损失；之所以放弃３左侧的｛２，－４｝，是因为这两个数的和为－２，对ｓｕｍ造成了累赘，拉低了值；之所以放弃２右侧的｛－４，３｝，也是因为这两个数的和值为－１，也对ｓｕｍ造成了累赘。</p><p>　　我们现在来看看数据规模，达到了<spanclass="math inline">\(10^5\)</span>的级别，也就意味着肯定不能用"暴力枚举区间两个端点"（<spanclass="math inline">\(O(n^2 )\)</span>）的方法而只能用<spanclass="math inline">\(O(n)\)</span>或者<spanclass="math inline">\(O(n*log_2n)\)</span>的算法才行。而一重ｆｏｒ只能枚举区间的一个端点，那另一个端点怎么办呢？</p><p>　　这个时候我们应该在草稿纸上用笔来推导一下样例１，采用的方法就是模拟一重循环，从左往右尝试处理。处理什么呢？我们可以采用问题拆解（即考虑ｎ＝１、２、３、……,逐个增加规模，即“递推”）的思想来试试。</p><ul><li><p>如果数组只有｛２｝，则不限长度的最大子段和值为２；</p></li><li><p>如果数组只有｛２，－４｝，则不限长度的最大子段和值仍为２（不选－４）；</p></li><li><p>如果数组只有｛２，－４，３｝，则不限长度的最大子段和值为３（不选２和－４，因为这两个数的累加和－２对求和来说是个累赘，不如舍弃这两个数，这就是“贪心”的思想）；</p></li></ul><p>　　做到这里，可能已经有同学发现这种做法有问题。当分析数组｛－４，２，３｝中的３时，因为前两个数的累加和值为－２，但最大子段和并不是３，而是５。因为我们应把２作为最大子段中的组成元素之一。当我们在考虑第３个元素是否该选时，应该考虑第二个元素是否在规模为２的数组中被选中。也就是说，｛－４，２，３｝和｛２，－４，３｝这两个数组，虽然前两个数的和值（都为－２）都对第３个数３造成了累赘。但这两个样例的解肯定是不同的。本题要求的是“连续”的最大子段和。“连续”这个概念应该如何体现呢？那就是</p><p>　　</p></li></ol><p>对于一个给定的序列a[1..n]，它的差分序列D[1..n]定义为： <spanclass="math display">\[D[1]=a[1], \qquad D[i]=a[i]-a[i-1],\qquad (2 \leq i \leq n)\]</span>D[]是a[]的<font color="red" >差分</font>序列，反过来，a[]是D[]的<font color=#ADFF2F>前缀和</font>序列。差分操作和前缀和操作是一对互逆运算。对任何序列a[]求差分D[]，再对D[]求其前缀和序列，就能得到原来的序列a[]。</p><p>关于上述这一点的证明如下： <span class="math display">\[\begin{align}a[1]&amp;=D[1] \\a[2]&amp;=D[2]+a[1]=D[2]+D[1]\\a[3]&amp;=D[3]+a[2]=D[3]+D[2]+D[1]\\......\end{align}\]</span></p><p>二维、三维形式的差分数组，在还原数组时，需要用到多维数组求前缀和的计算方法。具体见本站关于“前缀和”的帖子。</p><h2 id="一维差分">1.3 一维差分</h2><h3 id="问题假设">1.3.1 问题假设</h3><p>讨论这样一个场景：</p><p>（1）给定一个长度为n的一维数组<spanclass="math inline">\(a[1..n]\)</span>，数组内每个元素有初始值。</p><p>（2）<strong>区间修改</strong>操作：做m次区间修改，<strong>每次修改对区间内所有元素做相同的加减操作</strong>。例如第i次修改，把区间<spanclass="math inline">\([L_i,\ R_i]\)</span>内所有元素加上<spanclass="math inline">\(d_i\)</span>。</p><p>（3）<strong>单点查询</strong>操作：询问一个元素的新值是多少。</p><p>如果简单地用暴力法编码，那么每次区间修改的复杂度是<spanclass="math inline">\(O(n)\)</span>的，m次修改共<spanclass="math inline">\(O(m*n)\)</span>，总复杂度<spanclass="math inline">\(O(m*n)\)</span>，效率很差。利用差分法，可以把复杂度减少到<spanclass="math inline">\(O(m+n)\)</span>。模板题可见<ahref="http://acm.hdu.edu.cn/showproblem.php?pid=1556">hdu1556</a>，解法见2.1节。</p><h3 id="相关操作和解法">1.3.2 相关操作和解法</h3><h4 id="批量m次区间修改操作">1.3.2.1“<strong>批量（m次）区间修改</strong>”操作</h4><p>假设a[1..n]是原始数组，D[1..n]是该数组对应的差分数组。m次区间修改，把区间<spanclass="math inline">\([L_i,\ R_i]\)</span>内每个元素（在a[]中从第<spanclass="math inline">\(L_i\)</span>个元素到第<spanclass="math inline">\(R_i\)</span>个元素在内）全都加上<spanclass="math inline">\(d_i\)</span>，<span class="math inline">\((1\leq i\leq m)\)</span>。则区间修改的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)&#123;<br>D[ L[i] ] += d[i];<br>D[ R[i]+<span class="hljs-number">1</span> ] -= d[i];     <span class="hljs-comment">// 注意不要写成了R[i+1]了。做当前这个区间的修改，关下一个区间什么事？</span><br>&#125;<br></code></pre></td></tr></table></figure><p>for循环里的这两句代码如何理解呢？</p><p>举个例子：现在需要将a[]中第3个元素到第7个元素（共计7-3+1=5个）全都加上20，则代码应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">D[3] += 20;<br>D[8] -= 20;    <br></code></pre></td></tr></table></figure><p>注意，上述代码中不是D[7]!为什么呢？请看下图的例子：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240321112724482.png" alt="image-20240321112724482" style="zoom:67%;" /></p><p>我们可以把上面的代码整合一下，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> le, <span class="hljs-type">int</span> ri, <span class="hljs-type">int</span> v)</span></span>&#123;<br>D[le]+=v, D[ri+<span class="hljs-number">1</span>]-=v;            <span class="hljs-comment">// 注意 ri+1</span><br>&#125;<br><span class="hljs-built_in">main</span>()&#123;<br>    ......<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)          <span class="hljs-comment">// m次区间修改  </span><br>    <span class="hljs-built_in">change</span>(L[i], R[i], val[i]);  <span class="hljs-comment">// 每次把a[]从第L[i]到第R[i]个元素全都加上val[i]</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述的change函数是<spanclass="math inline">\(O(1)\)</span>的，for循环是<spanclass="math inline">\(O(m)\)</span>的。我们成功地将“m次<strong>区间</strong>操作”的<spanclass="math inline">\(O(m*n)\)</span>操作变成了“m次<strong>单点</strong>修改”的<spanclass="math inline">\(O(m)\)</span>，大大提高了效率。</p><h4 id="单点查询操作">1.3.2.2 “<strong>单点查询</strong>"操作</h4><p>这里说的单点查询，是指读取最终a[]数组中某一个元素的值。</p><p>当我们使用D[]数组做了m次<spanclass="math inline">\(O(1)\)</span>修改操作后，D[]已经面目全非了。现在要查询a[]中的第k个元素的值，该如何做呢？当然需要先通过D[1..n]还原出a[1..n]，然后提取a[k]。<strong>还原过程就是对D[]做“前缀和”操作</strong>，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;    <span class="hljs-comment">// 因为是对a[]做遍历，i要到n，这里和m没任何关系了</span><br>a[i] = a[i<span class="hljs-number">-1</span>] + D[i];   <span class="hljs-comment">// 谁加谁的值赋给谁，别晕哦！～下标别乱写～</span><br>&#125;<br>cout &lt;&lt;a[k];<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240321113343953.png" alt="image-20240321113343953" style="zoom:67%;" /></p><p>上述的操作，时间复杂度是<spanclass="math inline">\(O(n)\)</span>的，而不是<spanclass="math inline">\(O(1)\)</span>，因为需要先还原。当查询次数很少时，是可以接受的。</p><h3 id="局限性">1.3.3 局限性</h3><p>局限主要出现在“查询”上。如果查询不是发生了1次，而是这样：有m次修改，有k次查询，且修改和查询的顺序是随机的。此时总复杂度是：m次修改复杂度<spanclass="math inline">\(O(m)\)</span>，k次查询复杂度<spanclass="math inline">\(O(k*n)\)</span>，总复杂度<spanclass="math inline">\(O(m+k*n)\)</span>。当查询次数远大于修改次数时，还不如直接用暴力法（总复杂度<spanclass="math inline">\(O(m*n+k)\)</span>）。</p><p>对于“区间修改+<strong>多次</strong>单点查询”这种题型来说，用差分数组往往不够用。因为差分数组对“区间修改”很高效，但是对“<strong>多次</strong>单点查询”并不高效。此时需要用树状数组和线段树来求解。</p><p>树状数组常常结合差分数组来解决更复杂的问题，具体需要查阅“树状数组”专题中的<ahref="http://acm.hdu.edu.cn/showproblem.php?pid=1556">hdu1556</a>；差分数组也常用于“树上差分”，见本博客<strong>LCA</strong>专题的“树上差分”。</p><h2 id="二维差分">1.4 二维差分</h2><p>从一维差分容易扩展到二维差分。一维是线性数组，一个区间[L,R]有两个端点；<strong>二维则是矩阵，一个区间由四个端点围成</strong>。</p><h3 id="问题假设-1">1.4.1 问题假设</h3><p><a href="https://www.luogu.com.cn/problem/P3397">P3397地毯</a>是一个非常典型的二维差分的模板题。我们可以不妨以该题作为二维差分的问题假设。</p><h3 id="原始数组a和二维差分d之间的互换">1.4.2原始数组a[][]和二维差分D[][]之间的互换</h3><p>假设原始数组为a[1..R][1..C],二维差分数组D[1..R][1..C]。这里并不存在专门的前缀和数组，对D[][]进行前缀和运算，就能得到原始数组a[][]。“前缀和”只是从差分还原为原始数组时需要用到的计算方法。</p><h4 id="差分drightarrow原始数组a">1.4.2.1 差分D[][]<spanclass="math inline">\(\Rightarrow\)</span>原始数组a[][]</h4><p>在一维差分中，原数组a[1..n]是从第1个元素(即D[1])开始的差分数组D[1..n]的前缀和：<span class="math display">\[a[k]=D[1]+D[2]+...+D[k]\]</span>在二维差分中，a[i][j]实际上就是差分数组D[1..i][1..j]的前缀和运算结果，即<strong>由原点坐标(1,1)和坐标(i,j)围成的矩阵中，所有的D[][]相加等于a[i][j]</strong>，用数学公式来表示就是：<spanclass="math inline">\(a[i][j]=\sum_{r=1}^{i}(\sum_{c=1}^{j}D[r][c])\)</span>。所以，“根据D[][]求a[][]”的这个问题，其实就是如何求一个二维数组D的前缀和数组a的问题。可以参看本站“前缀和二维前缀和”的帖子第3节“高维前缀和”，有更加清晰和完整的阐述。</p><h5 id="一按维做前缀和操作-更优">（一）按维做“前缀和”操作（ 更优 ）</h5><p>如下图，每个小正圆形代表了一个D[][]值，每个小正方形代表了一个a[][]。在坐标(1,1)和(i,j)所围成的矩形范围内所有小圆形内的数值之和等于a[i][j]。注意，a[0][]和a[][0]值全0，需单独处理，以便后续的二重递推能顺利进行。填写过程的二重for循环都应从1开始。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240322114928462.png" style="zoom:67%;" /></p><p>相关代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 也可以“for C for R”，只是影响填写顺序，第4行代码决定了先累加横向数据，同学们可以试试。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r=<span class="hljs-number">1</span>; r&lt;=R; r++)               <span class="hljs-comment">// 每行都要做如下的事情：</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>; c&lt;=C; c++)&#123;          <span class="hljs-comment">// 对于指定的某一行，从左往右做前缀和并存于a[][]</span><br>    a[r][c]=a[r][c<span class="hljs-number">-1</span>] + D[r][c];   <span class="hljs-comment">// 该行当前列的累加和=该行左侧列的累加和 + 当前数</span><br>    &#125;<br><span class="hljs-comment">// for R for C和for C for R都可以，但第9行一定只能纵向累加，区别于第4行的横向累加</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>; r&lt;=C; c++)               <span class="hljs-comment">// 每列都要做如下的事情：</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r=<span class="hljs-number">1</span>; r&lt;=R; r++)&#123;          <span class="hljs-comment">// 对于指定的某一列，从下往上，继续做前缀和</span><br>    a[r][c]=a[r<span class="hljs-number">-1</span>][c] + a[r][c];   <span class="hljs-comment">// a[r][c]已经是一个横向的前缀和数值了，现在按纵向来累加</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>对于d维数组，则这种算法的时间复杂度为<spanclass="math inline">\(O(R*C*d)\)</span>，表现优异。</p><h5 id="二递推做法">(二)递推做法</h5><p>我们可以用二维的容斥原理来得到递推公式。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240322120812891.png" style="zoom:67%;" /></p><p>总结为公式就是如下： <span class="math display">\[\begin{cases}a[i][0]=0 \qquad (0 \leq i \leq R) \\a[0][j]=0 \qquad (0 \leq j \leq C) \\a[i][j]=a[i-1][j]\ +\ a[i][j-1]\ -\ a[i-1][j-1]\ +\ D[i][j] \qquad(1\leq i \leq R, \ 1\leq j \leq C) \tag {1}\end{cases}\]</span> 这种优化后的递推方法，复杂度为<spanclass="math inline">\(O(R*C)\)</span>。但是对于d维数组求前缀和来说，多维下的容斥原理，上面公式（1）中的第3个公式右边的数据项数不再是4项，而是有<spanclass="math inline">\(2^d\)</span>项。所以其时间复杂度准确地说，应该是<spanclass="math inline">\(O(R*C*2^d)\)</span>，看上去似乎没有第一种方法那么好了，而且公式复杂，书写易错，不推荐本方法。</p><h4 id="原始数组arightarrow差分数组d">1.4.2.2 原始数组a[][]<spanclass="math inline">\(\Rightarrow\)</span>差分数组D[][]</h4><p>在一维情况下，<spanclass="math inline">\(D[i]=a[i]−a[i−1]\)</span>。</p><p>在二维情况下，根据上面总结出来的公式(1)，可以很容易得到： <spanclass="math display">\[\begin{cases}D[i][0]=0 \qquad (0 \leq i \leq R) \\D[0][j]=0 \qquad (0 \leq j \leq C) \\D[i][j]=a[i][j]\quad\textcolor[RGB]{225,0,0}{–}a[i−1][j]\quad\textcolor[RGB]{225,0,0}{–}a[i][j−1]\quad\textcolor[RGB]{0,225,0}{+}a[i−1][j−1]\qquad(1\leq i \leq R,\ 1\leq j \leq C) \tag{2}\end{cases}\]</span> 这个公式的计算复杂度是<spanclass="math inline">\(O(4)\)</span>的。这个公式可以通过下图进一步，采用集合的容斥原理来分析。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240322143341699.png" style="zoom: 67%;" /></p><p>同学们可以想一下，如果这里是<spanclass="math inline">\(d=3\)</span>维数组，那采用容斥原理来分析，其复杂度是多少呢？<spanclass="math inline">\(O(2^d)\)</span></p><h3 id="相关操作和解法-1">1.4.3 相关操作和解法</h3><h4 id="批量m次区间修改操作-1">1.4.3.1“<strong>批量（m次）区间修改</strong>”操作</h4><p>在一维情况下，做区间修改只需要修改区间的两个端点的D[]值。在二维情况下，一个区间代表了一个小矩阵，有4个角点，只需要修改这4个角点的D[][]值。例如以两个坐标点<spanclass="math inline">\((r1,c1)\)</span>和<spanclass="math inline">\((r2,c2)\)</span>为对角点而定义的矩形区间，其修改方法如下代码所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">D[r1][c1]     += d;     <span class="hljs-comment">// 二维区间的起点，累加</span><br>D[r1][c2+<span class="hljs-number">1</span>]   -= d;     <span class="hljs-comment">// 横向看，原始数组的修改范围是列从c1到c2+1。累减</span><br>D[r2+<span class="hljs-number">1</span>][c1]   -= d;     <span class="hljs-comment">// 纵向看，原始数组的修改范围是行从r1到r2+1。累减</span><br>D[r2+<span class="hljs-number">1</span>][c2+<span class="hljs-number">1</span>] += d;     <span class="hljs-comment">// 由于前两式把d减了2次，多减了1次，这里加1次回来</span><br></code></pre></td></tr></table></figure><p>举个例子：现在有a[0..7][0..7]及其对应的差分数组D[0..7][0..7]的数据如下图所示，a[][]的每个元素值都是10的整倍数。现在需要在以(2，3)和（5，5）为对角点的矩形范围内把每个a[][]的值都累加上5。如果用差分数组来处理，该如何实现这个操作呢？我们需要在D[][]中找到4个坐标点，他们分别是（2，3）、（2，6）、（6，3）、（6，6），如下图左中黄色圆圈所示。然后对这四个D[][]做上面代码块中的相关操作就可以啦！注意，是<strong>累加</strong>，不是直接赋值。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240322152409516.png"alt="image-20240322152409516" /><figcaption aria-hidden="true">image-20240322152409516</figcaption></figure><p>修改后的D数组和其对应代表的a数组如上图右所示。同学们可以仔细体会。</p><h4 id="单点查询操作-1">1.4.3.2 “单点查询”操作</h4><p>当我们对D[][]数组做了m次<spanclass="math inline">\(O(4)\)</span>修改操作后，假如现在要查询其对应的a[][]中的第r行第c列的元素值，这就是所谓的“单点查询”操作。解决方法就是先通过D[1..R][1..C]还原出a[1..R][1..C]，然后提取a[r][c]。<strong>还原过程就是对D[][]做“前缀和”操作</strong>，从而还原得到a[][]。该操作过程请参看1.4.2.1节内容，此处不再赘述。算法复杂度为<spanclass="math inline">\(O(R*C)\)</span>。</p><h2 id="三维差分">1.5 三维差分</h2><h3 id="问题假设-2">1.5.1 问题假设</h3><p>元素值用三维数组a[][][]来定义，差分数组b[][][]也是三维的。与之前低维度的差分类似，把三维差分想象成立体空间的操作。与之对应的小立方块有8个顶点，所以三维的区间需要修改8个b[][][]的值。</p><h3 id="原始数组a和差分数组d之间的相互关系">1.5.2原始数组a[][][]和差分数组D[][][]之间的相互关系</h3><p>在二维差分中，a[][] 是差分数组 b[][]的前缀和，即原点坐标(1，1)和坐标(i，j)围成的矩阵面积。</p><p>在三维差分中，a[][][] 是差分数组b[][][]的前缀和，即原点坐标(1,1,1)和坐标(r,c,h)围成的立方体体积。同样地，我们把每个b[][][]看成一个小正方体，在坐标(1，1，1)~(i，j，k)所围成的三维空间中，所有小正方体加起来的总体积即为a[r][c][h]。如下图所示，每个小立方体由8个角点定义。坐标点(i，j，k)的值是a[r][c][h]; 图中正方体的体积是差分数组 b[i][j][k]的值。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240322215017626.png" style="zoom:67%;" /></p><p>类似的，在三维情况下，差分就变成了相邻的<code>a[][][]</code>的”体积差“。那么如何来写出差分的<strong>递推</strong>计算公式呢？</p><p>观察前面一、二维的前缀和我们可以发现，其前缀和规律十分吻合容斥原理:</p><ol type="1"><li><p>一维：</p><p>A)原始a <span class="math display">\[\begin{align} a_i = a^{i-1} + D_i \tag{3}\end{align}\]</span> B)差分D <span class="math display">\[\begin{align}D_i=a_i - a_{i-1}\end{align} \tag{4}\]</span></p></li><li><p>二维：</p><ol type="A"><li>原始a <span class="math display">\[\begin{align}a_{r,c} = &amp;\ \ \ \ \ \ D_{r,c}  \tag{5}\\&amp;+\a_{r-1,c} \ \ \ + \ \ a_{r,c-1}\quad\quad\quad(奇数个维度(1)要-1，加)\notag \\&amp;-\ a_{r-1,c-1}\quad\quad\quad\quad\quad\quad\quad(偶数个维度(2)要-1，减)\notag \\\end{align}\]</span></li><li>差分D <span class="math display">\[\begin{align}D_{r,c} = &amp;\ \ \ \ \ \ a_{r,c} \tag{6}\\&amp;-\a_{r-1,c} \ \ \ - \ \ a_{r,c-1}\quad\quad\quad(奇数个维度(1)要-1，减)\notag \\&amp;+\ a_{r-1,c-1}\quad\quad\quad\quad\quad\quad\quad(偶数个维度(2)要-1，加)\notag \\\end{align}\]</span></li></ol></li><li><p>三维：</p><ol type="A"><li>原始a <span class="math display">\[\begin{align}a_{r,c,h} = &amp;\ \ \ \ \ \ D_{r,c,h} \tag{7}\\&amp;+\a_{r-1,c,h} \ \ \ + \ \ a_{r,c-1,h}\ \ \ + \a_{r,c,h-1}\quad\quad\quad(奇数个维度(1)要-1，加) \notag \\&amp;-\ a_{r-1,c-1,h}-\ a_{r,c-1,h-1}-\ a_{r-1,c,h-1}\quad\quad(偶数个维度(2)要-1，减)\notag \\&amp;+\a_{r-1,c-1,h-1}\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\\ \ (奇数个维度(3)要-1，加)\notag\end{align}\]</span> B)差分D <span class="math display">\[\begin{align}D_{r,c,h} = &amp;\ \ \ \ \ \ a_{r,c,h}\tag{8}\\&amp;−\a_{r-1,c,h} \ \ \ − \ \ a_{r,c-1,h}\ \ \ − \a_{r,c,h-1}\quad\quad\quad(奇数个维度(1)要-1，减) \notag \\&amp;+\ a_{r-1,c-1,h}+\ a_{r,c-1,h-1}+\ a_{r-1,c,h-1}\quad\quad(偶数个维度(2)要-1，减减得加)\notag \\&amp;−\a_{r-1,c-1,h-1}\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\\ \ (奇数个维度(3)要-1，减)\notag\end{align}\]</span>上述A)和B)两个公式，其实是同一个公式。建议选一个来记住即可，临场现推另外一个，不必全记。</li></ol></li></ol><h3 id="相关操作和解法-2">1.5.3 相关操作和解法</h3><h4 id="批量m次区间修改操作-2">1.5.3.1“<strong>批量（m次）区间修改</strong>”操作</h4><p>在三维情况下，我们修改的是一个立方体，有8个顶点，故我们只需要修改这8个顶点的差分数组b[][][]的值即可。给出坐标点$$定义的区间，如下图所示:</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240325114915696.png" style="zoom: 50%;" /></p><p>那么对应的8个 D[][][]的修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 左侧</span><br>D[r1][c1][h1] += d;     <span class="hljs-comment">// 红点，左前下</span><br>D[r1][c1][h2 + <span class="hljs-number">1</span>] -= d;      <span class="hljs-comment">// 左前上</span><br>D[r1][c2 + <span class="hljs-number">1</span>][h1] -= d;      <span class="hljs-comment">// 左后下</span><br>D[r1][c2 + <span class="hljs-number">1</span>][h2 + <span class="hljs-number">1</span>] += d;  <span class="hljs-comment">// 左后上 </span><br><br><span class="hljs-comment">// 右侧</span><br>D[r2 + <span class="hljs-number">1</span>][c1][h1] -= d;      <span class="hljs-comment">// 右前下</span><br>D[r2 + <span class="hljs-number">1</span>][c1][h2 + <span class="hljs-number">1</span>] += d;  <span class="hljs-comment">// 右前上</span><br>D[r2 + <span class="hljs-number">1</span>][c2 + <span class="hljs-number">1</span>][h1] += d;  <span class="hljs-comment">// 右后下</span><br>D[r2 + <span class="hljs-number">1</span>][c2 + <span class="hljs-number">1</span>][h2 + <span class="hljs-number">1</span>] -= d; <span class="hljs-comment">// 绿点，右后上</span><br></code></pre></td></tr></table></figure><p>为了方便记忆，我们可以把它按照二进制的排列来写，若二进制中出现偶数个"正1"为正，奇数个"正1"为负，与前缀和恰好相反（前缀和是偶数个"-1"为负，奇数个"-1"为正）:$$ <span class="math display">\[\begin{align}{0, 0, 0}\quad&amp;\Rightarrow{r1, c1,h1}&amp;\Rightarrow&amp;D[][][]+=d; \notag \\{0, 0, \textcolor[RGB]{225,0,0}{1}}\quad&amp;\Rightarrow{r1, c1,h2+1}&amp;\Rightarrow&amp;D[][][]\textcolor[RGB]{225,0,0}{-}=d; \notag\\{0, \textcolor[RGB]{225,0,0}{1}, 0}\quad&amp;\Rightarrow{r1, c2+1,h1}&amp;\Rightarrow&amp;D[][][]\textcolor[RGB]{225,0,0}{-}=d; \notag \\{0, 1, 1}\quad&amp;\Rightarrow{r1, c2+1,h2+1}&amp;\Rightarrow&amp;D[][][]+=d; \notag \\{\textcolor[RGB]{225,0,0}{1}, 0, 0}\quad&amp;\Rightarrow{r2+1, c1,h1}&amp;\Rightarrow&amp;D[][][]\textcolor[RGB]{225,0,0}{-}=d; \notag \\{1, 0, 1}\quad&amp;\Rightarrow{r2+1, c1,h2+1}&amp;\Rightarrow&amp;D[][][]+=d; \notag \\{1, 1, 0}\quad&amp;\Rightarrow{r2+1, c2+1,h1}&amp;\Rightarrow&amp;D[][][]+=d; \notag \\  {\textcolor[RGB]{225,0,0}{1}, \textcolor[RGB]{225,0,0}{1},\textcolor[RGB]{225,0,0}{1}}\quad&amp;\Rightarrow{r2+1, c2+1,h2+1}&amp;\Rightarrow&amp;D[][][]\textcolor[RGB]{225,0,0}{-}=d; \notag\\\end{align}\]</span> $$</p><h1 id="二实战训练">二、实战训练</h1><h2 id="hdu-1556一维差分模板题">2.1 HDU 1556（一维差分模板题）</h2><p><strong>原题链接</strong>：<ahref="http://acm.hdu.edu.cn/showproblem.php?pid=1556">HDU 1556 Color theball</a></p><p><strong>问题描述</strong>：N个气球排成一排，从左到右依次编号为1,2,3....N。每次给定2个整数L,R(L&lt;=R)，lele从气球L开始到气球R依次给每个气球涂一次颜色。但是N次以后lele已经忘记了每个气球已经涂过几次颜色了，你能帮他算出每个气球被涂过几次颜色吗？<strong>输入</strong>：每个测试实例第一行为一个整数N，(N&lt;=100000)。接下来的N行，每行包括2个整数L,R(1&lt;=L&lt;=R&lt;=N)。当N=0，输入结束。<strong>输出</strong>：每个测试实例输出一行，包括N个整数，第I个数代表第I个气球总共被涂色的次数。</p><p><strong>分析</strong>：</p><p>这个例题是简单差分法的直接应用，下面给出代码。代码第13、14行是区间修改，第17行的a[i]=a[i−1]+D[i]，即利用D[]求得了最后的a[]。这个式子就是a[i]−a[i−1]=D[i]，它是差分数组的定义。</p><p>注意a[]的计算方法。a[i]=a[i−1]+D[i]是一个递推公式，通过它能在一个i循环中求得所有的a[]。如果不用递推，而是直接用前缀和a[k]=D[1]+D[2]+...+D[k]来求所有的a[]，就需要用两个循环i、k。</p><p>本题AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//hdu 1556用差分数组求解</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Maxn = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> a[Maxn],D[Maxn];               <span class="hljs-comment">//a是气球，D是差分数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)) &#123; <br>        <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a)); <span class="hljs-built_in">memset</span>(D,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(D));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> L,R; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;L,&amp;R);<br>            D[L]++;                 <span class="hljs-comment">//区间修改，这里d=1</span><br>            D[R+<span class="hljs-number">1</span>]--;<br>        &#125;<br>        <span class="hljs-comment">//小技巧：17行到20行，把a[]改成D[]也行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;              <span class="hljs-comment">//求原数组</span><br>            a[i] = a[i<span class="hljs-number">-1</span>] + D[i];           <span class="hljs-comment">//差分。求前缀和a[]，a[i]就是气球i的值</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);     <span class="hljs-comment">//逐个打印结果</span><br>        &#125;        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码可以把第17~20行的a[]改为D[]（即不使用专门的a数组）也能通过。这个技巧在后面的二维差分、三维差分中也能用，节省一倍的空间。</p><h2 id="p2367-一维差分模板题">2.2 P2367 （一维差分模板题）</h2><p>原题链接：<a href="https://www.luogu.com.cn/problem/P2367">P2367语文成绩</a></p><p>这个题和2.1节一样，是第二个裸的一维差分入门模板题。n=5e6，要求1秒完成，所以只能采用<spanclass="math inline">\(O(n)\)</span>的算法才能过。</p><p>AC代码如下。本题代码只用了一个数组，同学们也可以试试看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//P2367用差分数组求解</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Maxn = <span class="hljs-number">5e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> D[Maxn];            <span class="hljs-comment">//差分数组（初始也用来存原始数据）</span><br><span class="hljs-comment">// 本题也可以只定义a[]而不定义D[]，其实代码形式都一样，从内存的角度来说很容易看出来。 </span><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, p;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n, &amp;p);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;D[i]);  <span class="hljs-comment">// 先用差分数组D[]暂存a[] </span><br>    <span class="hljs-comment">// 注意循环顺序只能倒序，不能正序哦！递推公式决定的。 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n; i&gt;=<span class="hljs-number">1</span>; i--) D[i]=D[i]-D[i<span class="hljs-number">-1</span>];     <span class="hljs-comment">// 等效于D[i]=a[i]-a[i-1]，得到真正的差分数组D[] </span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=p; i++) &#123;<br>        <span class="hljs-type">int</span> L,R,s;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;L,&amp;R,&amp;s);<br>        D[L]+=s;                 <span class="hljs-comment">//区间修改的固定套路 </span><br>        D[R+<span class="hljs-number">1</span>]-=s;<br>    &#125;<br>    <span class="hljs-type">int</span> minn = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;            <br>        D[i] = D[i<span class="hljs-number">-1</span>] + D[i];    <span class="hljs-comment">//以前缀和的方法，恢复出原始数组a[i]，仍存于D[i]</span><br>        <span class="hljs-keyword">if</span> (D[i]&lt;minn)<br>            minn= D[i];<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, minn);   <span class="hljs-comment">//逐个打印结果</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p4552多少次多少种">2.3 P4552（多少次，多少种）</h2><p>原题链接：<a href="https://www.luogu.com.cn/problem/P4552">P4552[Poetize6] IncDec Sequence</a></p><p>视频讲解链接：<ahref="https://www.bilibili.com/video/BV12u411L7ii">差分二维差分</a>（04:53处）</p><p><strong>分析：</strong></p><p><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230705121209012-1332416451.png" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230705121209018-1370204910.png" /></p><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[maxn], D[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);<br>        D[i] = a[i] - a[i<span class="hljs-number">-1</span>];<br>    &#125;<br><br>LL p=<span class="hljs-number">0</span>, q=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++)<br><span class="hljs-keyword">if</span>(D[i]&gt;<span class="hljs-number">0</span>) <br>            p += D[i];<br><span class="hljs-keyword">else</span> <br>            q += <span class="hljs-built_in">abs</span>(D[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n%lld&quot;</span>, <span class="hljs-built_in">max</span>(p,q), <span class="hljs-built_in">abs</span>(p-q)+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p9011深搜为主一维差分可有">2.4P9011（深搜为主，一维差分可有）</h2><p>原题链接：<a href="https://www.luogu.com.cn/problem/P9011">P9011[USACO23JAN] Air Cownditioning II B</a></p><p>题目简意：要求从M(<span class="math inline">\(1\leqM\leq10\)</span>)个区间修改中选择若干个（次数不定）修改，对一个数组a[1..100]（初始全0）进行区间修改，每次修改的成本代价已知且不同，求将数组改造成指定要求的内容最少需要的代价之和。</p><p><strong>分析</strong>：</p><p>题意中说“从M个中选择若干个……”，且M如此之小，第一反应就是用深搜来暴力尝试。针对每个区间修改，我们有“选择它”和“不选择它”这两种选择方案。两种方案都要尝试，都要执行。</p><p>1）如果选择做第i个修改，则对a数组中第le[i]..ri[i]个之间的数据进行区间修改，可以采用差分数组将其降为<spanclass="math inline">\(O(1)\)</span>的复杂度（也可以直接开for循环来做，<spanclass="math inline">\(O(N=20)\)</span>变成<spanclass="math inline">\(O(N*100=2e4)\)</span>，也不大），累计成本，对下一个修改做选择；</p><p>2）如果选择不做该修改，成本不变，对下一个修改做选择；</p><p>以上的操作一直进行到M个区间修改全都完毕，可以视为一个方案。此时的成本即为该方案的成本。当前需要求最小成本，所以在深搜的过程中可以剪枝（若当前成本已经大于曾经的最小成本，则没必要继续深搜下去了，不可能优）</p><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> N,M,k,minmoney=<span class="hljs-number">1e9</span>;<br><span class="hljs-type">int</span> wendu[<span class="hljs-number">105</span>];   <span class="hljs-comment">// 100个围栏的温度 </span><br><span class="hljs-type">int</span> s[<span class="hljs-number">25</span>],t[<span class="hljs-number">25</span>],c[<span class="hljs-number">25</span>];  <span class="hljs-comment">// 最多20个奶牛，占据从s[]到t[]的围栏，要求温度要下降c[]度 </span><br><span class="hljs-type">int</span> a[<span class="hljs-number">25</span>],b[<span class="hljs-number">25</span>],p[<span class="hljs-number">25</span>],m[<span class="hljs-number">25</span>];  <span class="hljs-comment">// 最多10个空调，从a[]到b[]的围栏温度都能下降m[]度  </span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//是否满足</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=k; i++)&#123;<br>        <span class="hljs-keyword">if</span>(wendu[i]&gt;<span class="hljs-number">0</span>)   <span class="hljs-comment">// 如果还存在某个围栏的预设温度没有降到0及以下，说明降温不够要求 </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> dep,<span class="hljs-type">int</span> money)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (money &gt; minmoney)  <span class="hljs-comment">// 剪枝，如果继续下去，不可能再小于minnoney，放弃这个分支 </span><br>        <span class="hljs-keyword">return</span>; <br>    <span class="hljs-keyword">if</span>(dep&gt;M)&#123;     <span class="hljs-comment">// 已经处理完M个空调的选择 </span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>()) <br>            minmoney=<span class="hljs-built_in">min</span>(minmoney,money);<span class="hljs-comment">//合法就更新答案</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(dep+<span class="hljs-number">1</span>,money); <span class="hljs-comment">//不选，前进 </span><br><br>    <span class="hljs-comment">// 做完“不选第dep个修改”的尝试之后，再做“做第dep个修改”的尝试    </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a[dep]; i&lt;=b[dep]; i++) wendu[i]-=p[dep]; <span class="hljs-comment">//选，既然选，就要降温 </span><br>    <span class="hljs-built_in">dfs</span>(dep+<span class="hljs-number">1</span>,money+m[dep]);   <span class="hljs-comment">// 前进 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a[dep]; i&lt;=b[dep]; i++) wendu[i]+=p[dep]; <span class="hljs-comment">//回溯，抹掉对应的修改 </span><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt;N &gt;&gt;M;    <span class="hljs-comment">// 奶牛数N，空调数M </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=N; i++)&#123;<br>        cin &gt;&gt;s[i] &gt;&gt;t[i] &gt;&gt;c[i];<br>        k=<span class="hljs-built_in">max</span>(k,t[i]);<br>        wendu[s[i]]+=c[i];   <span class="hljs-comment">//差分的处理方式 </span><br>        wendu[t[i]+<span class="hljs-number">1</span>]-=c[i]; <span class="hljs-comment">// </span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">100</span>; i++)<br>        wendu[i]+=wendu[i<span class="hljs-number">-1</span>]; <span class="hljs-comment">//将差分数组还原成原始数组 </span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=M; i++) cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;p[i]&gt;&gt;m[i];<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);      <span class="hljs-comment">// 考虑第1个修改，已付成本为0 </span><br>    cout&lt;&lt;minmoney;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他简单的一维差分题训练">2.5 其他简单的一维差分题训练</h2><p>1）<a href="https://www.luogu.com.cn/problem/CF44C">CF44CHolidays</a>,原题链接点<ahref="https://codeforces.com/problemset/problem/44/C"><strong>这里</strong></a></p><p>2）<a href="https://www.luogu.com.cn/problem/P1672">P1672[USACO05FEB] Feed Accounting S</a></p><p>3)<a href="https://www.luogu.com.cn/problem/P4623">P4623[COCI2012-2013#6] BUREK</a></p><h2 id="p3397二维差分模板题">2.6 P3397（二维差分模板题）</h2><p><strong>原题链接</strong>：<ahref="https://www.luogu.com.cn/problem/P3397">P3397 地毯</a></p><p><strong>分析</strong>：</p><p>这一题是2.1节的hdu1556的二维扩展，其修改操作和查询操作完全一样。m=1000次修改，n*n的网格范围。</p><p>在用差分之前，先考虑能不能用暴力法。每次修改复杂度是<spanclass="math inline">\(O(n^2)\)</span>，共m次，总复杂度<spanclass="math inline">\(O(m*n^2=1e9)\)</span>，超时。</p><p>二维差分的复杂度是多少？一维差分的一次修改是<spanclass="math inline">\(O(1)\)</span>的，二维差分的修改是O(4)的；一维差分的一次查询是<spanclass="math inline">\(O(n)\)</span>的，二维差分是<spanclass="math inline">\(O(n^2)\)</span>的，所以二维差分的总复杂度是<spanclass="math inline">\(O(4*m+n^2)\)</span>。由于计算一次二维矩阵的值需要<spanclass="math inline">\(O(n^2)\)</span>的计算量，所以二维差分已经达到了最好的复杂度。</p><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> D[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>];     <span class="hljs-comment">//差分数组</span><br><span class="hljs-comment">//int a[1010][1010];   //原数组，不定义也行</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);<br>        D[x1][y1]     += <span class="hljs-number">1</span>;        <span class="hljs-comment">//计算差分数组</span><br>        D[x2+<span class="hljs-number">1</span>][y1]   -= <span class="hljs-number">1</span>;<br>        D[x1][y2+<span class="hljs-number">1</span>]   -= <span class="hljs-number">1</span>;<br>        D[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>] += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 还原的方法1：前缀和方式 O(d * n^2)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i)           <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;n; ++j)        <span class="hljs-comment">//注意这里是j&lt;n</span><br>            D[i][j+<span class="hljs-number">1</span>] += D[i][j];     <span class="hljs-comment">//把i看成定值，先累加计算j方向</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; ++j)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; ++i)        <span class="hljs-comment">//注意这里是i&lt;n</span><br>            D[i+<span class="hljs-number">1</span>][j] += D[i][j];     <span class="hljs-comment">//把j看成定值，再累加计算i方向</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) &#123;         <span class="hljs-comment">//打印</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; ++j)<br>             <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,D[i][j]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);                 <span class="hljs-comment">//换行</span><br>    &#125;<br>     <br><span class="hljs-comment">//    // 还原的方法2：递推方式   O(2^d * n^2) </span><br><span class="hljs-comment">//    for(int i=1;i&lt;=n;++i)&#123;   //根据差分数组计算原矩阵的值（想象成求小格子的面积和）</span><br><span class="hljs-comment">//        for(int j=1;j&lt;=n;++j)&#123;      //把用过的D[][]看成a[][]，就不用再定义a[][]了</span><br><span class="hljs-comment">//            //a[i][j] = D[i][j] + a[i-1][j] + a[i][j-1] - a[i-1][j-1];</span><br><span class="hljs-comment">//            //printf(&quot;%d &quot;,a[i][j]);  //这两行和下面两行的效果一样</span><br><span class="hljs-comment">//            D[i][j] += D[i-1][j]+D[i][j-1]-D[i-1][j-1];</span><br><span class="hljs-comment">//            printf(&quot;%d &quot;,D[i][j]);</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        printf(&quot;\n&quot;);//换行</span><br><span class="hljs-comment">//    &#125;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三体攻击三维差分模板题">2.7 三体攻击（三维差分模板题）</h2><p><strong>原题链接</strong>：<ahref="https://www.lanqiao.cn/problems/180/learning/">三体攻击（蓝桥杯2018年省赛A组）</a></p><p><strong>问题简述</strong>：</p><p>三体人将对地球发起攻击。为了抵御攻击，地球人派出了<spanclass="math inline">\(n = A × B × C\)</span> 艘战舰，在太空中排成一个 A层 B 行 C 列的立方体。其中，第 i 层第 j 行第 k 列的战舰（记为战舰 <spanclass="math inline">\((i, j, k)\)</span>）的生命值为 <spanclass="math inline">\(s(i, j, k)\)</span>。</p><p>三体人将会对地球发起 m轮“立方体攻击”，每次攻击会对一个小立方体中的所有战舰都造成相同的伤害。具体地，第t轮攻击用7个参数x1, x2, y1, y2, z1, z2, d 来描述；</p><p>所有满足<span class="math inline">\(i∈[x1, x2], j∈[y1, y2],k∈[z1, z2]\)</span> 的战舰 <spanclass="math inline">\((i, j, k)\)</span>会受到值为d的伤害。如果一个战舰累计受到的总伤害超过其防御力，那么这个战舰会爆炸。</p><p>地球指挥官希望你能告诉他，第一艘爆炸的战舰是在哪一轮攻击后爆炸的。</p><p>输入：第一行包括 4 个正整数 A, B, C, m；</p><p>第二行包含<span class="math inline">\(A × B ×C\)</span>个整数，其中第<span class="math inline">\(((i − 1)×B + (j −1)) × C + (k − 1)+1\)</span> 个数为<spanclass="math inline">\(s(i, j, k)\)</span>；</p><p>第 3 到第 m + 2 行中，第 (t − 2) 行包含 7 个正整数 x1,x2, y1, y2, z1, z2, d。</p><p><span class="math inline">\(A × B ×C ≤ 10^6, m ≤ 10^6, 0 ≤ s(i, j, k), d ≤ 10^9\)</span>。</p><p>输出：输出第一个爆炸的战舰是在哪一轮攻击后爆炸的。保证一定存在这样的战舰。</p><p><strong>分析</strong>：</p><p>首先看数据规模，有<span class="math inline">\(n=10^6\)</span>个点，<spanclass="math inline">\(m=10^6\)</span>次攻击，如果用暴力法，统计每次攻击后每个点的生命值，那么复杂度是<spanclass="math inline">\(O(m*n)\)</span>的，超时。</p><p>本题适合用三维差分，每次攻击只修改差分数组D[][][]，一次修改的复杂度是<spanclass="math inline">\(O(1)\)</span>，m次修改的总复杂度只有<spanclass="math inline">\(O(m)\)</span>。</p><p>但是光用差分数组并不能解决问题。因为在差分数组上查询区间内的原始数组中每个元素是否小于0，需要用差分数组来计算前缀和数组（即原始数组a）的值，复杂度是<spanclass="math inline">\(O(n)\)</span>的。合起来的总复杂度还是<spanclass="math inline">\(O(m*n)\)</span>的，跟暴力法的复杂度一样。</p><p>分析到这里，可以发现，本题和P1083是非常相似的（P1083的分析过程请见本站“二分查找和二分答案”帖），是存在单调性的。本题需要结合第二个算法：二分法。从第1次修改到第m次修改，肯定有一次修改是临界点。在临界点前，没有负值（战舰爆炸）；在临界点后，出现了负值，且后面一直有负值。这就是单调性。那么对m进行二分，就能在<spanclass="math inline">\(O(logm)\)</span>次内找到这个临界点，这就是答案。总复杂度<spanclass="math inline">\(O(n*logm)\)</span>。</p><p>下面给出代码。其中<code>check()</code>函数包含了三维差分的全部内容。代码有几个关键点：</p><p>（1）没有定义a[][][]，而是用D[][][]来代替。</p><p>（2）<strong>压维</strong>。直接定义三维差分数组D[][][]不太方便。虽然坐标点总数量<spanclass="math inline">\(n=A×B×C=10^6\)</span>比较小，但是本题并没有明确告知每一维的最大长度，所以如果定义成三维数组，那么每一维都需要定义到<spanclass="math inline">\(10^6\)</span>，那么总空间就是<spanclass="math inline">\(10^{18}\)</span>。为避免这一问题，可以把三维坐标压维成一维数组D[]，总长度仍然是<spanclass="math inline">\(10^6\)</span>的。这个技巧很有用。实现函数是<code>num()</code>，它把三维坐标(x,y,z)变换为一维坐标<spanclass="math inline">\(h=(x−1)∗B∗C+(y−1)∗C+(z−1)+1\)</span>，当x、y、z的取值范围分别是<spanclass="math inline">\([1,\ A]、[1,\ B]、[1,\C]\)</span>时，h的范围是<span class="math inline">\([1,\  A × B ×C]\)</span>。</p><p>如果希望按C语言的习惯从0开始，x、y、z的取值范围分别是<spanclass="math inline">\([0,\ A-1]、[0,\ B-1]、[0,\ C-1]\)</span>，h范围是0~ A × B × C-1，就把式子改为：<spanclass="math inline">\(h=x∗B∗C+y∗C+z\)</span>。</p><p>同理，二维坐标(x,y)也可以压维成一维<spanclass="math inline">\(h=(x−1)∗B+(y−1)+1\)</span>，当x、y的取值范围分别是<spanclass="math inline">\([1,\ A]、[1,\ B]\)</span>时，hℎ的范围是<spanclass="math inline">\([1,\  A × B]\)</span>。</p><p>（3）<code>check()</code>中19-26行，在D[1..n]上记录区间修改。</p><p>（4）<code>check()</code>中29-40行的3个<code>for</code>循环计算前缀和。分别从x、y、z三个方向累加小立方体的体积，计算出所有的前缀和。</p><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> A,B,C,n,m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Maxn = <span class="hljs-number">1000005</span>;<br><span class="hljs-type">int</span> s[Maxn];   <span class="hljs-comment">//存储舰队生命值</span><br><span class="hljs-type">int</span> D[Maxn];   <span class="hljs-comment">//三维差分数组（压维）；同时也用来计算每个点的攻击值</span><br><span class="hljs-type">int</span> x2[Maxn], y2[Maxn], z2[Maxn]; <span class="hljs-comment">//存储区间修改的范围，即攻击的范围</span><br><span class="hljs-type">int</span> x1[Maxn], y1[Maxn], z1[Maxn]; <br><br><span class="hljs-type">int</span> d[Maxn];                    <span class="hljs-comment">//记录伤害，就是区间修改</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;  <br><span class="hljs-comment">//小技巧：压维，把三维坐标[(x,y,z)转为一维的((x-1)*B+(y-1))*C+(z-1)+1</span><br>    <span class="hljs-keyword">if</span> (x&gt;A || y&gt;B || z&gt;C) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> ((x<span class="hljs-number">-1</span>)*B+(y<span class="hljs-number">-1</span>))*C+(z<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;              <span class="hljs-comment">//做x次区间修改。即检查经过x次攻击后是否有战舰爆炸</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)  D[i]=<span class="hljs-number">0</span>;  <span class="hljs-comment">//差分数组的初值，本题是0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=x; i++) &#123;         <span class="hljs-comment">//用三维差分数组记录区间修改：有8个区间端点</span><br>        D[<span class="hljs-built_in">num</span>(x1[i],  y1[i],  z1[i])]   += d[i];<br>        D[<span class="hljs-built_in">num</span>(x2[i]+<span class="hljs-number">1</span>,y1[i],  z1[i])]   -= d[i];<br>        D[<span class="hljs-built_in">num</span>(x1[i],  y1[i],  z2[i]+<span class="hljs-number">1</span>)] -= d[i];<br>        D[<span class="hljs-built_in">num</span>(x2[i]+<span class="hljs-number">1</span>,y1[i],  z2[i]+<span class="hljs-number">1</span>)] += d[i];<br>        D[<span class="hljs-built_in">num</span>(x1[i],  y2[i]+<span class="hljs-number">1</span>,z1[i])]   -= d[i];<br>        D[<span class="hljs-built_in">num</span>(x2[i]+<span class="hljs-number">1</span>,y2[i]+<span class="hljs-number">1</span>,z1[i])]   += d[i];<br>        D[<span class="hljs-built_in">num</span>(x1[i],  y2[i]+<span class="hljs-number">1</span>,z2[i]+<span class="hljs-number">1</span>)] += d[i];<br>        D[<span class="hljs-built_in">num</span>(x2[i]+<span class="hljs-number">1</span>,y2[i]+<span class="hljs-number">1</span>,z2[i]+<span class="hljs-number">1</span>)] -= d[i];<br>    &#125;<br>    <span class="hljs-comment">//下面从x、y、z三个方向计算前缀和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=A; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=B; j++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;C; k++)        <span class="hljs-comment">//把x、y看成定值，累加z方向</span><br>                D[<span class="hljs-built_in">num</span>(i,j,k+<span class="hljs-number">1</span>)] += D[<span class="hljs-built_in">num</span>(i,j,k)];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=A; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=C; k++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;B; j++)        <span class="hljs-comment">//把x、z看成定值，累加y方向</span><br>                D[<span class="hljs-built_in">num</span>(i,j+<span class="hljs-number">1</span>,k)] += D[<span class="hljs-built_in">num</span>(i,j,k)];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=B; j++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=C; k++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;A; i++)        <span class="hljs-comment">//把y、z看成定值，累加x方向</span><br>                D[<span class="hljs-built_in">num</span>(i+<span class="hljs-number">1</span>,j,k)] += D[<span class="hljs-built_in">num</span>(i,j,k)];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)    <span class="hljs-comment">//最后判断是否攻击值大于生命值</span><br>        <span class="hljs-keyword">if</span> (D[i]&gt;s[i])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;A, &amp;B, &amp;C, &amp;m);<br>    n = A*B*C;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;s[i]);  <span class="hljs-comment">//读生命值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)                      <span class="hljs-comment">//读每次攻击的范围，用坐标表示</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d%d%d%d&quot;</span>,&amp;x1[i],&amp;x2[i],&amp;y1[i],&amp;y2[i],&amp;z1[i],&amp;z2[i],&amp;d[i]);<br><br>    <span class="hljs-type">int</span> L = <span class="hljs-number">1</span>,R = m;      <span class="hljs-comment">//经典的二分写法</span><br>    <span class="hljs-keyword">while</span> (L&lt;R) &#123;     <span class="hljs-comment">//对m进行二分，找到临界值。总共只循环了log(m)次</span><br>        <span class="hljs-type">int</span> mid = (L+R)&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) R = mid;<br>        <span class="hljs-keyword">else</span> L = mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, R);  <span class="hljs-comment">//打印临界值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线性结构编程技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位操作（与、或、异或）方法详解</title>
      <link href="/2024/01/30/%E4%BD%8D%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%8E%E3%80%81%E6%88%96%E3%80%81%E5%BC%82%E6%88%96%EF%BC%89%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/01/30/%E4%BD%8D%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%8E%E3%80%81%E6%88%96%E3%80%81%E5%BC%82%E6%88%96%EF%BC%89%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="一.-按位与">一. 按位与（ &amp; ）</h1><h2 id="基本运算常识">1.1 基本运算常识</h2><p>参加运算的两个数据，按<strong>二进制位</strong>进行“与”运算。</p><p>运算规则：0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1;</p><p>即：<strong>两位同时为“1”，结果才为“1”，否则为0</strong></p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">AndOperator</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a &amp; b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 3&amp;5 即 0000 0011 &amp; 0000 0101 = 0000 0001  因此，3&amp;5的值得1</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">5</span>;<br>    cout&lt;&lt; <span class="hljs-built_in">AndOperator</span>(a, b) &lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：<strong>负数按补码形式参加按位与运算</strong>。</p><p>例如： -3 &amp; 5 　　　即 1111 1101 &amp; 0000 0101 = 0000 0101　　　因此，-3 &amp; 5的值得5</p><h2 id="与运算的小技巧">1.2 “与”运算的小技巧</h2><h3 id="清零">1.2.1 清零</h3><p>若想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。 例：3 &amp; 0 = 0</p><h3 id="提取一个数的指定位">1.2.2 提取一个数的指定位</h3><p>将一个数指定的某个或某些bit值设置为1，其余为0。</p><p>例：设 <span class="math inline">\(X = (1010 \ 1110)_2\)</span>，　　取X的低4位： 1010 <font color="red">1110</font> &amp; 0000<font color="yellow">1111</font> = 0000 <font color="red">1110</font>　　取X的第5位： 1010 <font color="red">1110</font> &amp; 0000<font color="yellow">1</font>000 = 0000<font color="red">1</font>000</p><h3 id="判断奇偶">1.2.3 判断奇偶</h3><p>根据未位是0还是1来决定该数的奇偶，若为0就是偶数，为1就是奇数。</p><p>因此可以用if (a &amp; 1 == 0)代替if (a % 2 ==0)来判断“a是不是偶数”。那判断“a是不是奇数”该怎么做呢？见下面的代码。</p><p>下面程序将输出0到100之间的所有奇数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i)&#123;  <br>    <span class="hljs-keyword">if</span> (i &amp; <span class="hljs-number">1</span>)   <span class="hljs-comment">// 等效于 if (i % 2) 或者 if ( i % 2 == 1)</span><br>        cout&lt;&lt; i &lt;&lt;endl;<br>&#125; <br></code></pre></td></tr></table></figure><h1 id="二.-按位或">二. 按位或（|）</h1><h2 id="基本运算常识-1">2.1 基本运算常识</h2><p>参加运算的两个对象，按二进制位进行“或”运算。</p><p>运算规则：0|0=0； 0|1=1； 1|0=1； 1|1=1；</p><p>即 ：<strong>参加运算的两个对象只要有一个为1，其值为1</strong>。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">OrOperator</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a | b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 3|5 即 0000 0011 | 0000 0101 = 0000 0111  因此，3|5的值得7</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">5</span>;<br>    cout&lt;&lt; <span class="hljs-built_in">OrOperator</span>(a, b) &lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：<strong>负数按补码形式参加按位或运算</strong>。</p><p>例如： -3 | 5 　　　即 <strong>1111 1101</strong> | 0000 0101 = 11111101 　　　因此，-3 | 5的值为-3</p><h2 id="或运算的小技巧">2.2 “或”运算的小技巧</h2><h3 id="常用来将一个数的-指定bit设置为1">常用来将一个数的指定bit设置为1</h3><p>例：将<span class="math inline">\(X=(1010\ 0000)_2\)</span>的低4位置1，用 <font color="red">1010</font> 0000 | 0000<font color="yellow">1111</font> = <font color="red">1010</font>1111即可得到。</p><h1 id="三.-按位异或">三. 按位异或（^）</h1><h2 id="运算规则及推论">3.1 运算规则及推论</h2><h3 id="运算规则">3.1.1 运算规则</h3><p>“异或”运算的<strong>数学</strong>表达符号是“<strong><spanclass="math inline">\(\oplus\)</span></strong>”，或者“<strong>xor</strong>”。例如<span class="math inline">\(a \oplus b \oplus c\)</span>，或者<spanclass="math inline">\(a\,\,xor\,\,b\,\,xor\,\, c\)</span></p><p>“异或”运算的C++代码书写符号是'^'。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>, b=<span class="hljs-number">-8</span>;<br><span class="hljs-type">int</span> c= a ^ b;<br></code></pre></td></tr></table></figure><p>参加运算的两个数据，按二进制位进行“异或”运算：</p><p>0^0=0； 0^1=1； 1^0=1； 1^1=0；</p><p>即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">XOR</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a ^ b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 3^5 即 0000 0011 ^ 0000 0101 = 0000 0111  因此，3|5的值得6</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">5</span>;<br>    cout&lt;&lt; <span class="hljs-built_in">XOR</span>(a, b) &lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="相关的重要推论">3.1.2 相关的重要推论</h3><p>假如有两个int或者char变量，分别为a和b，则有：</p><p>（1）交换律 <span class="math display">\[a \oplus b = b \oplus a\]</span> （2）结合律 <span class="math display">\[a \oplus b \oplus c = a \oplus (b \oplus c)\]</span> （3）任何数a与0异或后结果是a自己 <span class="math display">\[a \oplus 0 = a\]</span> （4）任何数a与自己异或后结果是0 <span class="math display">\[a \oplus a = 0\]</span></p><h2 id="异或运算的小技巧">3.2 “异或”运算的小技巧</h2><h3 id="使特定bit翻转其余bit不变">3.2.1使特定bit翻转，其余bit不变</h3><p>假如现在有一个X，想将其指定的某些bit值进行翻转，该怎么做呢？很简单，找到一个数Y，对应X要翻转的各位，该数Y的对应位为1，Y的其余位为零，此数与X做异或运算即可。例：<span class="math inline">\(X=(1010\1110)_2\)</span>，若要使X的低3位翻转，则用<font color="red">10101</font><font color="green">110</font> ^ 00000<font color="yellow">111</font> = <font color="red">10101</font><font color="green">001</font>即可得到。</p><h3 id="与0相异或保留原值">3.2.2 与0相异或，保留原值</h3><p>1010 1110 ^ 0000 0000 = 1010 1110。从上面的例题可以清楚的看到这一点。</p><h3 id="交换a和b的值">3.2.3 交换a和b的值</h3><p>交换两个整数a和b的值，不允许使用临时变量，该如何实现？用“异或”操作可以实现！但“异或”操作仅限于整数和char，不适用于double和结构体等类型。</p><p>这里只有a和b两个变量，但为了体现出变量因为时间先后而引起的值的差异，所以用a1和b1表示变量a和b的初始值，用a2和b2表示其经过更改后的值。数学步骤如下三步所示：</p><p><span class="math display">\[\begin{align*}(1)\qquad a2 &amp;= a1 \oplus b1\qquad\qquad\qquad\qquad\qquad\quad\end{align*}\]</span></p><p><span class="math display">\[\begin{align*}(2)\qquad b2 &amp;= \underline{a2} \oplus b1\\&amp;=(\underline{a1 \oplus b1})  \oplus b1\qquad (根据(1式))\\&amp;=a1\oplus (b1 \oplus b1)  \qquad(异或的结合律)\\&amp;=a1 \oplus 0\\&amp;=a1\end{align*}\]</span></p><p><span class="math display">\[\begin{align*}(3)\qquad a2&amp;= a2 \oplus \underline{b2} \\&amp;=(a1 \oplus b1)\oplus \underline{a1} \qquad(根据(1)、(2)式)\\&amp;=(b1 \oplus a1) \oplus a1\qquad\quad(交换律) \\&amp;=b1 \oplus (a1 \oplus a1)\qquad\quad(结合律) \\&amp;=b1 \oplus 0\\&amp;=b1 \\\end{align*}\]</span></p><p>其代码形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a, b;<br>cin &gt;&gt;a &gt;&gt;b;<br>a = a ^ b;  <span class="hljs-comment">// 这里三个赋值语句的左端变量，可以a、b、a；也可以b、a、b（体现出任意两个数）交换</span><br>b = a ^ b;  <span class="hljs-comment">// 右侧两个变量左右均可随意交换，因为“异或”满足交换律</span><br>a = a ^ b;<br>cout &lt;&lt;a &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;b;<br></code></pre></td></tr></table></figure><h2 id="强化练习">3.3 强化练习</h2><h3 id="p1469-找筷子">3.3.1 P1469 找筷子</h3><p>原题链接：<a href="https://www.luogu.com.cn/problem/P1469">P1469找筷子</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">给你 n 个数，求出现了奇数次的数（确保只有一个）的数值是多少? </span><br><span class="hljs-comment">n达到1e7，每个数的范围也很大，只能用O(n)的效率才能过，空间要求4MB，卡得很严，如果定义数组，很容易MLE</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">需要知道一个性质：</span><br><span class="hljs-comment">0 ^ a = a （1） </span><br><span class="hljs-comment">a ^ a = 0      （2） </span><br><span class="hljs-comment">a ^ a ^ a = a</span><br><span class="hljs-comment">a ^ a ^ b ^ b = 0   根据（2） </span><br><span class="hljs-comment">a ^ b ^ a ^ b = 0   满足交换律 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">所以，本题就简单了，只需要把n个数进行连续异或，其结果值就是那个具有奇数个的数。 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n,x,ans = <span class="hljs-number">0</span>;<br>n = <span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <br>x = <span class="hljs-built_in">read</span>(),ans ^= x;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> s = <span class="hljs-number">0</span>,f = <span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>((ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &amp;&amp; ch != EOF) &#123;<br><span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;-&#x27;</span>) f = <span class="hljs-number">-1</span>;<br>ch = <span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>s = s * <span class="hljs-number">10</span> + ch - <span class="hljs-string">&#x27;0&#x27;</span>;<br>ch = <span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">return</span> s * f;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="b3908-异或构造题">3.3.2 B3908 异或构造题？</h3><p>原题链接：<a href="https://www.luogu.com.cn/problem/B3908">B3908[语言月赛 202312] 异或构造题？</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n,a, x=<span class="hljs-number">0</span>;<br>    cin &gt;&gt;n;<br>    <span class="hljs-keyword">while</span> (n--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a), x=x^a;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld 0&quot;</span>, x);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="p8845-小卡和质数">3.3.3 P8845 小卡和质数</h3><p>原题链接：<a href="https://www.luogu.com.cn/problem/P8845">P8845[传智杯 #4 初赛] 小卡和质数</a></p><p>怎么样的两个数异或值为 00000001呢？显然是二进制下只有末位bit的值不同的数。要满足这个条件，需要两个质数的其他位都相同，而末位不同，也就是说，两者值相差1。所有质数中，只有3 和 2 相差1，所以他们的异或值为 1。最终得到：两个质数只能是 3 和2。</p><p>3是第2个质数，2 是第1个质数，则x和y为2和1，或者1和2。两数可能调换位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> t,a,b;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)&#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>((a==<span class="hljs-number">2</span>&amp;&amp;b==<span class="hljs-number">1</span>)||(a==<span class="hljs-number">1</span>&amp;&amp;b==<span class="hljs-number">2</span>)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="p9227异或积">3.3.4 P9227异或积</h3><p>原题链接：<a href="https://www.luogu.com.cn/problem/P9227">P9227异或积</a></p><p>分析：</p><p>拿到一个题，看懂题意之后，首先看数据规模。本题中n最大可到<spanclass="math inline">\(10^5\)</span>个数，最多要求做<spanclass="math inline">\(k=10^{18}\)</span>轮变化。如果直接硬干，早就TLE了。所以这个题必然是有巧方法的，不能硬干。根据3.1.2节中介绍的3）和4），所以我们可以从n和k的奇偶性方面来作为分析的切入点试试看。</p><p>此时，我们可以举个例子来试试看，推演一下，尝试看能不能找到其中的规律。</p><p>（1）假设n=4（当然，你也可以假设n=5或者6，但建议不要太多，不然草稿纸不够你写的），则有：</p><p><span class="math display">\[\begin{align*}(a_1,\quad a_2,\quada_3,\quad a_4)&amp;\stackrel{第1轮}{\Longrightarrow} (a_2\oplusa_3\oplus a_4, \quad a_1\oplus a_3\oplus a_4, \quad a_1\oplus a_2\oplusa_4, \quad a_1\oplus a_2\oplus a_3) \\&amp;\stackrel{第2轮}{\Longrightarrow}((\textcolor[RGB]{225,0,0}{\cancel{a_1}}\oplus\textcolor[RGB]{0,225,0}{\cancel{a_3}}\oplus\textcolor[RGB]{225,225,0}{\cancel{a_4}}\oplus\textcolor[RGB]{225,0,0}{\cancel{a_1}}\oplus\textcolor[RGB]{100,100,225}{\cancel{a_2}}\oplus\textcolor[RGB]{225,225,0}{\cancel{a_4}}\oplus a_1\oplus\textcolor[RGB]{100,100,225}{\cancel{a_2}}\oplus\textcolor[RGB]{0,225,0}{\cancel{a_3}}),\,\,数列第2项值\,\,,\,\,数列第3项值\,\,,\,\,数列第4项值\,\,)\\&amp;=(a_1,数列第2项值\,\,,\,\,数列第3项值\,\,,\,\,数列第4项值)\\&amp;=(a_1,a_2,a_3,a_4)\qquad\qquad//其他3项按照和a_1类似的方法\\\end{align*}\]</span></p><p>可以看出，当n为偶数时，经过第1轮变换后的每一项值，都是奇数个其他原数的连续异或值，则在进行第2轮变换时，该位置上的结果必然是n-1（n-1是奇数）个数值的异或，且这些数值也是奇数个原数的异或，<spanclass="math inline">\(a_1\)</span>经过两轮变换之后仍然还是<spanclass="math inline">\(a_1\)</span>，这样就很好办了！如果k为偶数，就返回原始序列的值；如果k为奇数，就返回第一轮的序列值。</p><p>（2）假设n=3，则有：</p><p><span class="math display">\[\begin{align*}(a_1,\quad a_2,\quada_3)&amp;\stackrel{第1轮}{\Longrightarrow} (a_2\oplus a_3, \quada_1\oplus a_3, \quad a_1\oplus a_2 )\\&amp;\stackrel{第2轮}{\Longrightarrow}((\textcolor[RGB]{225,0,0}{\cancel{a_1}}\oplusa_3\oplus \textcolor[RGB]{225,0,0}{\cancel{a_1}}\oplusa_2),\,\,数列第2项值\,\,,\,\,数列第3项值\,\,,\,\,数列第4项值\,\,) \\&amp;=(a_2\oplus a_3, \quad a_1\oplus a_3, \quad a_1\oplus a_2)\qquad//其他3项按照和a_1类似的方法\\\end{align*}\]</span></p><p>可以看出，当n为奇数时，经过第1轮变换后的每一项值，都是偶数个其他原数的连续异或值，则在进行第2轮变换时，该位置上的结果不变，仍然是第1轮的结果，这样也很好办了！不管k是奇数或者是偶数，都返回第一轮的序列值。</p><p>（3）可以对上述两点进行归纳，即：“<strong>当n为偶数且k为偶数时，返回原始序列的值；否则返回第一轮序列的值</strong>”</p><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br>ll T, n;<br>ll k;<br>ll a[N], b[N];<br><span class="hljs-comment">// 最多10万个数据的输入，建议上快读 </span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    ll x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> ch; <br>    <span class="hljs-keyword">while</span>(ch = <span class="hljs-built_in">getchar</span>() , ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;-&#x27;</span>) f = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        x = (x &lt;&lt; <span class="hljs-number">1</span>) + (x &lt;&lt; <span class="hljs-number">3</span>) + (ch ^ <span class="hljs-number">48</span>);<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> x * f;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    T = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">while</span>(T--) &#123;<br>        n = <span class="hljs-built_in">read</span>(), k = <span class="hljs-built_in">read</span>();<br>        ll sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            a[i] = <span class="hljs-built_in">read</span>();<br>            sum ^=a[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; k % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)  <span class="hljs-comment">// 输出原始序列的值，作为答案 </span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, a[i]);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)  <span class="hljs-comment">// 输出第一轮序列的值，作为答案</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, sum^a[i]);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四.-位运算综合练习">四. 位运算综合练习</h1><h2 id="p1100-高低位交换">4.1 P1100 高低位交换</h2><p>原题链接：<a href="https://www.luogu.com.cn/problem/P1100">P1100高低位交换</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> x;    <span class="hljs-comment">// 必须要unsigned，才是真正的32位有效数据，不管正负号</span><br>cin&gt;&gt;x;<br><span class="hljs-comment">//cout&lt;&lt;( (x&amp;0x0000ffff)&lt;&lt;16 | (x&amp;0xffff0000)&gt;&gt;16 ) &lt;&lt;endl;  //法1</span><br><span class="hljs-comment">//cout&lt;&lt; (x&lt;&lt;16) + (x&gt;&gt;16) &lt;&lt;endl;                           //法2</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u&quot;</span>,(x&gt;&gt;<span class="hljs-number">16</span>)+(x&lt;&lt;<span class="hljs-number">16</span>));                              <span class="hljs-comment">//法3，注意是%u</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="b3919-二进制与一">4.2 B3919 二进制与一</h2><p>原题链接：<a href="https://www.luogu.com.cn/problem/B3919">B3919[语言月赛 202401] 二进制与一</a></p><p>将 n 对 <span class="math inline">\(2^{k-1}\)</span>取模，就可以得到n 的最末尾k-1个二进制位的十进制结果 c 。也就是说，c=n%(1ll&lt;&lt;k);当然，也可以用另外一种计算方法，即c=n&amp;((1ll&lt;&lt;k)-1);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> n, q, ans=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>    cin &gt;&gt;n &gt;&gt;q;;<br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> k;<br>        cin &gt;&gt; k;<br>        --k; <span class="hljs-comment">// 得到 k - 1</span><br>        <span class="hljs-keyword">if</span> (n &amp; (<span class="hljs-number">1ll</span> &lt;&lt; k)) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果整数n的二进制右数第k位已经是1，则不需要加任何数 </span><br>        <span class="hljs-comment">//long long c = n % (1ll &lt;&lt; k);       // 方法 1 </span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> c = n &amp; ((<span class="hljs-number">1ll</span>&lt;&lt;k) - <span class="hljs-number">1</span>);     <span class="hljs-comment">// 方法 2   两种都要会写 </span><br>        ans += (<span class="hljs-number">1ll</span> &lt;&lt; k) - c;<br>        n += (<span class="hljs-number">1ll</span> &lt;&lt; k) - c;<br>    &#125;<br>    cout &lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基本知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针与尺取法</title>
      <link href="/2024/01/04/%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%88%E5%B0%BA%E5%8F%96%E6%B3%95%EF%BC%89/"/>
      <url>/2024/01/04/%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%88%E5%B0%BA%E5%8F%96%E6%B3%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="最长不重复字串问题">1.1 “最长不重复字串”问题</h2><p>“最长不重复子串”是一个经典问题。题意如下：</p><p><ahref="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">Leetcode第3题</a>：给定一个字符串s(<code>s</code>由英文字母、数字、符号和空格组成，长度在[0,50000])，请你找出其中不含有重复字符的 <strong>最长子串</strong>的长度。</p><h3 id="初步分析">1.1.1 初步分析</h3><p>首先我们分析一下这个问题的关键信息，主要有以下四个：</p><ul><li><p>1）n的取值范围是 <span class="math inline">\(0\leq n\leq5*10^4\)</span> ；</p></li><li><p>2）最长；</p></li><li><p>3）所有字符不重复；</p></li><li><p>4）子串；</p></li></ul><p>根据以上的几个关键词，我们可以得出一些结论：</p><p>1)根据的范围已经能够大致确认这是一个需要<spanclass="math inline">\(O(n)\)</span>或者<spanclass="math inline">\(O(lon_2n)\)</span>的算法才能解决的问题；</p><p>2)"最长"意味着可能是一个动态规划问题或者贪心问题，也有可能是搜索。所以这个关键词给我们的信息用处不大；</p><p>3)而“判断字符是否重复”可以用 <strong>哈希表</strong> 在<spanclass="math inline">\(O(1)\)</span>的时间内判断；</p><p>4)左和右两个端点能确定出一个子串，所以<strong>枚举所有"子串"</strong>意味着要枚举这两个端点，其时间复杂度是<spanclass="math inline">\(O(n^2)\)</span>的。</p><h3 id="朴素算法简单了解即可">1.1.2 朴素算法（简单了解即可）</h3><p>由以上分析，我们可以发现第1）个和第4）个关键词给我们得出的结论是矛盾的。那么，我们可以先尝试减小 n的范围。当<span class="math inline">\(n\leq10^3\)</span>时，怎么解决这个问题呢？浅显一点地来想：因为最后求的是满足条件的最长子串，所以我们如果能够枚举所有子串，那么选择长度最长的满足条件<spanclass="math inline">\(^{(*)}\)</span>的子串就是答案了（这里的条件<spanclass="math inline">\(^{(*)}\)</span>是指子串中所有字符都不同）。</p><p>用 ans 记录我们需要求的最大不重复子串的长度，用一个哈希表 h[]来代表某个字符是否出现过（你可以理解为一个访问标记数组，类似于vis[]），一个不太成熟的算法就成型了，描述如下：</p><ul><li><p>1）外层循环枚举子串的左端点 <span class="math inline">\(i=0\rightarrow n−1\)</span>；</p></li><li><p>2）清空哈希表h[]；</p></li><li><p>3）内层循环枚举子串的右端点 <span class="math inline">\(j=i\rightarrow n−1\)</span> ，如果当前这个字符<spanclass="math inline">\(s_j\)</span>出现过（即 <spanclass="math inline">\(h[s_j]=true\)</span>），则跳出j的循环；否则令<spanclass="math inline">\(h[s_j]=true\)</span>，并且用当前长度去考虑更新ans （即 <spanclass="math inline">\(ans=max⁡(ans, j−i+1)\)</span>）；</p></li><li><p>4）回到 2）；</p></li></ul><p><ahref="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">Leetcode第3题</a>的C++实现部分代码(朴素，AC，超过6.4%)如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>            <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">int</span> h[<span class="hljs-number">50005</span>]= &#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, i, j, len;<br>            <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;           <span class="hljs-comment">// 1)</span><br>                j = i;<br>                <span class="hljs-built_in">memset</span>(h, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(h));   <span class="hljs-comment">// 2)</span><br>                <span class="hljs-keyword">while</span>(j &lt; n &amp;&amp; !h[s[j]]) &#123;<br>                    h[ s[j] ] = <span class="hljs-literal">true</span>;        <span class="hljs-comment">// 3)</span><br>                    len = j - i + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(len &gt; ans)<br>                        ans = len; <span class="hljs-comment">// 记录最长值len的同时，也记录下其左端位置i和右端位置j的值</span><br>                    ++j;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>• 1）枚举对应子串的左端点i；</p><p>• 2）清空哈希表h，其中<spanclass="math inline">\(h[s_j]=true\)</span>代表原字符串的第j个字符<spanclass="math inline">\(s_j\)</span>是否出现在以第i个字符为左端点的子串中；</p><p>•3）如果字符串s[i..j]中已经出现重复的字符，那么s[i..j+1],s[i..j+2],…,s[i..n−1]必然会有重复字符，所以这里不需要继续往下枚举，直接跳出内层循环即可。</p><p>这个算法执行完毕， ans就是我们要求的最长不重复子串的长度， [l,r]代表了最长不重复子串在原字符串的区间。正确性毋庸置疑，因为已经枚举了所有子串的情况，如果字符集的个数为z ，那么算法的时间复杂度就是O(n∗z) 。</p><p>上述朴素算法的求解过程，其动图和不动图如下所示：</p><table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/clip_image001.gif"alt="图片" />原图</th><th><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104150815148.png"alt="image-20240104150815148" /> （i=0)</th><th><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104150831827.png"alt="image-20240104150831827" />(i=1)</th><th><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104150853687.png"alt="image-20240104150853687" />（i=2)</th></tr></thead><tbody><tr class="odd"><td><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104151050940.png"alt="image-20240104151050940" /> （i=3)</td><td><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104151122690.png"alt="image-20240104151122690" /> （i=4)</td><td><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104151137103.png"alt="image-20240104151137103" /> （i=5、6、7)</td><td></td></tr></tbody></table><p>结论：字符串下标从 0开始编号，该样例最长无重复子串为：s[1:5]=“bcaed”，长度为 5。</p><p>复杂度分析：由于该串是字符串，而一般的字符集内最多256个不同的字符。所以时间复杂度基本就是O(n∗256) ，当 <span class="math inline">\(1\leqn\leq 10^7\)</span> 时，这个时间复杂度<spanclass="math inline">\(O(1e7∗256) \geq1e7\)</span>，是肯定会TLE的，必须需要想办法优化。</p><h3 id="对朴素算法进行优化">1.1.3 对朴素算法进行优化</h3><p>如果仔细思考上面例题1的朴素算法的求解过程，就会发现：枚举子串的时候有很多区间是重叠的，所以必然存在许多没有必要的重复计算。</p><p>我们考虑一个子串以i为左端点，j为右端点，且s[i..j−1]中不存在重复字符，s[i..j]中存在重复字符（换言之，s[j]和s[i..j−1]中某个字符产生重复）的情况。如下图所示。</p><div data-align="center"><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104152821376.png" width = 40%/></div><p>在上图的情况下，我们没必要再去检测 s[i..j+1], s[i..j+2],…, s[i..n−1]这几个字符串的合法性，因为当前情况s[i..j]是非法的，而这些字符串是完全包含s[i..j]的，所以它们必然也是不合法的。</p><p>那么我们可以把枚举的左端点i自增，即：i=i+1，这时，按照朴素算法的实现，右端点需要重置，即j=i，实际上这里的右端点可以不动。</p><p>可以这么考虑，由于s[j]这个字符和s[i..j−1]中的某个字符s[k](k值未知)产生了重复，那么如果现在必须要加入s[j]且整个串不能产生重复字符，也就意味着s[x]必须要出局，即i 必须在位置x的右侧，即满足 i&gt;k ，换言之， i可以一直自增，直到i=k+1，如下图所示：</p><div data-align="center"><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240104153650717.png" width = 40%/></div><p>利用上述思路，我们重新实现 最长不重复子串 的算法， c++代码（改进，AC，超过70%）实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>            <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">-1</span>, len;   <span class="hljs-comment">// i=0, j=i-1代表 s[i:j] 为一个空串，从空串开始枚举</span><br>            <span class="hljs-type">int</span> h[<span class="hljs-number">50005</span>]= &#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-keyword">while</span> (j++ &lt; n - <span class="hljs-number">1</span>) &#123;              <span class="hljs-comment">// 外层循环看快指针j，快指针j右移前进，拓宽区间</span><br>                ++h[ s[j] ];<br>                <span class="hljs-keyword">while</span> (h[ s[j] ] &gt; <span class="hljs-number">1</span>) &#123;        <span class="hljs-comment">// 如果区间[i,j]不满足指定条件，</span><br>                    --h[ s[i] ];               <span class="hljs-comment">//   就调整慢指针i右移，收窄区间，直到满足指定条件为止</span><br>                    ++i;                       <span class="hljs-comment">//</span><br>                &#125;<br>                len = j - i + <span class="hljs-number">1</span>;               <span class="hljs-comment">// 此时的区间[i,j]是局部最优解，记录</span><br>                <span class="hljs-keyword">if</span>(len &gt; ans)                  <span class="hljs-comment">//        考虑刷新</span><br>                    ans = len;                 <span class="hljs-comment">// 可以在此处记录i和j，以记录最长区间的左右端</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于待定区间[i,j]，如何确定该区间是否符合指定条件（即区间内的字符不重复）呢？其实也很简单。只需要维护h[]和判断h[str[j]]&gt;1，如果判断成立，则表示重复，不符合条件。这是<spanclass="math inline">\(O(1)\)</span>的操作，满足区间的时效性。</p><p>算法执行完毕后，我们就可以得到最长不重复子串的长度为 ans ，并且 i 和j 这两个指针分别只自增 n次。当j右移时，i未动。当i右移时，j未动。两个指针都从未回退过。所以该算法的时间复杂度为<span class="math inline">\(O(n*2)=O(n)\)</span> 。</p><p>可以将第9行处的1改为k，以适应“求字符的重复次数不超过k次的最长子串”问题。</p><p>利用该优化算法优化后的最长不重复子串的求解过程如图所示：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/640%20(1).gif"alt="640 (1)" /><figcaption aria-hidden="true">640 (1)</figcaption></figure><p>对上述内容的简单总结是：当区间中存在重复（红色）字符时，左指针 i自增；否则，右指针 j 自增。</p><h2 id="尺取法双指针法">1.2 尺取法（双指针法）</h2><h3 id="算法定义">1.2.1 算法定义</h3><p>如1.1.3节所述，这种利用问题特性，<strong>通过两个指针，不断调整区间，从而求出问题最优解</strong>的模型就叫"<strong>尺取法</strong>"模型。由于利用的是两个指针，所以又叫 "双指针"模型。</p><p>这里 "尺"的含义，主要还是因为这类问题最终要求解的都是连续的序列（子串），就好比一把尺子一样，故而得名。</p><p><strong>双指针法</strong>（又称为“<strong>尺取法</strong>”）模型，是一个常用的优化技巧，用来解决<strong>序列的区间问题</strong>。</p><p>在双指针法中，会有两个指针i、j分别代表了区间的左右位置下标。它们有两种扫描方向：</p><p>1）反向扫描：i、j方向相反，i从左往右，j从右往左，在中间相会；</p><p>2）同向扫描：i、j方向相同，都从左往右，可以让j跑在i的前面。</p><p>其中，同向扫描的两个指针称为“<strong>快慢指针</strong>”。它们在序列上产生一个大小可变的“<strong>滑动窗口</strong>”，有多种灵活的运用。本帖研究的主要就是这种同向扫描。</p><h3 id="指定条件与代码模板的适用场合">1.2.2“指定条件”与代码模板的适用场合</h3><p>在1.2.1节中曾指出，双指针法，是用来解决序列的区间上的问题。如果问题是“要求从原始序列中抽取分散的多个数据”，这不是区间问题，不能用双指针法模型。如果要求连续区间，但不满足下述的“单调性”，则只能采用普通的办法。反之，如果是要找满足<strong>指定条件(<spanclass="citation" data-cites="1">@1</span>)</strong>的最<strong>短(<spanclass="citation" data-cites="2">@2</span>)</strong>/最<strong>长(<spanclass="citation"data-cites="3">@3</span>)</strong>的连续区间，则可以使用一定的套路模板。该模板会在1.2.3节中详述。</p><p>这里所说的"<strong>指定条件</strong>"的内涵并未明确化。对于本题来说，<strong>指定条件</strong>就是"字符不重复"。当然，其他题也可以是 "每个字符重复次数不超过 k次"，"至少包含 k 种字符"，"求和不大于 k " 等等，千变万化，因题而异。</p><p>如果要使用双指针法的代码模板，那么这个"指定条件"必须要满足以下两点：</p><p>1）待定区间的<strong>单调性</strong></p><p>所谓“单调性”，就是说：任意一个指针的增加，条件满足与否只会出现两种情况，即：【满足 -&gt; 不满足】或者 【不满足 -&gt; 满足】，<strong>不能出现【满足 -&gt; 不满足 -&gt; 满足】这样反复不定的情况。</strong></p><p>2）待定区间的<strong>时效性</strong></p><p><strong>所谓“时效性”，就是说：必须在 <spanclass="math inline">\(O(1)\)</span>或者 <spanclass="math inline">\(O(log_2⁡n)\)</span> 的时间内就能确定出当前区间 [i,j] 是否满足指定条件，否则无法用尺取法求解。</strong></p><h3 id="算法描述">1.2.3 算法描述</h3><p>在1.2.2节中我们提到了求最短<spanclass="math inline">\((@2)\)</span>和最长<spanclass="math inline">\((@3)\)</span>区间这两种情况。这两种情况，算法有差异，下面分开进行阐述。</p><h4 id="求最长区间">1.2.3.1 求最长区间</h4><ul><li><p>1）初始化i=0（数组从0存）/1（数组从1存） ,j=i−1，表示初始区间的长度为 0；</p></li><li><p>2）外层循环为<strong>快</strong>指针j，<strong>右拓宽</strong>区间，（右移j，j++）；</p></li><li><p>3）当区间<font color="red"><strong>不满足</strong></font>条件时，一直<strong>左收窄</strong>（内层循环）该新区间（慢指针i右移,i++),直到区间满足条件，结束内层循环；</p></li><li><p>4）此时的区间是局部最优解，<font color="red"><strong>记录</strong></font>，回到2）；</p></li></ul><p>之所以求最长区间，往往是因为当区间右拓宽之后，会导致区间不合法（否则直接拿[1,n]当答案得了）。所以，在步骤2）之后，需要持续检验新区间并左收窄之，直到新区间合法为止。</p><h4 id="求最短区间">1.2.3.2 求最短区间</h4><ul><li><p>1）初始化i=0（数组从0存）/1（数组从1存） ,j=i−1，表示初始区间的长度为 0；</p></li><li><p>2）外层循环为<strong>快</strong>指针j，<strong>右拓宽</strong>区间，（右移j，j++）；</p></li><li><p>3）当区间<font color="red"><strong>满足</strong></font>条件时，一直<strong>左收窄</strong>（内层循环）该新区间（慢指针i右移,i++),<font color="red"><strong>记录</strong></font>局部最优解，直到区间不满足条件，结束内层循环；</p></li><li><p>4）回到 2）；</p></li></ul><p>之所以求最短区间，往往是因为当区间右拓宽之后，虽然仍然合法（单调性决定），但区间不够短。所以，在步骤2）之后，需要持续检验新区间并左收窄之，尝试优化局部解，直到新区间不合法为止。</p><h1 id="二实战训练">二、实战训练</h1><h2id="视频教学链接"><a href="https://www.bilibili.com/video/BV1Mp4y1E74K/?_blank" target="_blank">视频教学链接：</a></h2><h2 id="最长无重复子串问题最长">2.1 最长无重复子串问题（最长）</h2><p><ahref="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">Leetcode第3题</a></p><p>题解代码见1.1.3节。</p><h2 id="区间和问题最短">2.2 区间和问题（最短）</h2><p><a href="http://poj.org/problem?id=3061"><strong>POJ 3061Subsequence</strong></a></p><p>【中文大意】现在有t组数据，每组数组中给定 <spanclass="math inline">\(n(10&lt;n&lt;10^5)\)</span> 个正数 <spanclass="math inline">\(a_i (0&lt;a_i \leq 10^4)\)</span> 和一个正数 <spanclass="math inline">\(p(0&lt;p&lt;10^8)\)</span>。找到一个最短的连续子序列，满足它的和 <span class="math inline">\(s\geqp\)</span>，输出该区间的长度值。如果全部加起来都不能&gt;=m，则该样例输出0。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">输入样例：<br>2  // 有2组数据<br>10 15                   // 第一组数据有10个正数，阀值p为15<br>5 1 3 5 10 7 4 9 2 8    // 10个数据<br>5 11                    // 第二组数据有5个正数，阀值p为11<br>1 2 3 4 5               // 5个数据<br>输出样例：               <br>2                       // 在第一组数据中，a4+a5=15&gt;=p=15，长度2，且是最短的<br>3                       // 在第二组数据中，a3+a4+a5=12&gt;=p=11，长度3，且是最短的   <br></code></pre></td></tr></table></figure><p>解题分析：</p><p>A. 单调性分析：对于一个连续子序列a[i..j] ，它所有数之和 s[i..j]<spanclass="math inline">\(=\sum_{k=i}^{j}a_k\)</span> 。如果我们已经知道<span class="math inline">\(s[i..j] \geq p\)</span>，那么就没必要再去求s[i..j+1] ( 因为a[j+1]&gt;0，所以s[i..j+1]= s[i..j]+ a[j+1] &gt; s[i..j] <span class="math inline">\(\geq p\)</span>，但题目要求找最短的区间，所以没必要再去求s[i..j+1])。所以基于这点，该题所述的“条件”满足单调性。</p><p>B. 时效性分析：可以定义前缀和数组 ，通过 O(1)的代价计算出给定区间[i..j]之间的连续子序列的和。O(1)的代价，这是具有时效性的。</p><p>C. 本题要求满足指定条件的一个区间[i,j]，但根据题意，有可能不存在这样的区间。（举个反例:"在1..10这个数列中找出一个区间，使得该区间数值和大于等于500万"，根本找不到这样的区间）。所以要留意区间长len=0的可能。</p><div data-align="center"><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240111160121957.png" width = 80%/></div><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//// 方法1：尺取法</span><br><span class="hljs-comment">// 基本题意：给长度为n (10 &lt; n &lt; 1e5)的数组，每个元素&lt;=1e4。另外有一个整数m(m&lt;1e9)，</span><br><span class="hljs-comment">//           求数组中数的总和&gt;=m的连续子序列的最小长度。如果全部加起来都不能&gt;=m，则</span><br><span class="hljs-comment">//           该样例输出 0</span><br><span class="hljs-comment">//  输入：</span><br><span class="hljs-comment">//  2组样例</span><br><span class="hljs-comment">//  n = 10，m = 15</span><br><span class="hljs-comment">//  5 1 3 5 10 7 4 9 2 8</span><br><span class="hljs-comment">//  输出：</span><br><span class="hljs-comment">//  2        (至少要有2个数，即5 10 这个子序列的和满足&gt;=15)</span><br><span class="hljs-comment">//  n = 5，m = 11</span><br><span class="hljs-comment">//  1 2 3 4 5</span><br><span class="hljs-comment">//  输出：</span><br><span class="hljs-comment">//  3        (至少要有3个数，即3 4 5 这个子序列的和满足&gt;=11)</span><br><br><span class="hljs-comment">//#include &lt;bits/stdc++.h&gt;</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br>LL data[maxn], le, ri, n, m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    LL t, i;<br>    cin &gt;&gt;t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        cin &gt;&gt;n &gt;&gt;m;<br>        <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>            cin&gt;&gt;data[i];<br>        &#125;<br>        le=<span class="hljs-number">1</span>;                      <span class="hljs-comment">// 区间左端至少应该是从第一个数开始</span><br>        LL minlen=n+<span class="hljs-number">1</span>;             <span class="hljs-comment">// 求符合条件的数的最小值的套路：先让最小值的初值为一个不可能的极大值，然后打擂台 </span><br>        LL sum=<span class="hljs-number">0</span>, len=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> ( ri=<span class="hljs-number">1</span>; ri&lt;=n; ri++) &#123; <span class="hljs-comment">// 快指针朝前进，作为主循环</span><br>            sum+=data[ri];         <span class="hljs-comment">// 区间已拓宽，处理相关事务（刷新sum和len）</span><br>            len++;<br>            <span class="hljs-comment">// 我们希望找到&quot;最短&quot;区间，所以每次拓宽区间的同时要想着能不能缩短区间(在符合条件的前提下)</span><br>            <span class="hljs-keyword">while</span> (sum-data[le] &gt;= m) &#123; <span class="hljs-comment">// 当区间[le+1, ri]合法时，连续尝试缩短区间</span><br>                sum= sum - data[le];  <span class="hljs-comment">// 缩短区间后，处理相关事务（刷新sum、le指针、len和minlen） </span><br>                le++;<br>                len--;<br>                <span class="hljs-keyword">if</span> (len&lt;minlen) &#123;<br>                    minlen= len;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (minlen==n+<span class="hljs-number">1</span>)       <span class="hljs-comment">// 如果全都不符合题意，即所有数加起来都不够m </span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, minlen);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入样例：</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">10 15</span><br><span class="hljs-comment">5 1 3 5 10 7 4 9 2 8</span><br><span class="hljs-comment">5 11</span><br><span class="hljs-comment">1 5 3 4 2</span><br><span class="hljs-comment">10 1000000</span><br><span class="hljs-comment">5 1 3 5 10 7 4 9 2 8</span><br><span class="hljs-comment">输出样例：</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">0 </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="luogu-p1147-连续自然数和img">2.3 <ahref="https://www.luogu.com.cn/problem/P1147">Luogu P1147连续自然数和</a><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230825170629229-1325480434.png"alt="img" /></h2><p>这个题，咋一看感觉像是“区间和”问题，但仔细分析发现：当区间拓宽或收窄时，都有可能会出现“不符合条件——符合——不符合”的情况。所以上面总结的两个代码模板，不适合本题。只能双指针硬干。</p><p>P1147 AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>,sum=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= m/<span class="hljs-number">2</span>) &#123;     <span class="hljs-comment">// 因为要求区间内至少2个数，所以左端数必然&lt;=m/2</span><br>        <span class="hljs-keyword">if</span>(sum&lt;m) &#123;       <span class="hljs-comment">// 不够就加右 </span><br>            j++;          <span class="hljs-comment">// 右拓宽 </span><br>            sum += j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum&gt;=m) &#123;      <span class="hljs-comment">// 超过就减左</span><br>            <span class="hljs-keyword">if</span>(sum==m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,i,j);<br>            sum -= i;     <span class="hljs-comment">// 左收窄</span><br>            i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一个类似的题目是<ahref="https://www.luogu.com.cn/problem/P1638">P1638</a>。其AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn= <span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> num,minwidth,le,j,ll,rr;<br><span class="hljs-type">int</span> n,m,a[maxn];  <span class="hljs-comment">// a[5]=3 表示第5幅画是3号画家画的</span><br><span class="hljs-type">int</span> cnt[<span class="hljs-number">2005</span>]; <span class="hljs-comment">// cnt[i]表示当前区间[le, j]内画家i的图画数</span><br><span class="hljs-comment">// cnt[10]=2 表示10号画家有2幅画在当前区间【le,j】里</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n, &amp;m);  <span class="hljs-comment">// n 幅画，m个画家</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    le=<span class="hljs-number">1</span>;      <span class="hljs-comment">// 区间左端至少应该是从第一个画家开始</span><br>    num=<span class="hljs-number">0</span>;     <span class="hljs-comment">// 当前区间内画家的人数</span><br>    minwidth=maxn;<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>; j&lt;=n; j++) &#123;  <span class="hljs-comment">// 快指针作为主循环</span><br>        <span class="hljs-comment">// 快指针前进，处理相关事情，尤其是num </span><br>        cnt[ a[j] ]++;      <br>        <span class="hljs-keyword">if</span>(cnt[ a[j] ]==<span class="hljs-number">1</span>) num++;<br><br>        <span class="hljs-keyword">while</span>(num&gt;=m) &#123; <span class="hljs-comment">//本题求最短区间，所以当该区间符合条件时，持续收窄区间</span><br>            <span class="hljs-comment">// 先记录</span><br>            <span class="hljs-keyword">if</span>(minwidth &gt; j-le + <span class="hljs-number">1</span>) &#123;   <br>                minwidth = j-le+<span class="hljs-number">1</span>;      <br>                ll=le;<br>                rr=j;<br>            &#125;<br>            <span class="hljs-comment">// 再收窄</span><br>            cnt[ a[le] ]--;<br>            <span class="hljs-keyword">if</span>(cnt[ a[le] ]==<span class="hljs-number">0</span>) num--;  <span class="hljs-comment">// 收窄时一定会影响到num的值 </span><br>            le++; <br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,ll,rr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入</span><br><span class="hljs-comment">12 5</span><br><span class="hljs-comment">2 5 3 1 3 2 4 1 1 5 4 3</span><br><span class="hljs-comment">输出</span><br><span class="hljs-comment">2 7</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="luogu-p1102-a-b-数对">2.4 <ahref="https://www.luogu.com.cn/problem/P1102">Luogu P1102 A-B数对</a></h2><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230825170629214-1614732805.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>本题已知C，要找有多少对“A-B”对。因为A和B都可能有多个，存在重复，且ABC都是正值，所以A必然大于B。对于每一个B，在排序后，存在连续的多个A符合题意。这多个A形成一个等值区间，用i和j-1来标识这个等值区间的左右端，即慢指针和快指针。当存在多个B时，i和j不变，能在<spanclass="math inline">\(O(1)\)</span>的效率内解决第二个、第三个B等，使得算法保持高效。i和j都不后退，所以算法效率为<spanclass="math inline">\(O(n)\)</span>。但因为需要先sort（sort函数效率<spanclass="math inline">\(O(n*log_2n)\)</span>），所以整体算法效率仍然是<spanclass="math inline">\(O(n*log_2n)\)</span>。</p><p>P1102 AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//  方法2：尺取法  详见“D双指针(尺取法)”  233ms</span><br><span class="hljs-comment">//  该方法和方法1高度相似，只是在for循环内确定i和j时，是采用快慢针前进。</span><br><span class="hljs-comment">//  快慢指针同步向右推进，k表示B，慢指针i指向第一个A，快指针j指向最后一个A的下一个元素 </span><br><span class="hljs-comment">//  因为快慢针并不会后退，所以二重循环的效率实际上是O(n)，优于方法1的O(n*logn) </span><br><span class="hljs-comment">//  </span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7 </span><br><span class="hljs-comment">//  k     i           j                    （1）ans=0+3 =3</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//     k  i           j                    （2）ans=3+3 =6</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//        k               i/j              （3）ans=6+0 =6</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//            k           i/j              （4）ans=6+0 =6</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//                k       i/j              （5）ans=6+0 =6</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//                    k    i          j    （6）ans=6+2 =8</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//                         k         i/j   （7）ans=8+0 =8</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//                              k    i/j   （8）ans=8+0 =8</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//                                    k    i/j=len+1  （9）ans=8+0 =8</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-type">const</span> LL N=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br>LL n,c,a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin&gt;&gt;n&gt;&gt;c;<br><span class="hljs-keyword">for</span>(LL k=<span class="hljs-number">1</span>; k&lt;=n; k++) cin&gt;&gt;a[k];<br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+n);<br><br>LL ans=<span class="hljs-number">0</span>;<br>LL i=<span class="hljs-number">1</span>, j=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(LL k=<span class="hljs-number">1</span>; k&lt;=n; k++) &#123; <span class="hljs-comment">//i&lt;=j</span><br><span class="hljs-keyword">while</span>(i&lt;=n &amp;&amp; a[i]-a[k]&lt; c) i++;   <span class="hljs-comment">// 此处不同于方法1，使用了快慢针 </span><br><span class="hljs-keyword">while</span>(j&lt;=n &amp;&amp; a[j]-a[k]&lt;=c) j++;  <span class="hljs-comment">// j指向相同值区间右端的下一个下标 </span><br>ans+=j-i;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="至少有k个重复字符的最长子串">2.5[至少有K个重复字符的最长子串</h2><p><ahref="https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/description/">Leetcode395</a></p><p>给你一个字符串s和一个整数k，请你找出s中的最长子串，要求该子串内的每一字符出现次数都不少于k。返回这一子串的长度。如果不存在这样的子字符串，则返回0。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：s = &quot;aaabb&quot;, k = 3<br>输出：3<br>解释：最长子串为 &quot;aaa&quot; ，其中 &#x27;a&#x27; 重复了 3 次。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：s = &quot;ababbc&quot;, k = 2<br>输出：5<br>解释：最长子串为 &quot;ababb&quot; ，其中 &#x27;a&#x27; 重复了 2 次， &#x27;b&#x27; 重复了 3 次。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><span class="math inline">\(1 \leq s.length \leq 10^4\)</span></li><li>s仅由小写英文字母组成</li><li><span class="math inline">\(1 \leq k \leq 10^5\)</span></li></ul><p>解题分析：</p><p>A.单调性分析：对于一个连续子序列a[i..j]，假设其区间长度为t，且满足条件（且此时k &gt; 1），那么将该区间长度扩成 t+1时（无论是往左扩还是往右扩）：</p><ol type="a"><li><p>如果新位置的字符在原有区间出现过，那必然还是满足出现次数大于 k次，这时候该新区间仍满足要求；</p></li><li><p>如果新位置的字符在原有区间没出现过，那新字符的出现次数只有 1次，这时候该新区间不满足要求；</p></li></ol><p>所以<strong>该题所要求的“条件”不满足区间的单调性</strong>，即不会随着区间的移动或者变化而肯定出现“不符合<spanclass="math inline">\(\rightarrow\)</span>符合”或者反之的情况。因此我们不能使用「二分答案法」，也<strong>不能直接使用</strong>「滑动窗口」思路的双指针法。</p><p>那么还有什么性质可以利用呢？这时候要留意数据范围「数值小」的内容。</p><p>题目说明了只包含小写字母（26个，为有限数据），如果我们把原题条件（区间内所包含的字符的重复次数至少为k次）<strong>改为新条件（区间内所包含的字符种类数量只能为t <span class="math inline">\((1 \leq t \leq26)\)</span>种）</strong>时，区间重新具有了单调性质。</p><p>当我们使用双指针的时候：</p><ol type="a"><li><p>右端点往右移动必然会导致字符类型数量增加（或不变）</p></li><li><p>左端点往右移动必然会导致字符类型数量减少（或不变）</p></li></ol><p>然后我们可以对t进行暴力枚举，范围从1到26，毕竟这也不大。然后可以看出，原题的答案区间必然会和我们在暴力枚举t的过程中找到的某个区间是一致的。例如s= "aaabb", k = 3的答案区间（子串aaa）必然会在我们枚举t=1时找到，而s ="ababbc", k = 2的答案区间（子串ababb）必然会在我们枚举t=2时找到。</p><p>B.时效性分析：当区间拓宽或收窄时，可以通过计数器数组来识别出从无到有的字符，或者从有到无的字符，通过O(1) 的代价判断出给定区间[i..j]是否符合新条件，具有时效性。</p><p>“搂草”的同时，还要“打兔子”！本题的最终目的是要找每种字符出现至少k次的最长子串，所以在双指针右移的过程中，顺带着还要记录区间内出现的每个字符的次数。这才是我们的最终目的！可以设置<strong>不达标字符（已出现在区间中，但个数不够k个）</strong>的个数less。当新增一个从无到有的字符时less++，若次数达到k次则less--；新减掉一个原本出现仅1次的字符时less--，新减掉一个原本出现了k次的字符时less++。当less==0时意味着区间没有不达标字符，即区间内所有字符都次数&gt;=k，记录该区间。</p><p>C.本题要求满足指定条件的一个区间[i,j]，但根据题意，有可能不存在这样的区间。（举个反例:"在aabbccdef这个字符串中找出一个区间，使得该区间每个字符都出现了至少10次"，根本找不到这样的区间）。所以要留意区间长len=0的可能。</p><p>AC代码如下：（8ms，超过45%）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestSubstring</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;                      <span class="hljs-comment">// 先假设找不到任何合法区间 </span><br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">1</span>; t &lt;= <span class="hljs-number">26</span>; t++) &#123;   <span class="hljs-comment">// 暴力枚举区间内出现的字符种数t </span><br>            <span class="hljs-comment">// 每次新的暴力枚举都需重置相关变量！ </span><br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;             <span class="hljs-comment">//  </span><br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br>            <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;             <br>            <span class="hljs-type">int</span> less = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (r &lt; n) &#123;               <span class="hljs-comment">// 双指针模板，快指针最多只到最后一个字符的下标n-1，</span><br>                <span class="hljs-comment">// 搂草，针对新进字符来处理tot</span><br>                cnt[s[r] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>                <span class="hljs-keyword">if</span> (cnt[s[r] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">1</span>) &#123;<br>                    tot++;                <span class="hljs-comment">// 处理tot </span><br>                    less++;<br>                &#125;<br>                <span class="hljs-comment">// 打兔子 </span><br>                <span class="hljs-keyword">if</span> (cnt[s[r] - <span class="hljs-string">&#x27;a&#x27;</span>] == k) &#123;<br>                    less--;<br>                &#125;<br><br>                <span class="hljs-keyword">while</span> (tot &gt; t) &#123;         <span class="hljs-comment">// 搂草，双指针模板。最长区间，当区间不合法时收窄左端 </span><br>                    cnt[s[l] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                    <span class="hljs-keyword">if</span> (cnt[s[l] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span>) &#123;<br>                        tot--;            <span class="hljs-comment">// 处理tot，模板 </span><br>                        less--;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (cnt[s[l] - <span class="hljs-string">&#x27;a&#x27;</span>] == k - <span class="hljs-number">1</span>) &#123;<br>                        less++;<br>                    &#125;<br>                    l++;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (less == <span class="hljs-number">0</span>) &#123;          <span class="hljs-comment">// 能到这里来，区间肯定合法，此时如果less也==0的话，就找到一个区间满足题意了 </span><br>                    ret = <span class="hljs-built_in">max</span>(ret, r - l + <span class="hljs-number">1</span>);<br>                &#125;<br>                r++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="poj2566-bound-found">2.6 POJ2566 Bound Found</h2><p>原题链接 ：<a href="http://poj.org/problem?id=2566">POJ2566</a></p><p>基本题意：给定一个数组n个元素和一个值t，求一个子区间使得其和的绝对值与t的差值最小，如果存在多个，任意解都可行。1&lt;=n &lt;= 1e5 ; 0&lt;= t &lt;= 1e9;</p><p>样例输入数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5 1             // 第1组样例：n=5个数   t=1次查询<br>-10 -5 0 5 10<br>3               // 查区间和的绝对值最靠近3的区间<br><br>10 2            // 第2组样例：n=10个数  t=2次查询<br>-9 8 -7 6 -5 4 -3 2 -1 0<br>5 11            // 查区间和的绝对值最靠近5的区间，查区间和的绝对值最靠近11的区间<br><br>15 2            // 第3组样例：n=15个数  t=2次查询<br>-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1<br>15 100          // 查区间和的绝对值最靠近15的区间，查区间和的绝对值最靠近100的区间<br>0 0             // 结束<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5 4 4 // 区间和为5，从4号到4号(网页此处写错了！输出测试样例给的是5 2 2，即区间[2,2]，该区间只有-5这个数，绝对值为5，与3的距离为3，最接近了。[4,4]这个5的下标没有[2,2]的小)<br>5 2 8           // 区间和5  从2号 到8号<br>9 1 1           // 区间和9  从1号 到1号<br>15 1 15         // 区间和15  从1号 到15号<br>15 1 15         // 区间和15  从1号 到15号<br></code></pre></td></tr></table></figure><p>分析：</p><p>之前的POJ3061题中，序列都是正数。随着区间拓宽，其sum呈现单调递增的特性。但是现在本题有正数有负数，其区间和不再具备单调性，而取绝对值之后，更不具备单调性了。不能直接用双指针法来做，需要想一下如何重构条件或者数据。</p><p>这个题我们首先能想到的是，既然要求区间之和，我们可以先利用前缀和数组，它能在O(1)的效率实现原区间求和。但必须要解决两个问题：</p><p>1）问题是如何枚举区间的左右端呢？</p><p>2)如何让每一次枚举出的区间更靠近所求的答案区间呢？</p><p>朴素做法就是先求前缀和数组s[]，然后基于该数组，for (ri=1..len)for(le=0..ri-1)这样去暴力枚举（因为前缀和数组有正有负，看似无规律，不单调）区间的左右端，然后用s[ri]-s[le]得到该区间和，然后看差值，求最小值。但这样做，并未解决问题2），每一次枚举都完全无视上一次枚举的比较结果，算法效率注定低下。</p><p>假设一个区间之和sum=data[le..ri]=s[ri]-s[le-1]，且sum&lt;t。那现在该如何调节？肯定是希望能扩大区间之和，即找到一个更大的s[<spanclass="math inline">\(\acute{ri}\)</span>]<font color="red">**(*)**</font>。但扩大区间之和，不能简单地理解为ri++,快指针在data[]上右移一格。因为data[]有正有负，s[]数组不是单调递增。所以不能简单地通过ri++来在data[]上拓宽区间。那我们如何去找一个比原来的s[ri]值更大的s[]值呢？</p><p>我们可以对s[]进行递增排序产生s2[]（也可以原地排序），弃用s[]原来的数据顺序关系，反正这种前后关系没有单调性，已无任何作用。（在排序之前注意要保存元素的原始序号pos，因为我们需要表示最初的data[]中的下标的区间。）因为s2[]是经过排序的，必然是单调递增的（<del>似乎这里是句废话</del>），所以当ri++，在s2[]上右移（<strong>理解的重点：不管是le或ri，都不是在data[]上右移！给一对le和ri，不要想成了data[le..ri]，非也！</strong>）后，s2[ri(新)]必然是&gt;s2[ri(旧)]的（单调性决定）。</p><p>排序之后，s[]单调递增，但其原元素发生了移动，所以s[ri].value -s[le].value 不再代表 sum(data[le+1] .. data[ri])！它代表的是sum(data[1..s[ri].pos]) - sum(data[1..s[le].pos])。虽然ri&gt;le，但是s[ri].pos 不一定大于 s[le].pos !所以在表示时，ll=min(s[ri].pos, s[le].pos)且rr=max(s[ri].pos,s[le].pos)</p><p>可能有人会说：因为s2[]是排序后的前缀和数组，举个例子：s2[4].v可能等于data[0..7]，根本就不等于s2[3].v+data[4]！但仔细一想，其实这个问题根本就不是什么问题。我们只需要找到比原来的s2[3].v更大一点的s2[7].v就达到<font color="red">**(*)**</font>处所述的“让sum变大”的目的了!看似好像在跳跃性地胡乱枚举，但实际上是递增地枚举。</p><p>1）当sum&lt;t时，ri在s2[]上右移；</p><p>2）当sum&gt;t时，此时再去ri++岂不是区间和更大？人家要最接近t值的区间和，你搞个越来越远是什么意思？果断不再ri++！此时意味着该le++，让le在s2[]上右移一格，换一个更大一点的s[<spanclass="math inline">\(\acute{le}\)</span>]，从而让sum变小一点。这样才能让sum越来越靠近t，算法高效！</p><p>原题链接中提供的三个样例都不太具有一般性，本帖重新列举一个更具一般性的输入样例和输出样例如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">输入样例：<br>10 1             //10个数，1次查询 <br>20 -25 10 5 -10 25 15 -10 15 5 <br>22               // 查找区间和绝对值最接近22的那个区间<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240119091130982.png" alt="image-20240119091130982" style="zoom:80%;" /></p><p>当ri=6，le=3时s2[6].v-s2[3].v= 20-5=15;这个结果15代表的是data[0..1]-data[0..3]=s[1]-s[3]= 20-5=15。虽然6&gt;3，但s2[6].pos=1 &lt; s2[3].pos=3！所以(&amp;1)<strong>此处data[0..1]-data[0..3]无法表达成data[2..3]，所以在data[]上表示这个区间时，假设区间为[ll+1,rr]，那么ll=<font color="red">min(1, 3)</font>=1 =min(s2[6].pos,s2[3].pos)，且rr= <font color="red">max(1, 3)</font>=3 =max(s2[6].pos,s2[3].pos)</strong>。然后把ll+1，得到2，最终得到区间为[2..3]，即data[2..3]。</p><p>但此时因为15&lt;22，需继续找个更大的区间，ri++，因为s2[7].v=s2[6].v=20，所以继续ri++，ri=8。</p><p>当ri=8，le=3时s2[8].v-s2[3].v= 30-5 =25;这个结果25代表的是data[0..7]-data[0..3]=s[7]-s[3]= 30-5 =25。ll= min(3,7)=3，且rr=max(3,7)=7。然后把ll+1，得到4，最终得到区间为[4..7]，即data[4..7]，其和25更接近22。</p><p>不管是sum&gt;t或者sum&lt;t，都无法预知下一次尝试是否更接近t，所以都需要记录和考虑刷新。但如果当sum==t时，没有什么区间比这更优了，首次遇到就不再尝试后续，结束程序。</p><p>需要注意的是：</p><ol type="1"><li><p>我们需要将下标为0的元素的id和sum字段都设置为0，并将该元素参与排序。这样当遇到类似s[7]-s[0]时，表示的是data[0..7]-data[0..0]=data[1..7]。</p></li><li><p>因为sum[j]-sum[i]表示的是[i+1,j]，此外在最后得到的答案左区间都 +1</p></li><li><p>网页上输出样例的第一组数据有毒，写错了。但其OJ系统的测试数据没问题，应该就是网页上写错了而已。</p></li><li><p>s[0]的初始化每次都要做，而且要先做，因为后面求前缀和时会用到s[0]</p></li><li><p>long long类型求绝对值需要用 llabs(long long)函数</p></li></ol><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>     <span class="hljs-comment">// sort()需要 </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span>         <span class="hljs-comment">// llabs()需要 </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>LL value;<br>LL pos;<br>&#125;;<br>LL data[maxn];<br>node s[maxn];<br>LL le, ri, n, t, k;<br>LL sum, ll, rr;<br>LL mindis;     <span class="hljs-comment">// 记录区间和与k之间的最近距离值（绝对值，正）</span><br>LL ans;        <span class="hljs-comment">// 记录具有这个最近距离值的区间之和值</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node x1, node x2)</span> </span>&#123;<br><span class="hljs-keyword">return</span> x1.value &lt; x2.value;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;t), !(n==<span class="hljs-number">0</span>&amp;&amp;t==<span class="hljs-number">0</span>)) &#123;<br>    s[<span class="hljs-number">0</span>].pos=<span class="hljs-number">0</span>;                 <span class="hljs-comment">// 别忘了先做初始化这个，排序后元素顺序会打乱，s[0]将可能会不再是(0,0)  </span><br>    s[<span class="hljs-number">0</span>].value=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(LL i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;    <span class="hljs-comment">// 需要先初始化好s[0]之后才能for，因为此处用到了原s[0] </span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;data[i]);<br>        s[i].value = s[i<span class="hljs-number">-1</span>].value + data[i];  <span class="hljs-comment">// 此时，s[ri].value - s[le].value代表sum(data[le+1] .. data[ri])，前缀和基本定义 </span><br>        s[i].pos = i;<br>        &#125;<br>        <br>    <span class="hljs-built_in">sort</span>(s, s+<span class="hljs-number">1</span>+n, cmp);        <span class="hljs-comment">// 需要把s[0]也参与排序</span><br>        <br>    <span class="hljs-keyword">while</span>( t-- ) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;k);<br>        le=<span class="hljs-number">0</span>;                   <span class="hljs-comment">// 因为s[ri].value - s[le].value代表sum(data[le+1] .. data[ri])，所以le应从0号开始，这样区间左端从1开始 </span><br>        ri=<span class="hljs-number">1</span>;<br>        mindis = <span class="hljs-number">1e17</span>+<span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">while</span>( ri&lt;=n ) &#123;        <span class="hljs-comment">// 也可以用for(ri=1; ri&lt;=n; ri++)  </span><br>            LL sum = s[ri].value - s[le].value; <span class="hljs-comment">// sum=sum(data[1..s[ri].pos]) - sum(data[1..s[le].pos])  &gt;0 </span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">llabs</span>(sum-k) &lt; mindis) &#123;        <span class="hljs-comment">// 如果le和ri表示的这个区间更优（更贴近 k），则更新mindis、ans、ll和rr  </span><br>                mindis = <span class="hljs-built_in">llabs</span>(sum-k);          <span class="hljs-comment">// </span><br>                ans = sum;<br>                ll=<span class="hljs-built_in">min</span>(s[ri].pos, s[le].pos)+<span class="hljs-number">1</span>; <span class="hljs-comment">// 此处解释见题解的(&amp;1)处 </span><br>                rr=<span class="hljs-built_in">max</span>(s[ri].pos, s[le].pos);<br>                &#125;<br>                <span class="hljs-comment">// 排序后的s[]是单调递增的，所以s[ri+1].value &gt;= s[ri].value  &gt;= s[le+1].value &gt;= s[le].value的，</span><br>                <span class="hljs-comment">// 也就是说，sum(data[1..s[ri+1].pos])必然是大于等于sum(data[1..s[ri].pos])的 </span><br>                <span class="hljs-comment">// 如果区间之和值sum少于k，应想办法增大sum值。故而选择了这个s[ri+1].value。</span><br>                <span class="hljs-comment">// s[ri+1].value - s[le].value  &gt; s[ri].value - s[le].value</span><br>            <span class="hljs-keyword">if</span> (sum &lt; k)        <br>                ri++;<br>                <span class="hljs-comment">// 如果区间和值sum在k的右侧，应想办法减小sum值。故而选择更大一点的s[le+1].value。</span><br>                <span class="hljs-comment">// s[ri].value - s[le+1].value  &lt; s[ri].value - s[le].value</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; k)<br>                le++;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;          <span class="hljs-comment">// 没有比这更完美的了，不必再算后续，跳出循环，输出 </span><br>                <br>            <span class="hljs-keyword">if</span> (le == ri)       <span class="hljs-comment">// 不允许也不考虑空区间，所以不允许le==ri，一旦相等，ri强行前进一格 </span><br>                ri++; <br>            &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld %lld\n&quot;</span>, ans, ll, rr);<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">5 1</span><br><span class="hljs-comment">-10 -5 0 5 10</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">10 2</span><br><span class="hljs-comment">-9 8 -7 6 -5 4 -3 2 -1 0</span><br><span class="hljs-comment">5 11</span><br><span class="hljs-comment">15 2</span><br><span class="hljs-comment">-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1</span><br><span class="hljs-comment">15 100</span><br><span class="hljs-comment">0 0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输出</span><br><span class="hljs-comment">5 2 2  // 网页数据有误！测试数据没问题 </span><br><span class="hljs-comment">5 2 8</span><br><span class="hljs-comment">9 1 1</span><br><span class="hljs-comment">15 1 15</span><br><span class="hljs-comment">15 1 15</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="poj2739-sum-of-consecutive-prime-numbers">2.7 POJ2739 Sum ofConsecutive Prime Numbers</h2><p><ahref="http://poj.org/problem?id=2739">POJ2739</a>的AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    一个整数分解为连续的素数之和，有多少种分法? 这是一个“区间和精确相等”的问题，</span><br><span class="hljs-comment">    因为“精确相等”不满足单调性，但“正数的累加和”是有单调性的，所以可在模板基础</span><br><span class="hljs-comment">    上微调即可。 </span><br><span class="hljs-comment">    思路：</span><br><span class="hljs-comment">    1. 打表，先打出素数表</span><br><span class="hljs-comment">    2. 然后用尺取法查询是否精确等？若s&lt;num就继续ri++，若s&gt;num就le++，若s==num就统计 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxn 10000+16        <span class="hljs-comment">// 1万以内求素数 </span></span><br>vector&lt;<span class="hljs-type">int</span>&gt; primes;<br>vector&lt;<span class="hljs-type">bool</span>&gt; is_prime;<br><br><span class="hljs-comment">// 暴力打表，也可以把这个代码单独开一个cpp文件来写，然后把打印结果复制为POJ2739的全局数组。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_prime</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化vector的前10000个元素均为true</span><br>    is_prime = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(maxn + <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 0和1都不是素数</span><br>    is_prime[<span class="hljs-number">0</span>] = is_prime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 埃氏筛法求素数，填入primes[]中。此处也可以换成欧拉筛法</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; maxn; i++) &#123;<br>        <span class="hljs-keyword">if</span> (is_prime[i]) &#123;<br>            primes.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i * <span class="hljs-number">2</span>; j &lt; maxn; j += i) &#123;<br>                is_prime[j] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-built_in">init_prime</span>();<br>    <span class="hljs-type">int</span> size = primes.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; num &amp;&amp; num) &#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>, s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>,r = <span class="hljs-number">0</span>; r&lt;size;  ) &#123;<br>            <span class="hljs-comment">// s没加够，且右边还有数可以继续加，那就一直加（因为正数的累加和是有单调性的）</span><br>            <span class="hljs-keyword">while</span> (r&lt;size &amp;&amp; s&lt;num)<br>                s = s + primes[r++];<br>            <span class="hljs-keyword">if</span> (s == num)  <span class="hljs-comment">// 找到一个方案，记上</span><br>                result++;<br>            <span class="hljs-comment">// 不管找没找到一个方案，如果r还没走到底而s已经超过num，就砍掉左端l++,s-=，然后循环上去继续r右移</span><br>            s -= primes[l++];<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, result);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入1： </span><br><span class="hljs-comment">17</span><br><span class="hljs-comment">输出1： </span><br><span class="hljs-comment">2     （2+3+5+7，17） </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="poj2100-graveyard-design">2.8 POJ2100 Graveyard Design</h2><p><a href="http://poj.org/problem?id=2100">POJ2100</a>的AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">给一个数 n （1 &lt;= n &lt;= 10^14）。</span><br><span class="hljs-comment">求一段连续的数的数字，使得其平方和等于n。</span><br><span class="hljs-comment">输出的时候，先输出有多少组解，然后换行，每一行输出一组解内的元素个数，及这些元素的数值。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    学习本代码，需要预先掌握尺取法的基本思想。本题思路和POJ2739很相似</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">注意typedef的这种写法，要学会</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">注意pair的使用，虽然本题还可以用其他结构来实现，但建议学会pair的使用。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;    <span class="hljs-comment">//  基本上等效于 #define LL long long</span><br>vector&lt;pair&lt;LL, LL&gt; &gt; ans;    <span class="hljs-comment">// 这里一定要注意这个&quot;&gt; &gt;&quot;之间要有空格</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(LL n)</span> </span>&#123;<br>    LL l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>, sq;<br>    <span class="hljs-comment">// 这里写成死循环比较方便一些！ </span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// r是否要右移。不在外层循环中决定，而是在内层循环中决定</span><br>        <span class="hljs-keyword">while</span> (sum &lt; n) &#123; <span class="hljs-comment">//当sum不够n时，因为区间平方和是单调的，所以右移r以扩大区间，从而扩大sum</span><br>            sq = r * r;<br>            sum += sq;<br>            r++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sq &gt; n)   <span class="hljs-comment">// 如果一个数的平方和都已经超过n，那后面不可能再有符合要求的区间了。可以输结果了 </span><br><span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// 当sum&gt;=n时走到这里来</span><br>        <span class="hljs-keyword">if</span> (sum == n)<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(l, r));    <span class="hljs-comment">// 注意，这里表示的是[l, r-1],因为r在while里多加了一次</span><br>        <span class="hljs-comment">// 不管有没有找到一个解，都需要慢指针右移，慢指针前行</span><br>        sum -= l * l;<br>        l++;<br>    &#125;<br><br>    <span class="hljs-comment">// 下面的代码都在凑输出</span><br>    LL size = ans.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, size);<br>    <span class="hljs-keyword">for</span> (LL i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        LL ansr = ans[i].second;<br>        LL ansl = ans[i].first;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,ansr-ansl);              <span class="hljs-comment">// 因为ansr偏大了1，所以这里算区间长度不需要再加1了</span><br>        <span class="hljs-keyword">for</span> (LL j=ansl; j&lt;ansr; j++)           <span class="hljs-comment">// ansr偏大了1，所以j最多到ansr-1就可以了</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %lld&quot;</span>, j);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);      //读入数据生成器造出来的数据</span><br><span class="hljs-comment">//    freopen(&quot;test.txt&quot;, &quot;w&quot;, stdout);   //输出答案</span><br>    <br>    LL n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;n);<br>    <span class="hljs-built_in">solve</span>(n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p1381-单词背诵">2.9 P1381 单词背诵</h2><p>视频链接：<ahref="https://www.bilibili.com/video/BV1MP411W7tk">双指针P1381（单词背诵）</a></p><p>原题链接：<ahref="https://www.luogu.com.cn/problem/P1381">P1381（单词背诵）</a></p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230825182436716-225604155.png" alt="img" style="zoom: 67%;" /></p><p>题意表述不太准确，需要澄清：文章由 <em>m</em>个单词构成，在该文章中找出连续的一段，其中包含<strong>最多种类</strong>（允许不包含完目标单词表的所有目标单词）的目标单词（重复的单词只算一种），且允许子串内包含其他非目标单词。并且在目标单词种类尽量多的前提下，还要使选出的文章区间尽量短。</p><p>举个例子：假如现在目标单词为A，B，C,D（为了表述方便，特意将每个目标单词假设为单字母大写，非目标单词假设为单字母小写），文章为hACnnBgC。其中“AC”是“包含两种目标单词”的最短子串，但“hACnnBgC”中存在有子串“ACnnB”和“ACnnBgC”这两个子串（不止这两个）包含了三种目标单词。根据题意，种类较多的胜出（哪怕长度值大于“AC”），所以最终答案在这些包含了三种目标单词的子串中选择，很明显最终答案是“ACnnB”，更短。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240121173427411.png"alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    基本题意：求文章中出现单词种数最多且最短的连续区间</span><br><span class="hljs-comment">    如果种数不是最多的，不是答案！ 如果不够短，不是答案！ </span><br><span class="hljs-comment">    如果该区间内有非单词表的单词，允许！</span><br><span class="hljs-comment">*/</span> <br><span class="hljs-type">int</span> n,m;<br>string s[<span class="hljs-number">100005</span>],s1;    <span class="hljs-comment">//s[] 记录文章中的所有单词</span><br>map&lt;string,<span class="hljs-type">bool</span>&gt; wordmp;<span class="hljs-comment">//wordmp[] 记录目标单词表中的所有单词</span><br>map&lt;string,<span class="hljs-type">int</span>&gt; cntmp;  <span class="hljs-comment">//cntmp[] 记录文章当前区间内各个目标单词出现的次数</span><br><span class="hljs-type">int</span> sum;                <span class="hljs-comment">//sum 记录文章中出现单词表的单词数（不算重复的）</span><br><span class="hljs-type">int</span> len;                <span class="hljs-comment">//len 记录包含表中单词最多的区间的最短长度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    cin&gt;&gt;s1,wordmp[s1]=<span class="hljs-number">1</span>;<br>cin&gt;&gt;m;                   <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>,i=<span class="hljs-number">1</span>; j&lt;=m; j++) &#123; <span class="hljs-comment">//i&lt;=j</span><br>    cin&gt;&gt;s[j];<br>        <span class="hljs-comment">// 处理快指针j的相关事务 </span><br>    <span class="hljs-keyword">if</span>(wordmp[s[j]])        <span class="hljs-comment">//如果新进单词是目标单词表里的单词，就累加其出现次数 </span><br>        cntmp[s[j]]++;<br>    <span class="hljs-keyword">if</span>(cntmp[s[j]]==<span class="hljs-number">1</span>)      <span class="hljs-comment">//如果新进单词是第一次出现，更新sum和len </span><br>        sum++, len=j-i+<span class="hljs-number">1</span>;   <span class="hljs-comment">//重难点！区间出现新单词时，放弃原来的len值，重新存新的区间长度，因为新区间内的目标单词“更多”，但不够精简 </span><br>            <br>        <span class="hljs-comment">// 本题求最短区间，所以考虑收窄区间</span><br>        <span class="hljs-comment">// 应收窄的情况1. 左端单词出现多次，则可以放弃1次左端单词，不影响区间内单词种数</span><br>        <span class="hljs-comment">// 应收窄的情况2. 左端单词不是目标单词表内的单词，直接无视，收窄 </span><br>    <span class="hljs-keyword">while</span>(i&lt;=j &amp;&amp; (cntmp[s[i]]&gt;=<span class="hljs-number">2</span> || !wordmp[s[i]])) &#123;<br>        <span class="hljs-keyword">if</span>(cntmp[s[i]]&gt;=<span class="hljs-number">2</span>)     <span class="hljs-comment">// 如果区间左端的单词在区间内有重复，则可以把它忽视掉，毕竟右侧还有它的其他副本 </span><br>            cntmp[s[i]]--,i++; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!wordmp[s[i]]) <span class="hljs-comment">// 如果当前区间左端的单词是目标单词表里的单词，直接无视，收缩区间 </span><br>            i++; <br>        &#125;<br>    len=<span class="hljs-built_in">min</span>(len,j-i+<span class="hljs-number">1</span>);     <span class="hljs-comment">//收窄，更新len </span><br>    &#125;<br>cout&lt;&lt;sum&lt;&lt;endl&lt;&lt;len&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="abc098d-xor-sum-2">2.10 [ABC098D] Xor Sum 2</h2><p>视频链接：<ahref="https://www.bilibili.com/video/BV1h14y117rq">[ABC098D] Xor Sum2</a></p><p>原题链接：<ahref="https://www.luogu.com.cn/problem/AT_arc098_b">[ABC098D] Xor Sum2</a></p><p>大致题意：</p><p>给你一串数a[]，求出满足<spanclass="math inline">\(a_l+a_{l+1}+...+a_r=a_l \enspace xor\enspace  a_{l+1}\enspace...\enspace xor \enspace a_r (l \leqr)\)</span>的<span class="math inline">\((i,j)\)</span>的数量。已知<spanclass="math inline">\(1 \leq n\leq2*10^5,\quad 1\leq i\leq n,\quad 0\leqa_i\leq2^{20}\)</span>。</p><p>预备知识：本题涉及到了“异或”操作，这是一个按位进行的操作。</p><p>初步分析：这个题求"有多少个符合题意要求的连续区间"，并不求"最长区间"，也不求"最短区间"，不能用1.2.3节总结出来的套路模板,但因为是求连续区间，所以仍可以用普通的双指针法。下面做1.2.2节中讲到的单调性分析和时效性分析。</p><p>1）单调性分析：本题求区间的个数，有点类似于“求逆序对的个数”这种风格，必然会涉及到对两个数的暴力枚举。但如果是无脑枚举，<spanclass="math inline">\(O(n^2)\)</span>的效率，复杂度为4e10，是会TLE的。不可取。题目涉及到的是连续区间。也就是说，区间内的所有数，代入公式，条件成立。如果遇到区间[l,r]内的某一个数<span class="math inline">\(a_k\)</span>代入该公式后<spanclass="math inline">\(a_l+...+a_k+...+a_r \neq a_l \enspace xor...\enspace xor\enspace  a_k\enspace...\enspace xor \enspace a_r (l &lt;k\le r)\)</span>，则需放弃该区间[l,r]。对于[l,r]，假设l固定不动，随着r的右移，区间变宽，只会出现“符合<spanclass="math inline">\(\Rightarrow\)</span>不符合”的情况，而不会出现“符合<spanclass="math inline">\(\Rightarrow\)</span>不符合<spanclass="math inline">\(\Rightarrow\)</span>符合”的情况。<strong>所以本题的“条件”具备单调性</strong>。一旦出现了上述这个<spanclass="math inline">\(a_k\)</span>，则k右侧的所有端点不必再枚举了，区间必定是不符合条件的。所以这里不应该盲目地采用<spanclass="math inline">\(O(n^2)\)</span>的效率去无脑枚举。</p><p>2）时效性分析：对于一个给定的区间[l,r]，假设该区间已经符合公式，有sum[l..r]=sumxor[l..r]。现在r尝试右移，仍然可以在O(1)的效率内计算出sum[l..r]+data[r+1]的值，以及sumxor[l..r]xor data[r+1]的值，进而判断是否相等。即该条件的判定具有时效性。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230826095827743-1068963304.png" alt="img" style="zoom:80%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230826095827887-317965124.png" alt="img" style="zoom:80%;" /></p><p>在上图的样例中，一共有9个区间符合公式条件。i不动的前提下，j指针每次尝试右移前先判定，符合就右移，答案数+1，换句话说，j右移一次，答案数加1，直到不符合条件。所以当i不动的前提下，贡献的答案数其实就是不符合之前的区间宽度，即j-i+1。然后i右移，j归位到i，再周而复始，直到i到最右侧。所以“j到最右侧”并不是外层循环的结束条件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL; <span class="hljs-comment">// 或者#define LL long long</span><br>LL a[<span class="hljs-number">200005</span>];<br>LL s1,s2,ans;<br><span class="hljs-comment">//s1:算术和, s2:异或和, ans:方案数</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) cin&gt;&gt;a[i];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>; i&lt;=n; ) &#123; <span class="hljs-comment">//外层循环以慢指针i到最右为止。可以看出，双指针法需要具体情况具体分析</span><br>        <span class="hljs-comment">// 当i不变时，让j走到不符合条件之前停下来</span><br>        <span class="hljs-keyword">while</span>(j+<span class="hljs-number">1</span>&lt;=n&amp;&amp;s1+a[j+<span class="hljs-number">1</span>]==(s2^a[j+<span class="hljs-number">1</span>])) &#123; <span class="hljs-comment">//预判，这里不能先改j的值！</span><br>            j++;<br>            s1+=a[j];    <span class="hljs-comment">// 累加和</span><br>            s2^=a[j];    <span class="hljs-comment">// 累异或和</span><br>        &#125;<br>        ans += j-i+<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 慢指针i前进，刷新</span><br>        s1-=a[i];<br>        s2^=a[i];<br>        i++;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 线性结构基础算法 </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和 二维前缀和</title>
      <link href="/2024/01/03/%E5%89%8D%E7%BC%80%E5%92%8C%20%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>/2024/01/03/%E5%89%8D%E7%BC%80%E5%92%8C%20%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><p>视频教学链接：<ahref="https://www.bilibili.com/video/BV1ja4y1F7Fk/?_blank&amp;vd_source=0e7cc4e4bbbb67e5c3c2a3e7d967f075">前缀和二维前缀和</a></p><h1 id="二实战训练">二、实战训练</h1><h2 id="luogu-p8218-b3612深进1.例1求区间和">2.1 Luogu P8218/B3612【深进1.例1】求区间和</h2><h3 id="原题链接">2.1.1 原题链接</h3><p><a href="https://www.luogu.com.cn/problem/P8218">Luogu P8218/B3612【深进1.例1】求区间和</a></p><p>这两个题是完全相同的内容和要求，合并在一起讲解。这个题是“前缀和”的入门模板题，裸求一维前缀和。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230704111737035-889544091.png" style="zoom: 67%;" /></p><h3 id="分析">2.1.2 分析</h3><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230704111737059-1374681507.png" style="zoom:80%;" /></p><h3 id="ac代码">2.1.3 AC代码</h3><p>下面展现B3612的AC代码。快读版本的代码可看P8218的AC代码，就不在此处展现了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[<span class="hljs-number">100005</span>],s[<span class="hljs-number">100005</span>];   <span class="hljs-comment">// 大量录入和输出，可以上快读、快写</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>        s[i]=s[i<span class="hljs-number">-1</span>]+a[i];  <span class="hljs-comment">// 此处也可以直接a[i] += a[i-1]，一数组两用，不需要s[]</span><br>    &#125;<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++) &#123;<br>        <span class="hljs-type">int</span> l,r;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="hljs-number">-1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与本题比较类型的还有<ahref="https://www.luogu.com.cn/problem/P10233">P10233 [yLCPC2024] A. dx分计算</a>，可以试试。</p><h2 id="p1115-最大子段和">2.2 <span id="jump1">P1115最大子段和</span></h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p><a href="https://www.luogu.com.cn/problem/P1115">P1115最大子段和</a></p><h3 id="分析-1">2.2.2 分析</h3><p>这个题是对前缀和的一个小变化。如果强行去暴力枚举每个区间的左右两个端点来求和，复杂度为<spanclass="math inline">\(O(n^2)=4e10\)</span>，铁定会TLE。我们可以换一个思路：如果左侧多个数的“累加和”对sum增加没有贡献，甚至变成累赘，那不如放弃而从当前数重新开始。这是一种贪心的思维，时间复杂度是<spanclass="math inline">\(O(n)\)</span>的。</p><h3 id="ac代码-1">2.2.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">这个题，一边累加sum，同时一边判断sum的正负，从而丢弃sum。这个sum实际上也算是</span><br><span class="hljs-comment">    一种前缀和，但没有用专门的数组来存储。这种思想可以琢磨琢磨。</span><br><span class="hljs-comment">复杂度O(n) </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-type">int</span> a[<span class="hljs-number">200001</span>];   <span class="hljs-comment">// 本题其实可以不使用这个数组也能AC </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> i,n,maxsum=<span class="hljs-number">-2e10</span>,sum=<span class="hljs-number">0</span>;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>cin&gt;&gt;a[i];<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-comment">// 不管当前的a[i]是正或者是负，都应该根据sum来做区别处理 </span><br><span class="hljs-comment">// 如果sum加前已为负数，那应放弃之前sum的积累，从当前数开始（不管当前数的正负） </span><br><span class="hljs-keyword">if</span>(sum&gt;<span class="hljs-number">0</span>)<br>sum+=a[i];<br><span class="hljs-keyword">else</span><br>sum=a[i];  <span class="hljs-comment">// 当前数应至少为sum </span><br><br><span class="hljs-keyword">if</span>(maxsum&lt;=sum)<br>maxsum=sum;<br>&#125;<br>cout&lt;&lt;maxsum;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">//// 如果数据全为负数，也应该得到-20，而不是-100000 </span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">-200 -20 -150 -100 -120</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="后记">2.2.4 后记</h3><p>1）这个题，我们要去找一个最大的子段和，但是我们并没有去暴力枚举区间的左端和右端，否则时间复杂度肯定是<spanclass="math inline">\(O(n^2)\)</span>。采用前缀和的思想，一旦发现sum&lt;=0，立刻丢弃累赘重新开始。用这种思想可以解决“不限宽度的区间最大和值”的问题。</p><p>2）如果我们不仅要求出最大的子段和，还要求这个区间的左右端点的下标值，那该怎么做呢？其实也简单，在新开辟一个“累加和”区间时，用le记录其下标i值，表示为区间的起始左端点。当刷新maxsum的同时也记录保存maxle的值为le值即可。展示代码如下：（完整代码见“P1115强化.cpp”）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> le, maxle=<span class="hljs-number">0</span>;  <br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>, le=<span class="hljs-number">0</span>; i&lt;=n; i++) &#123;<br>    <span class="hljs-keyword">if</span>(sum&gt;<span class="hljs-number">0</span>)            <span class="hljs-comment">// 如果当前数的左侧的数据之和是正的 </span><br>        sum+=a[i];       <span class="hljs-comment">// 那就累加当前，此刻暂时不管加起来是正或负（加后为负的情况在下一个数时做处理） </span><br>    <span class="hljs-keyword">else</span><br>        sum=a[i], le=i;  <span class="hljs-comment">// 如果左侧的数之和已为负数，是累赘，丢弃，从当前数重新开始累加 </span><br><br>    <span class="hljs-keyword">if</span>(maxsum&lt;=sum)      <span class="hljs-comment">// 刷新最大值的操作，应独立出来单独处理 </span><br>        maxsum=sum, maxle=le;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i=%-4d, sum=%-4d, le=%-4d, maxsum=%-4d, maxle=%-4d\n&quot;</span>, i, sum, le, maxsum, maxle);<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;le=%a, maxsum=%a&quot;</span>, maxle, maxsum);<br></code></pre></td></tr></table></figure><p>其运行结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs text">16<br>-20 15 10 -5 -20 5 15 10 -30 10 -5 10 30 -20 5 -1000<br>i=1   , sum=-20 , le=1   , maxsum=0   , maxle=0<br>i=2   , sum=15  , le=1   , maxsum=15  , maxle=1<br>i=3   , sum=25  , le=1   , maxsum=25  , maxle=1<br>i=4   , sum=20  , le=1   , maxsum=25  , maxle=1<br>i=5   , sum=0   , le=5   , maxsum=25  , maxle=1<br>i=6   , sum=5   , le=5   , maxsum=25  , maxle=1<br>i=7   , sum=20  , le=5   , maxsum=25  , maxle=1<br>i=8   , sum=30  , le=5   , maxsum=30  , maxle=5<br>i=9   , sum=0   , le=9   , maxsum=30  , maxle=5<br>i=10  , sum=10  , le=9   , maxsum=30  , maxle=5<br>i=11  , sum=5   , le=9   , maxsum=30  , maxle=5<br>i=12  , sum=15  , le=9   , maxsum=30  , maxle=5<br>i=13  , sum=45  , le=9   , maxsum=45  , maxle=9<br>i=14  , sum=25  , le=9   , maxsum=45  , maxle=9<br>i=15  , sum=30  , le=9   , maxsum=45  , maxle=9<br>i=16  , sum=-970, le=16  , maxsum=45  , maxle=9<br>le=9, maxsum=45<br></code></pre></td></tr></table></figure><h2 id="luogu-p2280-hnoi2003-激光炸弹">2.3 Luogu P2280 [HNOI2003]激光炸弹</h2><h3 id="原题链接-2">2.3.1 原题链接</h3><p>[Luogu P2280 <ahref="https://www.luogu.com.cn/problem/P2280">HNOI2003] 激光炸弹</a></p><p><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230704111737118-1986573874.png" /></p><h3 id="分析-2">2.3.2 分析</h3><p>这个题实际上就是要<strong>计算网格内<spanclass="math inline">\(m*m\)</span>的诸多正方形中，哪一个正方形内框住的数据之和值最大？</strong>需要频繁地计算某个大小区域范围内的数据之和，起点不同。采用二维前缀和的思路来做最方便：</p><p>1）首先需要先求出s[1..5001][1..5001]。s[i][j]表示长方形[1..i][1..j]范围内的数据之和值，即二维前缀和。这里需要注意，前缀和数组最好是从下标1开始存储数据，<strong>把0行和0列空出来并置为0，以方便后续的运算</strong>。递推方程式中0行及0列的数据都是0，才能正确做二维递推。</p><p>2）求出二维前缀和数组之后，当需要查询二维区间和值时，因为每个二维区间都是<spanclass="math inline">\(m *m\)</span>的正方形，其右下角方格的坐标应该在[m..R][m..C]范围内，所以只需要在这个范围<spanclass="math inline">\(O((R-m)*(C-m))\)</span>内以<spanclass="math inline">\(O(4)^{\textcolor[RGB]{225,0,0}{[*]}}\)</span>的代价就能求出其二维区间和值，找出其最大值。得解。</p><p>3）"二维前缀和"的递推方程式，以及"二维区间和"的求解方程式请见下图。</p><p>4）关于高维前缀和的求法，请见本页底部的拓展介绍。</p><p><strong><spanclass="math inline">\(\textcolor[RGB]{225,0,0}{[*]}\)</span>：此处的公式是一个变长的公式，其加减项的个数随着维数d的变化而呈现指数级的变化。因为本题是二维，所以此处复杂度都是<spanclass="math inline">\(O(4)\)</span>，近似等于<spanclass="math inline">\(O(1)\)</span>，忽略不计。但如果是d维(d&gt;=3)的前缀和，按容斥原理的这种写法计算，公式会有<spanclass="math inline">\(2^d\)</span>个加减项，所以此处的复杂度为<spanclass="math inline">\(O(2^d)\)</span>，不容忽视。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230704111737007-1486719667.png" style="zoom: 67%;" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1961668-20231208155117693-539585701.png" /></p><h3 id="p2280-ac代码">2.3.3 P2280 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*    用二维前缀和来求解二维区间和的模板题   */</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5005</span>;<br><span class="hljs-type">int</span> R,C;          <span class="hljs-comment">// R个目标, 边长为C的正方形</span><br><span class="hljs-type">int</span> s[N][N];      <span class="hljs-comment">// 价值前缀和</span><br><span class="hljs-comment">// 因为空间较为紧张，这里只用了一个数组，计算出前缀和之后，原数组直接被覆盖</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin&gt;&gt;R&gt;&gt;C;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;R; i++) &#123;<br>        <span class="hljs-type">int</span> x,y,v;<br>        cin&gt;&gt;x&gt;&gt;y&gt;&gt;v;<br>        x++,y++; <span class="hljs-comment">//先加1再存值，即基本数据从1行或1列开始存储，把0行和0列空出来以方便递推</span><br>        s[x][y]+=v;<br>    &#125;<br>    <span class="hljs-comment">// 求二维前缀和，方法一</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5001</span>; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=<span class="hljs-number">5001</span>; j++)<br>            s[i][j]+=s[i<span class="hljs-number">-1</span>][j]+s[i][j<span class="hljs-number">-1</span>]-s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br><span class="hljs-comment">//    // 方法二</span><br><span class="hljs-comment">//    for (int i = 1; i &lt;= N; i ++)</span><br><span class="hljs-comment">//        for (int j = 1; j &lt;= N; j ++) s[i][j] += s[i][j - 1];</span><br><span class="hljs-comment">//    for (int j = 1; j &lt;= N; j ++)</span><br><span class="hljs-comment">//        for (int i = 1; i &lt;= N; i ++) s[i][j] += s[i - 1][j];</span><br><br>    <span class="hljs-comment">// 查询二维区间和</span><br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C; i&lt;=<span class="hljs-number">5001</span>; i++)   <span class="hljs-comment">// 从C出发，因为C*C的正方形的右下角坐标至少应该是[C][C]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=C; j&lt;=<span class="hljs-number">5001</span>; j++)<br>            res=<span class="hljs-built_in">max</span>(res,s[i][j]-s[i-C][j]-s[i][j-C]+s[i-C][j-C]);<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p1719-1224-最大加权矩形最大子矩阵">2.4 P1719 /1224最大加权矩形(最大子矩阵)</h2><h3 id="原题链接-3">2.4.1 原题链接</h3><p><a href="https://www.luogu.com.cn/problem/P1719">P1719最大加权矩形</a> / <ahref="https://ybt.ssoier.cn/problem_show.php?pid=1224">1224最大子矩阵</a></p><h3 id="分析-3">2.4.2 分析</h3><p>这个题与2.3节的P2280最大的不同，就是P2280中规定了子矩阵的形状必定是<spanclass="math inline">\(m*m\)</span>的，而本题中并没有规定子矩阵的形状，需要自行去枚举和比较。而如果对一个子矩阵的两个端点(左上角坐标、右下角坐标)进行暴力枚举的话，因为n=120，所以其复杂度会达到<spanclass="math inline">\(O(n^4)=1e8\)</span>，将会TLE了，不能采用四重循环来解决。但如果我们能把<spanclass="math inline">\(n^4\)</span>降为<spanclass="math inline">\(n^3\)</span>，就没问题了。如何降低一维呢？</p><p>还记得我们曾经做过的"<a href="#jump1">P1115求最大子段和</a>"这个题吗？我们在一维数组中去寻找一个区间（区间宽度未知），并没有强行去枚举区间的左右端点，而是采用了一种<spanclass="math inline">\(O(n)\)</span>的算法来降维搞定，核心思想就是“贪心”（若左侧多个数据的前缀和已成累赘，丢弃之，从当前数据重新开始累加）！</p><p>我们能否把这种思想用在本题中呢？当然是可以的！但需要改良，如下图所示。我们可以对左右两端的列号le和ri进行枚举（<spanclass="math inline">\(O(C^2)\RightarrowO(n^2)\)</span>），但不枚举上端和下端的行号，而是从1到R枚举当前行号i。事先准备好矩阵每一行的前缀和数组，可以在<spanclass="math inline">\(O(1)\)</span>的范围内(sum[i][ri]-sum[i][le-1])算出每一行从data[i][le..ri]的数据之和。这样的话，就可以把一个二维的问题变成竖向的一维数据（每个长方形代表了一个数）的“求最大累加和”问题，和P1115很相似了。从上往下累加sum。一旦发现sum&lt;=0，则直接放弃上面的累加，从当前行开始重新累加。这个操作是<spanclass="math inline">\(O(R)\RightarrowO(n)\)</span>的，所以，整个算法的复杂度就是<spanclass="math inline">\(O(n^2*n=O(n^3))\)</span>，从而实现降维，搞定！</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240320105148242.png" style="zoom:50%" /></p><h3 id="ac代码-2">2.4.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 121</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f </span><br><span class="hljs-comment">// sum[i][j]：第i行元素的前缀和，即第i行前j个元素的和，行列都是从1开始编号</span><br><span class="hljs-comment">// sum[i][j] = 90 表示 第i行从左往右前j个元素之和等于90  </span><br><span class="hljs-type">int</span> sum[N][N], data[N][N];<br><span class="hljs-type">int</span> ans = -INF, sum, n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)<br>        &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data[i][j]);<br>        <span class="hljs-comment">// data[][]的行前缀和，注意！sum[][]并非二维前缀和！ </span><br>        sum[i][j] = sum[i][j<span class="hljs-number">-1</span>] + data[i][j];<br>&#125;<br>    <span class="hljs-comment">// 穷举子矩阵，从le列到ri列，逐行累加求子矩阵元素总和sum，</span><br><span class="hljs-comment">// 一旦sum为负，立刻清零并从下一行重新开始    </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> le=<span class="hljs-number">1</span>; le&lt;=n; le++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ri=le; ri&lt;=n; ri++) <span class="hljs-comment">// ri可以和le重叠 </span><br>    &#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;            <span class="hljs-comment">// 每次从上往下求和之前，sum都需要重新归零 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> row=<span class="hljs-number">1</span>; row&lt;=n; row++)<br>            &#123;<br>sum += sum[row][ri] - sum[row][le<span class="hljs-number">-1</span>];  <span class="hljs-comment">// O(1)的代价得到data[row][le..ri]的和值 </span><br>          ans = <span class="hljs-built_in">max</span>(sum, ans); <span class="hljs-comment">// ans记录sum曾经出现过的最大值 </span><br>            sum = <span class="hljs-built_in">max</span>(sum, <span class="hljs-number">0</span>);   <span class="hljs-comment">// 如果累加和为负数，直接放弃，sum重新归0 </span><br>    &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一本通的<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1224">1224</a>、<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1282">1282</a>，和本题完全一模一样，可作为巩固练习。</p><h2 id="luogu-p1387-最大正方形">2.5 Luogu P1387 最大正方形</h2><h3 id="原题链接-4">2.5.1 原题链接</h3><p><a href="https://www.luogu.com.cn/problem/P1387">Luogu P1387最大正方形</a></p><h3 id="基本题意">2.5.2 基本题意</h3><p>在一个 <span class="math inline">\(n*m\)</span> 的只包含 0 和 1的矩阵里找出一个不包含0(只包含1)的最大正方形，输出其边长。</p><h3 id="分析-4">2.5.3 分析</h3><p>这个题，其实和“前缀和”的关系不大，可以运用递推的思维来解决。搞定<spanclass="math inline">\(f[1][1..C]\)</span>和<spanclass="math inline">\(f[1..R][1]\)</span>，然后看<spanclass="math inline">\(f[i][j]\)</span>和之前的<spanclass="math inline">\(f[i-1][j]\)</span>、<spanclass="math inline">\(f[i-1][j-1]\)</span>、<spanclass="math inline">\(f[i][j-1]\)</span>等有什么关联，从而进一步推出dp的递推方程式。</p><p>1） 状态定义</p><p><strong>f[i][j]:表示以节点i,j为右下角，可构成的最大正方形的边长</strong>。</p><p>2） 所求目标 <span class="math display">\[max(f[1..R][1..C])\]</span> 3） 状态转移方程</p><p>if (a[i][j]==1) f[i][j] = min( min(f[i][j-1], f[i-1][j]),f[i-1][j-1]) + 1;</p><p>只有a[i][j]==1时，节点i,j才能作为正方形的右下角；</p><p>对于一个已经确定的f[i][j]=x，它表明包括节点i，j在内，向上x个节点，向左x个节点扫过的正方形中所有a[][]的值都为1；</p><p>对于一个待确定的f[i][j]，我们已知f[i-1][j]，f[i][j-1]，f[i-1][j-1]的值，如下：</p><p>                          f数组:        原a数组：</p><p><span class="math display">\[\left[\begin{matrix}   ? &amp; ? &amp; ? &amp; ?\\   ? &amp; ? &amp; 2 &amp; 1\\   ? &amp; ? &amp; 3 &amp; \textcolor{red}{?}\\   ? &amp; ? &amp; ? &amp; ?  \end{matrix}  \right]    反推出\Longrightarrow \left[\begin{matrix}   1 &amp; 1 &amp; 1 &amp; 0\\   1 &amp; 1 &amp; 1 &amp; 1\\   1 &amp; 1 &amp; 3 &amp; 1\\   ? &amp; ? &amp; ? &amp; ?  \end{matrix}  \right]\]</span> 由此得出状态转移方程：</p><p>if (a[i][j]==1) f[i][j]=min(min(f[i][j-1], f[i-1][j]), f[i-1][j-1]) +1;</p><p>例如:                           a数组:       f数组： <spanclass="math display">\[\left[\begin{matrix}   0 &amp; 0 &amp; 0 &amp; 1\\   1 &amp; 1 &amp; 1 &amp; 1\\   0 &amp; 1 &amp; 1 &amp; 1\\   1 &amp; 1 &amp; 1 &amp; 1  \end{matrix}  \right]    正推出\Longrightarrow \left[\begin{matrix}   0 &amp; 0 &amp; 0 &amp; 1\\   1 &amp; 1 &amp; 1 &amp; 1\\   0 &amp; 1 &amp; 2 &amp; 2\\   1 &amp; 1 &amp; 2 &amp; 3  \end{matrix}  \right]\]</span></p><h3 id="ac代码-3">2.5.4 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    二维前缀和的拓展题</span><br><span class="hljs-comment">    1） 状态定义</span><br><span class="hljs-comment">        f[i][j]表示以节点i,j为右下角，可构成的最大正方形的边长。</span><br><span class="hljs-comment">    2） 所求目标</span><br><span class="hljs-comment">        max(f[1..R][1..C])</span><br><span class="hljs-comment">    3） 状态转移方程</span><br><span class="hljs-comment">        if (a[i][j]==1)</span><br><span class="hljs-comment">            f[i][j] = min(min(f[i][j-1], f[i-1][j]), f[i-1][j-1]) + 1;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    只有a[i][j]==1时，节点i,j才能作为正方形的右下角；</span><br><span class="hljs-comment">    对于一个已经确定的f[i][j]=x，它表明包括节点i，j在内向上x个节点，向左x个节点扫过的正方形中所有a值都为1；</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> a,R,C,f[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>],ans;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;R,&amp;C);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=R; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=C; ++j) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);<br>            <span class="hljs-comment">//因为只需用到i，j上方，左方，左上方的信息，读入同步处理</span><br>            <span class="hljs-keyword">if</span> (a == <span class="hljs-number">1</span>)<br>                f[i][j] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(f[i][j<span class="hljs-number">-1</span>], f[i<span class="hljs-number">-1</span>][j]), f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])   +  <span class="hljs-number">1</span>;<br>            ans=<span class="hljs-built_in">max</span>(ans,f[i][j]);    <span class="hljs-comment">//同步更新答案</span><br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三高维前缀和">三、高维前缀和</h1><h2 id="高维前缀和">3.1 高维前缀和</h2><p>所谓“高维前缀和”，就是指”二维及以上“的前缀和</p><p>例如我们给定一个矩阵： <span class="math display">\[\left[\begin{matrix}   1 &amp; 2 &amp; 4 &amp; 3\\   5 &amp; 1 &amp; 2 &amp; 4\\   6 &amp; 3 &amp; 5 &amp; 9\\  \end{matrix}  \right] \tag{1}\]</span></p><p>那么它的前缀和就是： <span class="math display">\[\left[\begin{matrix}   1 &amp; 3 &amp; 7 &amp; 10\\   6 &amp; 9 &amp; 15 &amp; 22\\   12 &amp; 18 &amp; 29 &amp; 45\\  \end{matrix}  \right]\]</span></p><h2 id="两种求法">3.2 两种求法</h2><p>由于二维前缀和最为常用，我们先来看二维的情况。</p><h3 id="递推实现利用容斥原理效率一般">3.2.1递推实现（利用容斥原理，效率一般）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span> to R<br>    <span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span> to C<br>        sum[i][j] = sum[i<span class="hljs-number">-1</span>][j] + sum[i][j<span class="hljs-number">-1</span>] - sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + a[i][j];<br></code></pre></td></tr></table></figure><p>其实就是运用了容斥原理。</p><h3 id="硬干按维做前缀和效率更优更利于拓展为多维操作">3.2.2硬干（按维做“前缀和”，效率更优，更利于拓展为多维操作）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span> to R                           <br>    <span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span> to C<br>        sum[i][j]+=sum[i][j<span class="hljs-number">-1</span>]+a[i][j];<span class="hljs-comment">// 横向累加</span><br><span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span> to C                           <br>    <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span> to R<br>        sum[i][j]+=sum[i<span class="hljs-number">-1</span>][j];        <span class="hljs-comment">// 纵向累加。注意，这里没有a[][]参与了！因为都已经累加到累加和数组sum[][]里了</span><br></code></pre></td></tr></table></figure><p>第一遍循环后，所得的矩阵是<strong>每行各自独立的前缀和</strong>。</p><p>还是看上面的那个矩阵a[][]： <span class="math display">\[\left[\begin{matrix}   1 &amp; 2 &amp; 4 &amp; 3\\   5 &amp; 1 &amp; 2 &amp; 4\\   6 &amp; 3 &amp; 5 &amp; 9\\  \end{matrix}  \right] \tag{1}\]</span></p><p>第一个二重循环（先行后列）做完后，得到矩阵 <spanclass="math inline">\(sum^*[][]\)</span>： <span class="math display">\[\left[\begin{matrix}   1 &amp; 3 &amp; 7 &amp; 10\\   5 &amp; 6 &amp; 8 &amp; 12\\   6 &amp; 9 &amp; 14 &amp; 23\\  \end{matrix}  \right] \tag{2}\]</span> 第二个二重循环是将<spanclass="math inline">\(sum^*[][]\)</span>的每列再按行从上往下各自再做一遍前缀和，此时已经不需要原始数组a[][]的参与了。最终的二维前缀和矩阵sum[][]如下所示：<span class="math display">\[\left[\begin{matrix}   1 &amp; 3 &amp; 7 &amp; 10\\   6 &amp; 9 &amp; 15 &amp; 22\\   12 &amp; 18 &amp; 29 &amp; 45\\  \end{matrix}  \right]\tag{3}\]</span></p><p>现在我们变化一下循环顺序，对矩阵（1）按照“先列后行”的顺序来做，看看会得到什么不同的结果。<span class="math display">\[\left[\begin{matrix}   1 &amp; 2 &amp; 4 &amp; 3\\   5 &amp; 1 &amp; 2 &amp; 4\\   6 &amp; 3 &amp; 5 &amp; 9\\  \end{matrix}  \right] \stackrel{从上往下累加}{\Longrightarrow}\left[\begin{matrix}   1 &amp; 2 &amp; 4 &amp; 3\\   6 &amp; 3 &amp; 6 &amp; 7\\   12 &amp; 6 &amp; 11 &amp; 16\\  \end{matrix}  \right]\stackrel{从左往右累加}{\Longrightarrow}\left[\begin{matrix}   1 &amp; 3 &amp; 7 &amp; 10\\   6 &amp; 9 &amp; 15 &amp; 22\\   12 &amp; 18 &amp; 29 &amp; 45\\  \end{matrix}  \right]\]</span></p><p>可以看出，先列后行，仍然能得到相同的最终结果。</p><p>这里需要强调两点：</p><p>1）我们在书写两个二重for循环时写下的"for R for C"或者"for C forR"，它们是我们在填写数组时的<strong>填写顺序</strong>，比如"for R forC"表示“按照(1,1)、（1，2）...（1，R）、（2，1）、（2，2）”这个顺序来填写。经过我们刚才以实际数据来测试的结果，只要和推导的方向一致，那么两种顺序都是可以的。</p><p>2）针对每个具体的位置，例如sum[3][5]，它的数值来自于左侧的sum[3][4]或者上方的sum[2][5]呢？这个就要取决于你决定的累加顺序了。这里罗嗦一下，已经看懂的同学可以跳过本段后续的内容。如果你打算先从左往右累加前缀和，那么在第一个二重for里就应该写sum[i][j]=sum[i][j-1]+a[i][j]，然后在后续的二重循环里写sum[i][j]=sum[i-1][j]+sum[i][j]。反之，如果你打算先从上往下累加前缀和，那么在第一个二重for里就应该写sum[i][j]=sum[i-1][j]+a[i][j]，然后在后续的二重循环里写sum[i][j]=sum[i][j-1]+sum[i][j]。</p><h3 id="比较">3.2.3 比较</h3><p>两种求法的时间复杂度都是 <spanclass="math inline">\(O(len_1*len_2)\)</span>。但考虑维数 d的话，“递推实现”的复杂度为 <spanclass="math inline">\(O(len_1*len_2*...*len_d*\textcolor{red}{2^d})\)</span>（基于容斥原理去计算前缀和的复杂度为 <spanclass="math inline">\(O(2^d)\)</span>），“按维累加来实现”的复杂度为<span class="math inline">\(O( len_1*len_2*...*len_d*\textcolor{red}{d})\)</span>。所以如果是求多维数组的前缀和，<strong>推荐还是使用第二种方法</strong>。</p><h1 id="四拓展阅读">四、拓展阅读</h1><p><strong>（NOIP难度，普及、提高免进）</strong></p><h3 id="高维前缀和总结sosdp---heyuhhh---博客园-cnblogs.com">1. <ahref="https://www.cnblogs.com/heyuhhh/p/11585358.html">高维前缀和总结(sosdp)- heyuhhh - 博客园 (cnblogs.com)</a></h3><h3 id="专题高维前缀和---ruakker---洛谷博客-luogu.org">2.<ahref="https://chocola4ever.blog.luogu.org/prefix">专题——高维前缀和 -Ruakker - 洛谷博客 (luogu.org)</a></h3>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 前缀和/差分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序 第k小的数 nth_element()函数</title>
      <link href="/2024/01/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%20%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0%20nth_element()%E5%87%BD%E6%95%B0/"/>
      <url>/2024/01/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%20%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0%20nth_element()%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h3id="视频教学链接"><a href="https://bilibili.com/video/BV17h4y1E73i/?spm_id_from=333.999.0.0/?_blank" target="_blank">视频教学链接：</a></h3><h1 id="二实战训练">二、实战训练</h1><h3 id="p1177-模板排序">1.<ahref="https://www.luogu.com.cn/problem/P1177">P1177【模板】排序</a></h3><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1961668-20231206160224364-485932827.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1961668-20231206161152271-458682285.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1961668-20231206161726712-668972664.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>强调补充说明：</p><p>1）当左指针和右指针重叠或者错位时，退出while循环，所以while循环条件应写为<strong>while( i &lt; j ) ，不要加入'='号</strong>！</p><p>2）对x的取值，不一定非要去取区间中段的值，可以随机取（仍然无法确保肯定能把区间分成长度接近的两段）。</p><p>3）如果要取区间中段值，为防止int 或者longlong的加法溢出，<strong>最好是写成 x = a[ le + (ri - le)/2]的代码形式</strong>。</p><p>4）当退出while循环时，<strong>i 和 j 正好是重叠的(i == j)，或者是错位的( j+1 == i )</strong>。此时往下递归，左区间取[le, j]，<strong>右区间取[j+1, ri ]（不能取[i, ri]，因为i和j可能是重叠的，若取i 会让 a[i] 同时在两个子区间内）</strong></p><p>5）代码模板建议背下来！</p><p>P1177 AC代码： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,a[<span class="hljs-number">100005</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span>;         <span class="hljs-comment">// 重叠就返回</span><br>    <span class="hljs-type">int</span> i=l<span class="hljs-number">-1</span>, j=r+<span class="hljs-number">1</span>;        <span class="hljs-comment">// 左右指针分别初始化为“区间的外侧”</span><br>    <span class="hljs-type">int</span> x=a[i+(j-i)/<span class="hljs-number">2</span>];      <span class="hljs-comment">// x一定要提前取出来，不能在while内去临时取，因为中间位置的值可能在变化！</span><br>    <span class="hljs-keyword">while</span>(i&lt;j) &#123;             <span class="hljs-comment">// 当i==j（重叠）或者i&gt;j（错位）时跳出循环</span><br>        <span class="hljs-keyword">do</span> i++;<br>            <span class="hljs-keyword">while</span>(a[i]&lt;x);   <span class="hljs-comment">//向右找&gt;=x的数，不能写成while(a[i]&lt;a[i+(j-i/2)])！</span><br>        <span class="hljs-keyword">do</span> j--;<br>           <span class="hljs-keyword">while</span>(a[j]&gt;x);   <span class="hljs-comment">//向左找&lt;=x的数</span><br>        <span class="hljs-keyword">if</span>(i&lt;j)<br>            <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>    &#125;<br>    <span class="hljs-comment">// 不管是重叠或是错位，下面的写法都没问题</span><br>    <span class="hljs-built_in">quicksort</span>(l, j);<br>    <span class="hljs-built_in">quicksort</span>(j+<span class="hljs-number">1</span>, r);       <span class="hljs-comment">// 不能写成(i, ri)，因为可能ij重叠</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]); <span class="hljs-comment">// 从0号位开始存储</span><br>    <span class="hljs-built_in">quicksort</span>(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">6</span><br><span class="hljs-comment">4 3 2 4 5 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">10</span><br><span class="hljs-comment">4 2 1 2 8 9 -2 4 5 1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p><h3 id="p1923-深基9.例4求第-k-小的数">2.<ahref="https://www.luogu.com.cn/problem/P1923">P1923 【深基9.例4】求第 k小的数</a></h3><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1961668-20231206164116179-1683421866.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>方法(1)：快速排序搞定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,k,a[<span class="hljs-number">5000010</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qnth_element</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> a[l];<br>    <span class="hljs-type">int</span> i=l<span class="hljs-number">-1</span>, j=r+<span class="hljs-number">1</span>, x=a[(l+r)/<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">while</span>(i&lt;j) &#123;<br>        <span class="hljs-keyword">do</span> i++;<br>            <span class="hljs-keyword">while</span>(a[i]&lt;x); <span class="hljs-comment">//向右找&gt;=x的数</span><br>        <span class="hljs-keyword">do</span> j--;<br>            <span class="hljs-keyword">while</span>(a[j]&gt;x); <span class="hljs-comment">//向左找&lt;=x的数</span><br>        <span class="hljs-keyword">if</span>(i&lt;j) <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(k&lt;=j) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qnth_element</span>(l,j);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">qnth_element</span>(j+<span class="hljs-number">1</span>,r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">qnth_element</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>方法(2)：nth_element()函数实现程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,k,a[<span class="hljs-number">5000010</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-built_in">nth_element</span>(a,a+k,a+n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a[k]);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三-拓展nth_element函数讲解">三、拓展——<strong>nth_element()函数讲解</strong>：</h1><h3 id="作用">1、作用</h3><p><strong>将数组指定范围内第 k (从1开始编此号码)小的元素（会更改原数组中所有元素的位置。如需不变，请预先备份）存于a[k-1]位置上，其左侧的元素都&lt;=a[k-1]，右侧的元素都&gt;a[k-1]，但左右两侧区间内的数据仍然凌乱。</strong></p><h3 id="用法">2、用法</h3><p>nth_element(起始地址，k-1，最后一个元素地址+1，自定义排序)；</p><p>举例：查找数组中第5小的元素 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span><span class="hljs-comment">//必要头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>&#125;;<br>    <span class="hljs-comment">// 将数组中第5小（从1开始编）的元素放在a[4]位置，</span><br>    <span class="hljs-comment">// 其左侧元素都&lt;=a[4]，右侧元素都&gt;a[4]</span><br>    <span class="hljs-built_in">nth_element</span>(a, a+<span class="hljs-number">4</span>, a+<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">// 此时数组a[]的元素已发生挪位更改。a[]=&#123;2, 1, 3, 5, 5, 9, 8, 7, 6, 10&#125;</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;第5小的数是：&quot;</span>&lt;&lt;a[<span class="hljs-number">4</span>];<span class="hljs-comment">//第5小的数在a[4]</span><br>&#125;<br><span class="hljs-comment">//console:</span><br><span class="hljs-comment">//第5小的数是：5</span><br></code></pre></td></tr></table></figure></p><p>查找第 k 大的元素也是可以的。将第 k 大的问题转换为求第 n - k + 1小的问题就可以了例如：<strong>一个数组有10个元素，求第2大的数，那么它等同于求第10-2+1=9小的元素</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span><span class="hljs-comment">//必要头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;请问您需要查找第几大的数？&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">10</span>&#125;;<br>    <span class="hljs-built_in">nth_element</span>(a, a+<span class="hljs-number">10</span>-n, a+<span class="hljs-number">10</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;第&quot;</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">&quot;大的数是：&quot;</span>&lt;&lt;a[<span class="hljs-number">10</span>-n];<br>&#125;<br><span class="hljs-comment">//console:</span><br><span class="hljs-comment">//请问您需要查找第几大的数？</span><br><span class="hljs-comment">//2</span><br><span class="hljs-comment">//第2大的数是：9</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2020/03/13/hello/"/>
      <url>/2020/03/13/hello/</url>
      
        <content type="html"><![CDATA[<h1 id="是">是</h1><p><span class="math display">\[\lim_{h \rightarrow 0 } \frac{f(x+h)-f(x)}{h}\]</span></p><h2 id="一.-归并排序">一. 归并排序</h2><p>来一个分段函数</p><p>点击<a href="/2020/03/13/hello/#jump1">这里</a>可以到站内文章"hello.md"的锚点jump1，在下面的1.2.3。<span class="math display">\[f(n)=\begin{cases}1 &amp; (n=1) \\1 &amp; (n=2) \\f(n-1)+f(n-2) &amp; (n&gt;=3)\end{cases}\]</span></p><p><span class="math display">\[y=\begin{cases}0 &amp; z&lt;0 \\0.5 &amp; z=0 \\1 &amp; z&gt;0\end{cases}\]</span> <span class="math display">\[\begin{cases}s_{\Delta}=\sum_{i=1}^n(x_i^2+y_i^2)+\frac i{20} \\7x - 2y + 4z=C_n^m+10^{20} \\s_{\Delta}=\sqrt[]{x+\sqrt[3]{1+x}}\\\lfloor x \rfloor+\lceil \log_2n \rceil\end{cases}\]</span></p><p><span class="math display">\[s_{\Delta}=\sum_{i=1}^n(x_i^2+y_i^2)+\frac i{20}\label{a}\\7x - 2y + 4z=C_n^m+10^{20} \\s_{\Delta}=\sqrt[]{x+\sqrt[3]{1+x}}\\\lfloor x \rfloor+\lceil \log_2n \rceil\]</span></p><p><span class="math inline">\(\log_2{log_2n}\)</span></p><p><span class="math display">\[\begin{align}\label{eq2}u_{i1}(t)&amp;=-b_{i}(t),f(q_{i}),\u_{i2}(t)&amp;=\sum_{j\in \mathcal{N}{i}}c{ij}h(p_{j}(t)-p_{i}(t)),\quadi\in\bar{N}\end{align}\]</span></p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20231228124457143.png"alt="image-20231228124457143" /><figcaption aria-hidden="true">image-20231228124457143</figcaption></figure><p>$ dp[i][j]=dp[i-1][j]+data[i][j-1](i,j) $</p><p>$ dp_i$</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic/img/image-20241119161909303.png" alt="image-20241119161909303" style="zoom:67%;" /></p><p>dp[i]=data[i] + dp[i-1]</p><p><span class="math display">\[\begin{array}{|r|l|c|}\hline 20&amp;*&amp;?\\    \hline \leftarrow&amp;5&amp;3\\    \hline 6&amp;1&amp;8\\    \hline\end{array}\]</span></p><p><span class="math display">\[\begin{array}{}           &amp;0&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7\\    \hlinec&amp;\gets&amp;\Leftrightarrow&amp;\Longleftrightarrow&amp;\iff&amp;*\\    \hline c&amp;\to&amp;\Rightarrow&amp;3&amp;20000&amp;*\\    \hline maxc&amp;60000&amp;\Leftarrow&amp;8&amp;a_i\\    \hline\end{array}\]</span></p><p><span class="math display">\[\begin{array}{cc|c}           努力&amp;你好&amp;再见\\    \hline 0&amp;0&amp;0\\           0&amp;1&amp;1\\           1&amp;0&amp;1\\           1&amp;1&amp;1\\\end{array}\]</span></p><p>这里我打算嵌入一张gif图片试试看效果： <imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/a511f48b5a6455b8dfe0a256ab2eb466.gif"alt="a511f48b5a6455b8dfe0a256ab2eb466" /></p><p>AC代码参考如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> <span class="hljs-comment">// 我刚试了一下Ctrl + Shift + K</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> distance;<br><span class="hljs-type">double</span> s1, s2;<br>    <br>cin &gt;&gt;distance;<br>s1= <span class="hljs-number">27</span> +<span class="hljs-number">23</span> + distance/<span class="hljs-number">3.0</span>;<br>s2= distance / <span class="hljs-number">1.2</span>;<br><span class="hljs-keyword">if</span> (s1&lt;s2)<br>cout&lt;&lt;<span class="hljs-string">&quot;Bike&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s2 &lt; s1)<br>cout&lt;&lt;<span class="hljs-string">&quot;Walk&quot;</span>;<br><span class="hljs-keyword">else</span><br>cout&lt;&lt;<span class="hljs-string">&quot;All&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="本标题暗含了一个锚点名叫jump1">1.2.3 <spanid="jump1">本标题暗含了一个锚点名叫jump1</span></h2><p>或者版本二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">哈希查找的模板题 </span><br><span class="hljs-comment">2123 7044 013 013 7957 ll是一个1e18的超大质数，末尾有个ll，表示该数的长整型</span><br><span class="hljs-comment">不好意思，怕是要背下来…… </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span> <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><br>ull a[<span class="hljs-number">10010</span>];<br><span class="hljs-type">char</span> s[<span class="hljs-number">10010</span>];<br><span class="hljs-type">int</span> n,ans=<span class="hljs-number">1</span>;<br><span class="hljs-comment">//int prime=233317;</span><br><span class="hljs-comment">//ull mod=212370440130137957ll;</span><br><br><span class="hljs-function">ull <span class="hljs-title">BKDRHash</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span></span><br><span class="hljs-function"></span>&#123;<br>    ull seed = <span class="hljs-number">31</span>;    <span class="hljs-comment">// 31 131 1313 13131 131313 etc.. 37</span><br>    ull key = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (*str)<br>        key = (key * seed + (ull)(*str++)) % <span class="hljs-number">212370440130137957ll</span> + <span class="hljs-number">233317</span>;<br> <br><span class="hljs-keyword">return</span> key &amp; <span class="hljs-number">0x7fffffff</span>;  <span class="hljs-comment">// 舍弃符号位，稳妥起见。不加也能ac本题 </span><br>&#125;<br><span class="hljs-comment">//ull hashe(char s[]) &#123;</span><br><span class="hljs-comment">//int len=strlen(s);</span><br><span class="hljs-comment">//ull base=131;</span><br><span class="hljs-comment">//ull ans=0;</span><br><span class="hljs-comment">//for (int i=0; i&lt;len; i++)</span><br><span class="hljs-comment">//ans=(ans*base+(ull)s[i])%mod+prime;</span><br><span class="hljs-comment">//return ans;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<br>a[i]=<span class="hljs-built_in">BKDRHash</span>(s);<br>&#125;<br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++) &#123;<br><span class="hljs-keyword">if</span>(a[i]!=a[i+<span class="hljs-number">1</span>])<br>ans++;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,ans);<br>&#125;<br></code></pre></td></tr></table></figure><p>矩阵：</p><p><span class="math display">\[\begin{pmatrix}  1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n \\  1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \\  \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\  1 &amp; a_m &amp; a_m^2 &amp; \cdots &amp; a_m^n \\  \end{pmatrix}\]</span></p><script>    // add script tag and code at the end of your post    alert("Hello World");</script>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
