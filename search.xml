<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>求背包问题的具体方案</title>
      <link href="/2024/06/24/%E6%B1%82%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%85%B7%E4%BD%93%E6%96%B9%E6%A1%88/"/>
      <url>/2024/06/24/%E6%B1%82%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%85%B7%E4%BD%93%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><p>　　背包问题的具体方案求解，这个问题是背包问题拓展的经典题型，适合于已经学过01普通背包、完全背包、多重背包等基础背包类型之后的同学在拓展阶段学习。</p><p>　　一般来说，背包问题求具体方案，往往是在这些背包模型的基础上，要求输出最终选择的物品的种类编号和个数（若是普通01背包，则只需要输出物品编号）。这里需要注意的一点是，对于最终的最优收益值，其实现的方案往往可能是不唯一的。为了在线判题的方便，往往题目上会要求“输出方案按照字典序来输出”。所谓的字典序，类似于字符串的大小比较顺序，即小的数字或者字符先输出。在C++中，String类型和Vector类型的对象都支持直接比较大小，且按照字典序来比较大小。</p><h2 id="普通01背包不超过ys1输出最优收益值的选择方案">1.1“普通01背包+不超过YS1”，输出最优收益值的选择方案</h2><h3 id="为什么要逆推路径">1.1.1 为什么要逆推路径？</h3><p>　　“普通01背包+不超过YS1”，这是最普通常见的背包入门题型，以1267为例。这种题型，一般做法都是定义dp[i][j]表示“前i个物品在不超过指定容量YS1时的最优收益值”，然后采用从第1行到第n行的顺序来填写dp[][]数组，如下代码所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 代码(1)</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)      <span class="hljs-comment">// 一般做法都是正序向下填写数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++) <span class="hljs-comment">// 因为是标准状态数组，所以逆序也可以（不管是01背包或者完全背包）</span><br>    dp[i][j]= <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i<span class="hljs-number">-1</span>][j-ys1[i]]+value[i] ); <br></code></pre></td></tr></table></figure><p>　　最后再从dp[n][YS1]往上倒推，从而确定出所选物品的编号值序列，如下面的代码所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 代码(2)</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n,j=YS1; i&gt;<span class="hljs-number">0</span>; i--)<br>    <span class="hljs-keyword">if</span> (dp[i][j] == dp[i<span class="hljs-number">-1</span>][j-ys1[i]]+value[i] )&#123;<span class="hljs-comment">// 这种转移，是因为选择了第i个物品而导致。（暂时这么认为）</span><br>        cout &lt;&lt; i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        j-=ys1[i];<br>    &#125;<br></code></pre></td></tr></table></figure><p>　　为什么要采用倒推的方式来找路径呢？或者说，为什么不能从[0][0]开始去往下找路径，直到[n][YS1]为止呢？因为对于每个物品，我们都有“选第i个物品”和“不选第i个物品”这两种选择。理论上来说，每个数组方格都有“往下”和“往右下”这两个分支情况。如果从[0][0..YS1]中每个方格为根节点，往下形成多棵二叉树。如果每个分支情况都要去判断的话，算法复杂度会达到<spanclass="math inline">\(O(2^n)\)</span>指数级别，此法不可取。如下图绿色所示。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240630142301495.png"alt="image-20240630142301495" /><figcaption aria-hidden="true">image-20240630142301495</figcaption></figure><p>　　稍微聪明一点的同学可能已经意识到，既然这是一颗二叉树结构，要寻找根节点到下面某个结点之间的路径，最简单的方式就是“逆推”。因为每个树节点只有唯一的一个父节点。所以可以用<spanclass="math inline">\(O(n)\)</span>的效率，从路径终点往根节点逆推出唯一的路径。<font color="yellow">if(dp[i][j] == dp[i-1][j-ys1[i]]+value[i])，则说明dp[i][j]是因为选择了第i个物品而从dp[i-1][j-ys1[i]]转移过来而得</font>。代码（2）就是这个意思，只不过是逆序输出了而已。想要反过来输出也不难。</p><p>　　看到这里，似乎具体方案已经讲解完了。然则非也！上段的黄色文字的叙述是存在一定问题的。每种状态因为选择或者不选择物品，往下有两种状态转移的可能（只能二选一，不能既选又不选）；反过来思考，每种状态可能因为上一行的两种情况之一而得来，<font color="pink">但有可能存在"dp[i-1][j]==dp[i-1][j-ys1[i]]+value[i]"的情况，也就是说，选第i种物品或者不选，都可能达到相同的dp[i][j]值。如上图中的红色箭头所示，0+6==dp[3][0]+value[4]==dp[3][4]==6==dp[4][4]。总结来说，即这并非一棵树结构，而是图结构！</font></p><p>　　在这种情况下，如果要输出具体方案，则可能存在多条路径。如上图中，如果要达到[4][4]的状态，可以“选4”、“选1-3”和“选1-2”这三种方案。尤其是第三个方案，如果从下往上逆推，只能倒推到[0][1]而非[0][0]，也就是说，“选1-3”的方案，存在一定的成本冗余。根据题目的定义，这是允许且合理的。</p><h3 id="为什么要字典序输出">1.1.2 为什么要字典序输出？</h3><p>　　1.1.1节中我们说过，路径可能存在多条。在最糟糕的情况下（“ys1[1..n]=a，求dp[n][2*a]”，任选其中2个物品，共有<spanclass="math inline">\(A_n^2=n(n+1)/2\)</span>种选法，即路径），路径数为平方级。因路径太多条，更多的输出情况是“输出字典序最小的物品编号序列”，如<ahref="https://www.acwing.com/problem/content/12/">12.背包问题求具体方案</a>。</p><p>　　这里有必要科普一下“字典序”。字典序的比较规则，和字符串的比较规则完全一致。例如：1-4小于2-3；1-4小于4；1-4小于1-4-5。</p><h3 id="方法一为每个状态存储路径可拓展性更强建议掌握">1.1.3方法一：为每个状态存储路径（可拓展性更强，建议掌握！）</h3><p>　　要想表示和输出路径，一个最简单好理解的做法，就是为每一个状态都存储路径，在状态转移时比较路径的字典序，从而得到新状态的路径值。在C++中，String、Vector、map都是按照字典序来进行大小比较的，所以我们可以把路径存为String或者Vector这种结构。</p><p>　　1) 标准状态数组下的代码如代码（3）所示。空间复杂度为<spanclass="math inline">\(O( N * YS1 * N)\)</span>，较高，慎用。在<ahref="https://www.acwing.com/problem/content/12/">12.背包问题求具体方案</a>中使用会MLE！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 代码（3），01背包，标准状态数组，存储路径</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">jc</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>&#125; dp[N][<span class="hljs-number">201</span>];<br>......<br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)            <span class="hljs-comment">// 针对每1个物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++) &#123; <span class="hljs-comment">// 枚举背包总空间j，正序逆序均可！！</span><br>            dp[i][j]= dp[i<span class="hljs-number">-1</span>][j];   <span class="hljs-comment">// value和path都复制</span><br>            <span class="hljs-keyword">if</span> (j&gt;=ys1[i]) &#123;<br>                <span class="hljs-comment">// 先捏造一个临时决策来存储选择第i个物品后的value和path</span><br>                jc tmp=dp[i<span class="hljs-number">-1</span>][j-ys1[i]];  <span class="hljs-comment">// value和path都复制</span><br>                tmp.value+=value[i];       <span class="hljs-comment">// value要增加</span><br>                tmp.path.<span class="hljs-built_in">push_back</span>(i);     <span class="hljs-comment">// path也要增加</span><br>                <span class="hljs-keyword">if</span> (dp[i][j].value &lt; tmp.value || \<br>                        <span class="hljs-comment">// 等值时，若选择i的路径字典序更小，则也需要更新为更小字典序的决策</span><br>                        dp[i][j].value ==tmp.value  &amp;&amp; dp[i][j].path &gt; tmp.path ) &#123;<br>                    dp[i][j] = tmp;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    cout &lt;&lt;dp[n][YS1].value &lt;&lt;endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;dp[n][YS1].path.<span class="hljs-built_in">size</span>(); i++)    <span class="hljs-comment">//// 关掉这段代码，即可AC 1267题</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, dp[n][YS1].path[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　2）滚动状态数组下的代码如代码（4）所示：空间复杂度为<spanclass="math inline">\(O( YS1 * N)\)</span>，Nice！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 代码（4），01背包，滚动状态数组，存储路径</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">jc</span> &#123;           <span class="hljs-comment">// 决策</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> value;  <span class="hljs-comment">// 该决策的收益值</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 决策的具体内容（每个公司选择多少台机器，path长度不超过M）</span><br>&#125; dp[maxYS1];         <span class="hljs-comment">// 滚动数组，空间复杂度达到了O( M * M )</span><br>......<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--) &#123;     <span class="hljs-comment">// 普通01背包，滚动数组需要倒序填写</span><br>            jc tmp;  <span class="hljs-comment">// 暂时捏造一个决策tmp，表示选择第i个物品后的各种值。</span><br>            tmp.value= dp[j-ys1[i]].value + value[i];<br>            tmp.path= dp[j-ys1[i]].path;<br>            tmp.path.<span class="hljs-built_in">push_back</span>(i);      <span class="hljs-comment">// 表示选择第i个物品</span><br>            <span class="hljs-keyword">if</span> (dp[j].value &lt; tmp.value || \<br>                dp[j].value ==tmp.value &amp;&amp; dp[j].path &gt; tmp.path ) <br>            &#123; <span class="hljs-comment">// 如果在等值情况下新方案的路径字典序更小 </span><br>                dp[j] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>　　上述的方法，都需要用到struct jc来定义新类型。那能否就在intdp[][]数组的基础上直接逆推来得到字典序最小的唯一路径呢？</p><h3 id="方法二不存储路径直接逆推出最小字典序的唯一路径">1.1.4方法二：不存储路径，直接逆推出最小字典序的唯一路径</h3><p>　　我们以两个样例来研究一下如何倒推。两张图中，红色虚线圆圈处为逆推时需要抉择分支的状态，绿色箭头为最优路径，红色箭头为其他路径。任何颜色的箭头，从左往右指，表示逆推时需要选择当前物品；往上往下指，表示逆推时不选择当前物品。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240702153952478.png" alt="image-20240702153952478" style="zoom:70%;" /></p><p>　　从上面的两张图可以看出，在逆推遇到圆圈处时，并没有准确的规律该向“左上方”？或者该向“正上方”？这是为什么呢？因为在圆圈处有两种选择的前提下，如果往左上方逆推，意味着选择第i个物品；而如果想正上方逆推，意味着不选择第i个物品。那这为什么无法确定规律呢？</p><p>　　道理其实很简单。因为我们是从4号到1号，倒序来考虑每个物品的。假如当前我们选择4号物品，但我们此时并不确定以后是否会选择1、2、3号物品。<strong>序列越靠前的号码越能决定序列的字典序大小，光确定了中段或者末段的值是无法估算该序列大小的</strong>。光凭序列中有个“4”，并不能肯定该序列就是最小字典序的。例如[1,4]&lt;[2,3]，或者[1]&lt;[1,4]。</p><p>　　上述问题的解决方法其实也很简单。我们只需要<strong>让逆推时先决策的是小编号的物品</strong>即可。我们只要选择了1号物品，那么1开头的序列的字典序是肯定小于2或者3开头的序列的字典序的。例如[1,5,6,7]&lt;[2,4]。</p><p>　　那如何让逆推时先决策的是小编号的物品呢？先决策小编号，意味着先决策第一行。换句话说，我们要从dp[1][YS1]开始，从上往下去“倒推”dp数组，直到倒推到dp[n+1][]为止。</p><p>　　要想实现这个，只有一种可能，即<strong>[1][YS1]就是dp数组的终态</strong>。也就是说，dp数组需要换定义了，<strong>dp[i][j]表示“在第i～n个物品之间选择，不超过成本量j的最大收益值”</strong>。</p><p>　　在这种情况下，我们<strong>在填写dp数组值时，应该从下往上填写</strong>。并且，递推的特例也需要调整为第n+1行，dp[n+1][0..YS1]=0。新的递推方程如下：<span class="math display">\[\begin{align}dp[i][j]=\begin{cases}dp[i+1][j] &amp;(j&lt;ys1[i]) \tag{1}\\max(\ dp[i+1][j],\quad dp[i+1][j-ys1[i]]\ ) &amp;(j \geq ys1[i])\end{cases}\end{align}\]</span>　　可以看出，该公式相比之前传统的01背包公式，只是第一维从<spanclass="math inline">\(i-1\)</span>变成了<spanclass="math inline">\(i+1\)</span>，第二维依旧是<spanclass="math inline">\(j-ys1[i]\)</span>。这意味着，我们在推导公式时，第一维只能从n到1，而第二维则依然是正序逆序均可！若为滚动数组，第二维的顺序要领则依然和以前一样。</p><p>　　在下面的这四张图中，每一排的测试数据都各自相同，一共有两排（组）数据。左侧第一列的两组数据是从1到n的填写顺序，终态（黄色方格）在右下方的位置，且从下往上逆推方案路径。右侧第二列的两张图样例数据分别和左侧同一排的样例数据相同，但采用的是从n到1的填写顺序，终态在右上角的位置，且从上往下逆推方案路径。这四张图中，绿色箭头表示字典序最小的终态路径，是我们想要的答案；而红色箭头也属于终态路径，但字典序偏大。每一个红色虚线圆圈处，代表在逆推时需要对路径分叉进行选择的地方，也是我们研究决策的关键位置。</p><p>　　要想正确地逆推出字典序最小的到达终态的路径，可以看出，左侧第一列的两张图，在不同的样例数据下，分叉的最优选择各自不同，无法看出规律。而右侧第二列的两张图，<strong>在每次往下分叉时，只要选择“尽可能向左”（代表“选择第i个物品”），放弃“竖直向下”的分支（代表“不选第i个物品”），就能达成最优路径</strong>。</p><p>其核心代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// dp[i][j]表示从第i～n个物品之间挑选出不超过指定成本量j的最大收益值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n;i &gt;= <span class="hljs-number">1</span>;i--) &#123;        <span class="hljs-comment">// 倒序填写，从n到1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= YS1;j++) &#123;  <span class="hljs-comment">// 因为是标准状态数组，所以正序逆序都可以</span><br>            dp[i][j] = dp[i+<span class="hljs-number">1</span>][j];      <span class="hljs-comment">// 注意i+1</span><br>            <span class="hljs-keyword">if</span> (j &gt;= ys1[i])<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i+<span class="hljs-number">1</span>][j-ys1[i]]+value[i]);  <span class="hljs-comment">// 注意i+1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j=YS1;i &lt;= n;i++) &#123; <span class="hljs-comment">// 从终态[1][YS1]往下逆推到[0][..]</span><br>    <span class="hljs-comment">// 要一直确保j-ys1[i]为有效的数组下标！这一点别忘了！</span><br>        <span class="hljs-keyword">if</span> (j-ys1[i] &gt;= <span class="hljs-number">0</span> &amp;&amp; dp[i][j] == dp[i+<span class="hljs-number">1</span>][j-ys1[i]]+value[i]) &#123; <span class="hljs-comment">//能选i则选i</span><br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            j -= ys1[i];<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>　　<imgsrc="C:\Users\wangx\AppData\Roaming\Typora\typora-user-images\image-20240702152231395.png"alt="image-20240702152231395" /></p><p>　　从上面的代码中可以看出，<strong>这种算法的时间复杂度和空间复杂度，都是<spanclass="math inline">\(O(n*YS1)\)</span></strong>。因为涉及到要从终态开始逆推，所以dp数组不允许被压缩成滚动数组。</p><h2 id="完全背包不超过ys1输出最优收益值的选择方案">1.2“完全背包+不超过YS1”，输出最优收益值的选择方案</h2><p>　　如果不要求输出方案，则代码模板如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)          <span class="hljs-comment">// 针对每1种物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++) &#123;  <span class="hljs-comment">// 枚举背包总空间j，只能正序</span><br>        dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[i]) &#123;<br>            <span class="hljs-comment">// dp[i-1][j] 表示“能装而不装”，照搬上一行，注意是i-1</span><br>            <span class="hljs-comment">// dp[i][j - ys1[i]] + value[i]是当前行左侧（注意是i），它可能已经装有若干个物品i</span><br>            <span class="hljs-keyword">if</span> (dp[i][j] &lt; dp[i][j - ys1[i]] + value[i] ) &#123; <span class="hljs-comment">// 注意，是[i][j-...]</span><br>                dp[i][j] = dp[i][j - ys1[i]] + value[i];<br>            &#125;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>　　现在要求输出方案，则应该改装dp[][]的定义。在推导时，总体思路不变。代码模板如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++) &#123;<br>        dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>        dp[i][j].path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 先假设第i种物品装0个，即不装</span><br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[i]) &#123;<br>            <span class="hljs-comment">// dp[i][j - ys1[i]] + value[i]是当前行左侧（注意是i），它可能已经装有若干个物品i</span><br>            jc tmp= dp[i][j-ys1[i]];<br>            tmp.value += value[i];   <span class="hljs-comment">// [i][j - ys1[i]]状态再选择1个i号物品</span><br>            tmp.path[i<span class="hljs-number">-1</span>]++;  <span class="hljs-comment">// 第i种物品对应的是path[i-1]（vector从0开始编号），将其加1，表示再选择1个i号物品</span><br>            <span class="hljs-keyword">if</span> (dp[i][j].value &lt; tmp.value || \<br>                    dp[i][j].value == tmp.value &amp;&amp; dp[i][j].path &gt; tmp.path) &#123;<br>                dp[i][j] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="视频参考教程">1.3 视频参考教程</h2><p>　　<ahref="https://www.bilibili.com/video/BV1454y1C7AR/?spm_id_from=333.999.0.0">E20背包DP求具体方案</a>，该视频内容仅供参考，同学们有时间的话可以看看，加深印象。</p><h1 id="二实战训练">二、实战训练</h1><h2 id="acwing-12.-背包问题求具体方案">2.1 Acwing 12.背包问题求具体方案</h2><h3 id="原题链接">2.1.1 原题链接</h3><h3 id="acwing-12.-背包问题求具体方案微信登录">　　　　<ahref="https://www.acwing.com/problem/content/12/">Acwing 12.背包问题求具体方案</a>（微信登录）</h3><p>　　本题要求输出最优方案的具体内容，和 P2066 有相似之处。</p><h3 id="ac代码">2.1.2 AC代码</h3><h4 id="方法一为每个状态存储路径path">2.1.2.1方法一，为每个状态存储路径path</h4><p>　　时间复杂度：<spanclass="math inline">\(O(n*YS1)=1e3*1e3=1e6\)</span></p><p>　　空间复杂度：<spanclass="math inline">\(O(n*YS1)=1e3*1e3=1e6\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法1：01普通背包 + 滚动状态数组 + 路径保存 + 字典序输出具体方案 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    本题的maxn和maxYS1都达到了1e3，如果选择P2066那种标准状态数组，空间复杂度会达到1e9，超过64MB=6.4e7</span><br><span class="hljs-comment">    采用滚动数组后，空间复杂度为 4e6 &lt; 6.4e7</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxYS1=<span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n, YS1;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">jc</span> &#123;           <span class="hljs-comment">// 决策</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> value;  <span class="hljs-comment">// 该决策的收益值</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 决策的具体内容，空间复杂度O(n)。若要极限压缩空间，可设为为Bit类型，用0/1的bit序列来表示决策内容 </span><br>&#125; dp[maxYS1];         <span class="hljs-comment">// 滚动数组，空间复杂度为O(n*YS1)</span><br><span class="hljs-type">int</span> ys1[maxn], value[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;YS1);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;ys1[i], &amp;value[i]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--) &#123;     <span class="hljs-comment">// 普通01背包，滚动数组需要倒序填写</span><br>            jc tmp;  <span class="hljs-comment">// 暂时捏造一个决策tmp，表示选择第i个物品后的各种值。</span><br>            tmp.value= dp[j-ys1[i]].value + value[i];<br>            tmp.path= dp[j-ys1[i]].path;<br>            tmp.path.<span class="hljs-built_in">push_back</span>(i);      <span class="hljs-comment">// 表示选择第i个物品</span><br>            <span class="hljs-keyword">if</span> (dp[j].value &lt; tmp.value || dp[j].value ==tmp.value &amp;&amp; dp[j].path &gt; tmp.path ) &#123; <span class="hljs-comment">// 如果在等值情况下新方案的路径字典序更小 </span><br>                dp[j] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;dp[YS1].path.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        cout&lt;&lt;dp[YS1].path[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">4 5</span><br><span class="hljs-comment">2 4</span><br><span class="hljs-comment">3 4</span><br><span class="hljs-comment">4 6</span><br><span class="hljs-comment">1 2</span><br><span class="hljs-comment">输出</span><br><span class="hljs-comment">1 4</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">4 4</span><br><span class="hljs-comment">2 4</span><br><span class="hljs-comment">1 2</span><br><span class="hljs-comment">3 4</span><br><span class="hljs-comment">4 6</span><br><span class="hljs-comment">正确输出</span><br><span class="hljs-comment">1 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="方法二标准状态数组定义不变逆序填写正序逆推">2.1.2.2方法二，标准状态数组定义不变，逆序填写，正序逆推</h4><p>　　时间复杂度：<spanclass="math inline">\(O(n*YS1)=1e3*1e3=1e6\)</span></p><p>　　空间复杂度：<spanclass="math inline">\(O(n*YS1)=1e3*1e3=1e6\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法2：01普通背包 + 标准状态数组 + 倒序填写、正序逆推 + 字典序输出具体方案 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxYS1=<span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n,YS1;<br><span class="hljs-type">int</span> dp[maxn][maxYS1];<br><span class="hljs-type">int</span> ys1[maxn],value[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; YS1;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)<br>        cin &gt;&gt; ys1[i] &gt;&gt; value[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n;i &gt;= <span class="hljs-number">1</span>;i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= YS1;j++) &#123;<br>            dp[i][j] = dp[i+<span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">if</span> (j &gt;= ys1[i])<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i+<span class="hljs-number">1</span>][j-ys1[i]]+value[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j=YS1;i &lt;= n;i++) &#123;<br>        <span class="hljs-keyword">if</span> (j-ys1[i] &gt;= <span class="hljs-number">0</span> &amp;&amp; dp[i][j] == dp[i+<span class="hljs-number">1</span>][j-ys1[i]]+value[i]) &#123;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            j -= ys1[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p2066-机器分配">2.2 P2066 机器分配</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P2066">P2066机器分配</a> / <ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1266">1266</a></p><h3 id="分析">2.2.2 分析</h3><p>　　这是一个区间dp的题。不仅如此，题目还要求输出方案，且要求字典序最小。区间dp的题，必然是个三重for循环，其最内层循环k中，处理第i个物品在不超过指定成本量j时选择k的决策。决策方案不再是“选i”或者“不选i”，所以2.1节中的方法2（逆序填写，正序逆推）不再适用于本题。本题只能采用2.1节中的方法1，为每个状态加入path成员，随时记录路径，以供比较或运算。</p><p>　　需要指出的是，官方题解的第一篇题解有点问题，不要看。符合下列测试数据的，才有可能是正确题解。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs text">样例1 <br>3 6<br>10 10 1 1 1 1<br>10 1 10 1 1 1<br>10 10 10 1 1 1<br>正确输出   // 可以不选6台，不一定要选满哦！～<br>30<br>1 1<br>2 1<br>3 1<br>错误输出<br>30<br>1 2<br>2 1<br>3 3<br><br>样例2<br>2 5<br>1 1 1 1 1<br>1 1 1 1 2<br>正确输出<br>2<br>1 0<br>2 5   // 0 5比1 1更小<br><br>样例3<br>2 5<br>1 1 1 1 1<br>1 1 1 1 1<br>正确输出<br>2<br>1 1<br>2 1 <br></code></pre></td></tr></table></figure><h3 id="ac代码-1">2.2.3 AC代码</h3><h4 id="重点掌握的版本">2.2.3.1 重点掌握的版本</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    本题要求输出最优方案的具体内容，和acwing12题有相似之处</span><br><span class="hljs-comment">这个是区间DP的题，1266和本题几乎完全相同,1266题上漏了“要求字典序最小”的要求。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">定义状态：</span><br><span class="hljs-comment">dp[i][j]为前i个公司，分配不超过j台机器的最大收益值 （根据题意，可以不分满j台！）</span><br><span class="hljs-comment">        // dp[2][5].value=150表示前2个公司，一共选择5台机器， 其最大收益值是150</span><br><span class="hljs-comment">        // dp[2][5].path=[4,1]表示公司1要选择4台机器，公司2要选择1台机器   4+1 &lt;= 5</span><br><span class="hljs-comment">状态转移：</span><br><span class="hljs-comment">    前2个公司选不超过3台机器的收益dp[2][3]</span><br><span class="hljs-comment">        = max(&#x27;公司1选不超过3台，公司2选0台&#x27;，&#x27;公司1选不超过2台，公司2选1台&#x27;，&#x27;公司1选不超过1台，公司2选2台&#x27;，&#x27;公司1选不超过0台，公司2选3台&#x27;)</span><br><span class="hljs-comment">        = max(          dp[1][3],                    dp[1][2]+data[2][1],         dp[1][1]+data[2][2],              dp[1][0]+data[2][3]  )</span><br><span class="hljs-comment">        整理后得：</span><br><span class="hljs-comment">            dp[2][3]=max(dp[1][3], dp[1][2]+data[2][1], dp[1][1]+data[2][2], dp[1][0]+data[2][3])</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        状态转移方程如下：</span><br><span class="hljs-comment">dp[i][j] = max( dp[i][j] , dp[i-1][j-k] + a[i][k] )</span><br><span class="hljs-comment">(i属于[1..maxn], j属于[1..YS1], k属于[1..j])</span><br><span class="hljs-comment">k：给公司i分配k个机器</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">dp[]初始值和特例：dp数组全0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxn 11     <span class="hljs-comment">// 最大公司数量 </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxYS1 16     <span class="hljs-comment">// 设备最大总台数 </span></span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> data[maxn][maxYS1];<br><span class="hljs-type">int</span> n,YS1;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">jc</span> &#123;           <span class="hljs-comment">// 决策</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> value;  <span class="hljs-comment">// 该决策的收益值</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 决策的具体内容（每个公司选择多少台机器，path长度不超过maxYS1）</span><br>&#125; dp[maxn][maxYS1];  <span class="hljs-comment">// 空间复杂度达到了O( maxn * maxYS1 * maxYS1 ) ，可能会MLE，可考虑用滚动数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;YS1);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=YS1; j++) <span class="hljs-comment">// j ：选择j台机器</span><br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;data[i][j]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++) &#123;<br>            <span class="hljs-comment">// 为编程方便，先让dp[3][7]=dp[2][7]，即第3个公司暂时什么都不选</span><br>            dp[i][j].path= dp[i<span class="hljs-number">-1</span>][j].path;   <span class="hljs-comment">// 先复制下前两个公司选择的台数，2个int</span><br>            dp[i][j].path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);       <span class="hljs-comment">// 第3个公司既然一台都不选，则台数为 0</span><br>            dp[i][j].value= dp[i<span class="hljs-number">-1</span>][j].value; <span class="hljs-comment">// 别忘了值也要复制好</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=j; k++) &#123; <span class="hljs-comment">// 选择0台已经在上面处理过了，此处至少1台，最多j台</span><br>                jc tmp;                       <span class="hljs-comment">// 假设第i个公司选择k台机器，此处捏造状态tmp，以便于if内的运算</span><br>                tmp.value= dp[i<span class="hljs-number">-1</span>][j-k].value + data[i][k];<br>                tmp.path=dp[i<span class="hljs-number">-1</span>][j-k].path;<br>                tmp.path.<span class="hljs-built_in">push_back</span>(k);        <span class="hljs-comment">//</span><br>                <span class="hljs-keyword">if</span> (dp[i][j].value &lt; tmp.value || \<br>                        <span class="hljs-comment">// 等值时，若当前决策tmp.path的字典序更小，则也需要更新为更小字典序的决策</span><br>                        dp[i][j].value ==tmp.value  &amp;&amp; dp[i][j].path &gt; tmp.path ) &#123;<br>                    dp[i][j] = tmp; <span class="hljs-comment">// 1 &lt;= k &lt;= 15</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dp[n][YS1].value);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,i,dp[n][YS1].path[i<span class="hljs-number">-1</span>]);  <span class="hljs-comment">// 别忘了vector是从0开始编号的</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">3 6</span><br><span class="hljs-comment">10 10 1 1 1 1</span><br><span class="hljs-comment">10 1 10 1 1 1</span><br><span class="hljs-comment">10 10 10 1 1 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">正确输出   // 可以不选6台，不一定要选满哦！～</span><br><span class="hljs-comment">30</span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">3 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">错误输出</span><br><span class="hljs-comment">30</span><br><span class="hljs-comment">1 2</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">3 3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="精简版本学习操作符重载的可以进来看看优秀的代码">2.2.3.2精简版本（学习操作符重载的可以进来看看！优秀的代码）</h4><p>　　上面的代码是可以精简的，精简后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 写法2： 结构体操作符重载，可以大量节省码量，适合高手，建议看懂，学好！  lyyi2003的代码 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxYS1 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxn 16</span><br><span class="hljs-type">int</span> data[maxYS1][maxn];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">jc</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-comment">// 用字符来表示每个位置，有安全隐患，虽然也能存10以上的编号，</span><br>    <span class="hljs-comment">// 但无法存超过127的编号。意味着YS1不能超过127</span><br>    string path;<br>    <span class="hljs-comment">// 算术操作符的重载</span><br>    jc <span class="hljs-keyword">operator</span> +(<span class="hljs-type">int</span> y)  <span class="hljs-keyword">return</span> &#123;value+y,path&#125;;<br>    jc <span class="hljs-keyword">operator</span> +(<span class="hljs-type">char</span> c) <span class="hljs-keyword">return</span> &#123;value  ,path+c&#125;;<br>    <span class="hljs-comment">// 比较操作符的重载</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(jc a) <span class="hljs-type">const</span><br>        <span class="hljs-keyword">return</span> value&lt;a.value||value==a.value&amp;&amp;path&gt;a.path;<br>&#125; dp[maxYS1][maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n,YS1,i,j,k;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;YS1);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>; j&lt;=YS1; j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;data[i][j]);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;=YS1; j++) &#123;<br>            <span class="hljs-comment">// 别忘了value要复制过去，path+‘0’的值也要复制过去</span><br>            dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]+<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>; k&lt;=j; k++)<br>                <span class="hljs-comment">// 此处隐含了&#x27;&lt;&#x27;操作符的操作，且有value和path的操作</span><br>                dp[i][j]=<span class="hljs-built_in">max</span>(dp[i][j],dp[i<span class="hljs-number">-1</span>][j-k]+data[i][k]+(<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;0&#x27;</span>+k));<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dp[n][YS1].value);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,i,dp[n][YS1].path[i<span class="hljs-number">-1</span>]<span class="hljs-number">-48</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section">2.3 1268</h2><h3 id="原题链接-2">2.2.1 原题链接</h3><p>　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1268">1268</a></p><h3 id="分析-1">2.2.2 分析</h3><p>　　这个题的题解，我们之前已经研究过了。在这里主要是说一下完全背包的最优方案的字典序输出。其实总体思路并没有变化，但这里最好是采用“为每个状态存储路径”的方法。</p><h3 id="非ac代码">2.2.3 非AC代码</h3><p>　　下面的代码，只要去掉输出方案的部分，就能AC掉1268题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法5， 非AC代码, 标准状态数组 + 2重for + 增序 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">jc</span>&#123;<br>    <span class="hljs-type">int</span> value;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>&#125;dp[<span class="hljs-number">35</span>][<span class="hljs-number">211</span>], tmp;<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">35</span>], value[<span class="hljs-number">35</span>];<br><span class="hljs-type">int</span> YS1, n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin &gt;&gt;YS1 &gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>cin &gt;&gt;ys1[i] &gt;&gt;value[i];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)       <span class="hljs-comment">// 针对每1种物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 枚举背包总空间j，只能正序 </span><br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];   <br>dp[i][j].path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 先假设第i种物品装0个，即不装 </span><br><span class="hljs-keyword">if</span> (j&gt;=ys1[i])&#123;  <br>                <span class="hljs-comment">// dp[i][j - ys1[i]] + value[i]是当前行左侧（注意是i），它可能已经装有若干个物品i </span><br>                jc tmp= dp[i][j-ys1[i]];<br>                tmp.value += value[i];<br>                tmp.path[i<span class="hljs-number">-1</span>]++;  <span class="hljs-comment">// 第i种物品对应的是path[i-1]（vector从0开始编号），将其加1，表示再选择1个i号物品 </span><br>                <span class="hljs-keyword">if</span> (dp[i][j].value &lt; tmp.value || \<br>                dp[i][j].value == tmp.value &amp;&amp; dp[i][j].path &gt; tmp.path)&#123;<br>    dp[i][j] = tmp;<br>    &#125;<br>    &#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max=%d\n&quot;</span>, dp[n][YS1].value);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;dp[n][YS1].path.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        cout &lt;&lt; dp[n][YS1].path[i] &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">样例1 </span><br><span class="hljs-comment">10 4</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">3 3</span><br><span class="hljs-comment">4 5</span><br><span class="hljs-comment">4 9</span><br><span class="hljs-comment">正确输出</span><br><span class="hljs-comment">max=19</span><br><span class="hljs-comment">1 0 0 2</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 背包问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>其他的线性DP（简单）</title>
      <link href="/2024/05/04/%E5%85%B6%E4%BB%96%E7%9A%84%E7%BA%BF%E6%80%A7DP%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/"/>
      <url>/2024/05/04/%E5%85%B6%E4%BB%96%E7%9A%84%E7%BA%BF%E6%80%A7DP%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><p>　　因为dp的本质是递推，所以普通的线性dp，本质上就是线性递推的题，同学们只要定义好状态数组和递推方程等，严格做好六点分析，就能破之。</p><h1 id="二.-实战训练">二. 实战训练</h1><h2 id="城市交通网最短路径">2.1 1261 城市交通网——最短路径</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1261"><strong>1261：【例9.5】城市交通路网</strong></a></p><h3 id="分析">2.1.2 分析</h3><p>　　该题需要在带权的网中，求<strong>指定的两个点之间的最短路径</strong>。最短路径问题的各个解法，本质上就是动态规划。本题可以作为最短路径的入门题，虽然不是最短路径的最优算法，但属于朴素级的算法，简单易懂。</p><ol type="1"><li>状态数组定义</li></ol><p>　　dp[i]：从出发点A走到点i的最短路径值</p><ol start="2" type="1"><li>所求目标</li></ol><p>　　dp[n]，目标点是编号值最大的第n点（即E点）。</p><ol start="3" type="1"><li>状态转换方程</li></ol><p>　　动态规划的本质是递推，现在要找关于dp[i]的状态转移方程，就需要假设dp[i-1]、dp[i-2]……等已知，然后找dp[i]和dp[i-1]、dp[i-2]……等之间的关系式。“A点到i号点的最短路径值”，和“A点到i-1号点的最短路径值”、“A点到i-2号点的最短路径值”等之间有什么关系吗？</p><p>　　以8号点为例，从图上可以看到，从5号点和6号点都能走到8号点，且长度已知。要想从A点走到8号点，必然要经过5号点或者6号点，这是必经之路。只要我们求出“从A点走到5号点的最短路径值”，以及“从A点走到6号点的最短路径值”，分别加上<spanclass="math inline">\(5-&gt;8\)</span>的权值<spanclass="math inline">\(mapp_{5-&gt;8}\)</span>和<spanclass="math inline">\(6-&gt;8\)</span>的权值<spanclass="math inline">\(mapp_{6-&gt;8}\)</span>，两个<strong>和值</strong>比较，取最小值（因为是求最短路）即可。</p><p>　　<strong>我们用mapp[i][j]来表示从i号点<font color="red">直接</font>走到j号点的边弧长度值，如果从i号点不能走到j号点，则该值用INF（一个极大值，表示“无穷大”）表示。这是图论中的“邻接矩阵存储表示法”。</strong>因为较为简单，所以同学们可以记下该方法。</p><p>　　我们根据上面的样例分析，可以得出状态转移方程如下： <spanclass="math display">\[dp[i]=min(dp[from]+mapp[from][i])  \qquad \ (from: mapp[from][i]\ \!=INF)\]</span>　　from号点，为“能直接走到i号点的所有点”（这些点到i号点有一条<strong>或者多条</strong>直接的边弧），通过循环筛选，多次取min值，找到最小值。</p><ol start="4" type="1"><li>循环顺序和边界</li></ol><p>　　递推的核心，是“填数组，即根据已知填写未知”。本题有一个很重要的特点，那就是“所有点的编号都是从图的左侧往右侧进行编号的，所以所有能直接走到i号点的点，其编号值都肯定比i小”。可以看到样例数据的这个邻接矩阵，是一个上三角矩阵（矩阵右下部分为全0）所以要找所有能直接走到i号点的点from，只需要搜[1..i-1]这个范围编号的所有点即可。至于当前点i的循环顺序，只能从左往右填。总结如下：</p><p>　　 i：2 ---&gt; n增序（1号点就不必填了，自己到自己的路径长度值肯定是0了）</p><p>　　from：1 &lt;---&gt; i-1增减序均可（按什么序去比最小值都可以，只要找到了就行）</p><ol start="5" type="1"><li>特例</li></ol><p>　　状态转移方程中并没有出现dp[i-1]这种东西，所以不太直观。仔细思考，可以发现，有点是不需要算的，比如dp[1]，1号点到1号点自己的最短路径长度值，那肯定是0咯！</p><p>　　dp[1]=0;</p><ol start="6" type="1"><li>初始化值</li></ol><p>　　除了特例位置dp[1]上的值之外，dp[2..n]应该给什么初值呢？另外一个数组mapp[][]应该给什么初值呢？</p><ul><li>关于mapp[][]：我们仔细观察样例数据可以发现，如果i号点到j号点不可直达，样例数据是以0来表示两点之间的距离。对于标准的邻接矩阵来说，这是不规范的处理。为了方便和杜绝后患，在录入mapp[][]时，建议最好是把0更改为INF。当然，也可以不处理，但在后续二重dor里对dp[]更新时，一定就要预先筛选剔除掉“不可直达”的情况。鉴于本题在录入邻接矩阵时，已提供了完整的n*n个数据，所以mapp[][]不需要在录入之前做初始化了。</li><li>关于dp[]：从状态转移方程中可以看出，dp[i]的值，需要先找到符合条件（<spanclass="math inline">\(mapp[from][i]\ \!=INF\)</span>）的from点。如果没有找到这样的from点，if语句的判断条件不符合，则dp[i]并不会被修改。换句话说，如果没有任何点能直接走到i号点，那么从1号点走到i号点的最短路径长度值，必然只能是“无穷大”，千万不能赋值为0。</li></ul><p>　　所以：dp[2..n]=INF</p><ol start="7" type="1"><li>关于无穷大（INF）在图论算法中的特别说明</li></ol><p>　　需要注意的是，无穷大“INF”在图论算法中的处理非常重要，不同的图论算法对无穷大的处理是不同的，需要小心处理。否则容易形成坑点，难以拿到全分。详情请见本站专门的帖子，看这里。</p><ol start="8" type="1"><li>输出最短路径</li></ol><p>　　首先需要意识到一点，从一个点到另一个点的最短路径，可能不止一条。从地图上来看，我们从左往右求解从1号点到其他每一个点的最短路径值，在计算或更新每个dp[to]值时，from和to的值都是知道的，只需要同步地记录下from和to之间的这个选择关系即可。</p><p>　　1）该采用什么样的方式来记录路径呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> to=<span class="hljs-number">2</span>; to&lt;=n; to++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> from=<span class="hljs-number">1</span>; from&lt;=to<span class="hljs-number">-1</span>; from++)<br><span class="hljs-keyword">if</span>( dp[to] &gt; dp[from] + mapp[from][to] )&#123; <br>    dp[to] = dp[from] + mapp[from][to];<br>    ？？？？？ <span class="hljs-comment">// 此处该如何记录from和to之间的关系？？？</span><br>&#125;<br></code></pre></td></tr></table></figure><p>　　我们知道每个from都可以指向多个to点，也知道每个to点可以被多个from点指过来。我们可以用pre[to]=from或者nxt[from]=to来记录from和to之间的关系。但在此用nxt[from]=to是错误的！为什么呢？因为上面二重循环的代码是给定一个to值，找出与该to值最符合条件的from值（即找出to点的路径前驱节点）。要记录也应该是记录to点的前驱节点，而不应该记录from点的后继节点，否则会引起数据记录混乱。</p><p>　　举个例子，就拿本题的样例数据来说吧，看4号点的更新过程，它只有1个from点（即1号点）可供筛选，需要更新，dp[4]=1，但若记录为nxt[1]=4，这是错误的。因为实际上的最短路径是1号点走向3号点。那为什么1号点的后继结点会被改为4号点呢？仅仅只是因为4比3大，先更新3号点的dp值，nxt[1]=3，然后更新4号点的dp值。nxt[1]=4，这是绝对谬误的。</p><p>　　<strong>归纳总结</strong>：从左往右更新每个点的dp[]值时，根据当前点选择其正确的前驱节点，那么就应该用pre[to]=from的方式来记录前驱节点信息即可。反过来，如果是从右往左处理每个点，根据当前点选择其正确的后继结点，则应该用nxt[from]=to来记录from的后继结点即可。</p><p>　　<strong>结论</strong>：定义pre[]表示每个节点在最短路径中的上一个（即前驱）节点的编号值。</p><p>　　2）如何输出路径？</p><p>　　需要明白一点，上述的这种方式，只能存一条路径，并不能输出多条最短路径。</p><p>　　对于pre[]数组，要想输出路径很简单，只需要从终点倒推到起点即可。可以采用递归函数来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>( k!=<span class="hljs-number">1</span> )<br><span class="hljs-built_in">find</span>( pre[k] );<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, k);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ac代码">2.1.3 AC代码</h3><p>　　1261题的AC代码如下：</p><p>　　1) “mapp[][]初值不改为INF”的版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span>                                                                 </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;                                                               <span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1010</span><br><span class="hljs-type">int</span> mapp[N][N],n;<br><span class="hljs-comment">// dp[5] = 10: 从出发点到5号点的最短路径值为 10 </span><br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-type">int</span> pre[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>( k!=<span class="hljs-number">1</span> )<br><span class="hljs-built_in">find</span>( pre[k] );<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, k);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-comment">// 因为每条弧都是从编号小的点指向编号大的点，</span><br><span class="hljs-comment">// 所以在邻接矩阵中的值，是一个上三角矩阵(主对角线以下都是0) </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;mapp[i][j]);<br>    <span class="hljs-comment">// 既然是对dp[]进行收缩，求min，所以这里需要先赋初值为INF </span><br><span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br><span class="hljs-comment">// 出发点1到自己的最短路径值 是 0 </span><br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;  <br><span class="hljs-comment">// 因为状态转换方程里是根据dp[]左侧来计算dp[]右侧的值，</span><br><span class="hljs-comment">// 所以from需要从1到n-1循环，to无所谓。 </span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> to=<span class="hljs-number">2</span>; to&lt;=n; to++)          <span class="hljs-comment">// 因为是根据dp左边算dp右边，所以必须是升序 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> from=<span class="hljs-number">1</span>; from&lt;=to<span class="hljs-number">-1</span>; from++)   <span class="hljs-comment">// 正序逆序均可，上三角矩阵，from的范围是[1..to-1]</span><br>            <span class="hljs-keyword">if</span> ( mapp[from][to] != <span class="hljs-number">0</span> )&#123;   <span class="hljs-comment">// 单独先剔除掉“不可直达的边弧”情况 </span><br>            <span class="hljs-comment">// 如果从from到to有弧，并且从出发点到to的距离 大于 从出发点到点from的距离 加上 从点from到点to的弧长值 </span><br>                <span class="hljs-keyword">if</span>( dp[to] &gt; dp[from] + mapp[from][to] )&#123; <span class="hljs-comment">// 本代码中mapp[from][to]没有初始化为INF，所以不会爆int </span><br>                    dp[to] = dp[from] + mapp[from][to];<br>                    <span class="hljs-comment">// 因为是根据左边来计算右边，所以下面只能用pre[to]=left，而不能用next[from]=to; </span><br>                    pre[to] = from;<br>                &#125;<br>            &#125;<br><span class="hljs-comment">// 打印最短路径值 </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;minlong=%d\n&quot;</span>, dp[n]);<br>    <span class="hljs-comment">// 打印路径上各个点 </span><br>    <span class="hljs-built_in">find</span>( n );<br>&#125;<br></code></pre></td></tr></table></figure><p>　　2）“mapp[][]改为INF”的版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span>                                                                 </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f   <span class="hljs-comment">// 可能存在无穷大+无穷大，应定义为0x3f3f3f3f</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1010</span><br><span class="hljs-type">int</span> mapp[N][N],n;<br><span class="hljs-comment">// dp[5] = 10: 从出发点到5号点的最短路径值为 10</span><br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-type">int</span> pre[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>( k!=<span class="hljs-number">1</span> )<br>        <span class="hljs-built_in">find</span>( pre[k] );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, k);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;mapp[i][j]);<br>            <span class="hljs-keyword">if</span> (mapp[i][j] == <span class="hljs-number">0</span>)   <span class="hljs-comment">// 和上一个版本不同的地方</span><br>                mapp[i][j] = INF;<br>        &#125;<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> to=<span class="hljs-number">2</span>; to&lt;=n; to++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> from=<span class="hljs-number">1</span>; from&lt;=to<span class="hljs-number">-1</span>; from++)<br>            <span class="hljs-keyword">if</span>( dp[to] &gt; dp[from] + mapp[from][to] ) &#123; <span class="hljs-comment">// 和上一个版本不同的地方</span><br>                dp[to] = dp[from] + mapp[from][to];<br>                pre[to] = from;<br>            &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;minlong=%d\n&quot;</span>, dp[n]);<br>    <span class="hljs-built_in">find</span>( n );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="挖地雷最长路径">2.2 1262 挖地雷——最长路径</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><h3 id="例9.6挖地雷">　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1262">1262：【例9.6】挖地雷</a></h3><h3 id="分析-1">2.2.2 分析</h3><p>　　模型精简：在一个有向无环图中，点带权，边弧不带权，不规定起点和终点，求该图中带权路径最长的路径长度值及路径经过的点序列。</p><p>　　题目中有一句非常重要的信息：“且保证都是小序号地窖指向大序号地窖”。也就是说，边弧只能从编号小的点指向编号大的点。所以，该图不存在环路。如果以i号点为某一条路径的终点，则这些路径的起点编号必然是小于i号点的。题目中样例数据得出如下图所示：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240507152015118.png"alt="image-20240507152015118" /><figcaption aria-hidden="true">image-20240507152015118</figcaption></figure><p>　　这个题，和1261在某些地方上是相似的，例如它也是需要求路径，也需要锚定一个当前点，然后在当前点的所有“前驱”或者“后继”点中去做选择。但本题并没有规定起点和终点，我们该如何定义状态数组呢？</p><p>　　稍加思考，可以发现，我们可以设定“dp[i]表示以当前点i作为路径起点（或者终点）的最长路径值”，也就是说，有两种方法。事实上，本题用这两种方法都可以解出来。下面分别分析之。两种方法都需要同学们学会掌握，通过本题学会如何在dp中进行正推，或逆推。</p><h4 id="以当前点为路径起点">2.2.2.1以当前点为<font color="red"><strong>路径起点</strong></font></h4><ol type="1"><li>状态数组定义</li></ol><p>　　dp[i]表示从当前点<strong>出发</strong>（含），最多能挖到的地雷个数</p><ol start="2" type="1"><li>所求目标</li></ol><p>　　带权最长路径的终点不一定是n号点，所以有： <spanclass="math display">\[max(dp[i])\quad(1\leq i \leq n)\]</span></p><ol start="3" type="1"><li>状态转移方程</li></ol><p>　　以上图中的5号点为例进行分析：从5号点出发最多能挖到的地雷个数，肯定与以6号点、7号点等右侧的点出发挖到的地雷数密切相关。只要右侧的dp值确定，则dp[5]可以很容易算出。所以有：<span class="math display">\[dp[from]=w[from] + max(dp[to]) \quad(to:mapp[from][to]!=INF)\]</span></p><ol start="4" type="1"><li>循环顺序和边界</li></ol><p>　　from: 1 &lt;---- n 逆序（右侧点的dp值先算，根据右侧填左侧）</p><p>　　to：from + 1 &lt;---&gt; n正序、逆序均可（只要筛完from的所有邻接点就行，什么顺序不重要）</p><ol start="5" type="1"><li>特例</li></ol><p>　　因为from必须从右往左填写，所以dp[n]必须是已知的特定值。根据dp[]的定义，我们可以知道，从n号点出发往右走，是没法走的，后面一个点都没有了。所以该路径只能包含n号点自己。</p><p>　　故有dp[n]=w[n]。</p><ol start="6" type="1"><li>初始化值</li></ol><p>　　本题有dp[]和mapp[][]这两个数组需要考虑初始化的问题。</p><p>　　对于mapp[][]，因为本题是“点带权值且边弧无权值的有向图”，所以mapp[][]只需要填写1/0或者true/false即可。根据样例提供的数据形式，我们可以默认最初mapp[][]为全false/0即可。</p><p>　　对于dp[]，可能很多同学会认为初值应该是0（毕竟很多题中dp[]的初值都是0，写习惯了）。我们仔细看状态转移方程，对于每个from点的dp[]值，当找到合适的to值时，会去取最大值，更新dp[from]。但同学们务必要小心这种状态转移方程的写法，因为它暗含了一个假设前提：你得先能够找到满足条件的to值。那万一不存在或者没找到符合条件的to值呢？（例如from号点在图中是一个<strong>汇点，没有任何边弧从from点出去</strong>，例如n号点就肯定是一个汇点）这种情况下，dp[from]无法被更新，最终结果仍然会是其初值。那这个初值应该是多少呢？当from点为汇点时，从from点出发的路径是没有后续节点的，只有from号地窖的地雷可挖，故dp[1..n]的初值应该就是w[1..n]。</p><p>　　注意，这里的初值设置，正好涵盖了本题对特例的处理。所以就不再单独处理特例了。</p><ol start="7" type="1"><li>路径输出</li></ol><p>　　1）路径如何表示或记录？</p><p>　　因为外层循环变量from是从右往左填写的，而to在其右侧，所以<strong>只能用next[from]=to的方式来记录</strong>，而不能用pre[to]=from来记录。<strong>同学们可以配合着2.1.2节第8点中的分析来学习，体会两种情况下的不同处理方式，归纳总结好。</strong></p><p>　　2）最长路径如何输出？</p><p>　　首先应找到最长路径的起点。鉴于dp[]的基本定义，我们可以先找到max(dp[1..n])，然后从该点位置开始，不断去next，就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> k = startpos;<br><span class="hljs-keyword">while</span> ( next[k] != <span class="hljs-number">0</span> )&#123;  <span class="hljs-comment">// 如果最长路径有下一个节点，就一直输出打印下一个节点，直到没有下一个点（==0）为止</span><br>    k = next[k];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-%d&quot;</span>, k);<br>&#125;<br></code></pre></td></tr></table></figure><p>　　当然，上面的这个代码，也可以通过递归函数来实现。同学们可以自行思考一下。</p><ol start="8" type="1"><li>AC代码</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 模型提炼： 求整个有向图中的最长路径的长度值，不规定起点和终点。</span><br><span class="hljs-comment">// 1262 和P2196是高度类似的题，只是图的输入方式不同，图结点规模不同</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*                             o</span><br><span class="hljs-comment">方法一： 用dp动态规划</span><br><span class="hljs-comment">（1）状态数组定义</span><br><span class="hljs-comment">dp[i]：从第i号点出发，最多能挖到的地雷个数（和方法二含义不同）</span><br><span class="hljs-comment">e.g.   dp[3]=20 表示 从3号点出发最多能挖到20个地雷</span><br><span class="hljs-comment">（2）所求目标</span><br><span class="hljs-comment">       max(dp[i])：   i:[1..n]， 需要找出dp[i]的最大值</span><br><span class="hljs-comment">（3）状态转换方程</span><br><span class="hljs-comment">dp[from] = w[from] + max(dp[to]);</span><br><span class="hljs-comment">（4）循环边界和循环顺序</span><br><span class="hljs-comment">from: [1..n-1]        n-1  --&gt;  1从右往左降序（方程是根据右边决定左边）</span><br><span class="hljs-comment">    to: [from+1..n]      from+1 &lt;--&gt; n增减均可</span><br><span class="hljs-comment">（5）状态初始化值和特例</span><br><span class="hljs-comment">dp[i] = w[i]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   本题两种方法，希望学生都要掌握，并认真体会如果获得pre[]和next[]，编写tonext()来表达和输出一条路径</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 201</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> w[N];         <span class="hljs-comment">// 每个点上具有的地雷，  w[3]=10 表示第3号点上有10个地雷</span><br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-type">int</span> next[N];      <span class="hljs-comment">// 最长路径中，当前点的下一个点编号</span><br><span class="hljs-type">bool</span> mapp[N][N];  <span class="hljs-comment">// 0-1邻接矩阵</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>( <span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i] );<br>        dp[i] = w[i];  <span class="hljs-comment">// 就算一条边都不走，最起码能够获得出发点的地雷个数</span><br>        next[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-keyword">while</span> ( <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), x != <span class="hljs-number">0</span> )<br>        mapp[x][y] = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 如果从点x能到点y，则mapp数组对应元素值标记为true</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> from = n<span class="hljs-number">-1</span>; from &gt;= <span class="hljs-number">1</span> ; from-- )   <span class="hljs-comment">// from的填写顺序是从右往左</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> to = from+<span class="hljs-number">1</span>; to&lt;=n; to++)      <span class="hljs-comment">// to的顺序可正可逆！ </span><br>            <span class="hljs-keyword">if</span> ( mapp[from][to] &amp;&amp; dp[from] &lt; w[from] + dp[to] ) &#123;<br>                dp[from] = w[from] + dp[to];<br>                <span class="hljs-comment">// 因为from是从右往左填写，所以此处敲定的应该是from号点的信息，而不是to号点的信息</span><br>                next[from] = to;   <span class="hljs-comment">// 此处只能用next[]，不能用pre[]来表示 </span><br>            &#125;<br>    <span class="hljs-comment">//找到maxx= max(dp[i])并找出其最长路径起点的下标值startpos</span><br>    <span class="hljs-type">int</span> startpos =<span class="hljs-number">1</span>, maxx = dp[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++ )<br>        <span class="hljs-keyword">if</span> ( dp[i] &gt; maxx )&#123;<br>            maxx = dp[i];<br>            startpos = i;<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, startpos); <span class="hljs-comment">//输出最长路径的第一个点下标值</span><br>    <span class="hljs-type">int</span> k = startpos;<br>    <span class="hljs-keyword">while</span> ( next[k] != <span class="hljs-number">0</span> )&#123;  <span class="hljs-comment">// 如果最长路径有下一个节点，就一直输出打印下一个节点</span><br>        k = next[k];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-%d&quot;</span>, k);<br>    &#125;<br>    <span class="hljs-comment">// 打印路径的权值和</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>, maxx);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="以当前点为终点">2.2.2.2以当前点为<font color="red"><strong>终点</strong></font></h4><ol type="1"><li>状态数组定义</li></ol><p>　　dp[i]表示以当前点<strong>为终点</strong>，最多能挖到的地雷个数</p><ol start="2" type="1"><li>所求目标</li></ol><p>　　最长路径的起点不一定是1号点，所以有： <spanclass="math display">\[max(dp[i])\quad(1\leq i \leq n)\]</span></p><ol start="3" type="1"><li>状态转移方程</li></ol><p>　　以上图中的5号点为例进行分析：从5号点为终点，最多能挖到的地雷个数，肯定与以3号点、4号点等以左侧点结束而挖到的地雷数密切相关。只要左侧的dp值确定，则dp[5]可以很容易算出。所以有：<span class="math display">\[dp[to]=w[to] + max(dp[from]) \quad(from:mapp[from][to]!=INF)\]</span></p><ol start="4" type="1"><li>循环顺序和边界</li></ol><p>　　to: 1 ----&gt; n 正序（左侧点的dp值先算，根据左侧填右侧）</p><p>　　from： 1 &lt;---&gt; to-1正序、逆序均可（只要筛完to的所有逆邻接点就行，什么顺序不重要）</p><ol start="5" type="1"><li>特例</li></ol><p>　　因为to必须从左往右填写，所以dp[1]必须是已知的特定值。根据dp[]的定义，我们可以知道，以1号点结束的路径，其左端肯定是没有节点的。所以该路径只能包含1号点自己。</p><p>　　故有dp[1]=w[1]。</p><ol start="6" type="1"><li>初始化值</li></ol><p>　　初始化方法和2.2.2.1节中的处理是一样的。此处不再赘述。　　</p><ol start="7" type="1"><li>路径输出</li></ol><p>　　1）路径如何表示或记录？</p><p>　　因为外层循环变量to是从左往右填写的，而from在其左侧，所以<strong>只能用pre[to]=from的方式来记录</strong>，而不能用next[from]=to来记录。<strong>同学们可以配合着2.1.2节第8点中的分析来学习，体会两种情况下的不同处理方式，归纳总结好。</strong></p><p>　　2）最长路径如何输出？</p><p>　　鉴于pre[]的定义，所以应找到最长路径的终点。鉴于dp[]的基本定义，我们可以先找到max(dp[1..n])，然后从该点位置开始，不断去pre，就可以了。方法可以采用递归函数来实现。</p><ol start="8" type="1"><li>AC代码</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">方法二： 用dp动态规划，dp[]含义和路径表示及推导的方法一刚好相反</span><br><span class="hljs-comment">（1）状态数组定义</span><br><span class="hljs-comment">dp[i]：从任意点出发到第i号点结束，最多能挖到的地雷个数（和方法一含义不同）</span><br><span class="hljs-comment">e.g.   dp[3]=20 表示从任意点出发到3号点结束，最多能挖到20个地雷</span><br><span class="hljs-comment">（2）所求目标</span><br><span class="hljs-comment">       max(dp[i])：   i:[1..n]， 需要找出dp[i]的最大值</span><br><span class="hljs-comment">（3）状态转换方程</span><br><span class="hljs-comment">dp[to] = w[to] + max(dp[from]);</span><br><span class="hljs-comment">（4）循环边界和循环顺序</span><br><span class="hljs-comment">    to:   [1..n] 1 &lt;--&gt; n必须增序（方程是根据左边决定右边）</span><br><span class="hljs-comment">    from: [1..to-1]        1 &lt;--&gt; to-1    增减均可</span><br><span class="hljs-comment">（5）状态初始化值和特例</span><br><span class="hljs-comment">dp[i] = w[i]</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 201</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> w[N];       <span class="hljs-comment">// 每个点上具有的地雷，  w[3]=10 表示第3号点上有10个地雷</span><br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-type">int</span> pre[N];     <span class="hljs-comment">// 权值和最长的路径中，当前点的上一个点编号</span><br><span class="hljs-type">int</span> next[N];<br><span class="hljs-type">bool</span> mapp[N][N];<br><span class="hljs-comment">// 根据pre[]数组来得到next[]数组的值，以方便后续输出打印</span><br><span class="hljs-comment">// 注意递归函数的写法，本函数中“先递归，后特例”，这是有向路径从尾到头倒序访问的标准做法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tonext</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br><span class="hljs-comment">// 先递归</span><br><span class="hljs-type">int</span> pp = pre[k];<br><span class="hljs-keyword">if</span> ( pp != <span class="hljs-number">0</span> )  <span class="hljs-comment">// 如果最长路径有下一个节点，就一直输出打印下一个节点</span><br><span class="hljs-built_in">tonext</span>( pre[k] );<br><span class="hljs-comment">// 后特例</span><br>next[ pp ] = k; <span class="hljs-comment">//输出最长路径的第一个点下标值</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">1</span>; i&lt;= n; i++) &#123;<br><span class="hljs-built_in">scanf</span>( <span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i] );<br>dp[i] = w[i];  <span class="hljs-comment">// 就算一条边都不走，最起码能够获得出发点的地雷个数</span><br>pre[i] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> x, y;<br><span class="hljs-keyword">while</span> ( <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), x != <span class="hljs-number">0</span> )<br>mapp[x][y] = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 如果从点x能到点y，则mapp数组对应元素值标记为true</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> to=<span class="hljs-number">2</span>; to&lt;=n; to++)    <span class="hljs-comment">// 从1开始也可以，反正是会空转 </span><br><span class="hljs-comment">// 根据不同的from来决定dp[to]的值，决定出pre[to]的值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> from=<span class="hljs-number">1</span>; from&lt;=to<span class="hljs-number">-1</span>; from++) &#123;<br><span class="hljs-comment">// from点必须是指向to点的弧尾点，即mapp[from][to]要==true</span><br><span class="hljs-keyword">if</span>( mapp[from][to] &amp;&amp;  dp[to] &lt; dp[from] + w[to] ) &#123;<br>dp[to] = dp[from] + w[to];<br><span class="hljs-comment">// 既然是根据左侧来决定右侧的值，next[from]=to这样写在此处，</span><br><span class="hljs-comment">// 无法确定出next[from]的最终值，所以next[from]=to这个写法就不正确了！</span><br><span class="hljs-comment">// 此处必须要用pre[]这样写，。后续需要根据pre[]来决定next[]的值！</span><br>pre[to] = from;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//找到maxx= max(dp[i])并找出其最长路径的终点下标值startpos</span><br><span class="hljs-type">int</span> lastpos =<span class="hljs-number">1</span>, maxx = dp[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (  i = <span class="hljs-number">2</span>; i &lt;= n; i++ )<br><span class="hljs-keyword">if</span> ( dp[i] &gt; maxx ) &#123;<br>maxx = dp[i];<br>lastpos = i;<br>&#125;<br>    <span class="hljs-comment">// 根据pre[]计算出next[]的值，以方便输出</span><br><span class="hljs-built_in">tonext</span>(lastpos);<br><span class="hljs-comment">//根据next[]来输出路径</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, next[<span class="hljs-number">0</span>]);<br><span class="hljs-type">int</span> k = next[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">while</span> ( next[k] != <span class="hljs-number">0</span> ) &#123;<br>k = next[k];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-%d&quot;</span>, k);<br>&#125;<br><span class="hljs-comment">// 打印路径的权值和</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d\n&quot;</span>, maxx);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p2196-挖地雷">2.3 P2196 挖地雷</h2><h3 id="原题链接-2">2.3.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P2196">P2196 [NOIP1996提高组] 挖地雷</a></p><h3 id="分析-2">2.3.2 分析</h3><p>　　本题和1262高度相似，只是图的录入方式稍有变化。本题可作为同学们复习巩固1262的一个题，稍等一段时间再来复习，效果会更好。</p><h3 id="ac代码-1">2.3.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 模型提炼： 求整个有向图中的最长路径的长度值，不规定起点和终点。</span><br><span class="hljs-comment">// 1262 和P2196是高度类似的题，只是图的输入方式不同，图结点规模不同</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">方法一： 用dp动态规划</span><br><span class="hljs-comment">（1）状态数组定义</span><br><span class="hljs-comment">dp[i]：从第i号点出发，最多能挖到的地雷个数（和方法二含义不同）</span><br><span class="hljs-comment">e.g.   dp[3]=20 表示 从3号点出发最多能挖到20个地雷</span><br><span class="hljs-comment">（2）所求目标</span><br><span class="hljs-comment">       max(dp[i])：   i:[1..n]， 需要找出dp[i]的最大值</span><br><span class="hljs-comment">（3）状态转换方程</span><br><span class="hljs-comment">dp[from] = w[from] + dp[to];</span><br><span class="hljs-comment">（4）循环边界和循环顺序</span><br><span class="hljs-comment">from: [1..n-1]        n-1  --&gt; 1从右往左降序（方程是根据右边决定左边）</span><br><span class="hljs-comment">   to: [from+1..n] from+1 &lt;--&gt; n增减均可</span><br><span class="hljs-comment">（5）状态初始化值和特例</span><br><span class="hljs-comment">dp[i] = w[i]</span><br><span class="hljs-comment">   本题两种方法，希望学生都要掌握，并认真体会如果获得pre[]和next[]，编写tonext()来表达和输出一条路径</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 201</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> w[N];       <span class="hljs-comment">// 每个点上具有的地雷，  w[3]=10 表示第3号点上有10个地雷</span><br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-type">int</span> next[N];    <span class="hljs-comment">// 权值和最长的路径中，当前点的下一个点编号</span><br><span class="hljs-type">bool</span> mapp[N][N];  <span class="hljs-comment">// 0-1邻接矩阵</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-comment">// 录入原始数据，每个点上的地雷个数（给每个点赋权值）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>( <span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i] );<br>        dp[i] = w[i];  <span class="hljs-comment">// 就算一条边都不走，最起码能够获得出发点的地雷个数</span><br>        next[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-comment">// 录入 弧的关系，根据题意，不用考虑 r &lt; c 的情况</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r=<span class="hljs-number">1</span>; r&lt;=n; r++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c=r+<span class="hljs-number">1</span>; c&lt;=n; c++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>            mapp[r][c] = x;<br>        &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> from = n<span class="hljs-number">-1</span>; from &gt;= <span class="hljs-number">1</span> ; from-- )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> to = from+<span class="hljs-number">1</span>; to&lt;=n; to++)<br>            <span class="hljs-keyword">if</span> ( mapp[from][to] &amp;&amp; dp[from] &lt; w[from] + dp[to] ) &#123;<br>                dp[from] = w[from] + dp[to];<br>                <span class="hljs-comment">// 外层循环变量是from，故此处左侧应该是from </span><br>                next[from] = to;<br>            &#125;<br>    <span class="hljs-comment">//找到maxx= max(dp[i])并找出其最长路径起点的下标值startpos</span><br>    <span class="hljs-type">int</span> startpos =<span class="hljs-number">1</span>, maxx = dp[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++ )<br>        <span class="hljs-keyword">if</span> ( dp[i] &gt; maxx )&#123;<br>            maxx = dp[i];<br>            startpos = i;<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, startpos); <span class="hljs-comment">//输出最长路径的第一个点下标值</span><br>    <span class="hljs-type">int</span> k = startpos;<br>    <span class="hljs-keyword">while</span> ( next[k] != <span class="hljs-number">0</span> )&#123;  <span class="hljs-comment">// 如果最长路径有下一个节点，就一直输出打印下一个节点</span><br>        k = next[k];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>, k);<br>    &#125;<br>    <span class="hljs-comment">// 打印路径的权值和</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>, maxx);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">//#include &lt;cstdio&gt;</span><br><span class="hljs-comment">//#include &lt;cstring&gt;</span><br><span class="hljs-comment">//#include &lt;iostream&gt;</span><br><span class="hljs-comment">//using namespace std;</span><br><span class="hljs-comment">///*</span><br><span class="hljs-comment">//方法二： 用dp动态规划，dp[]含义和路径表示及推导的方法一刚好相反</span><br><span class="hljs-comment">//（1）状态数组定义</span><br><span class="hljs-comment">//dp[i]：从任意点出发到第i号点结束，最多能挖到的地雷个数（和方法一含义不同）</span><br><span class="hljs-comment">//e.g.   dp[3]=20 表示从任意点出发到3号点结束，最多能挖到20个地雷</span><br><span class="hljs-comment">//（2）所求目标</span><br><span class="hljs-comment">//       max(dp[i])：   i:[1..n]， 需要找出dp[i]的最大值</span><br><span class="hljs-comment">//（3）状态转换方程</span><br><span class="hljs-comment">//dp[to] = w[to] + dp[from];</span><br><span class="hljs-comment">//（4）循环边界和循环顺序</span><br><span class="hljs-comment">//   to: [1..n] 1 &lt;--&gt; n必须增序（方程是根据左边决定右边）</span><br><span class="hljs-comment">//from: [1..to-1]    1 &lt;--&gt; to-1增减均可</span><br><span class="hljs-comment">//（5）状态初始化值和特例</span><br><span class="hljs-comment">//dp[i] = w[i]</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//*/</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//#define N 201</span><br><span class="hljs-comment">//#define INF 0x7f7f7f7f</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//int n;</span><br><span class="hljs-comment">//// 每个点上具有的地雷，  w[3]=10 表示第3号点上有10个地雷</span><br><span class="hljs-comment">//int w[N];</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//int dp[N];</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//// 权值和最长的路径中，当前点的上一个点编号</span><br><span class="hljs-comment">//int pre[N];</span><br><span class="hljs-comment">//int next[N];</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//bool mapp[N][N];</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//// 根据pre[]数组来得到next[]数组的值，以方便后续输出打印</span><br><span class="hljs-comment">//// 注意递归函数的写法，本函数中“先递归，后特例”，这是有向路径从尾到头倒序访问的标准做法</span><br><span class="hljs-comment">//void tonext(int k) &#123;</span><br><span class="hljs-comment">//// 先递归</span><br><span class="hljs-comment">//int pp = pre[k];</span><br><span class="hljs-comment">//if ( pp != 0 )  // 如果最长路径有下一个节点，就一直输出打印下一个节点</span><br><span class="hljs-comment">//tonext( pre[k] );</span><br><span class="hljs-comment">//// 后特例</span><br><span class="hljs-comment">//next[ pp ] = k; //输出最长路径的第一个点下标值</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//int main() &#123;</span><br><span class="hljs-comment">//int i;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//scanf(&quot;%d&quot;, &amp;n);</span><br><span class="hljs-comment">//// 录入原始数据，每个点上的地雷个数（给每个点赋权值）</span><br><span class="hljs-comment">//for ( i = 1; i&lt;= n; i++) &#123;</span><br><span class="hljs-comment">//scanf( &quot;%d&quot;, &amp;w[i] );</span><br><span class="hljs-comment">//dp[i] = w[i];  // 就算一条边都不走，最起码能够获得出发点的地雷个数</span><br><span class="hljs-comment">//pre[i] = 0;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//int x;</span><br><span class="hljs-comment">//// 录入 弧的关系，根据题意，不用考虑 r &lt; c 的情况</span><br><span class="hljs-comment">//for (int r=1; r&lt;=n; r++)</span><br><span class="hljs-comment">//for (int c=r+1; c&lt;=n; c++)&#123;</span><br><span class="hljs-comment">//scanf(&quot;%d&quot;, &amp;x);</span><br><span class="hljs-comment">//mapp[r][c] = x;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//for(int to=2; to&lt;=n; to++)</span><br><span class="hljs-comment">//// 根据不同的from来决定dp[to]的值，决定出pre[to]的值</span><br><span class="hljs-comment">//for(int from=1; from&lt;=to-1; from++) &#123;</span><br><span class="hljs-comment">//// from点必须是指向to点的弧尾点，即mapp[from][to]要==true</span><br><span class="hljs-comment">//if( mapp[from][to] &amp;&amp;  dp[to] &lt; dp[from] + w[to] ) &#123;</span><br><span class="hljs-comment">//dp[to] = dp[from] + w[to];</span><br><span class="hljs-comment">//// 既然是根据左侧来决定右侧的值，next[from]=to这样写在此处，</span><br><span class="hljs-comment">//// 无法确定出next[from]的最终值，所以next[from]=to这个写法就不正确了！</span><br><span class="hljs-comment">//// 此处必须要用pre[]这样写，。后续需要根据pre[]来决定next[]的值！</span><br><span class="hljs-comment">//pre[to] = from;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">////找到maxx= max(dp[i])并找出其最长路径的终点下标值startpos</span><br><span class="hljs-comment">//int lastpos =1, maxx = dp[1];</span><br><span class="hljs-comment">//for (  i = 2; i &lt;= n; i++ )</span><br><span class="hljs-comment">//if ( dp[i] &gt; maxx ) &#123;</span><br><span class="hljs-comment">//maxx = dp[i];</span><br><span class="hljs-comment">//lastpos = i;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//    // 根据pre[]计算出next[]的值，以方便输出</span><br><span class="hljs-comment">//tonext(lastpos);</span><br><span class="hljs-comment">////根据next[]来输出路径</span><br><span class="hljs-comment">//printf(&quot;%d&quot;, next[0]);</span><br><span class="hljs-comment">//int k = next[0];</span><br><span class="hljs-comment">//while ( next[k] != 0 ) &#123;</span><br><span class="hljs-comment">//k = next[k];</span><br><span class="hljs-comment">//printf(&quot;-%d&quot;, k);</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//// 打印路径的权值和</span><br><span class="hljs-comment">//printf(&quot;\n%d\n&quot;, maxx);</span><br><span class="hljs-comment">//return 0;</span><br><span class="hljs-comment">//&#125;   </span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 线性DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>普通的01背包问题</title>
      <link href="/2024/05/04/%E6%99%AE%E9%80%9A%E7%9A%8401%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2024/05/04/%E6%99%AE%E9%80%9A%E7%9A%8401%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><p>　　背包问题是动态规划中的一个大类知识点，也是csp的普及组或提高组几乎必考的内容，非常重要。要学习背包问题，<strong>首先需要必须掌握递推、递归，</strong>同时强烈建议也掌握深搜、广搜、贪心、分治等。<strong>背包问题具有较强的模板特性，所以这部分的内容是可以通过多个不同的模板来快速拿下的。</strong>希望同学们务必认真学习每个题型及其变化和拓展。</p><p>　　因为这个大类知识点具有较强的模板性，所以<strong>强烈建议同学们在学习模板时对分析流程（7点步骤）和变量命名规则进行固化，以应对变化各异的应用</strong>。不必理睬题目中五花八门的变量命名，而统一采用一套命名规则来写代码，以方便自己在以后的复习和归纳总结。具体的命名规则请参看本帖以及后面关于背包问题的AC代码的命名规则。</p><h2 id="模型引入和变量命名规则约定">1.1 模型引入和变量命名规则约定</h2><p>　　背包问题主要求解的是<strong>带约束的收益最优化问题</strong>。其所使用的方法主要就是递推填表，用动态规则的方法来解决。而01背包问题则是背包问题的入门题型。</p><p>　　有一个总装量为YS1（约束1，<strong>y</strong>ue<strong>s</strong>hu，取两个字的拼音首字母ys）的背包，有n个可待选择的物品需要装入，每个物品<strong>只有一件</strong>，它们都有各自的重量和价值，你需要从中选择合适的组合来使得你背包中的物品总价值最大（<strong>每个物品不能拆分，且不需要刚好装满，允许不"刚好"装满</strong>）</p><p>　　上面这段就是普通01背包最常见的题面。强烈要求每个同学都按照下面的命名规则来写代码：</p><ul><li>背包一共能装多少斤的物品，在本题中这是总约束（<strong>命名为YS1</strong>，区别于以后的二维费用背包，第二维总约束可以命名为YS2，注意全大写表示总量）。</li><li>第<span class="math inline">\(\ i\ (1 \leq i \leqn)\)</span>个物品的“重量”是约束量，命名为ys1[i]。可能有些同学对这种命名不太适应，但其实在后续题型中可能会出现“每个物品有多个属性都是约束量”，故可能出现ys2[i]、ys3[i]等）。而且物品的重量并不绝对就是约束量，可能在其他题中重量变成是收益。所以，同学们不要固化自己的思维，不要根据物品属性来决定，而必须要根据抽象出来的题型来决定谁是约束、谁是收益。</li><li>第<span class="math inline">\(\ i\ (1 \leq i \leqn)\)</span>个物品的“价值”是收益量，命名为value[i]。</li><li>状态数组命名统一为dp[]或者dp[][]等。</li></ul><h2 id="dp和深搜贪心等的关系分析">1.2 dp和深搜、贪心等的关系分析</h2><p>　　为了方便下面的阐述，我们可以假定一些样例数据来帮我们更方便准确地说明问题。</p><p>　　现在假设背包总容量为YS1=10斤，有n=4个物品，重量ys1[]和价格value[]分别如下：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240510093216861.png" /></p><h3 id="为什么不能用暴力深搜">1.2.1 为什么不能用暴力深搜</h3><p>　　4个物品，每个物品都有“选择”和“不选择”两种结果，故一共有<spanclass="math inline">\(2^4=16\)</span>种结果。如果用暴力深搜的方法把16种结果一一枚举，时间复杂度呈现指数级增长，一旦n较大，即使能够及时剪枝，复杂度仍然很大。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240510134036335.png" alt="image-20240510134036335" style="zoom:60%;" /></p><h3 id="为什么不能用贪心算法">1.2.2 为什么不能用贪心算法</h3><p>　　可能有些同学会认为，对于n个物品，按照性价比进行排序，然后依次选择，直到装不下为止。这就是贪心算法的思路。但实际上这种做法是错误的。性价比并不能完全等价于总价值。</p><p>　　下面举个例子：假设背包容量为10斤，3个物品分别为A：6斤8元，B：5斤5元，C：5斤5元。如果按照性价比来排序，物品A的性价比最高，应该先选择物品A装入背包。然后，就没有然后了，因为剩下4斤容量，装不下任何第二个物品了。这种“装入A”的方案，总价值就为8元。</p><p>　　但如果选择不装A而装B和C，则总价值为5+5=10元。所以最优方案是“装BC”。</p><p>　　那贪心算法的问题出在哪里呢？问题就出在“物品不可分割”。在“装入A”的方案中，当只剩4斤容量时，如果物品可分割，那么大可以把物品B切下4斤来装入，就能达到最大价值8+4=12元。“<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1225">1225：金银岛</a>”就可以用贪心算法破解。但现在因为不可分割，没，为了贪那一点点的性价比，结果让背包空闲浪费了4斤的容量没有装任何物品，从而使得整个方案低效。</p><h2 id="标准状态数组">1.3 标准状态数组</h2><h3 id="六步分析">1.3.1 六步分析</h3><ol type="1"><li><p>状态数组定义</p><p>　　dp[i][j]：代表当背包的总容量为 j 时，前 i个物品选择一部分物品放入后，背包内物品的最大总价值；</p></li><li><p>所求目标</p><p>　　dp[n][YS1]：代表背包的总容量为YS1时，前 n个物品选择一部分物品放入后，背包内物品的最大总价值；</p></li><li><p>状态转移方程</p><p>我们这里暂时假设从1到n，依次考虑每个物品。（有些时候我们必须要逆序来考虑，请参看《求背包问题的具体方案》。初学的同学暂时可以不看）</p><p>对于第i个物品：</p></li></ol><ul><li><p>1）如果背包的总容量j不足以容纳第i个物品，此时“心有余而力不足”，只能被迫放弃第i个物品，价值没有一点增加。所以有：<span class="math display">\[dp[i][j]=dp[i-1][j] \tag{1}\]</span></p></li><li><p>2）如果背包的总容量j能够容纳第i个物品，此时可以有两种选择：“装”或者“不装”第i个物品。此时需要进行比较判断，因为装了当前的第i个物品，不一定能使最后组合达到最大价值。</p><ul><li><p>a)如果<strong>能装但不装</strong>第i个物品，则有:</p><p><span class="math display">\[dp[i][j]=dp[i-1][j] \tag{2}\]</span>　　既然决定不装入第i个物品，那么总价值不会增加，仍然和“前i-1个物品对于总容量j的策略”是一致的。</p></li><li><p>b)如果<strong>能装且装入</strong>第i个物品，则有:</p><p><span class="math display">\[dp[i][j]=dp[i-1][j-ys1[i]]+value[i] \tag{3}\]</span> 　　为什么会有这样的等式呢？</p><p>　　如果已经处理完前i-1个物品，且总容量没有超过j-ys1[i]，其最大总价值为dp[i-1][j-ys1[i]]。在这种情况下，选择装入第i个物品，那么总容量不会超过j-ys1[i]+ys1[i]=j，而总价值为dp[i-1][j-ys1[i]]+value[i]。</p><p>　　我们可以从公式（2）和（3）中选择较大值，来作为情况2）的决策。</p></li></ul></li></ul><p>　　综上情况1）和情况2），则有状态转移方程为： <spanclass="math display">\[dp[i][j]=\begin{cases}dp[i-1][j] &amp; (j&lt;ys1[i]) \\max(\ dp[i-1][j], \quad dp[i-1][j-ys1[i]]\ +\ value[i]\ ) &amp; (j\geqys1[i])\end{cases} \tag{4}\]</span></p><ol start="4" type="1"><li><p>循环顺序和边界</p><ul><li><p>i：1 -----&gt; n 只能增序</p></li><li><p>j：0 <font color ="red"><strong>&lt;-----&gt;</strong> </font>YS1<strong>增序、降序都可以</strong></p><p>　　虽然第j列的数据需要来自于第j-ys1[i]列，但却是上一排的第j-ys1[i]列。所以，只要上一排的数据全部已知，那么对于当前第i排，从左往右填写，或者从右往左填写，都是正确的！</p></li></ul></li><li><p>特例</p><p>　　当i=1时，i-1=0，所以需要把第0行当做特例来处理。当任何物品都还没处理时，总价值肯定是0，故有</p><p>dp[0][0..YS1]=0。</p></li><li><p>初始化值</p><p>　　从转移方程可以看出，dp数组的每个值都来自于以前的dp值或者value数组，会被完整覆盖。所以dp数组可以不初始化。一个简单做法就是“将dp数组定义为全局数组，自动初始化为全0”。这样也能自动搞定特例。</p></li></ol><h3 id="关键代码">1.3.2 关键代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)            <span class="hljs-comment">// 针对每1个物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)   <span class="hljs-comment">// 背包剩余空间j，注意，j的取值范围是[0, YS1]</span><br>     <span class="hljs-comment">//for(int j=YS1; j&gt;=0; --j)   // 正反序，在普通01背包中，都是可以的 </span><br><span class="hljs-comment">// 如果背包剩余空间够放第i个物品， </span><br><span class="hljs-keyword">if</span> ( ys1[i] &lt;= j )<br><span class="hljs-comment">// 需要判断放与不放，到底哪个更划算！ </span><br>dp[i][j]= <span class="hljs-built_in">max</span>( dp[i<span class="hljs-number">-1</span>][j-ys1[i]] + value[i],  dp[i<span class="hljs-number">-1</span>][j]);<br><span class="hljs-keyword">else</span><br><span class="hljs-comment">// 如果背包剩余空间不够放第i个物品，然并卵，肯定就不放进去了哈！上下照抄不变 </span><br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j]; <br></code></pre></td></tr></table></figure><p>　　需要注意一下的就是，内层循环的代码也可以写成如下的形式，是等效的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)&#123;   <span class="hljs-comment">// 背包剩余空间j，注意，j的取值范围是[0, YS1]</span><br>           dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];   <span class="hljs-comment">// 不管三七二十一，先照抄上一行的数据下来</span><br><span class="hljs-keyword">if</span> ( ys1[i] &lt;= j )       <span class="hljs-comment">// 如果背包剩余空间够放第i个物品， </span><br><span class="hljs-comment">// 需要判断放与不放，到底哪个更划算！ 此时赋值式右侧的dp[i][j]值实际上是dp[i-1][j]值</span><br>dp[i][j]= <span class="hljs-built_in">max</span>( dp[i][j], dp[i<span class="hljs-number">-1</span>][j-ys1[i]] + value[i]);<br>      &#125;<br></code></pre></td></tr></table></figure><h3 id="决策输出">1.3.3 决策输出</h3><p>　　我们可以以1267这个题为例来做分析决策。其样例数据对应的dp[][]初始化值如下图所示。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240510162522771.png" /></p><p>　　为了巩固对状态转移方程公式的理解深度，同学们可以自行拿出草稿纸来填写该表的所有数据，模拟程序实现过程，强化理解填表的步骤。其正确答案如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240510163109884.png" alt="image-20240510163109884" style="zoom:80%;" /></p><p>　　从这张表中我们可以看出，dp[4][10]=12元，是本样例的答案。但如果我想知道到底选择了哪些物品？该如何解决这个问题呢？</p><p>　　其实标准状态数组已经给我们暗示出了所有的决策。</p><ol type="1"><li>dp[4][10]=12元 !=9元=dp[3][10]，所以必然是因为选择了物品4。因为物品4重7斤，所以从当前的10斤扣除物品4的7斤，还剩3斤，找到dp[3][3]。</li><li>因为dp[3][3]=3=dp[2][3]，上下格子的值相等，这说明没有选择第3个物品。</li><li>因为dp[2][3]=3!=1=dp[1][3]，上下格子的值不相等，这说明选择了第2个物品。因为物品2重3斤，所以从当前的3斤扣除物品2的3斤，还剩0斤，找到dp[1][0]。</li><li>因为dp[1][0]=0=dp[0][0]，上下格子的值相等，这说明没有选择第1个物品。</li></ol><p>　　结论：选择了第2、4个物品，总重量10斤，总价值12元。</p><ul><li><p>如果从当前行往 <font color ="red"><strong>上</strong></font>走，说明<font color ="red"><strong>不选</strong></font>当前行的物品；</p></li><li><p>如果从当前行往 <font color ="green"><strong>左上</strong></font>走，说明 <font color ="green"><strong>选</strong></font>当前行的物品。</p></li></ul><h3 id="复杂度分析">1.3.4 复杂度分析</h3><p>　　上述的标准状态数组的AC代码，影响程序时间复杂度的关键在于那个二重for，复杂度为<spanclass="math inline">\(O(n*YS1)\)</span>，空间复杂度为状态数组的容量，也是<spanclass="math inline">\(O(n*YS1)\)</span>。</p><h2 id="滚动数组压缩数组">1.4 滚动数组/压缩数组</h2><p>　　从1.3.4节可以看到，标准状态数组的解法需要空间复杂度为<spanclass="math inline">\(O(n*YS1)\)</span>。当YS1较大时，可能会造成整个程序MLE。我们在本节提出“滚动状态数组”（有的地方也叫做“压缩状态数组”）的概念，并对空间复杂度进行优化，而时间复杂度不变。</p><p>　　从1.3.3节中的图上可以看到，表里大部分的内容都是上下照抄，并没有发生值的改变，这表示存在空间精简压缩的可能性。仔细观察上一节的填表过程，我们填写每一个网格（第i行，第j列）的数据时，都只依赖于第i-1行的数据，而不需要访问第i-2行、i-3行等。为了更直观的理解，下面再画一张图，并以i=3为例，详细展示一维数组的更新细节：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240511112403158.png" style="zoom:150%;" /></p><p>　　在填写一趟一维数组时，需要从右往左更新每个格子的数据。因为更新需要读取当前位置左侧的旧数据来进行比对，此时旧数据尚未被更新，仍然存储的是“上一行”的数据，所以这种更新是没有问题的。只是需要注意，这里必须只能“从右往左”更新每个格子！</p><p>因此，我们可以将求解空间进行优化，将二维数组压缩成一维数组。</p><h3 id="六步分析-1">1.4.1 六步分析</h3><ol type="1"><li><p>状态数组定义</p><p>　　dp[j]：代表当背包的总容量为 j时，前若干个物品选择一部分物品放入后，背包内物品的最大总价值；</p></li><li><p>所求目标</p><p>　　dp[YS1]：代表背包的总容量为YS1时，前若干个物品选择一部分物品放入后，背包内物品的最大总价值；</p></li><li><p>状态转移方程</p><p>对于第i个物品：</p></li></ol><ul><li>原有的状态转移方程为：</li></ul><p><span class="math display">\[dp[i][j]=\begin{cases}dp[i-1][j] &amp; (j&lt;ys1[i]) \\max(\ dp[i-1][j], \quad dp[i-1][j-ys1[i]]\ +\ value[i]\ ) &amp; (j\geqys1[i])\end{cases} \tag{1}\]</span></p><ul><li>经过滚动状态数组设计后的状态转移方程为：</li></ul><p><span class="math display">\[\begin{align*}dp[j]&amp;=\begin{cases}dp[j] &amp; (j&lt;ys1[i]) \\max(\ dp[j], \quad dp[j-ys1[i]]\ +\ value[i]\ ) &amp; (j\geq ys1[i])\end{cases} \tag{2}\\\end{align*}\]</span></p><ol start="4" type="1"><li><p>循环顺序和边界</p><ul><li><p>i： 1 -----&gt; n 只能增序</p></li><li><p>j： ys1[i] <font color ="red"><strong>&lt;-----</strong></font>YS1 <strong>只能降序</strong></p><ul><li><p>1）为什么必须降序？</p><p>　　dp[j]的更新需要读取dp[j-ys1[i]]，但要求dp[j-ys1[i]]必须是旧数据（因为（1）式中是<spanclass="math inline">\(dp[i-1][j-ys1[i]]\)</span>，是第i-1行的，是旧数据）。所以dp[j]必须比dp[j-ys1[i]]先更新，即必须从右往左更新。</p></li><li><p>2）从右往左，只需要到ys1[i]就可以了。为什么不能到0呢？</p><p>　　原因很简单，因为当j在[0..ys1[i]-1]这个范围内时，根据公式（2）有dp[j]=dp[j]。这实际上是一句废话，意思就是“什么都不需要做”。既然什么都不做，那干嘛还循环这个范围？所以只需要循环到ys1[i]就行了。</p><p>　　从另一个角度来思考，在公式（2）中的dp[j-ys1[i]]，当j&lt;ys1[i]时，j-ys1[i]&lt;0，这下标怎么能小于0？那还不乱套，爆一个RE？</p></li></ul></li></ul></li><li><p>特例</p><p>　　dp[0]=0</p></li><li><p>初始化值</p><p>　　在标准状态数组中的特例是dp[0][0..YS1]=0，所以在滚动状态数组结构下的特例应该是dp[0..YS1]=0。</p></li></ol><h3 id="关键代码-1">1.4.2 关键代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)  <span class="hljs-comment">// 针对每1个物品</span><br>    <span class="hljs-comment">// 这里j应该从右往左推，千万要注意！！注意是&gt;=ys1[i]截止，因为下标[j-ys1[i]]不可能为负数！</span><br>    <span class="hljs-comment">// 对于那些小于ys1[i]的j，在这里就不去处理（默认等于前值）了，也就是说，等效于dp[i][j] = dp[i-1][j]了！</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)<br>        <span class="hljs-comment">// 需要判断放与不放，到底哪个更划算！</span><br>        dp[j] = <span class="hljs-built_in">max</span>( dp[j - ys1[i]] + value[i],  dp[j]);<br></code></pre></td></tr></table></figure><p>　　需要注意一下的就是，第17～19行代码也可以写成如下的形式，是等效的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)  <span class="hljs-comment">// 针对每1个物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)<br><span class="hljs-keyword">if</span> (j &gt;= ys1[i])<br>            dp[j] = <span class="hljs-built_in">max</span>( dp[j - ys1[i]] + value[i],  dp[j]);<br></code></pre></td></tr></table></figure><h3 id="决策输出-1">1.4.3 决策输出</h3><p>　　以1267这个题为例来看，其标准状态数组的值如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240510163109884.png" alt="image-20240510163109884" style="zoom:80%;" /></p><p>　　如果改为滚动数组后，只剩最底层一排的数值，无法找其他排数据，自然也无法找到决策。　　</p><h3 id="复杂度分析-1">1.4.4 复杂度分析</h3><p>　　影响程序时间复杂度的关键在于那个二重for，复杂度为<spanclass="math inline">\(O(n*YS1)\)</span>，空间复杂度为<spanclass="math inline">\(O(YS1)\)</span>。</p><h2 id="其他重要资料学习">1.5 其他重要资料学习</h2><p>　　如果对上述资料学习之后，还觉得不够尽兴的，可以看下面的资料。</p><h3 id="视频链接">1.5.1 视频链接</h3><p>　　<ahref="https://www.bilibili.com/video/BV1kp4y1e794/?spm_id_from=333.999.0.0&amp;vd_source=0e7cc4e4bbbb67e5c3c2a3e7d967f075">E08【模板】背包DP01背包</a></p><h3 id="背包九讲">1.5.2 背包九讲</h3><p>　　非常经典牛逼的“背包九讲”，请看<a href="https://www.kancloud.cn/kancloud/pack/70124" target="_blank">这里</a>。</p><h1 id="二实战训练">二、实战训练</h1><h2 id="背包问题">2.1 1267 01背包问题</h2><h3 id="原题链接">2.1.1 原题链接</h3><h3 id="例9.1101背包问题">　　<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1267">1267：【例9.11】01背包问题</a></h3><h3 id="ac代码">2.1.2 AC代码</h3><h4 id="标准状态数组版本">2.1.2.1 标准状态数组版本</h4><p>　　时间复杂度：<spanclass="math inline">\(O(n*YS1)=30*200=6000\)</span></p><p>　　空间复杂度：<spanclass="math inline">\(O(n*YS1)=30*200=6000\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 0-1背包模型， 二维dp[][]， 的解法！</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 31</span><br><span class="hljs-comment">// dp[5][100] = 50  前5个物品装在背包容量为100斤的背包中的最大价值为50元</span><br><span class="hljs-type">int</span> dp[N][<span class="hljs-number">201</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i, YS1, n;<br>    <span class="hljs-type">int</span> ys1[N], value[N];<br>    <span class="hljs-comment">// 输入背包总重量YS1限制，及提供的物品总个数n</span><br>    cin &gt;&gt;YS1 &gt;&gt;n;<br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        cin &gt;&gt;ys1[i] &gt;&gt;value[i];<br><br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)            <span class="hljs-comment">// 针对每1个物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)   <span class="hljs-comment">// 背包剩余空间j，注意，j的取值范围是[0, YS1]</span><br>            <span class="hljs-comment">//for(int j=YS1; j&gt;=0; --j)   // 正反序，在标准状态数组中，都是可以的</span><br>            <span class="hljs-keyword">if</span> ( ys1[i] &lt;= j )<br>                dp[i][j]= <span class="hljs-built_in">max</span>( dp[i<span class="hljs-number">-1</span>][j-ys1[i]] + value[i],  dp[i<span class="hljs-number">-1</span>][j]);<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 如果背包剩余空间不够放第i个物品，然并卵，肯定就不放进去了哈！上下照抄不变</span><br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br><br>    cout &lt;&lt;dp[n][YS1];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="滚动状态数组版本">2.1.2.2<font color="red">滚动</font>状态数组版本</h4><p>　　时间复杂度：<spanclass="math inline">\(O(n*YS1)=30*200=6000\)</span></p><p>　　空间复杂度：<span class="math inline">\(O(YS1)=200\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//0-1背包，一维dp[] 的解法</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 31</span><br><span class="hljs-type">int</span> YS1, n;<br><span class="hljs-type">int</span> ys1[N], value[N];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">201</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 输入背包总重量YS1限制，及提供的物品总个数n</span><br>    cin &gt;&gt;YS1 &gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        cin &gt;&gt;ys1[i] &gt;&gt;value[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)  <span class="hljs-comment">// 针对每1个物品</span><br>        <span class="hljs-comment">// 这里j应该从右往左推，千万要注意！！注意是&gt;=ys1[i]截止，因为下标[j-ys1[i]]不可能为负数！</span><br>        <span class="hljs-comment">// 对于那些小于ys1[i]的j，在这里就不去处理（默认等于前值）了，也就是说，等效于dp[i][j] = dp[i-1][j]了！</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[i]; j--)<br>            <span class="hljs-comment">// 需要判断放与不放，到底哪个更划算！</span><br>            dp[j] = <span class="hljs-built_in">max</span>( dp[j - ys1[i]] + value[i],  dp[j]);<br><br>    cout &lt;&lt;dp[YS1];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p1048-采药">2.2 P1048 采药</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　下面两个题，基本上完全一样。</p><ul><li><h3 id="p1048-noip2005-普及组-采药">　　<ahref="https://www.luogu.com.cn/problem/P1048">P1048 [NOIP2005 普及组]采药</a></h3></li><li><a href="https://www.luogu.com.cn/problem/P2871">P2871 [USACO07DEC]Charm Bracelet S</a></li></ul><h3 id="ac代码-1">2.2.2 AC代码</h3><h4 id="标准状态数组版本-1">2.2.2.1 标准状态数组版本</h4><p>　　时间复杂度：<spanclass="math inline">\(O(n*YS1)=100*1000=1e5\)</span></p><p>　　空间复杂度：<spanclass="math inline">\(O(n*YS1)=100*1000=1e5\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 101</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T 1001</span><br><span class="hljs-type">int</span> dp[N][T]; <br><span class="hljs-type">int</span> n, YS1;<br><span class="hljs-type">int</span> ys1[N], value[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;YS1, &amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;ys1[i], &amp;value[i]);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;= YS1; j++)<br><span class="hljs-comment">//for(int j=YS1; j&gt;= 0; j--)   // 逆序在标准状态数组结构中也是可以的 </span><br><span class="hljs-keyword">if</span> (ys1[i] &lt;= j)<br>dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i<span class="hljs-number">-1</span>][j-ys1[i]] + value[i]);<br><span class="hljs-keyword">else</span><br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dp[n][YS1]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="滚动状态数组版本-1">2.2.2.2 滚动状态数组版本</h4><p>　　时间复杂度：<spanclass="math inline">\(O(n*YS1)=100*1000=1e5\)</span></p><p>　　空间复杂度：<span class="math inline">\(O(YS1)=1000\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 法2，滚动状态</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 101</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T 1001</span><br><span class="hljs-type">int</span> dp[T]; <br><span class="hljs-type">int</span> n, YS1;<br><span class="hljs-type">int</span> ys1[N], value[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;YS1, &amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;ys1[i], &amp;value[i]);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;= ys1[i]; j--)   <span class="hljs-comment">// 逆序在标准状态数组结构中也是可以的 </span><br>dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-ys1[i]] + value[i]);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dp[YS1]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 背包问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和 二维前缀和</title>
      <link href="/2024/01/03/%E5%89%8D%E7%BC%80%E5%92%8C%20%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>/2024/01/03/%E5%89%8D%E7%BC%80%E5%92%8C%20%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><p>视频教学链接：<ahref="https://www.bilibili.com/video/BV1ja4y1F7Fk/?_blank&amp;vd_source=0e7cc4e4bbbb67e5c3c2a3e7d967f075">前缀和二维前缀和</a></p><h1 id="二实战训练">二、实战训练</h1><h2 id="luogu-p8218-b3612深进1.例1求区间和">2.1 Luogu P8218/B3612【深进1.例1】求区间和</h2><h3 id="原题链接">2.1.1 原题链接</h3><p><a href="https://www.luogu.com.cn/problem/P8218">Luogu P8218/B3612【深进1.例1】求区间和</a></p><p>这两个题是完全相同的内容和要求，合并在一起讲解。这个题是“前缀和”的入门模板题，裸求一维前缀和。</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230704111737035-889544091.png" style="zoom: 67%;" /></p><h3 id="分析">2.1.2 分析</h3><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230704111737059-1374681507.png" style="zoom:80%;" /></p><h3 id="ac代码">2.1.3 AC代码</h3><p>下面展现B3612的AC代码。快读版本的代码可看P8218的AC代码，就不在此处展现了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[<span class="hljs-number">100005</span>],s[<span class="hljs-number">100005</span>];   <span class="hljs-comment">// 大量录入和输出，可以上快读、快写</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>        s[i]=s[i<span class="hljs-number">-1</span>]+a[i];  <span class="hljs-comment">// 此处也可以直接a[i] += a[i-1]，一数组两用，不需要s[]</span><br>    &#125;<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++) &#123;<br>        <span class="hljs-type">int</span> l,r;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="hljs-number">-1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与本题比较类型的还有<ahref="https://www.luogu.com.cn/problem/P10233">P10233 [yLCPC2024] A. dx分计算</a>，可以试试。</p><h2 id="p1115-最大子段和">2.2 <span id="jump1">P1115最大子段和</span></h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p><a href="https://www.luogu.com.cn/problem/P1115">P1115最大子段和</a></p><h3 id="分析-1">2.2.2 分析</h3><p>这个题是对前缀和的一个小变化。如果强行去暴力枚举每个区间的左右两个端点来求和，复杂度为<spanclass="math inline">\(O(n^2)=4e10\)</span>，铁定会TLE。我们可以换一个思路：如果左侧多个数的“累加和”对sum增加没有贡献，甚至变成累赘，那不如放弃而从当前数重新开始。这是一种贪心的思维，时间复杂度是<spanclass="math inline">\(O(n)\)</span>的。</p><h3 id="ac代码-1">2.2.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">这个题，一边累加sum，同时一边判断sum的正负，从而丢弃sum。这个sum实际上也算是</span><br><span class="hljs-comment">    一种前缀和，但没有用专门的数组来存储。这种思想可以琢磨琢磨。</span><br><span class="hljs-comment">复杂度O(n) </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-type">int</span> a[<span class="hljs-number">200001</span>];   <span class="hljs-comment">// 本题其实可以不使用这个数组也能AC </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> i,n,maxsum=<span class="hljs-number">-2e10</span>,sum=<span class="hljs-number">0</span>;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>cin&gt;&gt;a[i];<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-comment">// 不管当前的a[i]是正或者是负，都应该根据sum来做区别处理 </span><br><span class="hljs-comment">// 如果sum加前已为负数，那应放弃之前sum的积累，从当前数开始（不管当前数的正负） </span><br><span class="hljs-keyword">if</span>(sum&gt;<span class="hljs-number">0</span>)<br>sum+=a[i];<br><span class="hljs-keyword">else</span><br>sum=a[i];  <span class="hljs-comment">// 当前数应至少为sum </span><br><br><span class="hljs-keyword">if</span>(maxsum&lt;=sum)<br>maxsum=sum;<br>&#125;<br>cout&lt;&lt;maxsum;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">//// 如果数据全为负数，也应该得到-20，而不是-100000 </span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">-200 -20 -150 -100 -120</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="后记">2.2.4 后记</h3><p>1）这个题，我们要去找一个最大的子段和，但是我们并没有去暴力枚举区间的左端和右端，否则时间复杂度肯定是<spanclass="math inline">\(O(n^2)\)</span>。采用前缀和的思想，一旦发现sum&lt;=0，立刻丢弃累赘重新开始。用这种思想可以解决“不限宽度的区间最大和值”的问题。</p><p>2）如果我们不仅要求出最大的子段和，还要求这个区间的左右端点的下标值，那该怎么做呢？其实也简单，在新开辟一个“累加和”区间时，用le记录其下标i值，表示为区间的起始左端点。当刷新maxsum的同时也记录保存maxle的值为le值即可。展示代码如下：（完整代码见“P1115强化.cpp”）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> le, maxle=<span class="hljs-number">0</span>;  <br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>, le=<span class="hljs-number">0</span>; i&lt;=n; i++) &#123;<br>    <span class="hljs-keyword">if</span>(sum&gt;<span class="hljs-number">0</span>)            <span class="hljs-comment">// 如果当前数的左侧的数据之和是正的 </span><br>        sum+=a[i];       <span class="hljs-comment">// 那就累加当前，此刻暂时不管加起来是正或负（加后为负的情况在下一个数时做处理） </span><br>    <span class="hljs-keyword">else</span><br>        sum=a[i], le=i;  <span class="hljs-comment">// 如果左侧的数之和已为负数，是累赘，丢弃，从当前数重新开始累加 </span><br><br>    <span class="hljs-keyword">if</span>(maxsum&lt;=sum)      <span class="hljs-comment">// 刷新最大值的操作，应独立出来单独处理 </span><br>        maxsum=sum, maxle=le;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i=%-4d, sum=%-4d, le=%-4d, maxsum=%-4d, maxle=%-4d\n&quot;</span>, i, sum, le, maxsum, maxle);<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;le=%a, maxsum=%a&quot;</span>, maxle, maxsum);<br></code></pre></td></tr></table></figure><p>其运行结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs text">16<br>-20 15 10 -5 -20 5 15 10 -30 10 -5 10 30 -20 5 -1000<br>i=1   , sum=-20 , le=1   , maxsum=0   , maxle=0<br>i=2   , sum=15  , le=1   , maxsum=15  , maxle=1<br>i=3   , sum=25  , le=1   , maxsum=25  , maxle=1<br>i=4   , sum=20  , le=1   , maxsum=25  , maxle=1<br>i=5   , sum=0   , le=5   , maxsum=25  , maxle=1<br>i=6   , sum=5   , le=5   , maxsum=25  , maxle=1<br>i=7   , sum=20  , le=5   , maxsum=25  , maxle=1<br>i=8   , sum=30  , le=5   , maxsum=30  , maxle=5<br>i=9   , sum=0   , le=9   , maxsum=30  , maxle=5<br>i=10  , sum=10  , le=9   , maxsum=30  , maxle=5<br>i=11  , sum=5   , le=9   , maxsum=30  , maxle=5<br>i=12  , sum=15  , le=9   , maxsum=30  , maxle=5<br>i=13  , sum=45  , le=9   , maxsum=45  , maxle=9<br>i=14  , sum=25  , le=9   , maxsum=45  , maxle=9<br>i=15  , sum=30  , le=9   , maxsum=45  , maxle=9<br>i=16  , sum=-970, le=16  , maxsum=45  , maxle=9<br>le=9, maxsum=45<br></code></pre></td></tr></table></figure><h2 id="luogu-p2280-hnoi2003-激光炸弹">2.3 Luogu P2280 [HNOI2003]激光炸弹</h2><h3 id="原题链接-2">2.3.1 原题链接</h3><p>[Luogu P2280 <ahref="https://www.luogu.com.cn/problem/P2280">HNOI2003] 激光炸弹</a></p><p><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230704111737118-1986573874.png" /></p><h3 id="分析-2">2.3.2 分析</h3><p>这个题实际上就是要<strong>计算网格内<spanclass="math inline">\(m*m\)</span>的诸多正方形中，哪一个正方形内框住的数据之和值最大？</strong>需要频繁地计算某个大小区域范围内的数据之和，起点不同。采用二维前缀和的思路来做最方便：</p><p>1）首先需要先求出s[1..5001][1..5001]。s[i][j]表示长方形[1..i][1..j]范围内的数据之和值，即二维前缀和。这里需要注意，前缀和数组最好是从下标1开始存储数据，<strong>把0行和0列空出来并置为0，以方便后续的运算</strong>。递推方程式中0行及0列的数据都是0，才能正确做二维递推。</p><p>2）求出二维前缀和数组之后，当需要查询二维区间和值时，因为每个二维区间都是<spanclass="math inline">\(m *m\)</span>的正方形，其右下角方格的坐标应该在[m..R][m..C]范围内，所以只需要在这个范围<spanclass="math inline">\(O((R-m)*(C-m))\)</span>内以<spanclass="math inline">\(O(4)^{\textcolor[RGB]{225,0,0}{[*]}}\)</span>的代价就能求出其二维区间和值，找出其最大值。得解。</p><p>3）"二维前缀和"的递推方程式，以及"二维区间和"的求解方程式请见下图。</p><p>4）关于高维前缀和的求法，请见本页底部的拓展介绍。</p><p><strong><spanclass="math inline">\(\textcolor[RGB]{225,0,0}{[*]}\)</span>：此处的公式是一个变长的公式，其加减项的个数随着维数d的变化而呈现指数级的变化。因为本题是二维，所以此处复杂度都是<spanclass="math inline">\(O(4)\)</span>，近似等于<spanclass="math inline">\(O(1)\)</span>，忽略不计。但如果是d维(d&gt;=3)的前缀和，按容斥原理的这种写法计算，公式会有<spanclass="math inline">\(2^d\)</span>个加减项，所以此处的复杂度为<spanclass="math inline">\(O(2^d)\)</span>，不容忽视。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1973969-20230704111737007-1486719667.png" style="zoom: 67%;" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1961668-20231208155117693-539585701.png" /></p><h3 id="p2280-ac代码">2.3.3 P2280 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*    用二维前缀和来求解二维区间和的模板题   */</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5005</span>;<br><span class="hljs-type">int</span> R,C;          <span class="hljs-comment">// R个目标, 边长为C的正方形</span><br><span class="hljs-type">int</span> s[N][N];      <span class="hljs-comment">// 价值前缀和</span><br><span class="hljs-comment">// 因为空间较为紧张，这里只用了一个数组，计算出前缀和之后，原数组直接被覆盖</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin&gt;&gt;R&gt;&gt;C;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;R; i++) &#123;<br>        <span class="hljs-type">int</span> x,y,v;<br>        cin&gt;&gt;x&gt;&gt;y&gt;&gt;v;<br>        x++,y++; <span class="hljs-comment">//先加1再存值，即基本数据从1行或1列开始存储，把0行和0列空出来以方便递推</span><br>        s[x][y]+=v;<br>    &#125;<br>    <span class="hljs-comment">// 求二维前缀和，方法一</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5001</span>; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=<span class="hljs-number">5001</span>; j++)<br>            s[i][j]+=s[i<span class="hljs-number">-1</span>][j]+s[i][j<span class="hljs-number">-1</span>]-s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br><span class="hljs-comment">//    // 方法二</span><br><span class="hljs-comment">//    for (int i = 1; i &lt;= N; i ++)</span><br><span class="hljs-comment">//        for (int j = 1; j &lt;= N; j ++) s[i][j] += s[i][j - 1];</span><br><span class="hljs-comment">//    for (int j = 1; j &lt;= N; j ++)</span><br><span class="hljs-comment">//        for (int i = 1; i &lt;= N; i ++) s[i][j] += s[i - 1][j];</span><br><br>    <span class="hljs-comment">// 查询二维区间和</span><br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C; i&lt;=<span class="hljs-number">5001</span>; i++)   <span class="hljs-comment">// 从C出发，因为C*C的正方形的右下角坐标至少应该是[C][C]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=C; j&lt;=<span class="hljs-number">5001</span>; j++)<br>            res=<span class="hljs-built_in">max</span>(res,s[i][j]-s[i-C][j]-s[i][j-C]+s[i-C][j-C]);<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p1719-1224-最大加权矩形最大子矩阵">2.4 P1719 /1224最大加权矩形(最大子矩阵)</h2><h3 id="原题链接-3">2.4.1 原题链接</h3><p><a href="https://www.luogu.com.cn/problem/P1719">P1719最大加权矩形</a> / <ahref="https://ybt.ssoier.cn/problem_show.php?pid=1224">1224最大子矩阵</a></p><h3 id="分析-3">2.4.2 分析</h3><p>这个题与2.3节的P2280最大的不同，就是P2280中规定了子矩阵的形状必定是<spanclass="math inline">\(m*m\)</span>的，而本题中并没有规定子矩阵的形状，需要自行去枚举和比较。而如果对一个子矩阵的两个端点(左上角坐标、右下角坐标)进行暴力枚举的话，因为n=120，所以其复杂度会达到<spanclass="math inline">\(O(n^4)=1e8\)</span>，将会TLE了，不能采用四重循环来解决。但如果我们能把<spanclass="math inline">\(n^4\)</span>降为<spanclass="math inline">\(n^3\)</span>，就没问题了。如何降低一维呢？</p><p>还记得我们曾经做过的"<a href="#jump1">P1115求最大子段和</a>"这个题吗？我们在一维数组中去寻找一个区间（区间宽度未知），并没有强行去枚举区间的左右端点，而是采用了一种<spanclass="math inline">\(O(n)\)</span>的算法来降维搞定，核心思想就是“贪心”（若左侧多个数据的前缀和已成累赘，丢弃之，从当前数据重新开始累加）！</p><p>我们能否把这种思想用在本题中呢？当然是可以的！但需要改良，如下图所示。我们可以对左右两端的列号le和ri进行枚举（<spanclass="math inline">\(O(C^2)\RightarrowO(n^2)\)</span>），但不枚举上端和下端的行号，而是从1到R枚举当前行号i。事先准备好矩阵每一行的前缀和数组，可以在<spanclass="math inline">\(O(1)\)</span>的范围内(sum[i][ri]-sum[i][le-1])算出每一行从data[i][le..ri]的数据之和。这样的话，就可以把一个二维的问题变成竖向的一维数据（每个长方形代表了一个数）的“求最大累加和”问题，和P1115很相似了。从上往下累加sum。一旦发现sum&lt;=0，则直接放弃上面的累加，从当前行开始重新累加。这个操作是<spanclass="math inline">\(O(R)\RightarrowO(n)\)</span>的，所以，整个算法的复杂度就是<spanclass="math inline">\(O(n^2*n=O(n^3))\)</span>，从而实现降维，搞定！</p><p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240320105148242.png" style="zoom:50%" /></p><h3 id="ac代码-2">2.4.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 121</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f </span><br><span class="hljs-comment">// sum[i][j]：第i行元素的前缀和，即第i行前j个元素的和，行列都是从1开始编号</span><br><span class="hljs-comment">// sum[i][j] = 90 表示 第i行从左往右前j个元素之和等于90  </span><br><span class="hljs-type">int</span> sum[N][N], data[N][N];<br><span class="hljs-type">int</span> ans = -INF, sum, n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)<br>        &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data[i][j]);<br>        <span class="hljs-comment">// data[][]的行前缀和，注意！sum[][]并非二维前缀和！ </span><br>        sum[i][j] = sum[i][j<span class="hljs-number">-1</span>] + data[i][j];<br>&#125;<br>    <span class="hljs-comment">// 穷举子矩阵，从le列到ri列，逐行累加求子矩阵元素总和sum，</span><br><span class="hljs-comment">// 一旦sum为负，立刻清零并从下一行重新开始    </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> le=<span class="hljs-number">1</span>; le&lt;=n; le++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ri=le; ri&lt;=n; ri++) <span class="hljs-comment">// ri可以和le重叠 </span><br>    &#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;            <span class="hljs-comment">// 每次从上往下求和之前，sum都需要重新归零 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> row=<span class="hljs-number">1</span>; row&lt;=n; row++)<br>            &#123;<br>sum += sum[row][ri] - sum[row][le<span class="hljs-number">-1</span>];  <span class="hljs-comment">// O(1)的代价得到data[row][le..ri]的和值 </span><br>          ans = <span class="hljs-built_in">max</span>(sum, ans); <span class="hljs-comment">// ans记录sum曾经出现过的最大值 </span><br>            sum = <span class="hljs-built_in">max</span>(sum, <span class="hljs-number">0</span>);   <span class="hljs-comment">// 如果累加和为负数，直接放弃，sum重新归0 </span><br>    &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一本通的<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1224">1224</a>、<ahref="http://ybt.ssoier.cn:8088/problem_show.php?pid=1282">1282</a>，和本题完全一模一样，可作为巩固练习。</p><h2 id="luogu-p1387-最大正方形">2.5 Luogu P1387 最大正方形</h2><h3 id="原题链接-4">2.5.1 原题链接</h3><p><a href="https://www.luogu.com.cn/problem/P1387">Luogu P1387最大正方形</a></p><h3 id="基本题意">2.5.2 基本题意</h3><p>在一个 <span class="math inline">\(n*m\)</span> 的只包含 0 和 1的矩阵里找出一个不包含0(只包含1)的最大正方形，输出其边长。</p><h3 id="分析-4">2.5.3 分析</h3><p>这个题，其实和“前缀和”的关系不大，可以运用递推的思维来解决。搞定<spanclass="math inline">\(f[1][1..C]\)</span>和<spanclass="math inline">\(f[1..R][1]\)</span>，然后看<spanclass="math inline">\(f[i][j]\)</span>和之前的<spanclass="math inline">\(f[i-1][j]\)</span>、<spanclass="math inline">\(f[i-1][j-1]\)</span>、<spanclass="math inline">\(f[i][j-1]\)</span>等有什么关联，从而进一步推出dp的递推方程式。</p><p>1） 状态定义</p><p><strong>f[i][j]:表示以节点i,j为右下角，可构成的最大正方形的边长</strong>。</p><p>2） 所求目标 <span class="math display">\[max(f[1..R][1..C])\]</span> 3） 状态转移方程</p><p>if (a[i][j]==1) f[i][j] = min( min(f[i][j-1], f[i-1][j]),f[i-1][j-1]) + 1;</p><p>只有a[i][j]==1时，节点i,j才能作为正方形的右下角；</p><p>对于一个已经确定的f[i][j]=x，它表明包括节点i，j在内，向上x个节点，向左x个节点扫过的正方形中所有a[][]的值都为1；</p><p>对于一个待确定的f[i][j]，我们已知f[i-1][j]，f[i][j-1]，f[i-1][j-1]的值，如下：</p><p>                          f数组:        原a数组：</p><p><span class="math display">\[\left[\begin{matrix}   ? &amp; ? &amp; ? &amp; ?\\   ? &amp; ? &amp; 2 &amp; 1\\   ? &amp; ? &amp; 3 &amp; \textcolor{red}{?}\\   ? &amp; ? &amp; ? &amp; ?  \end{matrix}  \right]    反推出\Longrightarrow \left[\begin{matrix}   1 &amp; 1 &amp; 1 &amp; 0\\   1 &amp; 1 &amp; 1 &amp; 1\\   1 &amp; 1 &amp; 3 &amp; 1\\   ? &amp; ? &amp; ? &amp; ?  \end{matrix}  \right]\]</span> 由此得出状态转移方程：</p><p>if (a[i][j]==1) f[i][j]=min(min(f[i][j-1], f[i-1][j]), f[i-1][j-1]) +1;</p><p>例如:                           a数组:       f数组： <spanclass="math display">\[\left[\begin{matrix}   0 &amp; 0 &amp; 0 &amp; 1\\   1 &amp; 1 &amp; 1 &amp; 1\\   0 &amp; 1 &amp; 1 &amp; 1\\   1 &amp; 1 &amp; 1 &amp; 1  \end{matrix}  \right]    正推出\Longrightarrow \left[\begin{matrix}   0 &amp; 0 &amp; 0 &amp; 1\\   1 &amp; 1 &amp; 1 &amp; 1\\   0 &amp; 1 &amp; 2 &amp; 2\\   1 &amp; 1 &amp; 2 &amp; 3  \end{matrix}  \right]\]</span></p><h3 id="ac代码-3">2.5.4 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    二维前缀和的拓展题</span><br><span class="hljs-comment">    1） 状态定义</span><br><span class="hljs-comment">        f[i][j]表示以节点i,j为右下角，可构成的最大正方形的边长。</span><br><span class="hljs-comment">    2） 所求目标</span><br><span class="hljs-comment">        max(f[1..R][1..C])</span><br><span class="hljs-comment">    3） 状态转移方程</span><br><span class="hljs-comment">        if (a[i][j]==1)</span><br><span class="hljs-comment">            f[i][j] = min(min(f[i][j-1], f[i-1][j]), f[i-1][j-1]) + 1;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    只有a[i][j]==1时，节点i,j才能作为正方形的右下角；</span><br><span class="hljs-comment">    对于一个已经确定的f[i][j]=x，它表明包括节点i，j在内向上x个节点，向左x个节点扫过的正方形中所有a值都为1；</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> a,R,C,f[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>],ans;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;R,&amp;C);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=R; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=C; ++j) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);<br>            <span class="hljs-comment">//因为只需用到i，j上方，左方，左上方的信息，读入同步处理</span><br>            <span class="hljs-keyword">if</span> (a == <span class="hljs-number">1</span>)<br>                f[i][j] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(f[i][j<span class="hljs-number">-1</span>], f[i<span class="hljs-number">-1</span>][j]), f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])   +  <span class="hljs-number">1</span>;<br>            ans=<span class="hljs-built_in">max</span>(ans,f[i][j]);    <span class="hljs-comment">//同步更新答案</span><br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三高维前缀和">三、高维前缀和</h1><h2 id="高维前缀和">3.1 高维前缀和</h2><p>所谓“高维前缀和”，就是指”二维及以上“的前缀和</p><p>例如我们给定一个矩阵： <span class="math display">\[\left[\begin{matrix}   1 &amp; 2 &amp; 4 &amp; 3\\   5 &amp; 1 &amp; 2 &amp; 4\\   6 &amp; 3 &amp; 5 &amp; 9\\  \end{matrix}  \right] \tag{1}\]</span></p><p>那么它的前缀和就是： <span class="math display">\[\left[\begin{matrix}   1 &amp; 3 &amp; 7 &amp; 10\\   6 &amp; 9 &amp; 15 &amp; 22\\   12 &amp; 18 &amp; 29 &amp; 45\\  \end{matrix}  \right]\]</span></p><h2 id="两种求法">3.2 两种求法</h2><p>由于二维前缀和最为常用，我们先来看二维的情况。</p><h3 id="递推实现利用容斥原理效率一般">3.2.1递推实现（利用容斥原理，效率一般）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span> to R<br>    <span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span> to C<br>        sum[i][j] = sum[i<span class="hljs-number">-1</span>][j] + sum[i][j<span class="hljs-number">-1</span>] - sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + a[i][j];<br></code></pre></td></tr></table></figure><p>其实就是运用了容斥原理。</p><h3 id="硬干按维做前缀和效率更优更利于拓展为多维操作">3.2.2硬干（按维做“前缀和”，效率更优，更利于拓展为多维操作）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span> to R                           <br>    <span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span> to C<br>        sum[i][j]+=sum[i][j<span class="hljs-number">-1</span>]+a[i][j];<span class="hljs-comment">// 横向累加</span><br><span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span> to C                           <br>    <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span> to R<br>        sum[i][j]+=sum[i<span class="hljs-number">-1</span>][j];        <span class="hljs-comment">// 纵向累加。注意，这里没有a[][]参与了！因为都已经累加到累加和数组sum[][]里了</span><br></code></pre></td></tr></table></figure><p>第一遍循环后，所得的矩阵是<strong>每行各自独立的前缀和</strong>。</p><p>还是看上面的那个矩阵a[][]： <span class="math display">\[\left[\begin{matrix}   1 &amp; 2 &amp; 4 &amp; 3\\   5 &amp; 1 &amp; 2 &amp; 4\\   6 &amp; 3 &amp; 5 &amp; 9\\  \end{matrix}  \right] \tag{1}\]</span></p><p>第一个二重循环（先行后列）做完后，得到矩阵 <spanclass="math inline">\(sum^*[][]\)</span>： <span class="math display">\[\left[\begin{matrix}   1 &amp; 3 &amp; 7 &amp; 10\\   5 &amp; 6 &amp; 8 &amp; 12\\   6 &amp; 9 &amp; 14 &amp; 23\\  \end{matrix}  \right] \tag{2}\]</span> 第二个二重循环是将<spanclass="math inline">\(sum^*[][]\)</span>的每列再按行从上往下各自再做一遍前缀和，此时已经不需要原始数组a[][]的参与了。最终的二维前缀和矩阵sum[][]如下所示：<span class="math display">\[\left[\begin{matrix}   1 &amp; 3 &amp; 7 &amp; 10\\   6 &amp; 9 &amp; 15 &amp; 22\\   12 &amp; 18 &amp; 29 &amp; 45\\  \end{matrix}  \right]\tag{3}\]</span></p><p>现在我们变化一下循环顺序，对矩阵（1）按照“先列后行”的顺序来做，看看会得到什么不同的结果。<span class="math display">\[\left[\begin{matrix}   1 &amp; 2 &amp; 4 &amp; 3\\   5 &amp; 1 &amp; 2 &amp; 4\\   6 &amp; 3 &amp; 5 &amp; 9\\  \end{matrix}  \right] \stackrel{从上往下累加}{\Longrightarrow}\left[\begin{matrix}   1 &amp; 2 &amp; 4 &amp; 3\\   6 &amp; 3 &amp; 6 &amp; 7\\   12 &amp; 6 &amp; 11 &amp; 16\\  \end{matrix}  \right]\stackrel{从左往右累加}{\Longrightarrow}\left[\begin{matrix}   1 &amp; 3 &amp; 7 &amp; 10\\   6 &amp; 9 &amp; 15 &amp; 22\\   12 &amp; 18 &amp; 29 &amp; 45\\  \end{matrix}  \right]\]</span></p><p>可以看出，先列后行，仍然能得到相同的最终结果。</p><p>这里需要强调两点：</p><p>1）我们在书写两个二重for循环时写下的"for R for C"或者"for C forR"，它们是我们在填写数组时的<strong>填写顺序</strong>，比如"for R forC"表示“按照(1,1)、（1，2）...（1，R）、（2，1）、（2，2）”这个顺序来填写。经过我们刚才以实际数据来测试的结果，只要和推导的方向一致，那么两种顺序都是可以的。</p><p>2）针对每个具体的位置，例如sum[3][5]，它的数值来自于左侧的sum[3][4]或者上方的sum[2][5]呢？这个就要取决于你决定的累加顺序了。这里罗嗦一下，已经看懂的同学可以跳过本段后续的内容。如果你打算先从左往右累加前缀和，那么在第一个二重for里就应该写sum[i][j]=sum[i][j-1]+a[i][j]，然后在后续的二重循环里写sum[i][j]=sum[i-1][j]+sum[i][j]。反之，如果你打算先从上往下累加前缀和，那么在第一个二重for里就应该写sum[i][j]=sum[i-1][j]+a[i][j]，然后在后续的二重循环里写sum[i][j]=sum[i][j-1]+sum[i][j]。</p><h3 id="比较">3.2.3 比较</h3><p>两种求法的时间复杂度都是 <spanclass="math inline">\(O(len_1*len_2)\)</span>。但考虑维数 d的话，“递推实现”的复杂度为 <spanclass="math inline">\(O(len_1*len_2*...*len_d*\textcolor{red}{2^d})\)</span>（基于容斥原理去计算前缀和的复杂度为 <spanclass="math inline">\(O(2^d)\)</span>），“按维累加来实现”的复杂度为<span class="math inline">\(O( len_1*len_2*...*len_d*\textcolor{red}{d})\)</span>。所以如果是求多维数组的前缀和，<strong>推荐还是使用第二种方法</strong>。</p><h1 id="四拓展阅读">四、拓展阅读</h1><p><strong>（NOIP难度，普及、提高免进）</strong></p><h3 id="高维前缀和总结sosdp---heyuhhh---博客园-cnblogs.com">1. <ahref="https://www.cnblogs.com/heyuhhh/p/11585358.html">高维前缀和总结(sosdp)- heyuhhh - 博客园 (cnblogs.com)</a></h3><h3 id="专题高维前缀和---ruakker---洛谷博客-luogu.org">2.<ahref="https://chocola4ever.blog.luogu.org/prefix">专题——高维前缀和 -Ruakker - 洛谷博客 (luogu.org)</a></h3>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 前缀和/差分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序 第k小的数 nth_element()函数</title>
      <link href="/2024/01/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%20%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0%20nth_element()%E5%87%BD%E6%95%B0/"/>
      <url>/2024/01/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%20%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0%20nth_element()%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h3id="视频教学链接"><a href="https://bilibili.com/video/BV17h4y1E73i/?spm_id_from=333.999.0.0/?_blank" target="_blank">视频教学链接：</a></h3><h1 id="二实战训练">二、实战训练</h1><h3 id="p1177-模板排序">1.<ahref="https://www.luogu.com.cn/problem/P1177">P1177【模板】排序</a></h3><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1961668-20231206160224364-485932827.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1961668-20231206161152271-458682285.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1961668-20231206161726712-668972664.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>强调补充说明：</p><p>1）当左指针和右指针重叠或者错位时，退出while循环，所以while循环条件应写为<strong>while( i &lt; j ) ，不要加入'='号</strong>！</p><p>2）对x的取值，不一定非要去取区间中段的值，可以随机取（仍然无法确保肯定能把区间分成长度接近的两段）。</p><p>3）如果要取区间中段值，为防止int 或者longlong的加法溢出，<strong>最好是写成 x = a[ le + (ri - le)/2]的代码形式</strong>。</p><p>4）当退出while循环时，<strong>i 和 j 正好是重叠的(i == j)，或者是错位的( j+1 == i )</strong>。此时往下递归，左区间取[le, j]，<strong>右区间取[j+1, ri ]（不能取[i, ri]，因为i和j可能是重叠的，若取i 会让 a[i] 同时在两个子区间内）</strong></p><p>5）代码模板建议背下来！</p><p>P1177 AC代码： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,a[<span class="hljs-number">100005</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span>;         <span class="hljs-comment">// 重叠就返回</span><br>    <span class="hljs-type">int</span> i=l<span class="hljs-number">-1</span>, j=r+<span class="hljs-number">1</span>;        <span class="hljs-comment">// 左右指针分别初始化为“区间的外侧”</span><br>    <span class="hljs-type">int</span> x=a[i+(j-i)/<span class="hljs-number">2</span>];      <span class="hljs-comment">// x一定要提前取出来，不能在while内去临时取，因为中间位置的值可能在变化！</span><br>    <span class="hljs-keyword">while</span>(i&lt;j) &#123;             <span class="hljs-comment">// 当i==j（重叠）或者i&gt;j（错位）时跳出循环</span><br>        <span class="hljs-keyword">do</span> i++;<br>            <span class="hljs-keyword">while</span>(a[i]&lt;x);   <span class="hljs-comment">//向右找&gt;=x的数，不能写成while(a[i]&lt;a[i+(j-i/2)])！</span><br>        <span class="hljs-keyword">do</span> j--;<br>           <span class="hljs-keyword">while</span>(a[j]&gt;x);   <span class="hljs-comment">//向左找&lt;=x的数</span><br>        <span class="hljs-keyword">if</span>(i&lt;j)<br>            <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>    &#125;<br>    <span class="hljs-comment">// 不管是重叠或是错位，下面的写法都没问题</span><br>    <span class="hljs-built_in">quicksort</span>(l, j);<br>    <span class="hljs-built_in">quicksort</span>(j+<span class="hljs-number">1</span>, r);       <span class="hljs-comment">// 不能写成(i, ri)，因为可能ij重叠</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]); <span class="hljs-comment">// 从0号位开始存储</span><br>    <span class="hljs-built_in">quicksort</span>(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">6</span><br><span class="hljs-comment">4 3 2 4 5 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">10</span><br><span class="hljs-comment">4 2 1 2 8 9 -2 4 5 1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p><h3 id="p1923-深基9.例4求第-k-小的数">2.<ahref="https://www.luogu.com.cn/problem/P1923">P1923 【深基9.例4】求第 k小的数</a></h3><figure><imgsrc="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/1961668-20231206164116179-1683421866.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>方法(1)：快速排序搞定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,k,a[<span class="hljs-number">5000010</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qnth_element</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> a[l];<br>    <span class="hljs-type">int</span> i=l<span class="hljs-number">-1</span>, j=r+<span class="hljs-number">1</span>, x=a[(l+r)/<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">while</span>(i&lt;j) &#123;<br>        <span class="hljs-keyword">do</span> i++;<br>            <span class="hljs-keyword">while</span>(a[i]&lt;x); <span class="hljs-comment">//向右找&gt;=x的数</span><br>        <span class="hljs-keyword">do</span> j--;<br>            <span class="hljs-keyword">while</span>(a[j]&gt;x); <span class="hljs-comment">//向左找&lt;=x的数</span><br>        <span class="hljs-keyword">if</span>(i&lt;j) <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(k&lt;=j) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qnth_element</span>(l,j);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">qnth_element</span>(j+<span class="hljs-number">1</span>,r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">qnth_element</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>方法(2)：nth_element()函数实现程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,k,a[<span class="hljs-number">5000010</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-built_in">nth_element</span>(a,a+k,a+n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a[k]);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三-拓展nth_element函数讲解">三、拓展——<strong>nth_element()函数讲解</strong>：</h1><h3 id="作用">1、作用</h3><p><strong>将数组指定范围内第 k (从1开始编此号码)小的元素（会更改原数组中所有元素的位置。如需不变，请预先备份）存于a[k-1]位置上，其左侧的元素都&lt;=a[k-1]，右侧的元素都&gt;a[k-1]，但左右两侧区间内的数据仍然凌乱。</strong></p><h3 id="用法">2、用法</h3><p>nth_element(起始地址，k-1，最后一个元素地址+1，自定义排序)；</p><p>举例：查找数组中第5小的元素 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span><span class="hljs-comment">//必要头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>&#125;;<br>    <span class="hljs-comment">// 将数组中第5小（从1开始编）的元素放在a[4]位置，</span><br>    <span class="hljs-comment">// 其左侧元素都&lt;=a[4]，右侧元素都&gt;a[4]</span><br>    <span class="hljs-built_in">nth_element</span>(a, a+<span class="hljs-number">4</span>, a+<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">// 此时数组a[]的元素已发生挪位更改。a[]=&#123;2, 1, 3, 5, 5, 9, 8, 7, 6, 10&#125;</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;第5小的数是：&quot;</span>&lt;&lt;a[<span class="hljs-number">4</span>];<span class="hljs-comment">//第5小的数在a[4]</span><br>&#125;<br><span class="hljs-comment">//console:</span><br><span class="hljs-comment">//第5小的数是：5</span><br></code></pre></td></tr></table></figure></p><p>查找第 k 大的元素也是可以的。将第 k 大的问题转换为求第 n - k + 1小的问题就可以了例如：<strong>一个数组有10个元素，求第2大的数，那么它等同于求第10-2+1=9小的元素</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span><span class="hljs-comment">//必要头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;请问您需要查找第几大的数？&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">10</span>&#125;;<br>    <span class="hljs-built_in">nth_element</span>(a, a+<span class="hljs-number">10</span>-n, a+<span class="hljs-number">10</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;第&quot;</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">&quot;大的数是：&quot;</span>&lt;&lt;a[<span class="hljs-number">10</span>-n];<br>&#125;<br><span class="hljs-comment">//console:</span><br><span class="hljs-comment">//请问您需要查找第几大的数？</span><br><span class="hljs-comment">//2</span><br><span class="hljs-comment">//第2大的数是：9</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
