<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>区间dp(环)模型</title>
      <link href="/2024/07/31/%E5%8C%BA%E9%97%B4dp(%E7%8E%AF)%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/07/31/%E5%8C%BA%E9%97%B4dp(%E7%8E%AF)%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一理论教学">一、理论教学</h1><h2 id="模型说明">1.1 模型说明</h2><p>　　现在有N个数据依次排成<strong>一个圈</strong>，<strong>不允许移动</strong>（即有序），<strong>首尾连接</strong>。现在要对这N个数据进行合并，要求只能合并相邻的两个数据，合并后的数据可以参与下一次合并。现在给定每次数据合并产生的代价，求将所有数据合并成一个数所产生的最小代价/最大代价。这个模型和“区间dp(环)模型”的唯一区别就是“本模型的数据是一个环，首尾元素是相邻的，可以合并”。</p><p>　　<a href="https://www.luogu.com.cn/problem/P1880">P1880 [NOI1995]石子合并</a>是区间dp（环）的标准模板题型。理论上来说，也可以要求每次只能选择相邻的三堆数据。</p><h2 id="分析">1.2 分析</h2><p>　　环路数据合并，可以有两种方法来实现，下面分别进行讲述。</p><h3 id="方法1-割环为链拓展各个数组时间on3空间o4n2重点掌握">2.1.1 方法1割环为链，拓展各个数组（时间<spanclass="math inline">\(O(n^3)\)</span>，空间<spanclass="math inline">\(O(4n^2)\)</span>，重点掌握）</h3><p>　　由环转链，是解决环形区间dp较常用的一种方法。对于n个点，n条边构成的环路来说，每次对当前环路任意位置上相邻的两个点进行合并时，都会消除1个点和1条边，直到最后剩下1个点为止。也就是说，任何合并方案都需要对n个点、n条边的环路做n-1次合并即可。这样看来，必然会存在1条边是用不上的，多余的。换句话说，就算把多余的这1条边删掉，断环为链，也不影响这套合并方案的实施。但问题是我们并不知道哪一条边是多余的。既然如此，就干脆把该环路所有能够产生的链都去枚举处理一遍，然后比较得出最优解即可。那应该如何去“把所有的链都枚举一遍”呢？有一个简单的做法就是：<strong>对于由1-2-3-4-5组成的环路，我们可以将数据延展为：123451234</strong> 。也就是将长度为 n 的环变成了长度为 2n−1的链。那么最优解就在 12345、 23451、 34512、 45123和 51234中。以求最小值为例，那么就有<span class="math inline">\(dp(1,5)_环=min(\dp(1,5)_链,\quad  dp(2,6)_链,\quad dp(3,7)_链,\quad dp(4,8)_链,\quaddp(5,9)_链\ )\)</span>。</p><p>　　将数据拓展翻1倍之后，各个数组的维度长度都需要翻1倍。另外在初始化赋值时，更要小心处理。原始数组需要翻1倍，dp二维数组需要延展1倍，初始化时的对角线也需要延展。另外，关于两个区间进行合并的成本开销，即区间内所有数据之和，在链模型中是采用前缀和的方法来快捷算出的；在割环为链之后，其实这个方法仍然是可行的，但前缀和数组同样需要拓展一倍长度。</p><p>　　本方法虽然空间复杂度稍微较大，但后期可以采用平行四边形优化法，对时间复杂度进行优化，以适应更大的数据量处理。建议同学们重点掌握。</p><h3 id="方法2-利用取余来实现环不拓展数组时间on3空间on2">2.1.2 方法2利用取余来实现环，不拓展数组（时间<spanclass="math inline">\(O(n^3)\)</span>，空间<spanclass="math inline">\(O(n^2)\)</span>）</h3><p>　　在不拓展数组的情况下，如果区间右端点超过了数组的上限，则自动调整到下标0的位置上。对于方法2，因为涉及到取余，强烈建议所有数组都从下标0开始编号和存储数据，以便于代码书写。</p><p>　　需要提醒同学们注意的是，本来对区间（链）dp的填写有“for le, forri”和“for len, forle”这两种写法。在区间（环）的情况下如果不拓展数据，那么<spanclass="math inline">\(le \leq ri\)</span>的这个条件不再肯定成立，<spanclass="math inline">\(k+1\)</span>也不一定肯定会大于k，这会对dp数组的填写顺序造成较大的困扰，增添代码实现难度。所以，<strong>强烈建议如果要采用方法2来做，请最好是用“forlen, forle”的写法</strong>。虽然也会涉及到取余，但写起来相对容易一些。下面是参考的局部代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法2强烈建议用len和le来做循环变量，</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> le=<span class="hljs-number">0</span>; le&lt;n; le++ ) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ri=<span class="hljs-number">0</span>; le &lt;= n<span class="hljs-number">-1</span>; ++le) &#123;<br>        <span class="hljs-type">int</span> ri = le + len - <span class="hljs-number">1</span>;     <span class="hljs-comment">//先暂时不管越界，毕竟没在[]里</span><br>        <span class="hljs-comment">// 老老实实算区间和，用前缀和数组更难处理</span><br>        <span class="hljs-type">int</span> cost=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=le; k&lt;=ri; k++)  <span class="hljs-comment">// k在[]里，可能为ri，需要取余，否则k越界</span><br>            cost += data[k%n];     <span class="hljs-comment">// 因为下标从0开始存储基本数据，无法用前缀和，否则i-1为负数了</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=le; k &lt;= ri<span class="hljs-number">-1</span>; ++k) &#123; <span class="hljs-comment">//决策c</span><br>            <span class="hljs-comment">// 最大值和最小值都列举给同学们看看，注意 k、k+1 和 ri 都有可能数组越界，需要绕回来，取余%</span><br>            dpmin[le][ri%n] = <span class="hljs-built_in">min</span>(dpmin[le][ri%n], dpmin[le][k%n] + dpmin[(k+<span class="hljs-number">1</span>)%n][ri%n] + cost);<br>            dpmax[le][ri%n] = <span class="hljs-built_in">max</span>(dpmax[le][ri%n], dpmax[le][k%n] + dpmax[(k+<span class="hljs-number">1</span>)%n][ri%n] + cost);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　方法2的空间复杂度较小，但代码理解起来稍微困难，取余容易出错，且后期使用平行四边形优化法更为困难，所以建议会写即可。</p><h1 id="二实战训练">二、实战训练</h1><h2 id="p1880-石子合并">2.1 P1880 石子合并</h2><h3 id="原题链接">2.1.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P1880">P1880 [NOI1995]石子合并</a></p><h3 id="分析-1">2.1.2 分析</h3><p>　　这是一个区间（环）dp的裸题，<spanclass="math inline">\(n\leq1e2\)</span>，不管是采用方法1或者方法2，<spanclass="math inline">\(n^3=1e6 \leq1e7\)</span>，不采用任何优化也能直接AC。cost数组就是区间内的数据之和。</p><h3 id="ac代码">2.1.3 AC代码</h3><h4 id="割环为链不优化">2.1.3.1 割环为链，不优化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法1：区间（环）dp，数组翻倍处理，割环为链，无任何优化 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 102</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NN 2*N</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">区间dp，数据首尾链接成环，求最小值和最大值。</span><br><span class="hljs-comment">需要割环为链，设置2倍的数组空间， </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-type">int</span> data[NN];<br><span class="hljs-type">int</span> dpmin[NN][NN];<br><span class="hljs-type">int</span> dpmax[NN][NN];<br><span class="hljs-type">int</span> sum[NN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i, le, ri, k, n, nn;<br><span class="hljs-built_in">memset</span>(dpmin, INF, <span class="hljs-built_in">sizeof</span>(dpmin));  <span class="hljs-comment">//初值设定为极大值</span><br><span class="hljs-built_in">memset</span>(dpmax, -INF  , <span class="hljs-built_in">sizeof</span>(dpmax));   <span class="hljs-comment">//初值设定为-INF</span><br>cin &gt;&gt;n;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data[i]);<br>data[i+n] = data[i];<br>&#125;<br>nn = <span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=nn;++i)&#123;<br>dpmin[i][i] = <span class="hljs-number">0</span>;<br>dpmax[i][i] = <span class="hljs-number">0</span>;<br>sum[i] = sum[i<span class="hljs-number">-1</span>] + data[i]; <br>&#125;<br><span class="hljs-keyword">for</span>( le=nn; le&gt;=<span class="hljs-number">1</span>; --le ) <br><span class="hljs-keyword">for</span>( ri=le+<span class="hljs-number">1</span>; ri &lt;= nn; ++ri)&#123;<br><span class="hljs-type">int</span> cost= sum[ri] - sum[le<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span>( k=le; k &lt;= ri<span class="hljs-number">-1</span>; ++k)&#123; <span class="hljs-comment">//决策：从哪一个转移过来</span><br>dpmin[le][ri] = <span class="hljs-built_in">min</span>(dpmin[le][ri], dpmin[le][k] + dpmin[k+<span class="hljs-number">1</span>][ri] + cost);<br>    dpmax[le][ri] = <span class="hljs-built_in">max</span>(dpmax[le][ri], dpmax[le][k] + dpmax[k+<span class="hljs-number">1</span>][ri] + cost);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 注意，答案并不存于dpmin[1][nn]。要求左右之间一定是宽度为n的区间</span><br><span class="hljs-comment">// 例如dpmin[1][n], 或者dpmin[2][n+1]、 dpmin[3][n+2]……dpmin[n][2*n-1]等中的最小值 </span><br><span class="hljs-type">int</span> mymin = INF;<br><span class="hljs-type">int</span> mymax = -INF;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; ++i)&#123;<br>       mymin = <span class="hljs-built_in">min</span> ( mymin , dpmin[i][i+n<span class="hljs-number">-1</span>] ) ;<br>   mymax = <span class="hljs-built_in">max</span> ( mymax , dpmax[i][i+n<span class="hljs-number">-1</span>] ) ;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, mymin);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, mymax);<br><br><span class="hljs-comment">//    for(int j=0; j&lt;= nn; j++)</span><br><span class="hljs-comment">//        printf(&quot;%8d&quot;, j);</span><br><span class="hljs-comment">//    printf(&quot;\n&quot;);</span><br><span class="hljs-comment">//for(int i=0; i&lt;=nn; i++)&#123; </span><br><span class="hljs-comment">//   for(int j=0; j&lt;= nn; j++)</span><br><span class="hljs-comment">//       if (dpmax[i][j] &lt; -10000)</span><br><span class="hljs-comment">//           printf(&quot;    -INF&quot;);</span><br><span class="hljs-comment">//        else</span><br><span class="hljs-comment">//           printf(&quot;%8d&quot;, dpmax[i][j]);</span><br><span class="hljs-comment">//    printf(&quot;\n&quot;);</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="不延展数组循环取余硬干">2.1.3.2 不延展数组，循环取余硬干</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法2：区间环dp + 不延长数组</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 102</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">区间dp，数据首尾链接成环，求最小值和最大值。</span><br><span class="hljs-comment">需要割环为链，设置2倍的数组空间， </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-type">int</span> data[N];<br><span class="hljs-type">int</span> dpmin[N][N];<br><span class="hljs-type">int</span> dpmax[N][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i, le, ri, k, n;<br><span class="hljs-built_in">memset</span>(dpmin, INF, <span class="hljs-built_in">sizeof</span>(dpmin));  <span class="hljs-comment">//初值设定为   INF</span><br><span class="hljs-built_in">memset</span>(dpmax, -INF  , <span class="hljs-built_in">sizeof</span>(dpmax));   <span class="hljs-comment">//初值设定为  -INF</span><br>cin &gt;&gt;n;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data[i]);<br>dpmin[i][i] = <span class="hljs-number">0</span>;<br>dpmax[i][i] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 假设n=10，下标分别为0..9 </span><br><span class="hljs-comment">// len=2  0..1  1..2  ...   8..9   9..0 </span><br><span class="hljs-comment">// len=4  0..3  1..4  ...   8..1   9..2 </span><br><span class="hljs-comment">// len=10 0..9  1..0  ...   8..7   9..8  </span><br><span class="hljs-comment">// 可以用len和le来循环 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> le=<span class="hljs-number">0</span>; le&lt;n; le++ )&#123; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ri=<span class="hljs-number">0</span>; le &lt;= n<span class="hljs-number">-1</span>; ++le)&#123;<br><span class="hljs-type">int</span> ri = le + len - <span class="hljs-number">1</span>;     <span class="hljs-comment">// 先暂时不管越界，毕竟没在[]里</span><br><span class="hljs-comment">// 老老实实算区间和，用前缀和数组更难处理 </span><br><span class="hljs-type">int</span> cost=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=le; k&lt;=ri; k++)  <span class="hljs-comment">// k在[]里，可能为ri，需要取余，否则k越界</span><br>    cost += data[k%n];     <span class="hljs-comment">// 因为下标从0开始存储基本数据，无法用前缀和，否则i-1为负数了</span><br>    <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=le; k &lt;= ri<span class="hljs-number">-1</span>; ++k)&#123; <span class="hljs-comment">//决策</span><br><span class="hljs-comment">// 最大值和最小值都列举给同学们看看，注意 k、k+1 和 ri 都有可能数组越界，需要绕回来，取余%</span><br>dpmin[le][ri%n] = <span class="hljs-built_in">min</span>(dpmin[le][ri%n], dpmin[le][k%n] + dpmin[(k+<span class="hljs-number">1</span>)%n][ri%n] + cost);<br>    dpmax[le][ri%n] = <span class="hljs-built_in">max</span>(dpmax[le][ri%n], dpmax[le][k%n] + dpmax[(k+<span class="hljs-number">1</span>)%n][ri%n] + cost);<br>    &#125;<br><span class="hljs-comment">//    printf(&quot;(%d,%d)-%2d-%2d &quot;, le, ri%n, dpmin[le][ri%n], dpmax[le][ri%n] );</span><br>&#125;<br><span class="hljs-comment">//printf(&quot;\n&quot;);</span><br>&#125;<br><span class="hljs-comment">// 注意，答案并不存于dpmin[1][nn]。要求左右之间一定是宽度为n的区间</span><br><span class="hljs-comment">// 例如dpmin[1][n], 或者dpmin[2][n+1]、 dpmin[3][n+2]……dpmin[n][2*n-1]等中的最小值 </span><br><span class="hljs-type">int</span> mymin = INF;<br><span class="hljs-type">int</span> mymax = -INF;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; ++i)&#123;<br>       mymin = <span class="hljs-built_in">min</span> ( mymin , dpmin[i][(i+n<span class="hljs-number">-1</span>)%n] ) ;    <span class="hljs-comment">// 注意要取余 </span><br>   mymax = <span class="hljs-built_in">max</span> ( mymax , dpmax[i][(i+n<span class="hljs-number">-1</span>)%n] ) ;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, mymin);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, mymax);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p1063-能量项链">2.2 P1063 能量项链</h2><h3 id="原题链接-1">2.2.1 原题链接</h3><p>　　<a href="https://www.luogu.com.cn/problem/P1063">P1063 [NOIP2006提高组] 能量项链</a></p><h3 id="分析-2">2.2.2 分析</h3><p>　　N个能量珠串成一串，相邻的珠子可以进行合并，旧珠消失，产生新珠，释放能量，求如何选择合并，使得释放的总能量最大。这是个比较明显的区间（环）DP问题。本来没什么难度，但题目中加了一个要素，就是“每个珠子有头标记和尾标记”，合并后的释放能量为<spanclass="math inline">\(m*r*n\)</span>。这个值得我们仔细研究一下，也就是cost[le][ri]=？</p><p>　　现在假设有两个相邻的能量珠（不管是原始的，或者是合并后产生的），珠1是第[le..c]个珠子合并后产生的能量珠，其头标记为m（必然是第le个珠子的头标记值），尾标记为r（必然是第c个珠子的尾标记值，同时根据“珠子相邻衔接”的基本定义，该值也是第c+1个珠子的头标记值）；珠2是第[c+1..ri]个珠子合并后产生的能量珠，其头标记为r（只可能是r，同学们可以想想为什么？然后在纸上画一画看看），尾标记为n（必然是第ri个珠子的尾标记）。那么两个珠子进行合并释放的能量就是：<span class="math display">\[\begin{align}&amp;\quad\ 第[le..c]个珠子合并后的珠子\ 与\第[c+1..ri]个珠子合并后的珠子\ 进行合并产生的能量\\&amp;=m \times r\times n\\ &amp;=第\ le\ 个珠子的头标记值m\ ×\ 第\ c\ 个珠子的尾标记值r\×\ 第\ ri\ 个珠子的尾标记值n\end{align}\]</span>　　剩下的可能的坑点就是结构体数据的录入和数组拓展部分结构体数据的复制了。需要的是同学们的仔细，在纸上画结构体数组的样例结果，然后小心调试。</p><h3 id="ac代码-1">2.2.3 AC代码</h3><p>　　本题以“断环为链”的方法来实现，其他方法请同学们自行研究。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100      </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NN 2*N+5</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">这个题，2个区间合并时，涉及到了3个数，比较麻烦，还是设定每个区间有ll和rr两个数，</span><br><span class="hljs-comment">这样比较容易控制区间编号，不至于造成混乱。 </span><br><span class="hljs-comment">    注意割环为链之后，长度从n变成了2n-1，所有数组都需要延展长度，并且第二层循环left</span><br><span class="hljs-comment">需要以右端不越界为截止点。 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> ll, rr;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> data[NN];<br><span class="hljs-type">int</span> dp[NN][NN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i, len, left, rt, k, n;<br>cin &gt;&gt;n;<br><span class="hljs-comment">//     0     1    2    3       4  |   5    6    7      8</span><br><span class="hljs-comment">//           2    3    5      10  |   2    3    5</span><br><span class="hljs-comment">//    /0   2/3   3/5  5/10   10/2 |  2/3  3/5  5/10  10/ </span><br><span class="hljs-comment">// 处理基本的data数据 </span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data[<span class="hljs-number">1</span>].ll);  <span class="hljs-comment">// 第一个数据单独处理，以便首尾衔接 </span><br>    data[n].rr= data[<span class="hljs-number">1</span>].ll; <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data[i].ll);<br>        data[i<span class="hljs-number">-1</span>].rr = data[i].ll;<br>    &#125;<br>    <span class="hljs-comment">// 处理延展部分的data数据 </span><br>    <span class="hljs-keyword">for</span>(i=n+<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>; i++)&#123;<br>        data[i].ll = data[i-n].ll;<br>        data[i].rr = data[i-n].rr;<br>    &#125;<br>    <span class="hljs-comment">// 初始化和特例处理 </span><br>    <span class="hljs-built_in">memset</span>(dp, -INF, <span class="hljs-built_in">sizeof</span>(dp)); <span class="hljs-comment">// 本例中无负数，初始化为0在本例中也是可以的 </span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>; i++)&#123;<br>        dp[i][i] = <span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-keyword">for</span>(len = <span class="hljs-number">2</span>; len&lt;=n; len++)<br><span class="hljs-comment">// 截止位置的条件是 区间右端下标不能超过2*n-1 </span><br><span class="hljs-keyword">for</span>(left=<span class="hljs-number">1</span>; left+len<span class="hljs-number">-1</span>&lt;=<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>; left++)&#123;<br>rt = left+len<span class="hljs-number">-1</span>;<br><span class="hljs-comment">// k的取值范围不变 </span><br><span class="hljs-keyword">for</span>(k=left; k&lt;=rt<span class="hljs-number">-1</span>; k++)<br><span class="hljs-comment">// 用data[k].rr 去乘，才能衔接得上 </span><br>dp[left][rt] = <span class="hljs-built_in">max</span> (dp[left][rt] , dp[left][k] + dp[k+<span class="hljs-number">1</span>][rt] + data[left].ll*data[k].rr*data[rt].rr );<br>&#125;<br><br><span class="hljs-comment">// 注意跨度值，跨度为n的区间，如果左端是i的话，那么右端应该是i+n-1 </span><br><span class="hljs-type">int</span> ans= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>ans = <span class="hljs-built_in">max</span>(ans, dp[i][i+n<span class="hljs-number">-1</span>]);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 区间dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
