<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>dp中的状态转移训练 | 宝爸编程</title><meta name="author" content="雪宝和七七的爸爸"><meta name="copyright" content="雪宝和七七的爸爸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、理论教学1.1 模型说明　　dp中关于状态的描述和定义，是在做dp题时一个比较重要的环节。对于大部分dp题来说，其状态的描述和定义都比较简单，可能会引起初学者的忽视。这里用一个帖子来加强大家对这个环节的领悟能力。 　　“状态定义和转移”，一个比较经典的题型就是“股票买卖系列”的题。本帖主要剖析这个题型，同学们可自行感悟。 　　股票买卖系列是动态规划的经典题目，Leetcode上有六道关于股票买">
<meta property="og:type" content="article">
<meta property="og:title" content="dp中的状态转移训练">
<meta property="og:url" content="http://example.com/2024/07/31/dp%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E8%AE%AD%E7%BB%83/index.html">
<meta property="og:site_name" content="宝爸编程">
<meta property="og:description" content="一、理论教学1.1 模型说明　　dp中关于状态的描述和定义，是在做dp题时一个比较重要的环节。对于大部分dp题来说，其状态的描述和定义都比较简单，可能会引起初学者的忽视。这里用一个帖子来加强大家对这个环节的领悟能力。 　　“状态定义和转移”，一个比较经典的题型就是“股票买卖系列”的题。本帖主要剖析这个题型，同学们可自行感悟。 　　股票买卖系列是动态规划的经典题目，Leetcode上有六道关于股票买">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-07-30T16:00:00.000Z">
<meta property="article:modified_time" content="2024-11-18T07:33:26.774Z">
<meta property="article:author" content="雪宝和七七的爸爸">
<meta property="article:tag" content="信息学">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/07/31/dp%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E8%AE%AD%E7%BB%83/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'dp中的状态转移训练',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-18 15:33:26'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="宝爸编程"><span class="site-name">宝爸编程</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">dp中的状态转移训练</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-30T16:00:00.000Z" title="发表于 2024-07-31 00:00:00">2024-07-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-18T07:33:26.774Z" title="更新于 2024-11-18 15:33:26">2024-11-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">基础算法</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="dp中的状态转移训练"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、理论教学"><a href="#一、理论教学" class="headerlink" title="一、理论教学"></a>一、理论教学</h1><h2 id="1-1-模型说明"><a href="#1-1-模型说明" class="headerlink" title="1.1 模型说明"></a>1.1 模型说明</h2><p>　　dp中关于状态的描述和定义，是在做dp题时一个比较重要的环节。对于大部分dp题来说，其状态的描述和定义都比较简单，可能会引起初学者的忽视。这里用一个帖子来加强大家对这个环节的领悟能力。</p>
<p>　　“状态定义和转移”，一个比较经典的题型就是“股票买卖系列”的题。本帖主要剖析这个题型，同学们可自行感悟。</p>
<p>　　股票买卖系列是动态规划的经典题目，Leetcode上有六道关于股票买卖相关的问题。</p>
<p>　　<strong>给定一个大小为n的数组prices代表连续n天某支股票的股价，prices[i]即第i天的股价，且必须在买进后才能卖出。每天只能做一次操作（买或者卖，第二天才能卖或买），也就是$冷却期<em>{买 \Rightarrow 卖}=1；冷却期</em>{卖 \Rightarrow 买}=1$。再给定一些限制条件，问最大收益。</strong></p>
<p>　　一般有如下几种限制条件，对于LeetCode和Acwing网站上的六道题：</p>
<p>1) 买卖一次：　　　　　　　　　　<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121. 买卖股票的最佳时机</a>／<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1056/">1054.股票买卖</a></p>
<p>2) 不限买卖次数：   　　　　　　<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122. 买卖股票的最佳时机 II</a>/<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1057/">1055.买卖股票 II</a></p>
<p>3) 买卖两次：　　　　　　　　　　<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">123. 买卖股票的最佳时机 III</a>/<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1058/">1056.买卖股票 III</a></p>
<p>4) 买卖ｋ次：　　　　　　　　　　<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">188. 买卖股票的最佳时机 IV</a>/<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1059/">1057.买卖股票 IV</a></p>
<p>5) 带有冷却的股票买卖问题：　　　<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">309. 买卖股票的最佳时机含冷冻期</a>/</p>
<p>6) 带有交易费用的股票买卖问题：　<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">714. 买卖股票的最佳时机含手续费</a>/<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1061/">1059.买卖股票 VI</a></p>
<p>　　上述的题目，都有一点没说清楚。那就是<strong>“每次买卖，都只能买一手股票，不能多买多卖。而题目中提供的价格，也是一手股票在当天的价格”</strong>。如果考试遇到这类问题，怎么办？我们稳扎稳打，只用一种通用方法解决所用问题，以不变应万变。</p>
<p>　　这 6 道股票买卖问题是有共性的，我们通过对第四题（限制最大交易次数为 k）的分析一道一道解决。因为第四题是一个最泛化的形式，其他的问题都是这个形式的简化。</p>
<p>　　第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = INF（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易“冷冻期”和“手续费”的额外条件，其实就是第二题的变种，都很容易处理。</p>
<h2 id="1-2-如何描述和定义所有状态"><a href="#1-2-如何描述和定义所有状态" class="headerlink" title="1.2 如何描述和定义所有状态"></a>1.2 如何描述和定义所有状态</h2><p>　　在动态规划中，状态表示题目所描述的模型，在某一个时刻瞬间所具备的一种静态的综合信息的汇总。状态往往会对应着一个具体的数值。所以我们才会使用dp数组来存储这个数值。要想准确地界定出这种唯一的状态，就需要把状态描述的所有维度都进行准确的定义，不能出现含混不清、模棱两可的情况。如果出现含混不清，说明你对状态描述的维数太少。比如，你想描述出立体空间里的某一个点的准确位置，如果你只想出来了“长x”和“宽y”但缺乏“高z”的话，是无法准确定位出这个点的。</p>
<p>　　在“股票买卖模型”中，“天”是每一次交易的耗时单位，所以“天”肯定是该模型中状态的一个维度。但是当具体到某一“天”时，我们仍然无法准确地去做决策。因为我们不知道自己的交易次数用完了没有（若已用完k次的话则不能再买），也不知道自己有没有钱买股票（题型禁止买空）或有没有股票可卖成钱（题型禁止卖空）。所以状态还应该包括“已交易次数k”和“是否持有股票”这两个维度。具体需要细说一下：</p>
<ul>
<li>关于交易次数k的认定——因为有买必然就有卖，所以我们可以指定一种操作的发生来表示交易的发生，下文都以“买股票”来作为一次交易的发生。</li>
<li>关于“是否持有股票”——因为要求每次交易只能买或卖<strong>一手</strong>股票，不允许多买多卖，也不允许零买零卖，所以只有‘持有一手股票’和‘没有股票’这两种情况，不需要考虑‘持有0.6手或者3手等股票’。</li>
</ul>
<p>　　上述的三个维度可以准确地描述出一个状态，所以<strong>本题型的dp数组应该是三维的，分别为“第i天末、已交易k次、是否持有一手股票（用 1 表示持有一手股票，0 表示没有持有股票）”</strong>，用该三维数组就能表述出本题型中的所有状态。比如说 dp[3][2][1] 的含义就是：今天是第三天末，已经做了2 次交易，我现在手上持有着一手股票，我最多能获得多少收益值。再比如 dp[2][3][0] 的含义：今天是第二天末至今已经进行了 3 次交易，我现在手上没有持有股票，最多能获得多少收益值。很容易理解，对吧？</p>
<p>　　此时，我们可以对这三个维度相关数值的组合做一个仔细研究，确定出初值和特例来。</p>
<ol>
<li><p>dp[0][k][0] = 0      (k=[0..K])               （初值式1）<br> 解释：因为 i 是从 1 开始的，所以 i = 0 意味着还没有开始，这时候的利润当然是 0，不管 k 等于几，即不管现在已经交易买卖过多少次 </p>
</li>
<li><p>dp[0][k][1] = -INF    (k=[0..K])              （初值式2）<br> 解释：还没开始的时候，是不可能持有一手股票的，不管k等于几。用 -INF 表示这种不可能 。</p>
</li>
<li><p>dp[i][0][0] = 0      (i=[1..n])               （初值式3）<br> 解释：k = 0 意味着根本还没做过任何的买卖交易。在没有股票的前提下，利润当然是 0（连续躺平多天什么都不干，没有股票是合理的，利润必然是0） 。</p>
</li>
<li><p>dp[i][0][1] = -INF    (i=[1..n])              （初值式4）   </p>
<p> 解释：在没做任何交易的情况下，是不可能持有一手股票的，用 -INF 表示这种情况不合理，无解。</p>
</li>
</ol>
<p>　　上面的第1点和第2点处理了dp[0][..][..]的所有情况；第3点和第4点处理了dp[1..n][0][..]的所有情况。现在只剩dp[1..n][1..K][..]的所有情况尚未处理，等待填写了。上述4点对应的代码（1）大致如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 重要！代码（1） 初始化dp数组和对特例赋值。下面的代码并没有化简，纯粹是为了对应上面的4个点</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;=K; k++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>; t&lt;=<span class="hljs-number">1</span>; t++)&#123;<br>            <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span> &amp;&amp; t==<span class="hljs-number">0</span>)       <span class="hljs-comment">// 初始化1  dp[0][k][0] = 0       (k=[0..K])</span><br>                dp[i][k][t]= <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span> &amp;&amp; t==<span class="hljs-number">1</span>)  <span class="hljs-comment">// 初始化2  dp[0][k][1] = -INF    (k=[0..K])</span><br>                dp[i][k][t]= -INF;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k==<span class="hljs-number">0</span> &amp;&amp; t==<span class="hljs-number">0</span>)  <span class="hljs-comment">// 初始化3  dp[i][0][0] = 0       (i=[1..n]) </span><br>                dp[i][k][t]= <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span>                    <span class="hljs-comment">// 初始化4  dp[i][0][1] = -INF    (i=[1..n])</span><br>                dp[i][k][t]= -INF;            <br>        &#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-3-所求目标"><a href="#1-3-所求目标" class="headerlink" title="1.3 所求目标"></a>1.3 所求目标</h2><p>　　我们想求的最终答案是 dp[n][K][0]，即最后一天末（第n天末），已经做了 K 次交易，手里没有一手股票，最多能获得多少利润。读者可能问为什么不是 dp[n][K][1]？因为 [1] 代表手上持有一手股票，[0] 表示手上的这一手股票已经卖出去了，很显然后者得到的利润一定大于前者（除非股票价格允许是负数）。既然本题要求最大的现金值，那么手里持有了一手股票则明显没有达到现金的最大化。</p>
<h2 id="1-4-状态转移"><a href="#1-4-状态转移" class="headerlink" title="1.4 状态转移"></a>1.4 状态转移</h2><p>　　所谓的“状态转移”是指我在当前状态下，采取某种决策，从而转移成为另一个不同的状态。对于本题型的每个状态来说，原则上有三种决策可以选择：买入、卖出、无操作（我们用 buy, sell, rest 表示这三种选择）。但实际上所有状态之间肯定不是能够自由转移的（例如不可能从第1天的某个状态忽然就变成了第4天的任何状态），并且每个状态面临的三种决策也并非肯定真实有效（例如因为不准买空卖空，必须要先有“买”才能有“卖”，所以只持有现金时不能再卖股票，持有了一手股票时不能再买股票）。而且别忘了，我们还有交易次数 k 的限制，如果已经做过k次交易了就不能再去买股票了。这么多的状态和相互之间的关系，该怎么表达才比较清楚呢？我们可以采用“<strong>状态机模型</strong>”来帮助我们理解状态转移的过程，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240809142607044.png" alt="image-20240809142607044" style="zoom:67%;" /></p>
<p>　　上图就是一个简单的状态机模型图。两个正方形表达的是两种状态，0表示“只持有现金”，1表示“持有一手股票”。箭头表示状态之间的转移动作。每个箭头，都表示从某一天到下一天的状态转移的可选项。在状态为0时只有两种转移动作的选择（“不操作”和“买股票”）；在状态为1时也只有两种转移动作的选择（“不操作”和“卖股票”）。换一个角度来看，要想得到状态0，只有两个绿色箭头这样的操作；要想得到状态1，只有两个红色箭头这样的操作。想要得到状态0或者1，我们只需要在这两种同色转移（也是决策）中去取最优决策值即可，这就是后续我们的状态转移方程的书写依据。</p>
<ol>
<li>状态为0（只持有现金）的转移方程如下：</li>
</ol>
<script type="math/tex; mode=display">
\begin{align}\textcolor{red}{dp[i][k][0]}&=max(\ \textcolor{yellow}{dp[i-1][k][0]}, \quad \textcolor{orange}{dp[i-1][k][1]+price[i]}\ ) \tag{1}\\
\textcolor{red}{第i天只持有现金}&=max(\ \textcolor{yellow}{第i天不操作}\ \quad, \quad\textcolor{orange}{第i天卖光股票}\ )\tag{} \\
\end{align}</script><p>　　说明：<font color="red">在第i天末只持有现金</font>，可能是因为<font color="yellow">在第i-1天末就只持有现金，且在第i天什么都不操作（价值无变化，在第i天末仍然为前一天的值）</font>；也有可能是因为<font color="orange">在第i-1天末持有了一手股票，且在第i天卖光了股票（价值有变化，卖票后必然会增加现金收入）</font>。具体该为哪一个值呢？题目求最大收益，所以就看哪个值更大咯！橙色公式中需要注意，<strong>交易以“买”为准，“第i天卖掉股票”不算是1次交易，因为已经在第i-1天买股票的同时就计入交易次数了，1次买卖才算1次交易，不能算作2次交易！</strong></p>
<ol>
<li>状态为1（持有一手股票（可能也持有多余的现金））的转移方程如下：</li>
</ol>
<script type="math/tex; mode=display">
\begin{align}\textcolor{red}{dp[i][k][1]}&=max(\ \textcolor{yellow}{dp[i-1][k][1]}, \quad \textcolor{orange}{dp[i-1][k-1][0]-price[i]}\ ) \tag{2}\\
\textcolor{red}{第i天只持有股票}&=max(\ \textcolor{yellow}{第i天不操作}\ \quad, \quad\textcolor{orange}{第i天全买股票}\ )\tag{} \\
\end{align}</script><p>　　说明：<font color="red">在第i天末持有一手股票</font>，可能是因为<font color="yellow">在第i-1天末就持有了一手股票，且在第i天什么都不操作（价值无变化，在第i天末仍然为前一天的值）</font>；也有可能是因为<font color="orange">在第i-1天末时只持有现金，已交易k-1次，且在第i天全买成股票（价值有变化，买票后必然会减少现金收入）</font>。具体该为哪一个值呢？题目求最大收益，所以就看哪个值更大咯！橙色公式中需要注意，<strong>交易以“买”为准，“第i天卖掉股票”不算是1次交易，因为已经在第i-1天买股票的同时就计入交易次数了，1次买卖才算1次交易，不能算作2次交易！</strong></p>
<p>　　上面的公式（1）和公式（2）联合起来，组成了本贴最强大而通用的dp的转移方程。这看上去很像<a target="_blank" rel="noopener" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1312">1312：【例3.4】昆虫繁殖</a>这种双递推啊！两个递推方程，交叉地推~~如果对这种双递推感到不适应，可以先练“昆虫繁殖”这个题。</p>
<h2 id="1-5-秒杀题目"><a href="#1-5-秒杀题目" class="headerlink" title="1.5 秒杀题目"></a>1.5 秒杀题目</h2><p>　　充分理解了1.2节～1.4节的内容之后，对于帖子最开始处的6种题型，我们按照从简单到难的顺序依次来怕破解。</p>
<h3 id="1-5-1-k-1"><a href="#1-5-1-k-1" class="headerlink" title="1.5.1 k==1"></a>1.5.1 k==1</h3><p>　　k==1，也就是要求整个过程最多允许交易1次买卖。</p>
<p>　　根据公式（1）和1.2节初值分析的第3点内容，有如下2个状态转移方程：</p>
<script type="math/tex; mode=display">
\begin{align}\textcolor{red}{dp[i][1][0]}&=\textcolor{red}{max(\ dp[i-1][1][0],\quad dp[i-1][1][1]+price[i]\ )} \tag{3} \\
\textcolor{yellow}{dp[i][1][1]}&=max(\ dp[i-1][1][1],\quad dp[i-1][1-1][0]-price[i]\ ) \tag{} \\
&=max(\ dp[i-1][1][1],\quad dp[i-1][0][0]-price[i]\ ) \tag{} \\
&=max(\ dp[i-1][1][1],\quad \textcolor{red}{0}-price[i]\ )\quad\Longleftarrow\quad(根据1.2节初值分析第3点) \tag{} \\
&=\textcolor{yellow}{max(\ dp[i-1][1][1],\quad -price[i]\ )} \tag{4} \\
&(i \geq 1) \tag{}
\end{align}</script><p>　　我们仔细观察上面红色和黄色这两个状态转移方程结果，可以惊奇地发现，2个公式中的第二维全是1，没有0，这说明第2维k已无存在的意义，可以精简掉，把三维数组dp[i][k][t]变成二维数组dp[i][t]。精简后的状态转移方程如下：</p>
<script type="math/tex; mode=display">
\begin{align}\textcolor{red}{dp[i][0]}&=\textcolor{red}{max(\ dp[i-1][0],\quad dp[i-1][1]+price[i]\ )} \tag{5} \\
\textcolor{yellow}{dp[i][1]}&=\textcolor{yellow}{max(\ dp[i-1][1],\quad -price[i]\ )} \tag{6} \\ &(i \geq 1) \tag{}
\end{align}</script><p>　　我们把通用的初始化代码（1）结合“k==1”的情况调整一下，整合公式（5）和（6），得到如下的代码（2）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 代码（2）</span><br><span class="hljs-comment">//// 空间复杂度为O(2*n)，时间复杂度O(n)</span><br><span class="hljs-type">int</span> dp[maxn][<span class="hljs-number">2</span>];<br>......<br><span class="hljs-comment">///// 初始化dp数组和对特例赋值</span><br><span class="hljs-comment">//  dp[0][0]=0, dp[0][1]=-INF, dp[1..n][0]= 0, dp[1..n][1]= -INF </span><br><span class="hljs-comment">//  整合一下，就是 ====&gt;  dp[0..n][0]=0, dp[0..n][1]= -INF （重要，是代码（3）初始化的理论基础）</span><br><span class="hljs-comment">// 下面的代码主要是为了吻合代码（1）。只要背下来了代码（1），就能推出下面的代码，其效果和上一行代码等效</span><br><span class="hljs-comment">// 建议同学们背下来代码（1），再根据6种题型来做初始化赋值的演变，这样以不变应万变    </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++)<br><span class="hljs-comment">//    for(int k=0; k&lt;=K; k++)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>; t&lt;=<span class="hljs-number">1</span>; t++)&#123;<br>            <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span> &amp;&amp; t==<span class="hljs-number">0</span>)       <span class="hljs-comment">// 初始化1  原来是 dp[0][k][0] = 0       (k=[0..K])</span><br>                dp[i][t]= <span class="hljs-number">0</span>;        <br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span> &amp;&amp; t==<span class="hljs-number">1</span>)  <span class="hljs-comment">// 初始化2  原来是 dp[0][k][1] = -INF    (k=[0..K])</span><br>                dp[i][t]= -INF;     <br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t==<span class="hljs-number">0</span>)          <span class="hljs-comment">// 初始化3  原来是 if (k==0 &amp;&amp; t==0) dp[i][0][0] = 0  </span><br>                dp[i][t]= <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span>                    <span class="hljs-comment">// 初始化4  原来是 if(t==1) dp[i][1] = -INF    (i=[1..n])</span><br>                dp[i][t]= -INF;            <br>        &#125;    <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;  <br>	dp[i][<span class="hljs-number">0</span>]= <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + price[i] );<br>	dp[i][<span class="hljs-number">1</span>]= <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], -price[i] );<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>　　代码（2）已经是最精简的代码了吗？其实不是！仔细分析可以看到，两个赋值等式右边的数组第一维全都是i-1。我们完全可以利用$变量<em>新=f(变量</em>旧)$的方式来理解（回想一下“如何在不使用数组的前提下利用循环来递推斐波拉契数列？”问题的实现）。最精简的终极代码（3）如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 代码（3）这个代码够精简，够牛逼吧？如果没有前面的铺垫，这个代码是很难理解的！</span><br><span class="hljs-comment">//// 空间复杂度为O(1)，时间复杂度O(n)</span><br><span class="hljs-type">int</span> dp0= <span class="hljs-number">0</span>;     <span class="hljs-comment">// 理论基础见代码（2）第7行</span><br><span class="hljs-type">int</span> dp1= -INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;   <br>	dp0= <span class="hljs-built_in">max</span>(dp0, dp1 + price[i] );<br>	dp1= <span class="hljs-built_in">max</span>(dp1, -price[i] );<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1-5-2-k-INF"><a href="#1-5-2-k-INF" class="headerlink" title="1.5.2 k==INF"></a>1.5.2 k==INF</h3><p>　　如何理解k==INF在本题型中的含义呢？</p>
<p>　　k\==INF　\&lt;=\=\=&gt;　不限制交易次数　\&lt;=\=\=&gt;　在思考递推方程时不必考虑k　\&lt;=\=\=&gt;　可以去掉dp中k这个维度</p>
<p>　　所以，我们可以把公式（1）和（2）去掉k这个维度，整合成如下：</p>
<script type="math/tex; mode=display">
\begin{align}dp[i][0]&=max(\ dp[i-1][0],\quad dp[i-1][1]+price[i]\ ) \tag{7} \\
dp[i][1]&=max(\ dp[i-1][1],\quad dp[i-1][0]-price[i]\ ) \tag{8} \\
&(i \geq 1) \tag{}
\end{align}</script><p>把通用的初始化代码（1）结合“不考虑k”进行整改，然后和公式（7）和（8），得到如下代码（4）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 代码（4）</span><br><span class="hljs-comment">//// 空间复杂度为O(2*n)，时间复杂度O(n)</span><br><span class="hljs-type">int</span> dp[maxn][<span class="hljs-number">2</span>];<br>......<br><span class="hljs-comment">///// 初始化dp数组和对特例赋值</span><br><span class="hljs-comment">//   和1.5.1节类似，都需要砍掉k这个维度，所以下面处理和代码（2）一样 ，省略</span><br><span class="hljs-comment">//  ...初始化赋值同代码（2）...</span><br>    <br><span class="hljs-comment">// 开始递推</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;  <br>	dp[i][<span class="hljs-number">0</span>]= <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + price[i] );<br>	dp[i][<span class="hljs-number">1</span>]= <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]-price[i] );<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同样的，上面的代码（4）是可以简化的。简化掉第1维之后，代码（5）如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 代码（5）</span><br><span class="hljs-comment">//// 空间复杂度为O(1)，时间复杂度O(n)</span><br><span class="hljs-type">int</span> dp0= <span class="hljs-number">0</span>;     <span class="hljs-comment">// 理论基础见代码（2）第7行</span><br><span class="hljs-type">int</span> dp1= -INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>    <span class="hljs-type">int</span> dp0_old= dp0;<br>	dp0= <span class="hljs-built_in">max</span>(dp0, dp1 + price[i] );<br>	dp1= <span class="hljs-built_in">max</span>(dp1, dp0_old - price[i] ); <span class="hljs-comment">// dp0此时已经是新值了，根据代码（4）中for内容，我们需要的是旧值，只能定义一个dp0_old来临时存一下旧值了</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1-5-3-k-任意正整数"><a href="#1-5-3-k-任意正整数" class="headerlink" title="1.5.3 k==任意正整数"></a>1.5.3 k==任意正整数</h3><p>　　一次交易由“买股票”和“卖股票”这两个环节构成，而且在卖出股票时是不允许当天马上就买股票的（根据题意），也就是说，1次完整的交易无论如何都会占据2天的选择。所以说，10天内不可能交易超过5次，n天内不可能交易超过n/2次。k是最大允许的交易次数，如果这个值超过n/2，也就意味着在n天实际上是不限交易次数了。所以当$k \geq n/2$时，请用1.5.2节的方法来求解问题即可。本节主要讨论$k&lt;=n/2$的情况。“k\=\=2”属于“k\=\=任意正整数”的一种情况。只要搞定了任意正整数，也就搞定了k\=\=2。</p>
<p>　　因为$k \in [2..n/2]$，更具有一般性，我们需要把公式（1）和（2）用代码直接实现出来。仔细观察这两个公式，因为两个公式右侧的dp值第1维都是i-1，所以我们需要从小到大来循环i；至于k的循环顺序，因为在填写第i面数据时，第i-1面的全部数据都已知，所以实际上k的循环顺序是“增序降序均可”。但如果对dp采用滚动数组的方式，压缩掉第1维的话，k就必须只能降序循环了（原理同01背包的滚动数组实现法）。大致代码如下代码（6）所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">////代码（6） k==任意整数</span><br><span class="hljs-type">int</span> dp[maxn][maxK][<span class="hljs-number">2</span>];<br><span class="hljs-comment">//初始化dp，直接照搬代码（1）到此处</span><br>......<br><br><span class="hljs-comment">// 开始递推</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=K;k&gt;=<span class="hljs-number">1</span>; k--)&#123;  <span class="hljs-comment">// 标准数组下增序降序都均可，滚动数组下k只能降序填写       </span><br><span class="hljs-comment">//  for(int k=1;k&lt;=K; k++) </span><br>        dp[i][k][<span class="hljs-number">0</span>]= <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>]   + price[i] );<br>        dp[i][k][<span class="hljs-number">1</span>]= <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][k<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - price[i] );        <br>    &#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="1-5-4-k-INF-且-冷却期-卖-Rightarrow-买-2-天，-冷却期-买-Rightarrow-卖-1-天"><a href="#1-5-4-k-INF-且-冷却期-卖-Rightarrow-买-2-天，-冷却期-买-Rightarrow-卖-1-天" class="headerlink" title="1.5.4 k==INF　且　$冷却期{卖 \Rightarrow 买}==2$天，$冷却期{买 \Rightarrow 卖}==1$天"></a>1.5.4 k<em>==INF　且　$冷却期</em>{卖 \Rightarrow 买}<em>==2$天，$冷却期</em>{买 \Rightarrow 卖}==1$天</h3><p>　　k==INF并不难搞，之前1.5.2节已经对这种情况做过处理了，仅需要直接无视掉第二维，让dp数组只含两维即可。本题型的难点是“冷却期\==2天”。这里需要先科普一下“冷却期”的概念。</p>
<ul>
<li>冷却期==0：卖掉股票之后，当天马上就可以再买股票，即$冷却期_{卖 \Rightarrow 买}=0$；</li>
<li>冷却期==1：当天卖掉股票之后，第2天（明天）才能再买股票，即$冷却期_{卖 \Rightarrow 买}=1$；</li>
<li><strong>冷却期==2：当天卖掉股票之后，第3天（后天）才能再买股票，即$冷却期_{卖 \Rightarrow 买}=2$，这是本节讨论的对象</strong>；</li>
</ul>
<p>　　本题属于最后这种。在本题中，“卖出”操作的冷却期，即“卖出后再买入所需的最少时间间隔”，比较特殊地定为了2天。至于“买入”操作的冷却期，和1.5.1～3一样，仍然是1天，即$冷却期_{买\Rightarrow 卖}=1$。下面分别讨论两种状态的转移：</p>
<p>　　1.第i天末如果只持有现金（状态为dp[i][0]），该如何做才能达成这样的状态呢？有如下两种可能的转移来源：</p>
<p>　　1）第一种情况是：在第i天当天卖掉了手里的那1手股票，在第i天末时的现金价值为dp[i-1][1]+price[i]（在第i天卖出1手股票必然惠造成现金增多了price[i]）；</p>
<p>　　2）第二种情况是：在第i-1天末就已经只持有现金，且在第i天什么都没做，现金价值为dp[i-1][0]。</p>
<p>　　最终决策是在情况1）和情况2）种选择最大的那种，来作为最优决策。转移方程如下：</p>
<script type="math/tex; mode=display">
dp[i][0]=max(\ dp[i-1][0],\quad dp[i-1][1]+price[i]\ ) \tag{9}</script><p>　　2.第i天末如果要持有1手股票（状态为dp[i][1]），如何得来的呢？有如下两种可能的转移来源：</p>
<p>　　1）第一种情况是：在第i天当天购买了1手股票（根据“冷却期”的概念描述，要想能在第i天买入股票，需要第i-2天末一定是持有现金状态，且第i-1天没有买入），所以在第i天末时的现金价值为dp[i-2][0]-price[i]（在第i天买入1手股票必然惠造成现金减少了price[i]）；</p>
<p>　　2）第二种情况是：在第i-1天末就已经持有了一手股票，且在第i天什么都没做，现金价值为dp[i-1][1]。</p>
<p>　　最终决策是在情况1）和情况2）种选择最大的那种，来作为最优决策。转移方程如下：</p>
<script type="math/tex; mode=display">
dp[i][1]=max(\ dp[i-1][1],\quad dp[i-2][0]-price[i]\ ) \tag{10}</script><p>　　<strong>综合公式（9）和（10），就是1.5.4节这种情况的两个状态转移方程。它给我们指出了当$冷却期<em>{卖 \Rightarrow 买}$和$冷却期</em>{买 \Rightarrow 卖}$分别为不同的其他值时该如何分析处理。</strong>因为都是砍掉k这个维度，所以在针对公式（9）和（10）进行编码时，“初始化dp数组”的代码和代码（2）中“初始化dp数组”的代码完全一致即可。具体代码这里就不展示了，没什么难度。</p>
<p>　　仔细的同学可以看到，在公式（9）和（10）中实际上只涉及到了[i-1]和[i-2]，当n的规模很大，担心MLE的同学可以定义一个变量dppre0来存储和管理不断变化的dp[i-2][0]值，并对公式（9）和（10）做滚动化压缩处理。dp[i][]为当前值（分别对应代码中赋值号左侧的dp0和dp1），dp[i-1][]为旧值（分别对应代码中赋值号右侧的dp0和dp1）,dp[i-2][0]为更旧的值（对应dppre2）。具体代码如下代码（7）所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">////代码（7） 冷却期=2天，滚动实现dp迭代</span><br><span class="hljs-type">int</span> dp0=<span class="hljs-number">0</span>, dp1= -price[<span class="hljs-number">1</span>], dppre2=<span class="hljs-number">0</span>; <span class="hljs-comment">// 第1天末只有现金时价值为0，买了股票后则价值为-value[1]，第0天只有现金0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123;<br>    <span class="hljs-type">int</span> tmp= dp0;               <span class="hljs-comment">// 把“旧值”暂存，避免执行下一行时被覆盖掉，等更替结束后，将其变成“更旧的值”</span><br>    dp0= <span class="hljs-built_in">max</span>(dp0, dp1 + price[i]);    <span class="hljs-comment">// 新值 &lt;===== f(旧值)，或者说，根据旧值计算出新值</span><br>    dp1= <span class="hljs-built_in">max</span>(dp1, dppre2 - price[i]); <span class="hljs-comment">// 这里需要的是更旧的值，即dppre2，</span><br>    dppre2= tmp;                <span class="hljs-comment">// 在做下一轮之前，先把&#x27;旧的dp0&#x27;变成 &#x27;更旧的dp0&#x27; </span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果冷却期是3天的话，那具体代码如下代码（8）所示，同学们可以了解一下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">////代码（8） 冷却期=3天，滚动实现dp迭代</span><br><span class="hljs-type">int</span> dp0=<span class="hljs-number">0</span>, dp1= -INF; <span class="hljs-comment">// 理论基础见代码（2）和（5）中的初始化</span><br><span class="hljs-type">int</span> dppre3=<span class="hljs-number">0</span>;         <span class="hljs-comment">// dp[0..n][0] = 0 ，这里的dppre3、dppre2表示的都是dp[i-XXX][0]的值</span><br><span class="hljs-type">int</span> dppre2=<span class="hljs-number">0</span>; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>    <span class="hljs-type">int</span> tmp= dp0;               <span class="hljs-comment">// 把“旧值”暂存，避免执行下一行时被覆盖掉，等更替结束后，将其变成“更旧的值”</span><br>    dp0= <span class="hljs-built_in">max</span>(dp0, dp1 + price[i]);    <span class="hljs-comment">// 新值 &lt;===== f(旧值)，或者说，根据旧值计算出新值</span><br>    dp1= <span class="hljs-built_in">max</span>(dp1, dppre3 - price[i]); <span class="hljs-comment">// 这里需要的是更旧的值，即dppre3，</span><br>    dppre3= dppre2;             <span class="hljs-comment">// 在做下一轮之前，把&#x27;更旧的dp0&#x27;变成 &#x27;更更旧的dp0&#x27; </span><br>    dppre2= tmp;                <span class="hljs-comment">// 在做下一轮之前，把&#x27;旧的dp0&#x27;变成 &#x27;更旧的dp0&#x27; </span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>　　对于更大的冷却期值，只需要按照代码（8）中第9、10行的模式继续写就行了。不过一般来说，股票交易也不可能有很大的冷却期，所以这一点基本上可以不去理会了。</p>
<h3 id="1-5-5-k-INF-且-有交易手续费"><a href="#1-5-5-k-INF-且-有交易手续费" class="headerlink" title="1.5.5 ｋ\=\=INF 且　有交易手续费"></a>1.5.5 ｋ\=\=INF 且　有交易手续费</h3><p>　　每做一次交易要支付手续费，只要把手续费从利润中减去即可。这里要区分这个手续费是在买的过程中或是卖的过程中支付的。如果把买和卖合起来算一次交易，那么在二者任一过程中进行处理都行。需要注意的是，手续费始终属于支出的部分，不管在上下哪个式子里，都是要减掉的。</p>
<ol>
<li>如果是在 “买” 的环节中支付手续费，则改写方程如下：</li>
</ol>
<script type="math/tex; mode=display">
\begin{align}        dp[i][0] &= max(\ dp[i-1][0], \quad dp[i-1][1] + prices[i]\ ) \\
        dp[i][1] &= max(\ dp[i-1][1], \quad dp[i-1][0] - prices[i] - fee\ ) \\
\end{align}</script><ol>
<li>如果是在 “卖” 的环节中支付手续费，则改写方程如下：</li>
</ol>
<script type="math/tex; mode=display">
\begin{align}        dp[i][0] &= max(\ dp[i-1][0], \quad dp[i-1][1] + prices[i]- fee\ ) \\
        dp[i][1] &= max(\ dp[i-1][1], \quad dp[i-1][0] - prices[i] \ ) \\
\end{align}</script><p>至于初始化的处理，和上述其他几种情况类似，这里不再赘述。</p>
<h1 id="二、实战练习"><a href="#二、实战练习" class="headerlink" title="二、实战练习"></a>二、实战练习</h1><h2 id="2-1-Acwing1054（交易1次）"><a href="#2-1-Acwing1054（交易1次）" class="headerlink" title="2.1 Acwing1054（交易1次）"></a>2.1 Acwing1054（交易1次）</h2><h3 id="2-1-1-原题链接"><a href="#2-1-1-原题链接" class="headerlink" title="2.1.1 原题链接"></a>2.1.1 原题链接</h3><p>　　<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1056/">1054.股票买卖</a></p>
<h3 id="2-1-2-AC代码"><a href="#2-1-2-AC代码" class="headerlink" title="2.1.2 AC代码"></a>2.1.2 AC代码</h3><h4 id="2-1-2-1-标准三维dp，未简化i和k"><a href="#2-1-2-1-标准三维dp，未简化i和k" class="headerlink" title="2.1.2.1 标准三维dp，未简化i和k"></a>2.1.2.1 标准三维dp，未简化i和k</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// /// 方法1： 标准DP，三维，未简化i和k</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	股票买卖线性DP的第1个题，</span><br><span class="hljs-comment">	“只能进行一次买卖交易，&#x27;买入&#x27;为新的一次交易开始”</span><br><span class="hljs-comment">	Acwing1054～1059</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> K = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> dp[maxn][K+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]; <span class="hljs-comment">// 注意，第二维是K+1，交易次数从1开始编号，若定义为[K]，下标无法从1开始。</span><br><span class="hljs-type">int</span> n, pri[maxn];<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>	cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>	cin &gt;&gt;n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) cin &gt;&gt;pri[i];<br><br>	<span class="hljs-comment">// 初始化dp的0值，i的范围是[0..n]</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++)<br>		dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -INF;<br>	<span class="hljs-comment">// 初始化dp的-INF值，k的范围是[0..K]</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;=K; k++)<br>		dp[<span class="hljs-number">0</span>][k][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, dp[<span class="hljs-number">0</span>][k][<span class="hljs-number">1</span>] = -INF;<br><br>	<span class="hljs-comment">// 模板套上去，注意i和k都是从1开始</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=K; k++)&#123;<br>			dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>] + pri[i] );                     <br>			dp[i][k][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][k<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - pri[i] );<br>		&#125;<br><br>	cout &lt;&lt;dp[n][K][<span class="hljs-number">0</span>];<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                                                                               <br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-1-2-2-简化版本，不定义dp数组"><a href="#2-1-2-2-简化版本，不定义dp数组" class="headerlink" title="2.1.2.2 简化版本，不定义dp数组"></a>2.1.2.2 简化版本，不定义dp数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// /// 方法2： 简化DP，无需定义数组。 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	股票买卖线性DP的第一个题，</span><br><span class="hljs-comment">	“只能进行一次买卖交易，&#x27;买入&#x27;为新的一次交易开始”</span><br><span class="hljs-comment">  其实没必要写成简化模式，记住通杀模板不是更香么？还能根据通杀模板推导出简化模式 </span><br><span class="hljs-comment">	Acwing1054～1059</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> dp0, dp1;<br><span class="hljs-type">int</span> n, pri[maxn];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>	cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>	cin &gt;&gt;n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) cin &gt;&gt;pri[i];<br><br>	<span class="hljs-comment">// 初始化dp0 和 dp1</span><br>	dp0 = <span class="hljs-number">0</span>, dp1 = -INF;<br>	<span class="hljs-comment">// 模板套上去，注意i和k都是从1开始</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>		dp0 = <span class="hljs-built_in">max</span>(dp0, dp1 + pri[i] );<br><span class="hljs-comment">//		dp1 = max(dp1, dp0 - pri[i] );    </span><br><span class="hljs-comment">// 注意，这里不能这么搞，否则答案为7，无法AC，因为这里准确的说是需要dp[i-1][k-1][0]，而并非dp[i-1][k][0]</span><br>		dp1 = <span class="hljs-built_in">max</span>(dp1,  - pri[i] );<br>	&#125;<br>	cout &lt;&lt;dp0;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-2-Acwing1055（交易无限次）"><a href="#2-2-Acwing1055（交易无限次）" class="headerlink" title="2.2 Acwing1055（交易无限次）"></a>2.2 Acwing1055（交易无限次）</h2><h3 id="2-2-1-原题链接"><a href="#2-2-1-原题链接" class="headerlink" title="2.2.1 原题链接"></a>2.2.1 原题链接</h3><p>　　<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1057/">1055股票买卖 II</a></p>
<h3 id="2-2-2-AC代码"><a href="#2-2-2-AC代码" class="headerlink" title="2.2.2 AC代码"></a>2.2.2 AC代码</h3><h4 id="2-2-2-1-二维dp数组，简化了k"><a href="#2-2-2-1-二维dp数组，简化了k" class="headerlink" title="2.2.2.1 二维dp数组，简化了k"></a>2.2.2.1 二维dp数组，简化了k</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// /// 方法1： 标准DP，三维简化为二维，未简化i</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	股票买卖线性DP的第2个题，</span><br><span class="hljs-comment">	“能进行无限次买卖交易，&#x27;买入&#x27;为新的一次交易开始”</span><br><span class="hljs-comment">	Acwing1054～1059</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> K = INF;<br><span class="hljs-type">int</span> dp[maxn][<span class="hljs-number">2</span>]; <span class="hljs-comment">//  k为正无穷，那么对交易次数的限制就已经丧失了实用意义。所以第二维省略，只剩第一维和第三维 </span><br><span class="hljs-type">int</span> n, pri[maxn];<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>	cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>	cin &gt;&gt;n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) cin &gt;&gt;pri[i];<br><br>	<span class="hljs-comment">// 初始化dp的0值，i的范围是[0..n]</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++)<br>		dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, dp[i][<span class="hljs-number">1</span>] = -INF;<br><br>	<span class="hljs-comment">// 模板套上去，注意i和k都是从1开始</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>			dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + pri[i] );<br>			dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - pri[i] );<br>		&#125;<br>	cout &lt;&lt;dp[n][<span class="hljs-number">0</span>];<br> 	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-2-2-2-无需定义dp数组"><a href="#2-2-2-2-无需定义dp数组" class="headerlink" title="2.2.2.2 无需定义dp数组"></a>2.2.2.2 无需定义dp数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/// /// 方法2： 简化DP，无需定义数组。 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	股票买卖线性DP的第2个题，</span><br><span class="hljs-comment">	“能进行无限次买卖交易，&#x27;买入&#x27;为新的一次交易开始”</span><br><span class="hljs-comment">    其实没必要写成简化模式，记住通杀模板不是更香么？还能根据通杀模板推导出简化模式 </span><br><span class="hljs-comment">	Acwing1054～1059</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> K = INF;<br><span class="hljs-type">int</span> dp0, dp1; <span class="hljs-comment">//  k为正无穷，那么对交易次数的限制就已经丧失了实用意义。所以第二维省略，只剩第一维和第三维 </span><br><span class="hljs-type">int</span> n, pri[maxn];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>	cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>	cin &gt;&gt;n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) cin &gt;&gt;pri[i];<br><br>	<span class="hljs-comment">// 初始化dp0 和 dp1</span><br>	dp0 = <span class="hljs-number">0</span>, dp1 = -INF;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>		dp0 = <span class="hljs-built_in">max</span>(dp0, dp1 + pri[i] );<br>		dp1 = <span class="hljs-built_in">max</span>(dp1, dp0- pri[i] );   <span class="hljs-comment">// 此处dp0不能省了，因为要反复迭代dp0了 </span><br>	&#125;<br>	cout &lt;&lt;dp0;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">雪宝和七七的爸爸</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/07/31/dp%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E8%AE%AD%E7%BB%83/">http://example.com/2024/07/31/dp%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E8%AE%AD%E7%BB%83/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">宝爸编程</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BF%A1%E6%81%AF%E5%AD%A6/">信息学</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/12/15/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E6%9C%80%E5%80%BC%EF%BC%88%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%85%A5%E9%97%A8%EF%BC%89/" title="滑动窗口求最值（单调队列入门）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">滑动窗口求最值（单调队列入门）</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/31/%E5%8C%BA%E9%97%B4dp(%E7%8E%AF)%E6%A8%A1%E5%9E%8B/" title="区间dp(环)模型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">区间dp(环)模型</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/04/25/LCS%E9%97%AE%E9%A2%98/" title="最长公共子序列（LCS）问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-25</div><div class="title">最长公共子序列（LCS）问题</div></div></a></div><div><a href="/2024/04/25/LIS%E9%97%AE%E9%A2%98/" title="最长不下降子序列（LIS）问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-25</div><div class="title">最长不下降子序列（LIS）问题</div></div></a></div><div><a href="/2020/03/13/hello/" title="我的第一篇博客"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-13</div><div class="title">我的第一篇博客</div></div></a></div><div><a href="/2024/07/02/%E4%B8%89%E7%A7%8D%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E7%9A%84%E5%A4%84%E7%90%86/" title="三种分组背包的处理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-02</div><div class="title">三种分组背包的处理</div></div></a></div><div><a href="/2025/01/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D-%E4%B8%AD-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/" title="二叉树的前-中-后序遍历"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-10</div><div class="title">二叉树的前-中-后序遍历</div></div></a></div><div><a href="/2024/03/06/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/" title="二分查找和二分答案"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-06</div><div class="title">二分查找和二分答案</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">雪宝和七七的爸爸</div><div class="author-info__description">本博客致力于信息学奥赛知识学习。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%90%86%E8%AE%BA%E6%95%99%E5%AD%A6"><span class="toc-number">1.</span> <span class="toc-text">一、理论教学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%A8%A1%E5%9E%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 模型说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%A6%82%E4%BD%95%E6%8F%8F%E8%BF%B0%E5%92%8C%E5%AE%9A%E4%B9%89%E6%89%80%E6%9C%89%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 如何描述和定义所有状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%89%80%E6%B1%82%E7%9B%AE%E6%A0%87"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 所求目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 状态转移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E7%A7%92%E6%9D%80%E9%A2%98%E7%9B%AE"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 秒杀题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-k-1"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.5.1 k&#x3D;&#x3D;1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2-k-INF"><span class="toc-number">1.5.2.</span> <span class="toc-text">1.5.2 k&#x3D;&#x3D;INF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-3-k-%E4%BB%BB%E6%84%8F%E6%AD%A3%E6%95%B4%E6%95%B0"><span class="toc-number">1.5.3.</span> <span class="toc-text">1.5.3 k&#x3D;&#x3D;任意正整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-4-k-INF-%E4%B8%94-%E5%86%B7%E5%8D%B4%E6%9C%9F-%E5%8D%96-Rightarrow-%E4%B9%B0-2-%E5%A4%A9%EF%BC%8C-%E5%86%B7%E5%8D%B4%E6%9C%9F-%E4%B9%B0-Rightarrow-%E5%8D%96-1-%E5%A4%A9"><span class="toc-number">1.5.4.</span> <span class="toc-text">1.5.4 k&#x3D;&#x3D;INF　且　$冷却期{卖 \Rightarrow 买}&#x3D;&#x3D;2$天，$冷却期{买 \Rightarrow 卖}&#x3D;&#x3D;1$天</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-5-k-INF-%E4%B8%94-%E6%9C%89%E4%BA%A4%E6%98%93%E6%89%8B%E7%BB%AD%E8%B4%B9"><span class="toc-number">1.5.5.</span> <span class="toc-text">1.5.5 ｋ\&#x3D;\&#x3D;INF 且　有交易手续费</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%9E%E6%88%98%E7%BB%83%E4%B9%A0"><span class="toc-number">2.</span> <span class="toc-text">二、实战练习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Acwing1054%EF%BC%88%E4%BA%A4%E6%98%931%E6%AC%A1%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 Acwing1054（交易1次）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1 原题链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-AC%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2 AC代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-1-%E6%A0%87%E5%87%86%E4%B8%89%E7%BB%B4dp%EF%BC%8C%E6%9C%AA%E7%AE%80%E5%8C%96i%E5%92%8Ck"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">2.1.2.1 标准三维dp，未简化i和k</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-2-%E7%AE%80%E5%8C%96%E7%89%88%E6%9C%AC%EF%BC%8C%E4%B8%8D%E5%AE%9A%E4%B9%89dp%E6%95%B0%E7%BB%84"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">2.1.2.2 简化版本，不定义dp数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Acwing1055%EF%BC%88%E4%BA%A4%E6%98%93%E6%97%A0%E9%99%90%E6%AC%A1%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 Acwing1055（交易无限次）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 原题链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-AC%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 AC代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-1-%E4%BA%8C%E7%BB%B4dp%E6%95%B0%E7%BB%84%EF%BC%8C%E7%AE%80%E5%8C%96%E4%BA%86k"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">2.2.2.1 二维dp数组，简化了k</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-2-%E6%97%A0%E9%9C%80%E5%AE%9A%E4%B9%89dp%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">2.2.2.2 无需定义dp数组</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/16/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%881%EF%BC%89%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/" title="栈的应用（1）括号匹配">栈的应用（1）括号匹配</a><time datetime="2025-01-16T03:11:55.591Z" title="发表于 2025-01-16 11:11:55">2025-01-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D-%E4%B8%AD-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/" title="二叉树的前-中-后序遍历">二叉树的前-中-后序遍历</a><time datetime="2025-01-09T16:00:00.000Z" title="发表于 2025-01-10 00:00:00">2025-01-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/04/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8/" title="栈的应用">栈的应用</a><time datetime="2025-01-04T06:01:31.659Z" title="发表于 2025-01-04 14:01:31">2025-01-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/01/%EF%BC%88%E4%B8%89%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/" title="（三）宽度小于等于m的区间的“最大的和值”问题">（三）宽度小于等于m的区间的“最大的和值”问题</a><time datetime="2025-01-01T09:38:09.649Z" title="发表于 2025-01-01 17:38:09">2025-01-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/01/%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9B%BA%E5%AE%9A%E5%AE%BD%E5%BA%A6%E4%B8%BAm%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/" title="（二）固定宽度为m的区间的“最大的和值”问题">（二）固定宽度为m的区间的“最大的和值”问题</a><time datetime="2025-01-01T09:38:09.640Z" title="发表于 2025-01-01 17:38:09">2025-01-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 雪宝和七七的爸爸</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>