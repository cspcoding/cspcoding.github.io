<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>区间分段dp（“萝卜填坑”）模型 | 宝爸编程</title><meta name="author" content="雪宝和七七的爸爸"><meta name="copyright" content="雪宝和七七的爸爸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、理论教学 1.1 模型说明 　　现在有K个数据依次排成一条线，不允许移动。给定这一条线上任意两个位置之间（形成了一个区间）的收益值\(value[\ le\ ][\ ri\ ]\)，现在需要将这K个数据的线分割成\(P(1 \leq P \leq K)\)段，求分割后的收益最大值&#x2F;最小值（为了讲解方便，在第一章中我们统一用“最大值”）。 　　这种题型看上去有点像是区间DP，不过和正">
<meta property="og:type" content="article">
<meta property="og:title" content="区间分段dp（“萝卜填坑”）模型">
<meta property="og:url" content="http://example.com/2024/07/21/%E5%8C%BA%E9%97%B4%E5%88%86%E6%AE%B5dp%EF%BC%88%E2%80%9C%E8%90%9D%E5%8D%9C%E5%A1%AB%E5%9D%91%E2%80%9D%EF%BC%89%E6%A8%A1%E5%9E%8B/index.html">
<meta property="og:site_name" content="宝爸编程">
<meta property="og:description" content="一、理论教学 1.1 模型说明 　　现在有K个数据依次排成一条线，不允许移动。给定这一条线上任意两个位置之间（形成了一个区间）的收益值\(value[\ le\ ][\ ri\ ]\)，现在需要将这K个数据的线分割成\(P(1 \leq P \leq K)\)段，求分割后的收益最大值&#x2F;最小值（为了讲解方便，在第一章中我们统一用“最大值”）。 　　这种题型看上去有点像是区间DP，不过和正">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-07-20T16:00:00.000Z">
<meta property="article:modified_time" content="2024-07-31T01:24:40.318Z">
<meta property="article:author" content="雪宝和七七的爸爸">
<meta property="article:tag" content="信息学">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/07/21/%E5%8C%BA%E9%97%B4%E5%88%86%E6%AE%B5dp%EF%BC%88%E2%80%9C%E8%90%9D%E5%8D%9C%E5%A1%AB%E5%9D%91%E2%80%9D%EF%BC%89%E6%A8%A1%E5%9E%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":5,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '区间分段dp（“萝卜填坑”）模型',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-07-31 09:24:40'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/static/css/custom.css"><link rel="stylesheet" href="/fonts/font.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="宝爸编程"><span class="site-name">宝爸编程</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">区间分段dp（“萝卜填坑”）模型</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-20T16:00:00.000Z" title="发表于 2024-07-21 00:00:00">2024-07-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-31T01:24:40.318Z" title="更新于 2024-07-31 09:24:40">2024-07-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">基础算法</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4dp/">区间dp</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="区间分段dp（“萝卜填坑”）模型"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一理论教学">一、理论教学</h1>
<h2 id="模型说明">1.1 模型说明</h2>
<p>　　现在有K个数据依次排成一条线，不允许移动。给定这一条线上任意两个位置之间（形成了一个区间）的收益值<span
class="math inline">\(value[\ le\ ][\ ri\
]\)</span>，现在需要将这K个数据的线分割成<span class="math inline">\(P(1
\leq P \leq
K)\)</span>段，求分割后的收益最大值/最小值（为了讲解方便，在第一章中我们统一用“最大值”）。</p>
<p>　　这种题型看上去有点像是区间DP，不过和正规的区间DP在dp数组定义、求解思路等方面都有一些差别。因为这种题型还是涉及到了“在区间中进行决策”，所以我们把它归于“区间DP”这个大类中来了。</p>
<h2 id="分析">1.2 分析</h2>
<p>　　因为我们需要将K个数据分割成N段，所以我们完全可以把这N段设置为N个阶段，这种划分满足“局部最优”和“无后效性”这两大特点，所以这种题型可以用dp这种大模型来搞定。</p>
<ol type="1">
<li>状态数组定义</li>
</ol>
<p>　　我们用状态数组dp来存放最大收益值。既然如此，我们的dp数组的维度就要能够准确地描述出一个唯一的状态，或者说是一种划分。划分不仅和“数据”有关，也和划分的“段”有关。所以有如下的二维数组定义：</p>
<p>　　dp[p][k]：<strong>把前k个数据划分成p段后得到的最大收益值；</strong></p>
<ol start="2" type="1">
<li><p>所求目标</p>
<p>dp[P][K]：把K个数据划分成P段后得到的最大收益值；</p></li>
<li><p>状态转移方程</p>
<p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240721150540525.png" alt="image-20240721150540525" style="zoom:80%;" />
<span class="math display">\[
dp[p][k]= dp[p-1][c]\ \ \ + value[c+1][k] \tag{1}
\]</span>
<font color="red"><strong>把前k个数据划分成p段的收益值　=　把前c个数据划分成p-1段的收益值　+　在从[c+1..k]这1段数据中获得的收益值（假设是求和值）</strong></font></p>
<p>上面的公式，只是一次划分或者一次“决策”。根据定义，还需要所有决策值比较，获得最大值。所以状态转移方程如下：
<span class="math display">\[
\begin{align}dp[p][k]=max(dp[p-1][c]+value[c+1][k]) \tag{2} \\
(1 \leq p \leq P,\quad p \leq k \leq K,\quad p-1 \leq c \leq k-1 )
\tag{}
\end{align}
\]</span></p>
<p>　　上面的公式（2）只是一个数学简式，并不是一个真正的C++代码。如果要转成代码，需要考虑max函数和循环的特点。伪代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[p][k]= -INF;  <span class="hljs-comment">// 初值设为负无穷，为“无解”状态的初始值， 以方便max运算出正确的结果</span><br><span class="hljs-keyword">for</span> (p)          <span class="hljs-comment">// 省略了部分代码</span><br>    <span class="hljs-keyword">for</span>(k)<br>        <span class="hljs-keyword">for</span>(c)<br>            dp[p][k]= <span class="hljs-built_in">max</span>(dp[p][k], dp[p<span class="hljs-number">-1</span>][c]+value[c+<span class="hljs-number">1</span>][k]);<br></code></pre></td></tr></table></figure>
<p>　　这里我们假设了整个划分方案的收益值是每个分段收益值之和，所以方程中出现了“dp<font color="red"><strong>+</strong></font>value”。这是一个假设，并不绝对。同学们不必死背公式，一定要理解着来推。</p></li>
<li><p>循环顺序和循环边界</p></li>
</ol>
<p>　　在公式（2）的状态转移方程中有3个变量，分别为p、k、c。第p行依赖于第p-1行，而c&lt;k。这里我们需要分析一下变量k和变量c的取值范围。</p>
<p>1）k：因为这种题型基本上都要求每段至少要有1个数据，所以要把k个数据划分成p段，必然要求<span
class="math inline">\(k \geq
p\)</span>，所以<strong>k的循环取值范围是[p..K]</strong>；对于状态[p][0..p-1]，一律视为“无解”的状态，赋予他们“无解”该有的初值即可。</p>
<p>2）c：<strong>决策点c值的循环取值范围是[p-1..k-1]</strong>，其详细推导过程如下，请展开阅读。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">假设现在有8个数据，需要分成3段。如果要求每段至少要有1个数据的话，划分结果只能是如下几种：<br>    1)　&#123;[1..1]、  [2..2（第3段的决策点c值）]、  [3..8]&#125;<br>    2)　&#123;[1..1]、  [2..3（第3段的决策点c值）]、  [4..8]&#125;<br>    3)　&#123;[1..2]、  [3..3（第3段的决策点c值）]、  [4..8]&#125;<br>          ......// 太多了，这里不全列出来了，<br>    *)　&#123;[1..4]、  [5..7（第3段的决策点c值）]、  [8..8]&#125;<br>    *)　&#123;[1..6]、  [7..7（第3段的决策点c值）]、  [8..8]&#125;<br>对于第2段的右端点（即划分第3段的决策点c值），只可能是2、3、4、5、6、7。<br>我们把上面的结果推广一下，如果有k个数据需要划分成p段，那么决策点c值的取值范围是[p-1..k-1]。记住这个结论。<br></code></pre></td></tr></table></figure>
<p>　　所以循环顺序如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// P 个阶段，每个阶段划分出一段，必须增序</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p=<span class="hljs-number">1</span>; p&lt;=P; p++)             <span class="hljs-comment">// [1..P]</span><br>    <span class="hljs-comment">// 增序、降序均可，数据来源于上一行</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=p; k&lt;=K; k++)          <span class="hljs-comment">// [p..K]或者[K..p]</span><br>        <span class="hljs-comment">// 必须增序，从左往右填</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=p<span class="hljs-number">-1</span>; c&lt;=k<span class="hljs-number">-1</span>; c++)  <span class="hljs-comment">// [p-1..k-1]</span><br></code></pre></td></tr></table></figure>
<p>　　可以看出，这是一个时间复杂度为<span
class="math inline">\(O(P*K^2)\)</span>的算法。</p>
<ol start="5" type="1">
<li>初始化和特例</li>
</ol>
<p>　　整个dp[0..P][0..K]数组并不会全部被填写。循环没有遍历到的网格，必然就是不可能出现的状态（例如dp[10][3]，把3个数据划分成10段，这没法搞，直接“无解”），所以整个dp数组需要初始化成“无解”状态对应的值。</p>
<p>　　对于特例，</p>
<p>　　dp[0][0]表示把前0个数据划分成0段后得到的最大收益值；这里没有提供任何数据，要求0段（即不划分），很简单，什么都不做即为合理的做法，收益值为0.</p>
<p>　　dp[0][1]表示把前1个数据划分成0段后得到的最大收益值；把1个数据划分为0段，描述不合理，无法实现，无解，收益值为“无解”对应的取值INF。</p>
<p>　　从上面两条可以看出，特例只有<strong>dp[0][0]=0</strong>,
而dp[0][1..K]则和其他行的数据一样，不是特例，应初始化为"无解"。</p>
<p>　　个别题可能会把dp[i][i]归于特殊情况，需要酌情考虑给予恰当的值。</p>
<h1 id="二实战训练">二、实战训练</h1>
<h2 id="p1281">2.1 1278/P1281</h2>
<h3 id="原题链接">2.1.1 原题链接</h3>
<p>　　<a
target="_blank" rel="noopener" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1278">1278：【例9.22】复制书稿(book)</a>/<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1281">P1281 书的复制</a></p>
<h3 id="分析-1">2.1.2 分析</h3>
<p>　　要求把K本书分给P个人，每个人分到的书必须是连续的，这实际上就是一个“线性有序条件下的分段”的问题。每个分段内所需时间为该分段内每一本书所需时间之和，而整个划分方案的收益值为该方案中所有分段内部所需时间的最大值。现在要求整个方案的最小所耗时间。看上去有点像个min(max(sum()))的架构，挺吓人的，哈哈～</p>
<ol type="1">
<li><p>状态数组定义</p>
<p>　　dp[p][k]：把前k本书划分给p段（每个人1段）后得到的最小时间值；</p></li>
<li><p>所求目标</p>
<p>　　dp[P][K]：把前K本书划分给P段（每个人1段）后得到的最小时间值；</p></li>
<li><p>状态转移方程</p>
<p>　　我们再来看这张图，</p>
<p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240721150540525.png" alt="image-20240721150540525" style="zoom:80%;" /></p>
<p>　　根据题意，dp[p][k]和dp[p-1][c]及value[c+1][k]之间并不是“求和”的关系，而是“取最大值”的关系。也就是说，dp[p][k]=<font color="red">max</font>(dp[p-1][c],value[c+1][k])。1个方案的值等于每个人所需时间的最大值。注意，这只是一个方案的值，并不是我们要求的“最优方案”。那最优方案该怎么求呢？题目说了，值最小的就是最优。所以：
<span class="math display">\[
dp[p][k]=min(\ max(dp[p-1][c],\ \ value[c+1][k])\ ) \tag{3}
\]</span> 　　<span
class="math inline">\(value[c+1][k]\)</span>原本表示的是把第[c+1..k]个数设为1个段而得到的收益值，在本题中其实就是第[c+1..k]本书所需时间之和。我们现在已知每本书所需的时间，而本题又需要频繁求任意两本书位置区间之和，所以最好的办法就是新建一个前缀和数组，采用sum[k]-sum[c]来表示出value[c+1][k]。所以状态转移方程进一步转化为：
<span class="math display">\[
\begin{align}dp[p][k]=min(\ max(dp[p-1][c],\ \ sum[k]-sum[c])\ ) \tag{4}
\\
(1 \leq p \leq P,\quad p \leq k \leq K,\quad p-1 \leq c \leq k-1 )
\tag{}
\end{align}
\]</span></p>
<p>　　上面的公式（4）只是一个数学简式，并不是一个真正的C++代码。如果要转成代码，需要考虑max函数和循环的特点。伪代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[p][k]= INF;   <span class="hljs-comment">// 初值设为负无穷，为“无解”状态的初始值， 以方便min运算出正确的结果</span><br><span class="hljs-keyword">for</span> (p)          <span class="hljs-comment">// 省略了部分代码</span><br>    <span class="hljs-keyword">for</span>(k)<br>        <span class="hljs-keyword">for</span>(c)<br>            dp[p][k]= <span class="hljs-built_in">min</span>( dp[p][k],   <span class="hljs-built_in">max</span>( dp[p<span class="hljs-number">-1</span>][c], sum[k]-sum[c]) );<br></code></pre></td></tr></table></figure></li>
<li><p>循环顺序和边界</p>
<p>　　和1.2节分析结果相同，照做即可。</p></li>
<li><p>初始化和特例</p>
<p>　　公式（4）里面有max，有min，当初始化dp数组为“无解”时，到底应该初始化为“INF”或者“-INF”呢？在公式（4）中我们需要先计算max，再来计算min。但是在做max运算时，所比较的对象中并没有dp[p][k]自身，而是把两个确切的值（dp[p-1][c]
和
sum[k]-sum[c]）做比较，这跟“赋初值”毫无关系，只是一个干扰项。<strong>真正实现累比的是min操作（因为min操作的其中一个比较对象是dp[p][k]它自己）。所以dp[p][k]的初值应该定义成针对min操作合适的初值对象，即INF</strong>。</p>
<p>　　关于特例，有dp[0][0]=0。而dp[0][1..K]，因为无法把前k本书划分给0个人，人都没有，怎么划分？所以其最小时间值为“无解”状态。这也是根据1.2节中的第5点分析而来。所以初始化和特例的处理应该是如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;  <span class="hljs-comment">// 在第0行只应对dp[0][0]做特殊处理</span><br></code></pre></td></tr></table></figure></li>
<li><p>输出方案</p>
<p>　　根据本题对dp数组的定义，dp[P][K]表示把前K本书划分给P个人后得到的最小时间值。在最优方案中，dp[P][K]又表示每个人所获页数的最大值（根据题目上对任一方案值的定义）。所以我们只需要按序分配书，并且让每个人的页数不超过dp[P][K]即可。可用递归函数来实现，不难。</p></li>
<li><p>优化</p>
<p>这个题是可以做平行四边形优化的，具体后面再说。</p></li>
</ol>
<h3 id="ac代码">2.1.3 AC代码</h3>
<h4 id="标准dp数组无优化输出方案">2.1.3.1
标准dp数组，无优化，输出方案</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法1. 可AC1278和P1281， 标准dp数组，无优化，输出方案</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 501</span><br><span class="hljs-type">int</span> K, P;<br><span class="hljs-type">int</span> page[N];         <span class="hljs-comment">// 存储每本书的页数</span><br><span class="hljs-type">int</span> dp[N][N];        <span class="hljs-comment">// dp[p][k]表示前 k 本书分给前 p 个人抄写的最短复制时间</span><br><span class="hljs-type">int</span> sum[N];          <span class="hljs-comment">// 用前缀和数组sum[]来方便处理，sum[p]表示前p本书的总页数</span><br><span class="hljs-comment">//打印输出把前k本书分给前p个人抄写的划分方案</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> c, s;<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 1278题允许P为0，P1281要求p至少为1。加本行才可以过1278题，否则只能过P1281 </span><br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-number">1</span>) &#123;         <span class="hljs-comment">// 如果只有1个人，把所有前k本书都给他吧</span><br>        cout &lt;&lt;<span class="hljs-number">1</span> &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt;k &lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    c = k;<br>    s = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 从第k本书开始，在dp[P][K]范围内往左一直分配，尽量多分配书给第p个人</span><br>    <span class="hljs-keyword">while</span>( s + page[c] &lt;= dp[P][K] ) &#123;<br>        s = s + page[c];<br>        c--;<br>    &#125;<br>    <span class="hljs-comment">// [c+1, k]之间的书已经分配给第p个人了，</span><br>    <span class="hljs-comment">// 下面接着分配[1, c]的书给剩下的p-1个人</span><br>    <span class="hljs-built_in">print</span>( p<span class="hljs-number">-1</span>, c );<br>    <span class="hljs-comment">// 为了体现正序，所以这里应该先追溯递归，然后再cout本次函数的分配方案</span><br>    cout &lt;&lt;c+<span class="hljs-number">1</span>  &lt;&lt;<span class="hljs-string">&quot; &quot;</span>  &lt;&lt;k  &lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> k, p;<br>    cin &gt;&gt;K &gt;&gt;P;           <span class="hljs-comment">// K本书，P个人</span><br>    <span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=K; k++) &#123;  <span class="hljs-comment">// K本书</span><br>        cin &gt;&gt;page[k];<br>        sum[k] = sum[k<span class="hljs-number">-1</span>] + page[k];<br>    &#125;<br>    <span class="hljs-comment">// 先要算出dp[P][K]，这样print函数才能用得上</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=<span class="hljs-number">1</span>; p&lt;=P; p++)      <span class="hljs-comment">// p个人</span><br><span class="hljs-comment">//      for(k=K; k&gt;=p; k--)  // k本书 增序降序均可 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=p; k&lt;=K; k++)  <span class="hljs-comment">// k本书</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=p<span class="hljs-number">-1</span>; c&lt;=k<span class="hljs-number">-1</span>; c++) <span class="hljs-comment">//</span><br>                dp[p][k] = <span class="hljs-built_in">min</span> (dp[p][k] , <span class="hljs-built_in">max</span>( dp[p<span class="hljs-number">-1</span>][c], sum[k]-sum[c] ));<br><br>    <span class="hljs-comment">// 这个题不光是要最短时间dp[P][K]，也要分配方案</span><br>    <span class="hljs-built_in">print</span>(P, K);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>样例对应的dp数组如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240722151409997.png" alt="image-20240722151409997" style="zoom:50%;" /></p>
<h4 id="滚动dp数组无优化输出方案">2.1.3.2
滚动dp数组，无优化，输出方案</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法2. 可AC1278和P1281，滚动dp数组，无优化，输出方案</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 501</span><br><span class="hljs-type">int</span> K, P;<br><span class="hljs-type">int</span> page[N];         <span class="hljs-comment">// 存储每本书的页数</span><br><span class="hljs-type">int</span> dp[N];           <span class="hljs-comment">// dp[k]表示前 k 本书分给前 p 个人抄写的最短复制时间</span><br><span class="hljs-type">int</span> sum[N];          <span class="hljs-comment">// 用前缀和数组sum[]来方便处理，sum[p]表示前p本书的总页数</span><br><span class="hljs-comment">//打印输出把前k本书分给前p个人抄写的划分方案</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> c, s;<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 1278题允许P为0，P1281要求p至少为1。加本行才可以过1278题，否则只能过P1281 </span><br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-number">1</span>) &#123;         <span class="hljs-comment">// 如果只有1个人，把所有前k本书都给他吧</span><br>        cout &lt;&lt;<span class="hljs-number">1</span> &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt;k &lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    c = k;<br>    s = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 从第k本书开始，在dp[K]范围内往左一直分配，尽量多分配书给第p个人</span><br>    <span class="hljs-keyword">while</span>( s + page[c] &lt;= dp[K] ) &#123;<br>        s = s + page[c];<br>        c--;<br>    &#125;<br>    <span class="hljs-comment">// [c+1, k]之间的书已经分配给第p个人了，</span><br>    <span class="hljs-comment">// 下面接着分配[1, c]的书给剩下的p-1个人</span><br>    <span class="hljs-built_in">print</span>( p<span class="hljs-number">-1</span>, c );<br>    <span class="hljs-comment">// 为了体现正序，所以这里应该先追溯递归，然后再cout本次函数的分配方案</span><br>    cout &lt;&lt;c+<span class="hljs-number">1</span>  &lt;&lt;<span class="hljs-string">&quot; &quot;</span>  &lt;&lt;k  &lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> k, p;<br>    cin &gt;&gt;K &gt;&gt;P;               <span class="hljs-comment">// K本书，P个人</span><br>    <span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=K; k++) &#123;  <span class="hljs-comment">// K本书</span><br>        cin &gt;&gt;page[k];<br>        sum[k] = sum[k<span class="hljs-number">-1</span>] + page[k];<br>    &#125;<br>    <span class="hljs-comment">// 先要算出dp[K]，这样print函数才能用得上</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=<span class="hljs-number">1</span>; p&lt;=P; p++)      <span class="hljs-comment">// p个人</span><br>        <span class="hljs-keyword">for</span>(k=K; k&gt;=p; k--)      <span class="hljs-comment">// k本书 滚动数组只能降序 </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=p<span class="hljs-number">-1</span>; c&lt;=k<span class="hljs-number">-1</span>; c++) <span class="hljs-comment">//</span><br>                dp[k] = <span class="hljs-built_in">min</span> (dp[k] , <span class="hljs-built_in">max</span>( dp[c], sum[k]-sum[c] ));<br><br>    <span class="hljs-comment">// 这个题不光是要最短时间dp[K]，也要分配方案</span><br>    <span class="hljs-built_in">print</span>(P, K);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="p4677">2.2 1197/P4677</h2>
<h3 id="原题链接-1">2.2.1 原题链接</h3>
<p>　　<a
target="_blank" rel="noopener" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1197">1197：山区建小学</a>/<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4677">P4677 山区建小学</a></p>
<h3 id="分析-2">2.2.2 分析</h3>
<p>　　题目比较难懂，先把测试样例的结果搞明白，往往有助于理解题意。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724103511313.png"
alt="image-20240724103511313" />
<figcaption aria-hidden="true">image-20240724103511313</figcaption>
</figure>
<p>　　把2个学校分别设置在2号村庄和7号村庄的话，各个村庄到附近学校的距离之和达到最小，为18。</p>
<h4 id="动态规划多步分析">2.2.2.1 动态规划多步分析</h4>
<p>　　理解了基本题意之后，我们来观察这张图，感觉这个题像是在“k个村庄中选择p个小学”的选择策略问题，而且每个小学会涵盖一个区间范围。所有K个小学被分割成了P个区间范围。每个区间范围内的村庄都去对应的小学上学。区间之间互不影响。下面我们用动态规划的分析思路来进行整理和细化。</p>
<ol type="1">
<li>状态数组定义</li>
</ol>
<p>dp[p][k]:
把前k个村庄分成p段，每1段内建立1个小学后,每段内每个村庄到各自段内小学的最短路程之总和</p>
<ol start="2" type="1">
<li>所求目标</li>
</ol>
<p>dp[P][K]:
把K个村庄分成P段，每1段内建立1个小学后,每段内每个村庄到各自段内小学的最短路程之总和</p>
<ol start="3" type="1">
<li>状态转移方程</li>
</ol>
<p>　　这个内容比较复杂，下面需要用较多的篇幅来讲述。</p>
<p>　　首先我们要意识到这是一个“把K个数据分为P段”策略问题，可以用dp来求最优解。</p>
<p>　　我们现在要计算dp[p][k]，也就是要填表格中第p行第k列的值。我们现在能利用的，就是已经填过值的数据，也就是表格中dp[p][k]所处位置以左或以上的数据，也就是例如dp[p-1][k]、dp[p-1][k-1]、dp[p-2][k]、dp[p-3][k-1]、dp[p-2][k-2]、...等这些数据。</p>
<p>　　为了方便说明，我们下面暂时以dp[3][6]为例，即在前6个村庄中选3个位置来作为学校，求所有村庄到附近小学的最短路径之和。很多时候，当我们在推导状态转移方程时，可以假设一些具体的数据，便于快速找到方法，再推广到普通的情况。</p>
<p>　　<strong>1）传统dp做法，让dp[p][k]去和dp[p][k-1]、dp[p-1][k-1]或者dp[p-1][k]等产生关联（不可行）</strong></p>
<p>　　如下图所示，先算出这6个点“ABCDEF”到其中2个点“B”和“D”的最短距离之和，即dp[2][6]。其中B和D是假定的学校位置，具有随机性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723141319295.png" alt="image-20240723141319295" style="zoom:67%;" /></p>
<p>　　然后再在剩下的4个点中新增第3个学校F，调整参与求和的距离，使得总和最小。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723141456308.png" alt="image-20240723141456308" style="zoom:67%;" /></p>
<p>　　可以看出，在把F点设置为学校之后，上面两个图在计算距离之和这方面，参与计算求和的多个距离值存在较大的不同。这样划分，使得上一个步骤计算出来的各种距离值化为乌有，不可再用，很多距离值都需要重新计算，会使得程序更难理解和处理，复杂度暴涨，放弃！而且这样设计，并没有体现出“把K个数据分为P段”当中的“段”的思想。</p>
<p>　　2）<strong>改进做法（可行，但需调整）</strong></p>
<p>　　当村庄和学校的位置都确定时，每个村庄都会到附近最近的学校去上学，这实际上已经形成了以多个学校为中心的片区。每个片区可以看成一个段。段与段之间的村庄不产生相互的联系。这实际上更像是“线性结构上分段”的类型。　　</p>
<p>　　如果要计算dp[3][6]，可以先算出前5个点“ABCDE”到其中2个点“B”和“D”的最短距离之和，即dp[2][5]（注意，“B”和“D”仍然是随便假定的学校位置）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723141808078.png" alt="image-20240723141808078" style="zoom:67%;" /></p>
<p>　　然后再在剩下的6-5=1个点中新增第3个学校“F”，<strong>并且要求前5个村庄不得到新增点的学校来上课（体现出了“段”的思想，不同段内的数据相互不产生任何联系）</strong>。这样可以保持之前已有的数据关系和数据值不变（可以使得划分具有“无后效性”和“局部最优”的特点，满足动态规划的基本要求），得到“在前6个点中设置3个学校的距离之和”的<strong>一个（注意，并不是唯一的）</strong>计算公式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723142122884.png" alt="image-20240723142122884" style="zoom:67%;" /></p>
<p>　　当然，这个公式肯定是存在一定问题的。从上面的图中可以看出，E点如果要去学校D，明显会比去学校F更远。也就是说，这种划分，虽然能很方便地利用之前dp数组的数据，但其结果却是不对的，还需要进一步修正。</p>
<p>　　上面这个结果的错误之处，在于这种划分不对。我们不应该划分成“ABCDE+F”的组合，这样会使得E点的孩子去学校D上学而不去更近的学校F。那除了“ABCDE+F”这种划分之外，还可以有其他的划分方法，即“空+ABCDEF”，“A+BCDEF”，“AB+CDEF”，“ABC+DEF”，“ABCD+EF”这五种。</p>
<p>　　<font color="red">正确的划分方法，肯定就在这六种划分方式中。我们可以遍历一遍，找出其中的最小值。哪个组合的距离之和最小，那对应的划分方法自然就是正确答案。</font></p>
<ul>
<li><del>空+ABCDEF—— dp[3][6] = dp[2][0] +
“ABCDEF中选一个点作为学校后其他5个点到该点的距离之和的最小值”</del>(无法在0个村庄中选2个学校，dp[2][0]必然无解，本策略无效，不必参与min比较)</li>
<li><del>A+BCDEF　—— dp[3][6] = dp[2][1] + “BCDEF
中选一个点作为学校后其他4个点到该点的距离之和的最小值”</del>(无法在1个村庄中选2个学校，dp[2][1]必然无解，本策略无效，不必参与min比较)</li>
<li>AB+CDEF　—— dp[3][6] = dp[2][2] + “CDEF
中选一个点作为学校后其他3个点到该点的距离之和的最小值”</li>
<li>ABC+DEF　—— dp[3][6] = dp[2][3] + “DEF
中选一个点作为学校后其他2个点到该点的距离之和的最小值”</li>
<li>ABCD+EF　—— dp[3][6] = dp[2][4] + “EF
中选一个点作为学校后其他1个点到该点的距离之和的最小值”</li>
<li>ABCDE+F　—— dp[3][6] = dp[2][5] + “F
中选一个点F作为学校后的距离的最小值（其实就是0了，自己到自己的距离）”</li>
</ul>
<p>　　从上面的6个式子可以看出，有一种信息需要频繁求取，而我们还没有对应的数据结构来表示它。那就是“在一段连续的村庄（假设为从第i个村庄到第j个村庄）中选一个点作为学校后，该段内其他所有点到该点的距离之和的最小值”。该如何表示这个信息呢？其实只需要把i和j表示出来即可。该信息表示的是最小值，所以不应该在数据结构中指定学校的位置。所以该结构只需要2个信息即可，就是i和j，我们可以<strong>用一个二维数据
Cost[i][j]
来表示从第i个村庄到第j个村庄这一个区间中选1个点作为学校后，该区间内其他点到该学校点的距离之和的最小值</strong>。</p>
<p>　　关于Cost[][]的值，怎么计算出来呢？这是本题比其他同类型题复杂的地方。题面上并没有直接给出Cost[][]的值，需要我们去计算出来。具体分析和计算过程，因为内容较多，为了避免冲淡主题，把这部分内容单独做成2.2.2.2小节，请同学们注意学习。下面的分析假设该数组C的值已经获得。</p>
<p>　　根据上面红色文字的叙述，我们可以总结出下面的公式来。 <span
class="math display">\[
\begin{align}dp[3][6]=min(\ &amp;dp[2][\textcolor{red}2]+Cost[3][6],
\tag{}\\ &amp;dp[2][\textcolor{red}3]+Cost[4][6],
\tag{}\\&amp;dp[2][\textcolor{red}4]+Cost[5][6], \tag{}\\
&amp;dp[2][\textcolor{red}5]+Cost[6][6]\ \ ) \tag{1}
\end{align}
\]</span></p>
<p>　　把公式（1）翻译成代码，那就是如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 公式1对应的代码如下：</span><br>dp[<span class="hljs-number">3</span>][<span class="hljs-number">6</span>]= INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=<span class="hljs-number">3</span><span class="hljs-number">-1</span>; c&lt;=<span class="hljs-number">6</span><span class="hljs-number">-1</span>; c++)  <span class="hljs-comment">// c表示公式（1）中的红色数字，代表了不同的分割策略</span><br>    dp[<span class="hljs-number">3</span>][<span class="hljs-number">6</span>]= <span class="hljs-built_in">min</span>( dp[<span class="hljs-number">3</span>][<span class="hljs-number">6</span>],  dp[<span class="hljs-number">3</span><span class="hljs-number">-1</span>][c] + Cost[c+<span class="hljs-number">1</span>][<span class="hljs-number">6</span>] );<br></code></pre></td></tr></table></figure>
<p>　　所以状态转移方程就是： <span class="math display">\[
dp[p][k]=min(dp[p][k],\ dp[p-1][c]\ + \ Cost[c+1][k]\ ) \\
(1 \leq p \leq P;\quad p \leq k \leq K;\quad p-1 \leq c\leq k-1)
\]</span></p>
<ol start="4" type="1">
<li><p>循环顺序和边界</p>
<p>p:
dp[p][k]的求解，需要且只需要用到上一行的数据，所以p只能增序，[1..P]；</p>
<p>k:
既然是只用到上一行的数据，所以k可以增序，也可以降序。在本题中，如果村庄数k少于学校数p，是不合理的，无解，所以只需要填写<span
class="math inline">\(k \geq
p\)</span>的情况。所以循环顺序和边界为[p..K]，或者[K..p];</p>
<p>c:
策略c在dp的第二维，对于状态[p-1][c]来说，第二维的数字c不能小于第一维的数字p-1（否则该状态无解，不应参与比较，即使参与了也是白比），所以c的范围是[p-1,
k-1]。增序降序均可。先比哪个策略，后比哪个策略，这个顺序并不重要，最终都要比完所有的策略。</p></li>
<li><p>初始化和特例</p></li>
</ol>
<p>　　因为状态可能存在无解，所以dp数组初始化为无解，在本题中对应的就是INF。</p>
<p>　　根据1.2节第5点的分析，dp[0][0]=0。而对于dp[0][1..K]，在k个村庄中设置0个学校，把k个数据划分为0段，描述不合理，无解。</p>
<h4 id="推导cost数组">2.2.2.2 推导Cost数组</h4>
<p>　　Cost数组是状态转移方程中非常重要的一个数据结构。Cost[le][ri]
来表示从第le个村庄到第ri个村庄这一个区间中选1个点作为学校后，该区间内其他点到该学校点的距离之和的最小值。该如何找规律来计算呢？老规矩，草稿纸上画样例，先看看样例具有什么样的规律。下面以6个村庄中找1个学校为例来分析。</p>
<p>1）以1号点为学校，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724114648838.png" alt="image-20240724114648838" style="zoom:50%;" /></p>
<p>2）以2号点为学校，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724114610444.png" alt="image-20240724114610444" style="zoom:50%;" /></p>
<p>3）以3号点为学校，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724113906535.png" alt="image-20240724113906535" style="zoom:50%;" /></p>
<p>4）以4号点为学校，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724114049227.png" alt="image-20240724114049227" style="zoom:50%;" /></p>
<p>5）以5号点为学校，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724114250586.png" alt="image-20240724114250586" style="zoom:50%;" /></p>
<p>6）以6号点为学校，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240724114501124.png" alt="image-20240724114501124" style="zoom:50%;" /></p>
<p>　　把上面6种方案的距离值进行对比，可以发现，不管红黄绿蓝紫的路径值为多少，必然会有：</p>
<p>　　5红4黄3绿2蓝1紫(以1号为学校) &gt;= 1红4黄3绿2蓝1紫(以2号为学校)
&gt;= <strong>1红2黄3绿2蓝1紫(以3号为学校)==
1红2黄3绿2蓝1紫(以4号为学校)</strong> &lt;= 1红2黄3绿4蓝1紫(以5号为学校)
&lt;= 1红2黄3绿4蓝5紫(以6号为学校)</p>
<p>　　也就是说，在这串村庄组成的线性结构中，<strong>取区间中点位置的点作为村庄，总距离之和是最小的，不管各个点之间的线性距离是多少。</strong>当这些点为奇数个时，直接取中点作为学校；当这些点为偶数个时，取中间两个点都能得到最小值。</p>
<p>　　搞清楚了这一点，我们就能确定任意一个指定区间[le,
ri]中学校的位置为(le+ri)/2。</p>
<p>　　下一步要做什么呢？下一步就是计算该区间内所有点到该学校点的距离之和了。这里有一个小问题需要解决，在确定好学校点之后，如何以最快捷方便的办法计算出该区间内所有点到学校点的距离之和呢？题目上只告知了每相邻2个点之间的距离值。其实方法很简单，因为所有点都正好在一个线形上，任意两点之间的距离值，就变成了两点之间所有相邻点距离值之和，这实际上是个“区间和”的问题，所以用前缀和数组就能搞定了。</p>
<p>　　相关的局部代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=K; i++)  <span class="hljs-comment">// 村庄从1开始编号，sum[1]=0 </span><br>   	cin &gt;&gt;sum[i], sum[i]+= sum[i<span class="hljs-number">-1</span>];<br><span class="hljs-comment">// cost[i][j]：第i~j个村庄之间建立1所小学，这几个村庄到这个小学的最小距离之和。 </span><br>   <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> le=<span class="hljs-number">1</span>; le&lt;=K; le++)<br>   	<span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> ri=le; ri&lt;=K; ri++)&#123;<br>       	<span class="hljs-type">int</span> mid = (le+ri) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// 把这所小学定在第mid个村庄，使得第i~j个村庄到这个小学距离之和最小  </span><br>       	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=le; k&lt;=ri; k++)<br>       		cost[le][ri] += <span class="hljs-built_in">abs</span>(sum[mid] - sum[k]); <span class="hljs-comment">// 算出这个距离之和，然后填表cost </span><br>  		&#125;<br></code></pre></td></tr></table></figure>
<h3 id="ac代码-1">2.2.3 AC代码</h3>
<p>　　在不考虑平行四边形优化的前提下，本题的朴素代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//dp，标准状态数组，无优化</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 法1： 朴素做法，标准状态数组dp[][]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1001</span><br><span class="hljs-type">int</span> K, P;<br><span class="hljs-type">int</span> sum[N];     <span class="hljs-comment">// 距离的前缀和数组， </span><br><span class="hljs-type">int</span> cost[N][N]; <span class="hljs-comment">// cost[10][20]=400表示从第[10..20]个小学内设置一个学校后，这11个村庄到这所小学的最短距离之和 </span><br><span class="hljs-type">int</span> dp[N][N];   <span class="hljs-comment">//前 k个村庄放 p 个小学时的“村校最小距离和”（即: 所有小学到附近村庄的最小距离之和）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> i, j, p, k, le, rt;<br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); <br>	<span class="hljs-comment">// K村庄数     P小学数 </span><br>    cin &gt;&gt;K &gt;&gt;P;<br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">2</span>; i&lt;=K; i++)  <span class="hljs-comment">// 村庄从1开始编号，sum[1]=0 </span><br>    	cin &gt;&gt;sum[i], sum[i]+= sum[i<span class="hljs-number">-1</span>];<br>    	<br>    <span class="hljs-comment">// 根据上面的数组(任意两村之间的距离)，填数组cost[][]的右上部分，对角线上全0 </span><br>	<span class="hljs-comment">// cost[i][j]：第i~j个村庄之间建立1所小学，这几个村庄到这个小学的最小距离之和。 </span><br>    <span class="hljs-keyword">for</span>( le=<span class="hljs-number">1</span>; le&lt;=K; le++)<br>    	<span class="hljs-keyword">for</span>( rt=le; rt&lt;=K; rt++)&#123;<br>        	<span class="hljs-type">int</span> mid = (le+rt) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// 把这所小学定在第mid个村庄，使得第i~j个村庄到这个小学距离之和最小  </span><br>        	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=le; k&lt;=rt; k++)<br>        		cost[le][rt] += <span class="hljs-built_in">abs</span>(sum[mid] - sum[k]); <span class="hljs-comment">// 算出这个距离之和，然后填表cost </span><br>   		&#125;<br>    <br>	<span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp)); <br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <br>    <span class="hljs-keyword">for</span>( p=<span class="hljs-number">1</span>; p&lt;=P; p++)       <span class="hljs-comment">// p个小学   1&lt;=p&lt;=P</span><br>	    <span class="hljs-keyword">for</span>( k=p; k&lt;=K; k++)   <span class="hljs-comment">// k个村庄 , p&lt;=k&lt;=K    </span><br><span class="hljs-comment">//	    for( k=K; k&gt;=p; k--)   // 标准数组，k增序降序都可以  </span><br>        	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=k<span class="hljs-number">-1</span>; c&gt;=p<span class="hljs-number">-1</span>; c--)  <span class="hljs-comment">// c个分隔点（策略），p-1&lt;= c &lt;=k-1, 增序降序都可以！ </span><br>            	dp[p][k] = <span class="hljs-built_in">min</span>(dp[p][k],  dp[p<span class="hljs-number">-1</span>][c] + cost[c+<span class="hljs-number">1</span>][k]);<br><br>    cout &lt;&lt;dp[P][K]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">雪宝和七七的爸爸</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/07/21/%E5%8C%BA%E9%97%B4%E5%88%86%E6%AE%B5dp%EF%BC%88%E2%80%9C%E8%90%9D%E5%8D%9C%E5%A1%AB%E5%9D%91%E2%80%9D%EF%BC%89%E6%A8%A1%E5%9E%8B/">http://example.com/2024/07/21/%E5%8C%BA%E9%97%B4%E5%88%86%E6%AE%B5dp%EF%BC%88%E2%80%9C%E8%90%9D%E5%8D%9C%E5%A1%AB%E5%9D%91%E2%80%9D%EF%BC%89%E6%A8%A1%E5%9E%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">宝爸编程</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BF%A1%E6%81%AF%E5%AD%A6/">信息学</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/31/%E5%8C%BA%E9%97%B4dp(%E9%93%BE)%E6%A8%A1%E5%9E%8B/" title="区间dp(链)模型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">区间dp(链)模型</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/02/%E4%B8%89%E7%A7%8D%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E7%9A%84%E5%A4%84%E7%90%86/" title="三种分组背包的处理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">三种分组背包的处理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/04/25/LCS%E9%97%AE%E9%A2%98/" title="最长公共子序列（LCS）问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-25</div><div class="title">最长公共子序列（LCS）问题</div></div></a></div><div><a href="/2024/04/25/LIS%E9%97%AE%E9%A2%98/" title="最长不下降子序列（LIS）问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-25</div><div class="title">最长不下降子序列（LIS）问题</div></div></a></div><div><a href="/2020/03/13/hello/" title="我的第一篇博客"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-13</div><div class="title">我的第一篇博客</div></div></a></div><div><a href="/2024/07/31/dp%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E8%AE%AD%E7%BB%83/" title="dp中的状态转移训练"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-31</div><div class="title">dp中的状态转移训练</div></div></a></div><div><a href="/2024/07/02/%E4%B8%89%E7%A7%8D%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E7%9A%84%E5%A4%84%E7%90%86/" title="三种分组背包的处理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-02</div><div class="title">三种分组背包的处理</div></div></a></div><div><a href="/2024/03/06/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/" title="二分查找和二分答案"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-06</div><div class="title">二分查找和二分答案</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">雪宝和七七的爸爸</div><div class="author-info__description">本博客致力于信息学奥赛知识学习。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://cspcoding.github.io/"><i class="fab fa-github"></i><span>回到主页</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">玩游戏害人害己哦！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E7%90%86%E8%AE%BA%E6%95%99%E5%AD%A6"><span class="toc-text">一、理论教学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E8%AF%B4%E6%98%8E"><span class="toc-text">1.1 模型说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-text">1.2 分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%AE%9E%E6%88%98%E8%AE%AD%E7%BB%83"><span class="toc-text">二、实战训练</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#p1281"><span class="toc-text">2.1 1278&#x2F;P1281</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5"><span class="toc-text">2.1.1 原题链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-1"><span class="toc-text">2.1.2 分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ac%E4%BB%A3%E7%A0%81"><span class="toc-text">2.1.3 AC代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86dp%E6%95%B0%E7%BB%84%E6%97%A0%E4%BC%98%E5%8C%96%E8%BE%93%E5%87%BA%E6%96%B9%E6%A1%88"><span class="toc-text">2.1.3.1
标准dp数组，无优化，输出方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8dp%E6%95%B0%E7%BB%84%E6%97%A0%E4%BC%98%E5%8C%96%E8%BE%93%E5%87%BA%E6%96%B9%E6%A1%88"><span class="toc-text">2.1.3.2
滚动dp数组，无优化，输出方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#p4677"><span class="toc-text">2.2 1197&#x2F;P4677</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5-1"><span class="toc-text">2.2.1 原题链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-2"><span class="toc-text">2.2.2 分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%A4%9A%E6%AD%A5%E5%88%86%E6%9E%90"><span class="toc-text">2.2.2.1 动态规划多步分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BCcost%E6%95%B0%E7%BB%84"><span class="toc-text">2.2.2.2 推导Cost数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ac%E4%BB%A3%E7%A0%81-1"><span class="toc-text">2.2.3 AC代码</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/01/%EF%BC%88%E4%B8%89%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/" title="（三）宽度小于等于m的区间的“最大的和值”问题">（三）宽度小于等于m的区间的“最大的和值”问题</a><time datetime="2025-01-01T09:38:09.649Z" title="发表于 2025-01-01 17:38:09">2025-01-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/01/%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9B%BA%E5%AE%9A%E5%AE%BD%E5%BA%A6%E4%B8%BAm%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/" title="（二）固定宽度为m的区间的“最大的和值”问题">（二）固定宽度为m的区间的“最大的和值”问题</a><time datetime="2025-01-01T09:38:09.640Z" title="发表于 2025-01-01 17:38:09">2025-01-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/01/%EF%BC%88%E4%B8%83%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84m%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/" title="（七）不限宽的m子段的“最大的和值”问题">（七）不限宽的m子段的“最大的和值”问题</a><time datetime="2024-12-31T16:00:00.000Z" title="发表于 2025-01-01 00:00:00">2025-01-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/31/%EF%BC%88%E5%85%AD%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%842%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/" title="（六）不限宽的2子段的“最大的和值”问题">（六）不限宽的2子段的“最大的和值”问题</a><time datetime="2024-12-30T16:00:00.000Z" title="发表于 2024-12-31 00:00:00">2024-12-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/30/%EF%BC%88%E4%BA%94%EF%BC%89%E7%8E%AF%E7%8A%B6%E7%9A%84%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/" title="（五）环状的不限宽的区间的“最大的和值”问题">（五）环状的不限宽的区间的“最大的和值”问题</a><time datetime="2024-12-29T16:00:00.000Z" title="发表于 2024-12-30 00:00:00">2024-12-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 雪宝和七七的爸爸</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>