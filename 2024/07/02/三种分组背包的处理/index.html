<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>三种分组背包的处理 | 宝爸编程</title><meta name="author" content="雪宝和七七的爸爸"><meta name="copyright" content="雪宝和七七的爸爸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、理论教学 1.1 分组背包的题型和分类 　　一个背包的总约束量为YS1，有n个物品，约束量分别为\(ys1[1]、ys1[2]、...、ys1[n]\),收益量分别为\(value[1]、value[2]、...、value[n]\),这n个物品被划分为了若干组，在选择物品时每个组遵循一个共同的规则要求，求解在这种规则要求下选出来的物品的约束量之和不超过YS1的情况下，其物品组合的最大收益">
<meta property="og:type" content="article">
<meta property="og:title" content="三种分组背包的处理">
<meta property="og:url" content="http://example.com/2024/07/02/%E4%B8%89%E7%A7%8D%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E7%9A%84%E5%A4%84%E7%90%86/index.html">
<meta property="og:site_name" content="宝爸编程">
<meta property="og:description" content="一、理论教学 1.1 分组背包的题型和分类 　　一个背包的总约束量为YS1，有n个物品，约束量分别为\(ys1[1]、ys1[2]、...、ys1[n]\),收益量分别为\(value[1]、value[2]、...、value[n]\),这n个物品被划分为了若干组，在选择物品时每个组遵循一个共同的规则要求，求解在这种规则要求下选出来的物品的约束量之和不超过YS1的情况下，其物品组合的最大收益">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-07-01T16:00:00.000Z">
<meta property="article:modified_time" content="2024-07-25T06:17:26.431Z">
<meta property="article:author" content="雪宝和七七的爸爸">
<meta property="article:tag" content="信息学">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/07/02/%E4%B8%89%E7%A7%8D%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E7%9A%84%E5%A4%84%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":5,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '三种分组背包的处理',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-07-25 14:17:26'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/static/css/custom.css"><link rel="stylesheet" href="/fonts/font.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="宝爸编程"><span class="site-name">宝爸编程</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">三种分组背包的处理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-01T16:00:00.000Z" title="发表于 2024-07-02 00:00:00">2024-07-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-25T06:17:26.431Z" title="更新于 2024-07-25 14:17:26">2024-07-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">基础算法</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/">背包问题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="三种分组背包的处理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一理论教学">一、理论教学</h1>
<h2 id="分组背包的题型和分类">1.1 分组背包的题型和分类</h2>
<p>　　一个背包的总约束量为YS1，有n个物品，约束量分别为<span
class="math inline">\(ys1[1]、ys1[2]、...、ys1[n]\)</span>,收益量分别为<span
class="math inline">\(value[1]、value[2]、...、value[n]\)</span>,这n个物品被划分为了若干组，在选择物品时每个组遵循一个共同的<font color="red">规则要求</font>，求解在这种规则要求下选出来的物品的约束量之和不超过YS1的情况下，其物品组合的<strong>最大收益值</strong>。</p>
<p>　　上述的<font color="red">规则要求</font>，可分为以下三类，分别对应着三种类型的分组背包题型：</p>
<ol type="1">
<li>每组物品选的物品个数<font color="red">&lt;=</font>1个：每组内的物品之间相互冲突，最多只能选一个，允许不选；</li>
<li>每组物品选的物品个数<font color="red">==</font>1个：每组内的物品之间相互冲突，只能选一个，不能多，也不能少；</li>
<li>每组物品选的物品个数<font color="red">&gt;=</font>1个：每组内的物品之间不冲突，至少选一个，可以多选，但不允许不选；</li>
</ol>
<p>　　需要指出的是，分组背包支持多维费用，求解时也并不一定是“&lt;=YS1”情况下的最大收益值，也支持其他情况，求解方式大同小异。同学们可以自己去思考拓展。</p>
<h2 id="题型1每组物品选的物品个数1个">1.2
题型1：每组物品选的物品个数<font color="red">&lt;=</font>1个</h2>
<p>　　这种题型在普及组中出现得较多，是最基础的分组背包题型。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240716100733859.png"
alt="image-20240716100733859" />
<figcaption aria-hidden="true">image-20240716100733859</figcaption>
</figure>
<p>　　我们来分析一下上面的样例数据，看看怎么破解这种题型。YS1=10，6个物品，一共被分为了3组。我们需要针对每一组内的物品来做考虑，但是录入的时候，物品编号是全局的编号值，并非组内的序号，这会给我们遍历每一组内的所有物品带来不便。所以我们需要用idx[][]数组来转换一下全局编号和组内序号之间的关系。这个数组的填写过程可以在录入所有物品的同时就完成。idx[2][0]=2表示第2组一共有2个物品；idx[2][2]=4表示第2组的第2个物品的编号是4号。在这种结构下，我们可以使用如下的代码来遍历访问第g组所有物品的ys1[]值和value[]值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)&#123;<br>	cout &lt;&lt; ys1[ idx[g][k] ] &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt;value[ idx[g][k] ] &lt;&lt;endl; <span class="hljs-comment">// 注意idx[g][k]返回的是i值，即物品的全局编号值i</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240716111815053.png" alt="image-20240716111815053" style="zoom:80%;" /></p>
<p>　　我们用dp[][]数组来表示物品组合的最大收益值，<strong>但因为有分组的约束，所以这里第一维不能是全局编号i了，而应该是组号g</strong>。第二维仍然是约束总量j。所以<strong>dp[g][j]表示“前g组中所选物品在不超过总约束量为j的前提下，物品组合的最大收益值”</strong>。根据这个定义，本题的所求目标就是dp[maxg][YS1]了（假设一共有maxg组物品）。</p>
<p>　　既然是分组背包，那我们就只能一组一组地来做选择，所以在填写dp[][]数组时，第一层循环应该是for(int
g=1; g&lt;=maxg;
g++)了。处理完一组的所有物品之后，再去处理下一组的所有物品。这里遇到一个问题：请问第二层循环应该是什么呢？是for
j呢，或者是for
组内物品k？其实两种方法都是可以的，但要小心在初始化或者if语句或者循环边界上的一些微小的差别。</p>
<h3 id="先for-组内物品k再for-j重点掌握">1.2.1 先for 组内物品k，再for
j（重点掌握）</h3>
<p>　　第一层是for
g，针对每一组进行循环，在所有题型中都一样，这里就不专门去写了，我们重点分析第二层和第三层。第二层循环是for
组内物品k，即针对第g组的所有物品去做第三层循环的操作（只能是for
j了，即遍历填写dp[g][0..YS1]），即如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（1），组内最多选1件，先for 组内物品k 再 for j，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>	dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br><span class="hljs-comment">// 开始循环填写</span><br>......<span class="hljs-comment">// k=1 针对该组的第1个物品，j的循环范围为[YS1..ys1[ idx[g][1]] ]</span><br>dp[g][<span class="hljs-number">50</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">50</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] );  <span class="hljs-comment">// j=50，如果50&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">51</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">51</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] );  <span class="hljs-comment">// j=51，如果51&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">52</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">52</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] );  <span class="hljs-comment">// j=52，如果52&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">53</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">53</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">53</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] );  <span class="hljs-comment">// j=53，如果53&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>...<br>......<span class="hljs-comment">// k=2 针对该组的第2个物品，j的循环范围为[YS1..ys1[ idx[g][2]] ]</span><br>dp[g][<span class="hljs-number">50</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">50</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] );  <span class="hljs-comment">// j=50，如果50&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">51</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">51</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] );  <span class="hljs-comment">// j=51，如果51&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">52</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">52</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] );  <span class="hljs-comment">// j=51，如果51&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">53</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">53</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">53</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] );  <span class="hljs-comment">// j=53，如果53&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>...<br>......<span class="hljs-comment">// k=3 针对该组的第3个物品，j的循环范围为[YS1..ys1[ idx[g][3]] ]</span><br>dp[g][<span class="hljs-number">50</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">50</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] );  <span class="hljs-comment">// j=50，如果50&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">51</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">51</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] );  <span class="hljs-comment">// j=51，如果51&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">52</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">52</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] );  <span class="hljs-comment">// j=52，如果52&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">53</span>]=<span class="hljs-built_in">max</span>(dp[g][<span class="hljs-number">53</span>], dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">53</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] );  <span class="hljs-comment">// j=53，如果53&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>...<br><br></code></pre></td></tr></table></figure>
<p>　　上面的代码（1）整合之后的等效代码（2）如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（2），等效于代码（1），组内最多选1件，先for 组内物品k 再 for j，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>	dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br><span class="hljs-comment">// 开始循环填写</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>		dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[idx[g][k]]] + value[idx[g][k]] );<br></code></pre></td></tr></table></figure>
<p>　　上面的代码（2）是针对“第g组为‘组内最多选择1件物品’”的情况。如果所有组的物品都是“组内最多选择1件物品”的话，则在代码（2）的外面套一个对所有组的循环即可，得到如下的代码（3）.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（3），所有组都只能组内最多选1件，先for 组内物品k 再 for j，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=maxg; g++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>	    dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>	    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>		    dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[idx[g][k]]] + value[idx[g][k]] );<br>&#125;<br></code></pre></td></tr></table></figure>
<p>　　如果对dp[][]采用滚动数组，看上去好像可以把代码（3）进一步演变为如下代码（4）所示，但实际上这个代码是错误的!</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（4），错误代码！错误代码！所有组都只能组内最多选1件，先for 组内物品k 再 for j，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=maxg; g++)<br>    <span class="hljs-comment">// 不需要再“照抄上一行数据”了，下面的写法已经隐含地包括了对“不选任何物品”这个选择的max比较了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>	    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 必须只能倒序！</span><br>		    dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dp[j-ys1[idx[g][k]]] + value[idx[g][k]] );<br></code></pre></td></tr></table></figure>
<p>　　错误的原因就在于在代码（4）的第5、6行执行时，可能会把一些dp[]值进行更改为新值（选择了当前组的某个物品价值更大），这会使得对该组后续的其他物品进行选择考虑时，本应该做dp[g][j]=
max( dp[g][j], dp[g-1][j-ys1[idx[g][k]]] + value[idx[g][k]]
);，但因为dp[j]被改过，所以它表达的实际上已经是dp[g][j]的值，而不是dp[g-1][j]的值了，如果此时再去选，会造成该组同时选择2个或多个物品。举个例子：</p>
<p>　　假如第1组现在有2个物品，成本分别是2斤、3斤，收益对应分别为1元和3元。如果我们按照代码（4）来做的话，当第1个物品处理结束后，dp[0..YS1]值会是{0,0,1,1,1,1,1,1,...}。在这种情况下，去处理第二个物品时，dp[0..YS1]会是{0,0,1,3,3,4,4,4,4,....}。这是错误的。实际上dp[0..YS1]的正确答案应该是{0,0,1,3,3,3,3,....}。之所以出现这种情况，是因为代码（4）在处理第二个物品时，做了dp[5]=max(dp[5],
dp[2]+3)=max(1,
1+3)=4，而实际上应该是dp[5]=max(dp[5],dp[2]+3)=max(1,0+3)=3。这里的dp[2]错误地取成了1（表示已选了第1个物品），本应该是0。</p>
<p>　　找到问题之后，解决方法如下代码（５）所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（５），正确代码！所有组都只能组内最多选1件，先for 组内物品k 再 for j，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=maxg; g++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--) <br>        dptmp[j]=dp[j];     <span class="hljs-comment">// 用dptmp[0..YS1]来存dp[g-1][0..YS1] </span><br>    <span class="hljs-comment">// 不需要再“照抄上一行数据”了，下面的写法已经隐含地包括了对“不选任何物品”这个选择的max比较了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>	    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 必须只能倒序！</span><br>            <span class="hljs-comment">// dptmp[]表示的是dp[g-1][] !!</span><br>		    dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dptmp[j-ys1[idx[g][k]]] + value[idx[g][k]] );<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="先for-j再for-组内物品k">1.2.2 先for j，再for 组内物品k</h3>
<p>　　第二层循环是for
j，即针对所有的总约束量j去做第三层循环的操作（只能是for
组内物品k了，即遍历该组的每个物品），即如下代码（6）所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（6），所有组都只能组内最多选1件，先for j 再 for 组内物品k，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>	dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br>......<span class="hljs-comment">// j=50</span><br>dp[g][<span class="hljs-number">50</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] ); <span class="hljs-comment">// k=1，如果50&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">50</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] ); <span class="hljs-comment">// k=2，如果50&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">50</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">50</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] ); <span class="hljs-comment">// k=3，如果50&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>...<br>......<span class="hljs-comment">// j=51</span><br>dp[g][<span class="hljs-number">51</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] ); <span class="hljs-comment">// k=1，如果51&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">51</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] ); <span class="hljs-comment">// k=2，如果51&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">51</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">51</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] ); <span class="hljs-comment">// k=3，如果51&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>...<br>......<span class="hljs-comment">// j=52</span><br>dp[g][<span class="hljs-number">52</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">1</span>] ]]+value[ idx[g][<span class="hljs-number">1</span>] ] ); <span class="hljs-comment">// k=1，如果52&gt;=ys1[ idx[g][1] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">52</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">2</span>] ]]+value[ idx[g][<span class="hljs-number">2</span>] ] ); <span class="hljs-comment">// k=2，如果52&gt;=ys1[ idx[g][2] ]则执行本行代码</span><br>dp[g][<span class="hljs-number">52</span>]  =<span class="hljs-built_in">max</span>(dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>],   dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">52</span>-ys1[ idx[g][<span class="hljs-number">3</span>] ]]+value[ idx[g][<span class="hljs-number">3</span>] ] ); <span class="hljs-comment">// k=3，如果52&gt;=ys1[ idx[g][3] ]则执行本行代码</span><br>...<br></code></pre></td></tr></table></figure>
<p>　　仔细把代码（1）和上面的代码（6）进行比对，你会发现其实他们是等效的，只是语句的顺序不太一样而已。把上面的代码（6）整合，得到等效的代码（7）如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（7），等效于代码（6），所有组都只能组内最多选1件，先for j 再 for 组内物品k，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>	dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] )  <span class="hljs-comment">// 因为在第4行还没有k，无法写出j&gt;=ys1[ idx[g][k] ]，所以只能在这里写！</span><br>            dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br></code></pre></td></tr></table></figure>
<p>　　注意，代码（7）中的第2、3行代码，其实是可以整合到下面的循环中去的，得到等效的代码（8）如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（8），等效于代码（7），所有组都只能组内最多选1件，先for j 再 for 组内物品k，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>    dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];     <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] )  <span class="hljs-comment">// 因为在第4行还没有k，无法写出j&gt;=ys1[ idx[g][k] ]，所以只能在这里写！</span><br>            dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br>&#125;<br></code></pre></td></tr></table></figure>
<p>　　如果对dp[][]采用滚动数组，则可以把代码（8）进一步演变为如下代码（9）所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（9），等效于代码（8），所有组都只能组内最多选1件，先for j 再 for 组内物品k，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>    <span class="hljs-comment">// 不需要再“照抄上一行数据”了，下面的写法已经隐含地包括了对“不选任何物品”这个选择的max比较了</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] )  <span class="hljs-comment">// 因为在第2行还没有k，无法写出j&gt;=ys1[ idx[g][k] ]，所以只能在这里写！</span><br>            dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dp[j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br>&#125;<br></code></pre></td></tr></table></figure>
<p>　　上面的代码（9）是针对“第g组为‘组内最多选择1件物品’”的情况。如果所有组的物品都是“组内最多选择1件物品”的话，则在代码（9）的外面套一个对所有组的循环即可，得到如下的代码（10）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（10），所有组都只能组内最多选1件，先for j 再 for 组内物品k，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=maxg; g++)   <span class="hljs-comment">// 对每一组进行</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>            <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] ) <br>                dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dp[j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>　　我们现在可以来比较这两种方法，会发现各种版本的代码都各有千秋，不存在哪个版本绝对精简。希望同学们尽量都能推导，要懂得灵活处理，理解原理，没必要死记硬背，很容易背错。滚动数组看起来虽然方便，但理解困难，容易出错。标准数组理解起来方便一些，但涉及初值赋予，多占空间。鉴于分组背包的复杂性和易错，建议基础薄弱的同学们最好是首先考虑标准状态数组。</p>
<h2 id="题型2每组物品选的物品个数-1个">1.3
题型2：每组物品选的物品个数<font color="red">= =</font>1个</h2>
<p>题型2和题型1的区别在于：每一组必须要选择一个物品。这种区别会带来一些变化如下：</p>
<ol type="1">
<li><p>因为每一组要求必须要选择一个物品，在“总成本量&lt;=j”的这个限制条件下，有可能无法选择任何一个物品，即无解。例如假设第g组所有物品的成本量都超过了100，则dp[g][0..99]都肯定是无解的，无法选出，只能无解。</p></li>
<li><p>既然要求每组不能不选物品，那么就不能再用dp[g][j]=dp[g-1][j]了，因为这行代码表示“本组不选任何物品”。因为可能存在本组无解的情况，所以dp[g][j]的初值应该对应着“无解”。如果在计算的过程中发现有解，则应该替换覆盖原来的初值。</p></li>
</ol>
<p>　　对于“无解”的处理，在<a href="/2024/05/27/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98/">《背包问题的初始化问题》</a>中的1.3节中专门讨论过各种题型对“无解”这个状态的理解。同学们可以回看一下。</p>
<p>　　<strong>分组背包模型中，对“无解”的处理，总结出来如下三点：</strong></p>
<p>　　1.<strong>首先应该看当前题型是否可能存在“无解”的状态（在分组背包中，只有"当前组必须要选1个或者至少选1个"的题型才存在“无解（如果选不出来就意味着无解）”的状态）。如果可能存在，那么</strong></p>
<p>　　　　1）<strong>如果dp表示最大值，则初始化时dp[1..gcnt][<font color="red">0</font>..YS1]=
-INF；</strong></p>
<p>　　　　2）<strong>如果dp表示方案数，则初始化时dp[1..gcnt][<font color="red">1</font>..YS1]=0,
dp[0][0]=1；</strong></p>
<p>　　　　3）<strong>如果dp表示最小值，则初始化时dp[1..gcnt][<font color="red">0</font>..YS1]=
INF。</strong></p>
<p>　　2.
<strong>不管当前题型是否存在无解的情况，dp[<font color="red">0</font>][0..YS1]都应该要设置为全0（若表示方案数，dp[0][0]=1,dp[0][1..YS1]=0）！因为在任何情况下，如果连组都没有（g==0，表示“尚未开始选择”），那肯定收益值是0，方案数是1（“什么都不做”）。从另外一个角度来看，如果第0行全是-INF或者INF的话，就没法更新dp数组下面的每行数据（因为每组题型的dp[g][]都依赖于dp[g-1][]）了。</strong></p>
<p>　　3.
这里需要小心容易被同学们忽略的地方，那就是“对第0列的处理”。虽然第0行属于特例，需要单独处理，但是第0列并不是特例！当dp数组表示最大值或者最小值，并且在题型2或者题型3中时，dp[g][0]=0表示对第g组的选择是合理合法的，但如果dp[g][0]=无解，这表示对第g组的选择已经无法按规定要求正确进行。在这种情况下，去处理第g+1行的数据，一旦需要使用到dp[g][0]则必然会出现问题！从公式上来看，右侧的式子一旦是无解的状态，则由它来推导出左侧的状态值，这显然是不合理的！有部分同学把dp[1..gcnt][0]设置为了全0，似乎也能AC某些题，这纯粹是因为测试数据太弱的缘故，在考试时肯定会出问题。总结起来，记住一点，<strong>对dp数组的第0列不要做特殊处理。初始化第g行所有数据时，一定要把dp[g][0]的初始化包含在内</strong>。</p>
<p>　　在1.2节中的“先for 组内物品k，再for j”和“先for j，再for
组内物品k”这两个不同的策略，同样适用于1.3节这种题型。同学们可以选择自己熟悉的策略来重点掌握（<strong>建议掌握“先for
组内物品k，再for j”这种策略的做法，适用范围更广</strong>）。</p>
<h3 id="先for-组内物品k后for-j重点掌握">1.3.1 先for 组内物品k，后for
j（重点掌握）</h3>
<p>1.标准状态数组下的做法</p>
<p>　　在代码（2）的基础之上演变得到如下的代码（11）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（11），组内必须选1件，先for 组内物品k 再 for j，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>	dp[g][j]= -INF;    <span class="hljs-comment">// 默认针对每个j，当前组都暂时无解，值为-INF。当然，也可以用memset或者直接设置为全局数组以自动清0，这样就可以不用写这个for循环了</span><br><span class="hljs-comment">// 开始循环填写dp</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>		dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[idx[g][k]]] + value[idx[g][k]] );<br><span class="hljs-comment">// 填完整个dp数组之后，如果某个dp[g][j]的值仍然是-INF，说明这个状态是无解的。</span><br></code></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>滚动状态数组下的做法</li>
</ol>
<p>　　在代码（5）的基础之上演变得到如下的代码（12）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（12），组内必须选1件，先for 组内物品k 再 for j，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123; <br>    dptmp[j]=dp[j];   <span class="hljs-comment">// 用dptmp[0..YS1]来存dp[g-1][0..YS1]</span><br>    dp[j]= -INF;      <span class="hljs-comment">// dp[j]现在要去存放dp[g][j]了，以“无解”（收益值为-INF）来作为该状态([g][j])的初始值</span><br>&#125;<br><span class="hljs-comment">// 不再“照抄上一行数据”，每个dp[0..YS1]的初值设为了-INF，在第一次执行dp[j]=max(dp[j], ...)时，等效于执行了“dp[j]=max(-INF, ...)”，意味着本组的所有策略中没有包含“本组什么物品都不选”。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[idx[g][k]]; j--)  <span class="hljs-comment">// 必须只能倒序，表示每个物品不能多选！</span><br>         <span class="hljs-comment">// dptmp[]表示的是dp[g-1][] !!</span><br>	    dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dptmp[j-ys1[idx[g][k]]] + value[idx[g][k]] );<br></code></pre></td></tr></table></figure>
<h3 id="先for-j后for-组内物品k">1.3.2 先for j，后for 组内物品k</h3>
<ol type="1">
<li>标准状态数组下的做法</li>
</ol>
<p>　　在代码（8）的基础之上演变得到如下的代码（13）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（13），组内必须选1件，先for j 再 for 组内物品k，标准dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>    dp[g][j]= -INF;     <span class="hljs-comment">// 以“无解”（收益值为-INF）来作为该状态的初始值。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] )  <span class="hljs-comment">// 因为在第2行还没有k，无法写出j&gt;=ys1[ idx[g][k] ]，所以只能在这里写！</span><br>            dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>滚动状态数组下的做法</li>
</ol>
<p>　　在代码（9）的基础之上演变得到如下的代码（14）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 代码（14），组内必须选1件，先for j 再 for 组内物品k，滚动dp数组，求收益最大值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>    dp[j]=-INF;<span class="hljs-comment">// 以“无解”（收益值为-INF）来作为[g][j]状态的初始值。即使dp全数组在for g之前已全都置为了-INF，本行代码也必须要写！</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++)<br>        <span class="hljs-keyword">if</span> (j&gt;=ys1[ idx[g][k] ] )  <br>            dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dp[j-ys1[ idx[g][k] ]] + value[ idx[g][k] ] );<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="题型3每组物品选的物品个数-1个">1.4
题型3：每组物品选的物品个数<font color="red">&gt; =</font>1个</h2>
<p>　　题型3仍然存在题型2中面临的“可能存在无解”的情况。所以，题型2中关于dp[g][0..YS1]初值的设定，对于题型3仍然适用。为了降低初学难度，我们还是以“<strong>在&lt;=YS1的前提下求最大收益值</strong>”为例，来讲解“每组物品选的物品个数&gt;=1个”这种要求的应对策略。</p>
<p>　　dp[g][j] 表示选前 g 组物品（每组至少选1个）并且限制量不超过
j的最大收益值。所求目标为dp[gcnt][YS1]。有两种情况可以转到当前状态[g][j]：</p>
<ol type="1">
<li>在“<strong>第g组还没选择任何物品</strong>”的前提下，第一次选择了第g组的编号为x的物品，则会有:</li>
</ol>
<p><span class="math display">\[
dp[g][j]= max(\ dp[g][j], \quad dp[g-1][j-ys1[x] ] + value[x]\ );
\tag{1}
\]</span></p>
<ol start="2" type="1">
<li>在“<strong>已经选择了第g组的某个或者某些物品</strong>”的前提下，现在选择编号为x的物品，则会有:
<span class="math display">\[
dp[g][j]= max(\ dp[g][j], \quad dp[g][j-ys1[x] ] + value[x]\ );\tag{2}
\]</span>
既然这两种情况都可能发生，那么最终策略就看哪种方案的值最大，就选哪种方案了。所以最终的状态转移方程是：
<span class="math display">\[
dp[g][j]= max(\ dp[g][j], \quad dp[g-1][j-ys1[x] ] + value[x]\ , \quad
dp[g][j-ys1[x] ] + value[x]\ ); \tag{3}
\]</span></li>
</ol>
<p>　　公式（3）在转成代码的时候，需要小心！对于编号为x的物品，情况1和情况2是不可能同时存在的。所以公式（3）中的
<span class="math inline">\(dp[g-1][j-ys1[x] ] + value[x]\)</span> 和
<span class="math inline">\(dp[g][j-ys1[x] ] +
value[x]\)</span>这两个策略不可能都执行，在写代码的时候建议采用A=max(max(A,B),C)的方式来写。而且，第1次执行公式（1）时，公式右侧的dp[g][j]存放的应该是该状态的初值“无解”，即-INF。而后续执行该公式时，右侧的dp[g][j]纯粹只是为了实现“多个数据之间的<strong>累计比较</strong>”的效果而已。</p>
<h3 id="先for-组内物品k再for-j掌握">1.4.1 先for 组内物品k，再for
j（掌握）</h3>
<p>　　下面我们看一个例子，用“先for 组内物品k，后for
j”的思路来进一步来加深对公式（３）的理解。</p>
<p>　　1)处理第1组的1号物品</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723170245209.png"
alt="image-20240723170245209" />
<figcaption aria-hidden="true">image-20240723170245209</figcaption>
</figure>
<p>　　可以看到，第一次填写dp[g][j]时，等式右边的dp[g][j]为“无解”的状态，值为-INF，以方便max运算。</p>
<p>　　2）处理第1组的4号物品</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723170855857.png"
alt="image-20240723170855857" />
<figcaption aria-hidden="true">image-20240723170855857</figcaption>
</figure>
<p>　　3)处理第2组的2号物品</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723171222171.png"
alt="image-20240723171222171" />
<figcaption aria-hidden="true">image-20240723171222171</figcaption>
</figure>
<p>　　后续对剩余2个物品的处理与上雷同，就不再画图展示了。</p>
<p>　　需要注意的是，这里j的循环顺序一定是倒序，即从YS1到ys1[i]。这是因为对于每个物品来说，最多只能被选择一次，不能被连续选择2次。这和“一个组内允许选择多个物品”，是不相关的。如下图所示。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/cspcoding/pic@main//img/image-20240723172427927.png"
alt="image-20240723172427927" />
<figcaption aria-hidden="true">image-20240723172427927</figcaption>
</figure>
<p>　　题型3的代码模板如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g &lt;= gcnt; g++ )            <span class="hljs-comment">// 历所有组数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++ ) &#123;   <span class="hljs-comment">// 遍历每组的物品</span><br>        <span class="hljs-type">int</span> i=idx[g][k];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j&gt;=ys1[i]; j--) <span class="hljs-comment">// 此处必须只能倒序，因为有dp[g][...] </span><br><span class="hljs-comment">//      for(int j = ys1[i]; j&lt;=YS1; j++) // 错误！ 每个物品只能被选1次！ 右侧公式里有dp[g][...] ！见帖子说明</span><br>            <span class="hljs-comment">//dp[g][j] = max ( dp[g][j] , max(dp[g-1][j-ys1[i]]+value[i] , dp[g][j-ys1[i]]+value[i]) ); // 和下一行等效，可AC</span><br>            dp[g][j] = <span class="hljs-built_in">max</span> ( <span class="hljs-built_in">max</span>(dp[g][j] , dp[g<span class="hljs-number">-1</span>][j-ys1[i]]+value[i] ), dp[g][j-ys1[i]]+value[i] );<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="先for-j再for-组内物品k-1">1.4.2 先for j，再for 组内物品k</h3>
<p>　　从公式（3）中可以看到一个我们需要注意的东西，那就是dp[g][j]的值，依赖于dp[g][j-
...]的值。换句话说，当前格子的填写，依赖于同行左侧某个格子的填写。这是之前题型1和题型2所没有的情况（这两种题型都是依赖于上一行的值，已确定）。在这种情况下，就需要我们必须要从左往右填写每一排数据，否则左侧格子的值肯定是-INF或者0这种初始值，这样会导致dp[g][j-
...]失去对max的参与，无法发挥作用（这一项的作用就是“在已选本组某物品的情况，再选择本组的其他物品”。一旦失效，意味着dp[g][j]无法存放多个物品的累加和）。但是，如果从左往右填写，会带来另外一个问题，那就是“同一个物品，被选择了2次或者无限次”（这是完全背包的典型特征）。</p>
<p>　　鉴于上面的情况，<strong>请同学们对本题型放弃“先for j，后for
组内物品k”的做法</strong>。</p>
<h1 id="二实战练习">二、实战练习</h1>
<h2 id="每组最多选1个物品">2.1 1272（每组最多选1个物品）</h2>
<h3 id="原题链接">2.1.1 原题链接</h3>
<p>　　<a
target="_blank" rel="noopener" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1272">1272：【例9.16】分组背包</a></p>
<h3 id="ac代码">2.1.2 AC代码</h3>
<p>1.先for j，再for 组内物品k，标准dp数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法2，每组最多选1个，先for j，再for 组内物品k，标准dp数组  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    参考帖子代码（8） </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxYS1 201</span><br><span class="hljs-type">int</span> dp[<span class="hljs-number">11</span>][maxYS1];    <span class="hljs-comment">// dp应该是物品组g和背包容量YS1的函数，所以定义为dp[g][YS1] </span><br><span class="hljs-type">int</span> YS1, n, gcnt;<br><span class="hljs-type">int</span> tot[maxYS1], ys1[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>], value[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>]; <span class="hljs-comment">// ys1[2][4]：第2组的第4个物品的ys1值，value同理 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-comment">// 录入背包总重量YS1， 物品件数n个，种类gcnt种 </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;YS1, &amp;n, &amp;gcnt);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> W, C, g;         <span class="hljs-comment">//group组 </span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;W, &amp;C, &amp;g);  	<span class="hljs-comment">// 重量W，价值C，组号g </span><br>        tot[g]++;                     	<span class="hljs-comment">// 第g组的物品个数增加1个 </span><br>        ys1[g][tot[g]] = W;             <span class="hljs-comment">// 第g组的最新个的重量值为W </span><br>        value[g][tot[g]] = C;           <span class="hljs-comment">// 第g组的最新个的价值值为C </span><br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]= <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">// 每组最多选1个，所以按组来划分阶段。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g = <span class="hljs-number">1</span>; g &lt;= gcnt; g++) <br><span class="hljs-comment">//      for(int j = YS1; j &gt;= 0; j--)   // 标准dp数组，正序逆序都可以 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= YS1; j++)&#123; <br>			dp[g][j] = dp[g<span class="hljs-number">-1</span>][j];       <span class="hljs-comment">// 允许本组一个都不选，所以先假定一个都没选  </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= tot[g]; k++) <br>                <span class="hljs-keyword">if</span> ( j &gt;= ys1[g][k] )<br>                    dp[g][j] = <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j - ys1[g][k]] + value[g][k] );<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[gcnt][YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>先for j，再for 组内物品k，滚动dp数组</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"> <span class="hljs-comment">//// 方法1；每组最多选1个，先for j，再for 组内物品k，滚动dp数组 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    参考帖子代码（10） </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxYS1 201</span><br><span class="hljs-type">int</span> dp[maxYS1];<br><span class="hljs-type">int</span> YS1, n, gcnt;<br><span class="hljs-type">int</span> tot[maxYS1], ys1[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>], value[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <br>	<span class="hljs-comment">// 录入背包总重量YS1， 物品件数n个，种类gcnt种 </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;YS1, &amp;n, &amp;gcnt);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123; <br>        <span class="hljs-type">int</span> W, C, g;       <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;W, &amp;C, &amp;g);  	<span class="hljs-comment">// 重量W，价值C，组号g </span><br>        tot[g]++;                     	<span class="hljs-comment">// 第g组的物品个数增加1个 </span><br>        ys1[g][tot[g]] = W;             <span class="hljs-comment">// 第g组的最新个的重量值为W </span><br>        value[g][tot[g]] = C;           <span class="hljs-comment">// 第g组的最新个的价值值为C </span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 每一组物品 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g = <span class="hljs-number">1</span>; g &lt;= gcnt; g++)<br>      <span class="hljs-comment">// dp[g][j]需要用到dp[g-1][...]，且每个物品最多只被选1次，所以若用滚动数组的话，这里必须倒序  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j &gt;= <span class="hljs-number">0</span>; j--)  <span class="hljs-comment">// 这里没法写j&gt;=ys1[k]了；k在内层。 </span><br>			<span class="hljs-comment">// 第g组的第k个不同的物品 </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= tot[g]; k++) <br>                <span class="hljs-keyword">if</span> ( j &gt;= ys1[g][k] )<br>                    dp[j] = <span class="hljs-built_in">max</span>( dp[j],  dp[j - ys1[g][k]] + value[g][k] );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>先for 组内物品k，再for j，标准dp数组</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法3，每组最多选1个，先for 组内物品k，再for j，标准dp数组</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    参考帖子代码（3）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxYS1 201</span><br><span class="hljs-type">int</span> dp[<span class="hljs-number">11</span>][maxYS1];    <span class="hljs-comment">// dp应该是物品组g和背包容量YS1的函数，所以定义为dp[g][YS1]</span><br><span class="hljs-type">int</span> YS1, n, gcnt;<br><span class="hljs-type">int</span> tot[maxYS1], ys1[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>], value[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>]; <span class="hljs-comment">// ys1[2][4]：第2组的第4个物品的ys1值，value同理</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 录入背包总重量YS1， 物品件数n个，种类gcnt种</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;YS1, &amp;n, &amp;gcnt);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> W, C, g;         <span class="hljs-comment">//group组</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;W, &amp;C, &amp;g);  	<span class="hljs-comment">// 重量W，价值C，组号g</span><br>        tot[g]++;                     	<span class="hljs-comment">// 第g组的物品个数增加1个</span><br>        ys1[g][tot[g]] = W;             <span class="hljs-comment">// 第g组的最新个的重量值为W</span><br>        value[g][tot[g]] = C;           <span class="hljs-comment">// 第g组的最新个的价值值为C</span><br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 每组最多选1个，所以按组来划分阶段。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>            dp[g][j]= dp[g<span class="hljs-number">-1</span>][j];    <span class="hljs-comment">// 先照抄上一行数据，默认针对每个j，当前组都暂时不选任何物品</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=tot[g]; k++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[g][k]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>                dp[g][j]= <span class="hljs-built_in">max</span>( dp[g][j],  dp[g<span class="hljs-number">-1</span>][j-ys1[g][k]] + value[g][k] );<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4d&quot;</span>, dp[g][j]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <br>    <br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[gcnt][YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>先for 组内物品k，再for j，滚动dp数组</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//// 方法4；每组最多选1个，先for 组内物品k，再for j，滚动dp数组</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    参考帖子代码（5）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxYS1 201</span><br><span class="hljs-type">int</span> dp[maxYS1], dptmp[maxYS1];<br><span class="hljs-type">int</span> YS1, n, gcnt;<br><span class="hljs-type">int</span> tot[maxYS1], ys1[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>], value[<span class="hljs-number">11</span>][<span class="hljs-number">31</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 录入背包总重量YS1， 物品件数n个，种类k种</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;YS1, &amp;n, &amp;gcnt);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> W, C, g;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;W, &amp;C, &amp;g);  	<span class="hljs-comment">// 重量W，价值C，组号g</span><br>        tot[g]++;                     	<span class="hljs-comment">// 第g组的物品个数增加1个</span><br>        ys1[g][tot[g]] = W;             <span class="hljs-comment">// 第g组的最新个的重量值为W</span><br>        value[g][tot[g]] = C;           <span class="hljs-comment">// 第g组的最新个的价值值为C</span><br>    &#125;<br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++) &#123;<br>        <span class="hljs-comment">// 用dptmp[0..YS1]来存dp[g-1][0..YS1] </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>            dptmp[j]= dp[j];<br>        <span class="hljs-comment">// 不需要再“照抄上一行数据”了，下面的写法已经隐含地包括了对“不选任何物品”这个选择的max比较了</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=tot[g]; k++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[g][k]; j--)  <span class="hljs-comment">// 必须只能倒序！</span><br>                <span class="hljs-comment">// dptmp[]表示的是dp[g-1][] </span><br>                dp[j]= <span class="hljs-built_in">max</span>( dp[j],  dptmp[j-ys1[g][k]] + value[g][k] );<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[YS1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>　　<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1757">P1757
通天之分组背包</a>和本题几乎完全一样，只是录入稍有差异。可作为复习巩固之用。</p>
<h2 id="p5322每组最多选1个物品">2.2 P5322（每组最多选1个物品）</h2>
<h3 id="原题链接-1">2.2.1 原题链接</h3>
<p>　　<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5322">P5322 [BJOI2019]
排兵布阵</a></p>
<p>　　简明题意如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++">   简明题意<br>       你有m个士兵，可以把它们随意分配到 n 个城堡里，在每个城堡中，你需要挑战城堡内的所有<br>   对手，如果在第 i 个城堡的一次挑战中你的士兵个数 &gt; 对手士兵个数 * <span class="hljs-number">2</span>，该场你就获得了i 分；<br>如果挑战失败，该场你获得<span class="hljs-number">0</span>分。已知对手们在每个城堡的士兵人数，求你能获得的总得分的最大值。<br>样例分析：<br>	输入： <br>	<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">10</span>  （除我之外还有<span class="hljs-number">2</span>个玩家，<span class="hljs-number">3</span>个城堡，我有<span class="hljs-number">10</span>个士兵） <br>	<span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span>   （第<span class="hljs-number">1</span>个玩家对三个城堡的出兵数量分别为 <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span>） <br>	<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>   （第<span class="hljs-number">1</span>个玩家对三个城堡的出兵数量分别为 <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>）<br>	输出：<br>	<span class="hljs-number">8</span>分<br>	解释：我的对三个城堡的出兵数量分别为 <span class="hljs-number">1</span>人   <span class="hljs-number">5</span>人   <span class="hljs-number">1</span>人 <br>		这样的话，和第一个玩家PK，赢第<span class="hljs-number">2</span>个城堡得<span class="hljs-number">2</span>分 <br>				  和第二个玩家PK，赢第<span class="hljs-number">1</span>个城堡得<span class="hljs-number">1</span>分、赢第<span class="hljs-number">2</span>个城堡得<span class="hljs-number">2</span>分、 赢第<span class="hljs-number">3</span>个城堡得<span class="hljs-number">3</span>分<br>		所以一共得<span class="hljs-number">2</span>+<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3</span>=<span class="hljs-number">8</span>分<br>		这是得最高分的策略了 <br></code></pre></td></tr></table></figure>
<h3 id="分析">2.2.2 分析</h3>
<p>　　首先我们需要搞清楚一个事情，这个题为什么是分组背包而不是贪心？我们可以来看看如下的反例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">  如果要尽量贪心，那么就应该尽可能获得编号值较大的城堡内的挑战胜利，在该城堡内也尽可能获得较多的胜利场次；<br>  反例（1）输入： <br>2 5 21  （除我之外还有2个对手玩家，3个城堡，我有21个士兵） <br>1 1 1 1 10   （第1个对手对三个城堡的出兵数量分别为 1 1 1 1 10） <br>0 0 0 0 0    （第2个对手对三个城堡的出兵数量分别为 0 0 0 0 0）<br>  错误的贪心策略：在编号最大的第5个城堡安排2×10+1=21个士兵（用光），获得2场胜利，得到2×5=10分；<br>  正确的策略：在1～4号城堡分别安排3个士兵，共12个士兵，获得1～4号城堡的8场胜利，共得2+4+6+8=20分；还剩9个士兵安排在5号城堡，获得一场胜利，得5分。所有共计25分。<br><br>  从这个例子可以看出，虽然想尽可能获得编号值较大的城堡里的挑战胜利，但是否真能如愿，完全取决于该城堡里的各玩家的士兵人数情况。而士兵人数情况是存在很大的不确定性的。有可能很轻松就拿下该城堡内所有场次的胜利，也有可能非常困难，得不偿失。在这种情况下，如果一味地想着去贪这种胜利，绝对是错误的策略。<br><br>  既然如此，那是不是在本题中就完全用不上一点点贪心呢？那也不是。<br>  当你已经在某个城堡里打败了所有的对手，那就没有必要再往这个城堡里安排更多的士兵了，而应该把剩余的士兵安排去征服其他的城堡。<br></code></pre></td></tr></table></figure>
<p>　　根据上面所述的贪心规则，我们完全可以针对每个城堡内敌方的士兵情况，计算出要获得每场胜利所需的最少士兵人数，作为我们的决策。例如在反例（1）中，我们如果想在第1个城堡打败对手2，只需要派1人入驻即可；但如果我们需要打败对手1，则需要派遣3个士兵入驻（这3个士兵同时也能打败对手2）。</p>
<p>　　对于城堡1，摆在我们面前的结果其实就3种：躺平放弃；打败对手2；打败对手1和对手2。<strong>这三种策略分别对应着“不派遣士兵；派遣1个士兵；派遣3个士兵”这3种策略，带来的收益则分别是“在城堡1内2场挑战两场全输共得0分；在城堡1内2场挑战一胜一负共得1分；在城堡1内2场挑战两场全胜共得2分；”</strong>分析到这里，可能有些同学已经领悟过来了，这不就是分组背包中的题型1（每组最多选1个）吗？</p>
<p>　　假设第i个城堡有 5
个对手，分别在该城堡里入驻了ys1[1..5]={10,20,5,3,5}个士兵，那么除了“不派遣”这个策略之外，我们面临的其他派遣策略就是{21,41,
11,7,11}这一共5个策略。如果我们现在选择“战胜第k=1个对手，即派遣21个士兵”这个策略，那么在第i个城堡里可以赢几场呢？这需要我们拿着21去和{21,41,
11,7,11}数组中的每个数去比较，累计而得。这挺麻烦的。一个简单的优化就是：我们可以事先对ys1[]进行递增排序，得到ys1[1..5]={3,5,5,10,20}。在这种情况下，如果我们选择“战胜对手1（派遣7人）”，则可以胜1场，获得1×i=i分；如果我们选择“战胜对手4（派遣21人）”，则可以胜4场（战胜对手1、2、3、4），获得4×i=4i分；如果我们选择“战胜对手k（派遣2*ys1[k]+1人）”，则可以胜k场，获得k×i分。经过排序之后，我们可以很方便地获得一个组内的“获胜场次”值k，从而优化代码。</p>
<p>　　可能有些同学已经看到了ys1[1..5]={3,5,5,10,20}中有两个5。当我们选择第1个5时，k=2，我们认为我们战胜了对手1和对手2，但实际上我们也战胜了对手3。那获胜场次这样计算是否有误呢？仔细思考，其实不影响答案。因为在dp[g][j]=max(dp[g][j],
dp[g][j-(2*5+1)]+1*g, dp[g][j-(2*5+1)]+2*g,
...)的运算中，dp[g][j-(2*5+1)]+1*g &lt;
dp[g][j-(2*5+1)]+2*g，所以dp[g][j-(2*5+1)]+1*g是不会对dp[g][j]的运算结果产生任何影响的。</p>
<h3 id="ac代码-1">2.2.3 AC代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-comment">//#define MAX(A,B) ((A)&gt;(B)?(A):(B))       // 自己打MAX比调用max的确要快一丁点 </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">		设 dp[j]表示玩家(在第g个城堡)放j个士兵可以获得的最大分数。a[g][k]表示在第g个</span><br><span class="hljs-comment">    城堡时s个玩家中出兵数量第k大的玩家的出兵数量（这样设计有利于算出得分。一共有gcnt个城堡，</span><br><span class="hljs-comment">    相当于就是gcnt个分组。对于每一个城堡，s个玩家有s个出兵</span><br><span class="hljs-comment">	数。在和这s个玩家中的任一个进行两两对决时，我只需要出对方数量的两倍多1即可，也</span><br><span class="hljs-comment">	就是说，我面对这个玩家，我的策略是a[g][k] * 2 + 1。一共有s个玩家，也就是说，我有</span><br><span class="hljs-comment">	s个策略数量可供我选择。这就是我在这一个城堡（分组）内可供选择的策略的成本。</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment">		与之对应，这些策略的收益是得分。战胜当前玩家，我能获得第g个城堡的g分；同时，</span><br><span class="hljs-comment">	因为还有k-1个玩家的出兵数少于当前玩家（因为当前玩家的出兵数是第k小），所以我的</span><br><span class="hljs-comment">	这个出兵数还能超过这k-1个玩家出兵数的2倍，故我这个策略能使我在第g个城堡的对抗中</span><br><span class="hljs-comment">	面对其他玩家，再得(k-1)*g分，所以我这个策略实际有k*g分的收益。</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment">		归纳地说，gcnt个分组，每组内s个决策，每个决策的成本是a[g][k]*2+1人，收益是k*g分 </span><br><span class="hljs-comment">	 </span><br><span class="hljs-comment">		dp转移方程即为： </span><br><span class="hljs-comment">			dp[j] = max( dp[j - a[g][k]*2 - 1] + k * g,   dp[j]);</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> s , gcnt, YS1, ans;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">20002</span>];     <span class="hljs-comment">// 滚动dp[]，玩家(在第i个城堡)放j个士兵可以获得的最大分数</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>];   <span class="hljs-comment">// 第i个城堡时s个玩家中出兵数量第k大的玩家的出兵数量</span><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;s, &amp;gcnt, &amp;YS1);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=s; ++k)         <span class="hljs-comment">// s个玩家 </span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; ++g)  <span class="hljs-comment">// gcnt个城堡 </span><br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[g][k]);  <span class="hljs-comment">// 反过来存储，以便于等会对每个城堡，按照玩家来进行增序排序 </span><br>			<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; ++g)<br>		<span class="hljs-built_in">sort</span>(a[g]+<span class="hljs-number">1</span>, a[g]+<span class="hljs-number">1</span>+s);     <span class="hljs-comment">// 对每个城堡，让s个玩家的出兵数做递增排序，以便于后续统计得分 </span><br>		<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; ++g)      <span class="hljs-comment">// 枚举分组：gcnt个城堡，就相当于是gcnt个分组 </span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; --j) 	<span class="hljs-comment">// 枚举背包容量：倒序枚举派出的兵数 </span><br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=s; ++k) <span class="hljs-comment">// 枚举组内策略：对每个城堡，我可以选择s个玩家出兵数的2倍以上，即对这个分组我有s个策略可以选择 </span><br>				<span class="hljs-keyword">if</span>( j &gt; a[g][k]*<span class="hljs-number">2</span> ) <span class="hljs-comment">// </span><br>					<span class="hljs-comment">// 每个决策的成本是a[g][k]*2+1，收益是k*g，详情解释见上面的说明 </span><br>					dp[j] = <span class="hljs-built_in">max</span>(dp[j-a[g][k]*<span class="hljs-number">2</span><span class="hljs-number">-1</span>]+k*g, dp[j]);<br><span class="hljs-comment">//	for(int g=1;g&lt;=gcnt;g++)</span><br><span class="hljs-comment">//		for(int j=YS1;j&gt;=0;j--)&#123;</span><br><span class="hljs-comment">//			dp[g][j]=dp[g-1][j];//要在枚举 k 的循环外继承。</span><br><span class="hljs-comment">//			for(int k=1;k&lt;=s;k++)</span><br><span class="hljs-comment">//				if(j&gt;=a[g][k]*2+1)dp[i][j]=max(dp[i][j],dp[i-1][j-a[i][k]*2-1]+k*i);</span><br><span class="hljs-comment">//		&#125;</span><br>    <span class="hljs-comment">// 给我的YS1个士兵，我可以不全部放完。反正求出最大值即可。就算放多了，也不会影响得分。 </span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=YS1; ++i) <br>		ans=<span class="hljs-built_in">max</span>(ans, dp[i]);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="p2409每组只能选1个物品不能多不能少">2.3
P2409（每组只能选1个物品，不能多、不能少）</h2>
<h3 id="原题链接-2">2.3.1 原题链接</h3>
<p>　　<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2409">P2409
Y的积木</a></p>
<h3 id="分析-1">2.3.2 分析</h3>
<p>　　这个题要求方案数，dp[g][j] = t
表示前g个盒子各抽1个积木凑成==j斤积木的组合方案个数是4种。既然表示的是方案数，所以在转移方程中应该是“累加”，而不应该是“累比”。因为是“恰好等于j”，并且还要求每组必须要选，所以对状态[g][j]可能存在无解的情况，所以所有方案数的初始dp值建议设置为0，表示“暂时认为没有任何方案”，即“无解”。</p>
<p>　　特例情况是“前0个盒子中各抽1个积木，凑成恰好0斤重量，其组合的方案数为1种（dp[0][0]=1;），即'什么积木都不放'（因为是在0个盒子中选，所以不必遵守‘每个盒子都必须选1个’的规定了，因为连盒子都没有）。”</p>
<p>　　所求目标：一言难尽，看代码。</p>
<p>　　关于状态转移方程，因为本题的dp数组存放的是方案数，而不是最大值，所以状态转移方程中并没有max或者min，而是用‘+’。现在不能直接套用1.3节中的代码模板，那该怎么做呢？
我们可以用一个实际样例来分析看看。有时候把数字具体化，推导起来会更方便，更容易看到一些关系。样例推导过程如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//    分组背包，每组必须要放1个物品，不能多，不能少</span><br><span class="hljs-comment">//    dp[3][6] = 4 表示前3个盒子各抽1个积木凑成6斤积木的组合方案个数是4种.</span><br><br>    对于第g组的处理：<br>    <span class="hljs-number">1.</span> 如果先<span class="hljs-keyword">for</span> j，再<span class="hljs-keyword">for</span> k（即针对每个状态[g][j]，去考虑它由哪些数值累加而成）<br>        假设第g组(盒)的物品(积木)的重量分别依次是 <span class="hljs-number">10</span>、 <span class="hljs-number">50</span>、 <span class="hljs-number">100</span>和 <span class="hljs-number">580</span>。那么：<br>        <span class="hljs-number">1</span>）对于[g][<span class="hljs-number">300</span>]    <br>            <span class="hljs-comment">// 重量为580的那个积木无法装入，不考虑它</span><br>            dp[g][<span class="hljs-number">300</span>] = dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">290</span>] +  dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">250</span>] + dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">200</span>] <span class="hljs-comment">// 如果不懂这行的由来，请看本站关于背包方案数的专帖后再回来学本帖。 </span><br>            上面的累加式子演变成代码的话，如下所示：<br>            dp[g][<span class="hljs-number">300</span>] = <span class="hljs-number">0</span>;              <span class="hljs-comment">// 初始化[g][300]为&quot;无解&quot;状态</span><br>            dp[g][<span class="hljs-number">300</span>] += dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">290</span>];  <span class="hljs-comment">// 开始累加, 300&gt;=290</span><br>            dp[g][<span class="hljs-number">300</span>] += dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">250</span>];  <span class="hljs-comment">//   300 &gt;=250</span><br>            dp[g][<span class="hljs-number">300</span>] += dp[g<span class="hljs-number">-1</span>][<span class="hljs-number">200</span>];  <span class="hljs-comment">// 300&gt;=200 </span><br>            <span class="hljs-comment">// ......直到本组内所有j&gt;=ys1[]的积木都考虑完，则结束累加的循环</span><br><br>        <span class="hljs-number">2</span>）对于[g][<span class="hljs-number">5</span>]<br>            <span class="hljs-comment">//因为本组内的4个物品的ys1[]值都&gt;5，所以本组内的所有积木都不考虑装入</span><br>            dp[g][<span class="hljs-number">5</span>] = 空气 + 空气（哈哈）<br>            演变成代码就是    <br>            dp[g][<span class="hljs-number">5</span>] = <span class="hljs-number">0</span>;                <span class="hljs-comment">// 初始化[g][5]为&quot;无解&quot;状态 </span><br>            <span class="hljs-comment">// 累加循环一次都不做，直接略过</span><br><br>        对上面的<span class="hljs-number">1</span>）和<span class="hljs-number">2</span>）进行总结后，得到代码模板如下：<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--) <span class="hljs-comment">// YS1是通过计算而得</span><br>            dp[g][j]= <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化状态[g][j]的方案数为0（即“无解”），而不是来源于dp[g-1][j] ！！ </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=ys1[g][<span class="hljs-number">0</span>]; k++)   <span class="hljs-comment">//组内枚举每个物品，ys1[g][0]表示该组内物品的个数</span><br>                <span class="hljs-keyword">if</span> ( j &gt;= ys1[g][k] ) <span class="hljs-comment">//先判断能不能放</span><br>                    <span class="hljs-comment">// 和以往的背包问题中求最大值最小值不同，本题背包问题是求累加和！</span><br>                    <span class="hljs-comment">// 第一次累加时，dp[g][j]原值为0，表示所有方案数都来自于dp[g-1][ j-ys1[g][...] ] </span><br>                    dp[g][j] = dp[g][j] + dp[g<span class="hljs-number">-1</span>][ j-ys1[g][k] ];<br><br>    <span class="hljs-number">2.</span> 如果先<span class="hljs-keyword">for</span> k，再<span class="hljs-keyword">for</span> j（即针对组内的每<span class="hljs-number">1</span>个物品，去填写或者修正dp数组第g排的所有元素）<br>    对于第g组的第k个物品（假设重量为<span class="hljs-number">580</span>），它不可能装入容量为<span class="hljs-number">300</span>斤或者<span class="hljs-number">5</span>斤的背包中，只可能装入容量&gt;=<span class="hljs-number">580</span>的背包中。所以在填写或者修正dp[g][YS1.<span class="hljs-number">.1</span>]时，不需要<span class="hljs-keyword">for</span>\(<span class="hljs-type">int</span> j=YS1, j&gt;=<span class="hljs-number">1</span>; j--)，只需要<span class="hljs-keyword">for</span>\(<span class="hljs-type">int</span> j=YS1, j&gt;=ys1[idx[g][k]]; j--)即可。假设YS1=<span class="hljs-number">1000</span>， 对于本组内重量为<span class="hljs-number">580</span>的物品，只需要处理dp[g][<span class="hljs-number">1000.</span><span class="hljs-number">.580</span>]即可。而对于dp[g][<span class="hljs-number">1.</span><span class="hljs-number">.579</span>]的这些元素值，仍保留原来的数值即可（不管是为初值<span class="hljs-number">0</span>（无解）或者其他数值，这样处理都是合理的）<br>        代码模板如下：<br>        <span class="hljs-comment">///// 参考本帖代码（11），组内必须选1件，先for K 再 for j，标准dp数组，求方案数，初始化为“无解 ” </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>        	dp[g][j]= <span class="hljs-number">0</span>;    <span class="hljs-comment">// 默认[g][j]状态暂时无解，方案数为0。当然，也可以用memset或者直接设置为全局数组以自动清0，这样就可以不用写这个for循环了</span><br>        <span class="hljs-comment">// 开始循环累加</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=ys1[g][<span class="hljs-number">0</span>]; k++)<br>        	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[g][k]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>        		dp[g][j]=  dp[g][j] + dp[g<span class="hljs-number">-1</span>][ j-ys1[g][k] ];<br><br></code></pre></td></tr></table></figure>
<p>　　本题有个小坑点，那就是关于方案数爆int和long
long的问题。同学们一定要小心，一般来说，方案数都是一个很大的数字。所以一旦题目中涉及到要求方案数，一定要注意爆int或者爆long
long的问题。本题如果不特别处理，最后一个subtask会爆long
long。处理方法也很简单，就是不让dp[g][j]的值超过k。为什么可以这样做呢？因为本题要输出dp最后一排各个元素中非零元素的下标（若dp[g][j]==5，则要输出5个j值），如果某一个dp[g][j]的值&gt;k了，的确没必要再去保存精确数值了，对输出的结果无任何影响。</p>
<h3 id="ac代码-2">2.3.3 AC代码</h3>
<h4 id="先for-组内物品k后for-j">2.3.3.1 先for 组内物品k，后for j</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 方法1： 分组背包，每组必须要放1个物品，标准状态数组，先for 组内物品k 再forj，恰好等于，方案数 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// ys1[3][5]=12, 表示第3组的第5个积木的约束1属性值（重量）是12</span><br><span class="hljs-comment">// ys1[3][0]=13, 表示第3组内一共有13个物品，存储本组物品个数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxg=<span class="hljs-number">101</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxYS1=<span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> ys1[maxg][<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> dp[maxg][maxYS1]; <span class="hljs-comment">// dp[3][6] = 4 表示前3个盒子各抽1个积木凑成6斤积木的组合方案个数是4种. </span><br><span class="hljs-type">int</span> K, gcnt, YS1;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;gcnt, &amp;K);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++) &#123;<br>        <span class="hljs-comment">// 第i组的物品个数存于ys1[i][0]</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;ys1[g][<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> maxa = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=ys1[g][<span class="hljs-number">0</span>]; j++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;ys1[g][j]);<br>            maxa = <span class="hljs-built_in">max</span>(maxa, ys1[g][j]);<br>        &#125;<br>        <span class="hljs-comment">// 本题中的YS1没有直接被告知，找出每组内的最大值，加起来</span><br>        <span class="hljs-comment">// 每个盒子抽取1个积木，加起来的总重量肯定不会超过YS1=每组中积木的最大重量之和</span><br>        YS1 += maxa;<br>    &#125;<br>    <span class="hljs-comment">// 前0个盒子各抽1个积木凑成&lt;=0斤积木的组合方案个数是1种（=不抽）.</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++)&#123; <span class="hljs-comment">//控制组数</span><br>        <span class="hljs-comment">///// 参考本帖代码（11），组内必须选1件，先for K 再 for j，标准dp数组，求方案数，初始化为“无解 ” </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>        	dp[g][j]= <span class="hljs-number">0</span>;    <span class="hljs-comment">// 默认[g][j]状态暂时无解，方案数为0。当然，也可以用memset或者直接设置为全局数组以自动清0，这样就可以不用写这个for循环了</span><br>        <span class="hljs-comment">// 开始循环填写dp</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=ys1[g][<span class="hljs-number">0</span>]; k++)<br>        	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=YS1; j&gt;=ys1[g][k]; j--)  <span class="hljs-comment">// 正序或倒序都可以，数据来自上一行</span><br>        		dp[g][j]=  dp[g][j] + dp[g<span class="hljs-number">-1</span>][ j-ys1[g][k] ], dp[g][j] = <span class="hljs-built_in">min</span>(dp[g][j], K);<br>    &#125;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=YS1; i++)&#123;<br>        <span class="hljs-comment">// 打印dp[gcnt][i]个i（在没数到K个之前）</span><br>        <span class="hljs-keyword">while</span>( dp[gcnt][i])&#123;<br>            cout &lt;&lt;i &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            dp[gcnt][i]--;<br><br>            j++;<br>            <span class="hljs-keyword">if</span> (j==K) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种方法对应的滚动数组模式的代码，请参看本帖的代码（12），此处略过。</p>
<h4 id="先for-j-再for-组内物品k">2.3.3.2 先for j 再for 组内物品k</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///// 方法2： 分组背包，每组必须要放1个物品，标准状态数组，先for j 再for 组内物品k，恰好等于，方案数 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// ys1[3][5]=12, 表示第3组的第5个积木的约束1属性值（重量）是12</span><br><span class="hljs-comment">// ys1[3][0]=13, 表示第3组内一共有13个物品，存储本组物品个数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxg=<span class="hljs-number">101</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxYS1=<span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> ys1[maxg][<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> dp[maxg][maxYS1];  <span class="hljs-comment">// dp[3][6] = 4 表示前3个盒子各抽1个积木凑成6斤积木的组合方案个数是4种.</span><br><span class="hljs-type">int</span> k, gcnt, YS1;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;gcnt, &amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++) &#123;<br>        <span class="hljs-comment">// 第i组的物品个数存于ys1[i][0]</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;ys1[g][<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> maxa = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=ys1[g][<span class="hljs-number">0</span>]; j++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;ys1[g][j]);<br>            maxa = <span class="hljs-built_in">max</span>(maxa, ys1[g][j]);<br>        &#125;<br>        <span class="hljs-comment">// 本题中的YS1没有直接被告知，找出每组内的最大值，加起来</span><br>        <span class="hljs-comment">// 每个盒子抽取1个积木，加起来的总重量肯定不会超过YS1=每组中积木的最大重量之和</span><br>        YS1 += maxa;<br>    &#125;<br>    <span class="hljs-comment">// 前0个盒子各抽1个积木凑成&lt;=0斤积木的组合方案个数是1种（=不抽）.</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++)    <span class="hljs-comment">// 控制组数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=YS1; j&gt;=<span class="hljs-number">0</span>; j--) <span class="hljs-comment">// YS1是通过计算而得</span><br>            dp[g][j]= <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化状态[g][j]的方案数为0（即“无解”），而不是来源于dp[g-1][j] ！！ </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=ys1[g][<span class="hljs-number">0</span>]; k++) <span class="hljs-comment">//组内枚举每个物品k</span><br>                <span class="hljs-keyword">if</span> ( ys1[g][k] &lt;= j )       <span class="hljs-comment">//先判断能不能放</span><br>                    <span class="hljs-comment">// 和以往的背包问题中求最大值最小值不同，本题背包问题是求累加和！</span><br>                    dp[g][j] = dp[g][j] + dp[g<span class="hljs-number">-1</span>][ j-ys1[g][k] ], dp[g][j] = <span class="hljs-built_in">min</span>(dp[g][j], k);;<br><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=YS1; i++)&#123;<br>        <span class="hljs-comment">// 打印dp[gcnt][i]个i（在没数到K个之前）</span><br>        <span class="hljs-keyword">while</span>( dp[gcnt][i])&#123;<br>            cout &lt;&lt;i &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            dp[gcnt][i]--;<br><br>            j++;<br>            <span class="hljs-keyword">if</span> (j==K) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种方法对应的滚动数组模式的代码，请参看本帖的代码（14），此处略过。</p>
<h2 id="hdu3033每组至少选择1个物品">2.4
HDU3033（每组至少选择1个物品）</h2>
<h3 id="原题链接-3">2.4.1 原题链接</h3>
<p>　　<a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=3033">HDU3033
I love sneakers!</a></p>
<p>题意：</p>
<p>　　一个人去买运动鞋，他手里拥有的钱为<span
class="math inline">\(YS1(1 \leq YS1 \leq 10000
)\)</span>，运动鞋有<span class="math inline">\(gcnt(1 \leq gcnt \leq
10)\)</span>种品牌，每种品牌都可能有多双运动鞋，并且对于每种品牌，他都至少要买一双。</p>
<p>　　输入的数据包含多组测试样例，直到输入的数据文件结束为止。对于每组测试样例，依次输入<span
class="math inline">\(n(1 \leq n\leq
100)\)</span>双运动鞋，YS1值和gcnt值。后面跟着n行数据，每行数据依次为第<span
class="math inline">\(\ i\ (1 \leq i \leq
n)\)</span>双运动鞋所属的品牌号<span class="math inline">\(g[i](1 \leq
g[i]\leq gcnt)\)</span>，价格<span class="math inline">\(ys1[i](0 \leq
ys1[i]\leq 10^5)\)</span>，价值<span class="math inline">\(value[i](0
\leq value[i]\leq
10^5)\)</span>。输出能获得的最大价值，如果本测试样例无解，输出"Impossible"。</p>
<h3 id="分析-2">2.4.2 分析</h3>
<p>　　1)根据“输入的数据包含多组测试样例，直到输入的数据文件结束为止”，可以得到，代码主框架肯定如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>( <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n, &amp;YS1, &amp;gcnt) != EOF ) &#123;<br>        ........<br>&#125;<br></code></pre></td></tr></table></figure>
<p>　　2)本题是“组内至少要选择1件物品+求最大收益值”的类型，可能存在无解。所以dp数组应初始化为“无解”，即dp[g][j]=
-INF。对于本题来说，因为所有收益值都是正数，所以也可以初始化为0，不影响max函数的运行结果。若初始化为-INF，则需要小心第0行应该是全0。</p>
<p>　　3）关于“测试样例无解”，该怎么理解呢？如果给你10元钱，让你去买飞机坦克大炮，你能买得回来吗？肯定不行。换句话说，每组都有一个最廉价的物品，如果手里的钱不够买所有组内最廉价的物品，那就是无解了。所以我们可以找出每组内最低的价格，累加得到一个购买所有组物品的的最低价。如果给予的钱YS1少于这个最低价，则必然无法购买所有组的物品，即无解，输出“Impossible”。</p>
<p>　　4）本题要求支持多组样例。所以在每组样例录入前，一定要记得对各种数组进行复位或者重置。</p>
<h3 id="ac代码-3">2.4.3 AC代码</h3>
<p>根据分析，这种题型只能采用“先for 组内物品k，再for j”的思路来做。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 一共100双鞋子以内，1万元以内的成本，最多10个品牌 </span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">101</span>, maxYS1=<span class="hljs-number">10001</span>, maxg=<span class="hljs-number">11</span>;<br><span class="hljs-type">int</span> n, YS1, gcnt;<br><span class="hljs-type">int</span> ys1[maxn], value[maxn];<br><span class="hljs-type">int</span> minys1[maxg];  <span class="hljs-comment">// 每组内最小的物品约束量（每组内最便宜的鞋价） </span><br><span class="hljs-comment">// 分组背包专用的下标转换数组</span><br><span class="hljs-comment">// idx[3][5]=14 表示第3组第5个物品在所有物品列表中的下标是14 </span><br><span class="hljs-type">int</span> idx[maxg][maxn];<br><span class="hljs-comment">// dp[3][200]=480 表示前3组物品按照约束要求（每组至少必须买1个），</span><br><span class="hljs-comment">//       在200元约束范围内能获得的最大价值是480元 </span><br><span class="hljs-type">int</span> dp[maxg][maxYS1];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">while</span>( <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n, &amp;YS1, &amp;gcnt) != EOF ) &#123;<br>		<span class="hljs-comment">// 因为会有多组案例，所以一定要把历史数据清空干净！ </span><br>		<span class="hljs-built_in">memset</span>(minys1, INF, <span class="hljs-built_in">sizeof</span>(minys1));  <span class="hljs-comment">// 最小值数组要初始化为最大值 </span><br>		<span class="hljs-built_in">memset</span>(idx, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(idx));<br>		<span class="hljs-comment">// 如果嫌弃下面这两行有点罗嗦的话，也可以直接让整个dp数组全0，毕竟所有收益值都是整数，0值已经足够小 </span><br>		<span class="hljs-built_in">memset</span>(dp, -INF, <span class="hljs-built_in">sizeof</span>(dp));         <br>		<span class="hljs-built_in">memset</span>(dp[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp[<span class="hljs-number">0</span>]));     <span class="hljs-comment">// dp[0][0..YS1]必须要全0 </span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>			<span class="hljs-comment">// 录入每双鞋所属的品牌编号，需耗成本和价值 </span><br>			<span class="hljs-type">int</span> g; <br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;g, &amp;ys1[i], &amp;value[i] );<br>			++idx[g][<span class="hljs-number">0</span>];<br>			idx[g][ idx[g][<span class="hljs-number">0</span>] ] = i;       <span class="hljs-comment">// 第g组第idx[g][0]个鞋子在所有物品中的下标序号是 i </span><br>			minys1[g] = <span class="hljs-built_in">min</span> ( minys1[g], ys1[i]);  <span class="hljs-comment">// 记录第g组最小的需耗成本，这个数据不必初始化为最大 </span><br>		&#125;<br>		<span class="hljs-comment">// x表示要每个品牌买一双鞋最起码一共需要多少钱 </span><br>		<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=gcnt; i++) <br>			x += minys1[i];<br>		<br>		<span class="hljs-comment">// 所带的钱不够每个品牌买1双	</span><br>		<span class="hljs-keyword">if</span> ( YS1 &lt; x ) <br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Impossible\n&quot;</span>);<br>		<span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>; g &lt;= gcnt; g++ )            <span class="hljs-comment">// 历所有组数 </span><br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=idx[g][<span class="hljs-number">0</span>]; k++ )&#123;    <span class="hljs-comment">// 遍历每组的物品 </span><br>					<span class="hljs-type">int</span> i=idx[g][k];<br>					<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = YS1; j&gt;=ys1[i]; j--) <span class="hljs-comment">// 倒序遍历约束量YS1 </span><br><span class="hljs-comment">//                  for(int j = ys1[i]; j&lt;=YS1; j++) // 错误！ 每个物品只能被选1次！ 右侧公式里有dp[g][...] ！见帖子说明 </span><br>						<span class="hljs-comment">//dp[g][j] = max ( dp[g][j] , max(dp[g-1][j-ys1[i]]+value[i] , dp[g][j-ys1[i]]+value[i]) ); // 和下一行等效，可AC </span><br>						dp[g][j] = <span class="hljs-built_in">max</span> ( <span class="hljs-built_in">max</span>(dp[g][j] , dp[g<span class="hljs-number">-1</span>][j-ys1[i]]+value[i] ), dp[g][j-ys1[i]]+value[i] );<br>				&#125;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dp[gcnt][YS1]);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">// dp[3][200]=480 表示前3组物品在200元约束范围内能获得的最大价值是480元 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">(1)</span><br><span class="hljs-comment">5 15 3</span><br><span class="hljs-comment">1 4 5</span><br><span class="hljs-comment">2 5 10</span><br><span class="hljs-comment">3 4 100</span><br><span class="hljs-comment">1 5 70</span><br><span class="hljs-comment">2 7 50</span><br><span class="hljs-comment">ans:</span><br><span class="hljs-comment">180</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">(2)</span><br><span class="hljs-comment">3 5 3</span><br><span class="hljs-comment">1 2 5</span><br><span class="hljs-comment">2 2 1</span><br><span class="hljs-comment">3 2 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">3 5 3</span><br><span class="hljs-comment">1 0 5</span><br><span class="hljs-comment">2 0 1</span><br><span class="hljs-comment">3 0 2</span><br><span class="hljs-comment">ans:</span><br><span class="hljs-comment">Impossible</span><br><span class="hljs-comment">8</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">(3)</span><br><span class="hljs-comment">3 5 3</span><br><span class="hljs-comment">1 6 0</span><br><span class="hljs-comment">2 0 0</span><br><span class="hljs-comment">3 0 0</span><br><span class="hljs-comment">3 5 3</span><br><span class="hljs-comment">1 0 5</span><br><span class="hljs-comment">2 0 1</span><br><span class="hljs-comment">3 0 2</span><br><span class="hljs-comment">3 5 3</span><br><span class="hljs-comment">1 0 0</span><br><span class="hljs-comment">2 0 0</span><br><span class="hljs-comment">3 0 0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">ans：</span><br><span class="hljs-comment">Impossible</span><br><span class="hljs-comment">8</span><br><span class="hljs-comment">0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span> <br></code></pre></td></tr></table></figure>
<p>如果需要用滚动数组来做的话，则需要定义一个dptmp[]来存放上一组的结果。之前已经分析过，这里就不再赘述了。</p>
<h2 id="hdu3535混合分组背包的典型题">2.5
HDU3535(混合分组背包的典型题)</h2>
<h3 id="原题链接-4">2.5.1 原题链接</h3>
<p>　　<a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=3535">hdu3535
AreYouBusy</a></p>
<p>　　题目中文意思和解读如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">问题描述<br>新学期快乐！<br>到了三年级之后，小A意识到她没有太多时间来解决问题，因为她还有其他事情要做，这使她几乎发疯了。<br>而且，老板告诉她，对于某些工作集合（是一个“分组”），她必须选择组内的至少一项工作；但是对于某些工作集合而言，她则最多只能选择组内的一项工作。这对老板来说毫无意义。对于其他的工作集合，她可以尽自己的意愿，不选或者选做其中的任意多项工作。我们只将她可以选择的东西定义为“工作”。每1个工作都需要时间，并给xiaoA带来一些幸福感（这意味着她总是愿意做这些工作）。因此，您可以选择其中的最佳组合来给她带来最大的幸福快乐点，同时也可以成为一个好的初中生。 （这意味着她应该听老板的建议）？<br><br>输入项<br>下面有几套测试用例，每套测试用例都以两个整数n和T（0 &lt;= n，T &lt;= 100）开头，有n组作业供您选择，由T分钟供她完成。然后后面是n个描述集，每个描述都以两个整数m和s（0 &lt;m &lt;= 100）开头，该集合中有m个作业，集合类型为s，（0代表应选择的集合至少要完成1项工作，对于最多应选择1项的集合要进行1项选择，可以自由选择的项要进行2项选择。），然后后面是m对整数ci，gi（0 &lt;= ci，gi &lt;= 100），表示第i个工作成本为ci分钟，可以通过完成它获得幸福感gi。每一项工作只能做一次。<br> 输出量<br>每个测试用例一行包含我们可以从所有工作中选择的最大幸福值。如果她不能完成老板想要的工作，则输出-1。<br> 样本输入<br>3 3     第1套用例内有3组作业，要求在3分钟内完成<br>2 1        第1组作业内有2个作业，分组类型为1（最多选择1个作业）<br>2 5           第1个作业成本2分钟，幸福值5<br>3 8           第2个作业成本3分钟，幸福值8<br>2 0        第2组作业内有2个作业，分组类型为0（至少要选择1个作业）<br>1 0           第1个作业成本1分钟，幸福值0<br>2 1           第2个作业成本2分钟，幸福值1<br>3 2        第3组作业内有3个作业，分组类型为2（随意选择）<br>4 3           第1个作业成本4分钟，幸福值3<br>2 1           第2个作业成本2分钟，幸福值1<br>1 1           第3个作业成本1分钟，幸福值1<br><br><br>3 4    第2套用例内有3组作业，要求在4分钟内完成<br>2 1        第1组作业内有2个作业，分组类型为1（最多选择1个作业）<br>2 5           第1个作业成本2分钟，幸福值5<br>3 7           第2个作业成本3分钟，幸福值7<br>2 0        第2组作业内有2个作业，分组类型为0（至少要选择1个作业）<br>1 1           第1个作业成本1分钟，幸福值1<br>2 8           第2个作业成本2分钟，幸福值8<br>3 2        第3组作业内有3个作业，分组类型为2（随意选择）<br>4 4           第1个作业成本4分钟，幸福值4<br>2 1           第2个作业成本2分钟，幸福值1<br>1 1           第3个作业成本1分钟，幸福值1<br><br><br>1 1   第3套用例内有1组作业，要求在1分钟内完成<br>1 0       第1组作业内有1个作业，分组类型为0（至少要选择1个作业）<br>2 1          第1个作业成本2分钟，幸福值1<br><br><br>5 3   第4套用例内有5组作业，要求在3分钟内完成 <br>2 0       第1组作业内有2个作业，分组类型为0（至少要选择1个作业）<br>1 0           第1个作业成本1分钟，幸福值0<br>2 1           第2个作业成本2分钟，幸福值1<br>2 0       第2组作业内有2个作业，分组类型为0（至少要选择1个作业）<br>2 2           第1个作业成本2分钟，幸福值2<br>1 1           第2个作业成本1分钟，幸福值1<br>2 0       第3组作业内有2个作业，分组类型为0（至少要选择1个作业）<br>3 2           第1个作业成本3分钟，幸福值2<br>2 1           第2个作业成本2分钟，幸福值1<br>2 1       第4组作业内有2个作业，分组类型为1（最多选择1个作业）<br>1 5           第1个作业成本1分钟，幸福值5<br>2 8           第2个作业成本2分钟，幸福值8<br>3 2       第5组作业内有3个作业，分组类型为2（任意选择作业）<br>3 8           第1个作业成本3分钟，幸福值8<br>4 9           第2个作业成本4分钟，幸福值9<br>5 10          第3个作业成本5分钟，幸福值10<br><br>样本输出<br><br>5<br>13<br>-1<br>-1<br></code></pre></td></tr></table></figure>
<h3 id="分析-3">2.5.2 分析</h3>
<p>　　这是一个分组背包的题，而且每一组的选择策略还不相同，属于混合分组背包，所以不能统一地对整个dp数组去做初始化，而应该根据当前组的选择策略来分别对当前行赋予不同的初始值。当然，第0行是肯定要清零的，而且，因为是多组测试数据，所以需要反复清零。</p>
<p>　　本题中有一种分组策略为“可以选择0个或者任意多个”。这种题型在第一章中没有讲到。其实做起来也很简单。它实际上是题型1和题型3的结合。因为允许本组选0个物品，所以本组不会存在‘无解’的情况。既然如此，初始化时直接沿用上一行数据，表示本组暂选0个。dp[g][0..YS1]=dp[g-1][0..YS1]。然后再采用题型3的策略，2个max组合起来即可。</p>
<p>　　本题中允许ys1[i]和value[i]的值为0。只要在填写dp时采用2个max组合起来填，就没问题。</p>
<p>　　如果把第0列初始化为0，会造成网页中第4个测试样例错误。本题容易出错的地方就是每一行的初始化问题。小心做好，不要“想当然”。</p>
<h3 id="ac代码-4">2.5.3 AC代码</h3>
<p>题目中有些分组要求至少要选择一个物品，为简单和统一，建议全都采用“先for
组内物品k，再for j”的代码框架。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-type">int</span> gcnt, n, YS1, type;<br><span class="hljs-type">int</span> ys1[<span class="hljs-number">101</span>],value[<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> g, j, i;<br>    <span class="hljs-keyword">while</span>( ~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;gcnt, &amp;YS1) ) &#123;  <span class="hljs-comment">// 多组数据</span><br>		<span class="hljs-built_in">memset</span>(dp[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp[<span class="hljs-number">0</span>]));  <span class="hljs-comment">// 做每组数据之前重置第0行为全0。中间的正常格子需要根据分组的类型来决定其初值</span><br><br>        <span class="hljs-keyword">for</span>(g=<span class="hljs-number">1</span>; g&lt;=gcnt; g++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;type);<br>            <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;ys1[i], &amp;value[i]);<br>            <span class="hljs-keyword">if</span>(type == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 组内要至少选择一项工作</span><br>                <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)  <span class="hljs-comment">// 本组要求必须要选，所以可能存在无解，故初始化为无解对应的值-INF，如果选不出来则造成“无解”</span><br>                    dp[g][j] = -INF;   <span class="hljs-comment">// dp[g][0]的初值也必须是无解，其值不能为0！ </span><br><br>                <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>                    <span class="hljs-keyword">for</span>(j=YS1; j&gt;=ys1[i]; j--)<br>                        dp[g][j] = <span class="hljs-built_in">max</span>( dp[g][j], <span class="hljs-built_in">max</span>( dp[g][j-ys1[i]]+value[i], dp[g<span class="hljs-number">-1</span>][j-ys1[i]]+value[i] ) );<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( type == <span class="hljs-number">1</span> ) &#123;	 <span class="hljs-comment">// 组内最多选择一项工作，可以不选</span><br>                <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;=YS1; j++) <span class="hljs-comment">// 当前组初始化，因为本组允许不选，不存在无解，初始化为上一组的对应值，表示“本组什么都不选”这个策略</span><br>                    dp[g][j] = dp[g<span class="hljs-number">-1</span>][j];<br><br>                <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>                    <span class="hljs-keyword">for</span>(j=YS1; j&gt;=ys1[i]; j--) <span class="hljs-comment">// 倒序</span><br>                        dp[g][j] = <span class="hljs-built_in">max</span>( dp[g][j] , dp[g<span class="hljs-number">-1</span>][j-ys1[i]] + value[i] );<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( type == <span class="hljs-number">2</span> ) &#123;     <span class="hljs-comment">// 任意选择，可一个都不选，也可选多个不同工作</span><br>                <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;=YS1; j++)<br>                    dp[g][j] = dp[g<span class="hljs-number">-1</span>][j];  <span class="hljs-comment">// 分析与type==1相同</span><br><br>                <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>                    <span class="hljs-keyword">for</span>(j=YS1; j&gt;=ys1[i]; j--)<br>                        dp[g][j] = <span class="hljs-built_in">max</span>( dp[g][j], <span class="hljs-built_in">max</span>( dp[g][j-ys1[i]]+value[i], dp[g<span class="hljs-number">-1</span>][j-ys1[i]]+value[i] )  );<br>            &#125;<br>        &#125;<br>        dp[gcnt][YS1] = <span class="hljs-built_in">max</span>(dp[gcnt][YS1], <span class="hljs-number">-1</span>); <span class="hljs-comment">//所有“无解”的状态，其值都是远远小于0的，现在做输出调整，输出-1</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[gcnt][YS1]);<br><span class="hljs-comment">//        // 调试专用，省略</span><br><span class="hljs-comment">//        for(int j = 0; j&lt;=YS1; j++)</span><br><span class="hljs-comment">//            printf(&quot;%4d&quot;, j);</span><br><span class="hljs-comment">//        printf(&quot;\n&quot;);</span><br><span class="hljs-comment">//        for(int g=0; g &lt;= gcnt; g++ ) &#123;</span><br><span class="hljs-comment">//            for(int j = 0; j&lt;=YS1; j++)</span><br><span class="hljs-comment">//                printf(&quot;%4d&quot;, max(-1,dp[g][j]));</span><br><span class="hljs-comment">//            printf(&quot;\n&quot;);</span><br><span class="hljs-comment">//        &#125;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">第一套测试样例</span><br><span class="hljs-comment">5 3</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">1 0</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">2 2</span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">1 5</span><br><span class="hljs-comment">2 8</span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">3 8</span><br><span class="hljs-comment">4 9</span><br><span class="hljs-comment">5 10</span><br><span class="hljs-comment">正确输出</span><br><span class="hljs-comment">-1</span><br><span class="hljs-comment">错误输出</span><br><span class="hljs-comment">8 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">第二套测试样例</span><br><span class="hljs-comment">输入：</span><br><span class="hljs-comment">3 3</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">2 5</span><br><span class="hljs-comment">3 8</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">1 0</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">4 3</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">3 4</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">2 5</span><br><span class="hljs-comment">3 7</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">1 3</span><br><span class="hljs-comment">1 8</span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">4 4</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment">1 0</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">5 3</span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">1 0</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">2 2</span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2 0</span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">1 5</span><br><span class="hljs-comment">2 8</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">3 2</span><br><span class="hljs-comment">3 8</span><br><span class="hljs-comment">4 9</span><br><span class="hljs-comment">5 10</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">1 4</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">2 5</span><br><span class="hljs-comment">3 7</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">正确输出：</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">16</span><br><span class="hljs-comment">-1</span><br><span class="hljs-comment">-1</span><br><span class="hljs-comment">7</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">雪宝和七七的爸爸</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/07/02/%E4%B8%89%E7%A7%8D%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E7%9A%84%E5%A4%84%E7%90%86/">http://example.com/2024/07/02/%E4%B8%89%E7%A7%8D%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E7%9A%84%E5%A4%84%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">宝爸编程</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BF%A1%E6%81%AF%E5%AD%A6/">信息学</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/21/%E5%8C%BA%E9%97%B4%E5%88%86%E6%AE%B5dp%EF%BC%88%E2%80%9C%E8%90%9D%E5%8D%9C%E5%A1%AB%E5%9D%91%E2%80%9D%EF%BC%89%E6%A8%A1%E5%9E%8B/" title="区间分段dp（“萝卜填坑”）模型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">区间分段dp（“萝卜填坑”）模型</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/24/%E6%B1%82%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%85%B7%E4%BD%93%E6%96%B9%E6%A1%88/" title="求背包问题的具体方案"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">求背包问题的具体方案</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/04/25/LIS%E9%97%AE%E9%A2%98/" title="最长不下降子序列（LIS）问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-25</div><div class="title">最长不下降子序列（LIS）问题</div></div></a></div><div><a href="/2024/04/25/LCS%E9%97%AE%E9%A2%98/" title="最长公共子序列（LCS）问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-25</div><div class="title">最长公共子序列（LCS）问题</div></div></a></div><div><a href="/2024/07/31/dp%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E8%AE%AD%E7%BB%83/" title="dp中的状态转移训练"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-31</div><div class="title">dp中的状态转移训练</div></div></a></div><div><a href="/2020/03/13/hello/" title="我的第一篇博客"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-13</div><div class="title">我的第一篇博客</div></div></a></div><div><a href="/2024/03/06/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/" title="二分查找和二分答案"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-06</div><div class="title">二分查找和二分答案</div></div></a></div><div><a href="/2025/01/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D-%E4%B8%AD-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/" title="二叉树的前-中-后序遍历"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-10</div><div class="title">二叉树的前-中-后序遍历</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">雪宝和七七的爸爸</div><div class="author-info__description">本博客致力于信息学奥赛知识学习。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://cspcoding.github.io/"><i class="fab fa-github"></i><span>回到主页</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">玩游戏害人害己哦！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E7%90%86%E8%AE%BA%E6%95%99%E5%AD%A6"><span class="toc-text">一、理论教学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E7%9A%84%E9%A2%98%E5%9E%8B%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-text">1.1 分组背包的题型和分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%9E%8B1%E6%AF%8F%E7%BB%84%E7%89%A9%E5%93%81%E9%80%89%E7%9A%84%E7%89%A9%E5%93%81%E4%B8%AA%E6%95%B01%E4%B8%AA"><span class="toc-text">1.2
题型1：每组物品选的物品个数&lt;&#x3D;1个</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88for-%E7%BB%84%E5%86%85%E7%89%A9%E5%93%81k%E5%86%8Dfor-j%E9%87%8D%E7%82%B9%E6%8E%8C%E6%8F%A1"><span class="toc-text">1.2.1 先for 组内物品k，再for
j（重点掌握）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88for-j%E5%86%8Dfor-%E7%BB%84%E5%86%85%E7%89%A9%E5%93%81k"><span class="toc-text">1.2.2 先for j，再for 组内物品k</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%9E%8B2%E6%AF%8F%E7%BB%84%E7%89%A9%E5%93%81%E9%80%89%E7%9A%84%E7%89%A9%E5%93%81%E4%B8%AA%E6%95%B0-1%E4%B8%AA"><span class="toc-text">1.3
题型2：每组物品选的物品个数&#x3D; &#x3D;1个</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88for-%E7%BB%84%E5%86%85%E7%89%A9%E5%93%81k%E5%90%8Efor-j%E9%87%8D%E7%82%B9%E6%8E%8C%E6%8F%A1"><span class="toc-text">1.3.1 先for 组内物品k，后for
j（重点掌握）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88for-j%E5%90%8Efor-%E7%BB%84%E5%86%85%E7%89%A9%E5%93%81k"><span class="toc-text">1.3.2 先for j，后for 组内物品k</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%9E%8B3%E6%AF%8F%E7%BB%84%E7%89%A9%E5%93%81%E9%80%89%E7%9A%84%E7%89%A9%E5%93%81%E4%B8%AA%E6%95%B0-1%E4%B8%AA"><span class="toc-text">1.4
题型3：每组物品选的物品个数&gt; &#x3D;1个</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88for-%E7%BB%84%E5%86%85%E7%89%A9%E5%93%81k%E5%86%8Dfor-j%E6%8E%8C%E6%8F%A1"><span class="toc-text">1.4.1 先for 组内物品k，再for
j（掌握）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88for-j%E5%86%8Dfor-%E7%BB%84%E5%86%85%E7%89%A9%E5%93%81k-1"><span class="toc-text">1.4.2 先for j，再for 组内物品k</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%AE%9E%E6%88%98%E7%BB%83%E4%B9%A0"><span class="toc-text">二、实战练习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%8F%E7%BB%84%E6%9C%80%E5%A4%9A%E9%80%891%E4%B8%AA%E7%89%A9%E5%93%81"><span class="toc-text">2.1 1272（每组最多选1个物品）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5"><span class="toc-text">2.1.1 原题链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ac%E4%BB%A3%E7%A0%81"><span class="toc-text">2.1.2 AC代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#p5322%E6%AF%8F%E7%BB%84%E6%9C%80%E5%A4%9A%E9%80%891%E4%B8%AA%E7%89%A9%E5%93%81"><span class="toc-text">2.2 P5322（每组最多选1个物品）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5-1"><span class="toc-text">2.2.1 原题链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-text">2.2.2 分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ac%E4%BB%A3%E7%A0%81-1"><span class="toc-text">2.2.3 AC代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#p2409%E6%AF%8F%E7%BB%84%E5%8F%AA%E8%83%BD%E9%80%891%E4%B8%AA%E7%89%A9%E5%93%81%E4%B8%8D%E8%83%BD%E5%A4%9A%E4%B8%8D%E8%83%BD%E5%B0%91"><span class="toc-text">2.3
P2409（每组只能选1个物品，不能多、不能少）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5-2"><span class="toc-text">2.3.1 原题链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-1"><span class="toc-text">2.3.2 分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ac%E4%BB%A3%E7%A0%81-2"><span class="toc-text">2.3.3 AC代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88for-%E7%BB%84%E5%86%85%E7%89%A9%E5%93%81k%E5%90%8Efor-j"><span class="toc-text">2.3.3.1 先for 组内物品k，后for j</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88for-j-%E5%86%8Dfor-%E7%BB%84%E5%86%85%E7%89%A9%E5%93%81k"><span class="toc-text">2.3.3.2 先for j 再for 组内物品k</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hdu3033%E6%AF%8F%E7%BB%84%E8%87%B3%E5%B0%91%E9%80%89%E6%8B%A91%E4%B8%AA%E7%89%A9%E5%93%81"><span class="toc-text">2.4
HDU3033（每组至少选择1个物品）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5-3"><span class="toc-text">2.4.1 原题链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-2"><span class="toc-text">2.4.2 分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ac%E4%BB%A3%E7%A0%81-3"><span class="toc-text">2.4.3 AC代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hdu3535%E6%B7%B7%E5%90%88%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E7%9A%84%E5%85%B8%E5%9E%8B%E9%A2%98"><span class="toc-text">2.5
HDU3535(混合分组背包的典型题)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5-4"><span class="toc-text">2.5.1 原题链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-3"><span class="toc-text">2.5.2 分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ac%E4%BB%A3%E7%A0%81-4"><span class="toc-text">2.5.3 AC代码</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/16/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%881%EF%BC%89%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/" title="栈的应用（1）括号匹配">栈的应用（1）括号匹配</a><time datetime="2025-01-16T03:11:55.591Z" title="发表于 2025-01-16 11:11:55">2025-01-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D-%E4%B8%AD-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/" title="二叉树的前-中-后序遍历">二叉树的前-中-后序遍历</a><time datetime="2025-01-09T16:00:00.000Z" title="发表于 2025-01-10 00:00:00">2025-01-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/04/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8/" title="栈的应用">栈的应用</a><time datetime="2025-01-04T06:01:31.659Z" title="发表于 2025-01-04 14:01:31">2025-01-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/01/%EF%BC%88%E4%B8%89%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/" title="（三）宽度小于等于m的区间的“最大的和值”问题">（三）宽度小于等于m的区间的“最大的和值”问题</a><time datetime="2025-01-01T09:38:09.649Z" title="发表于 2025-01-01 17:38:09">2025-01-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/01/%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9B%BA%E5%AE%9A%E5%AE%BD%E5%BA%A6%E4%B8%BAm%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/" title="（二）固定宽度为m的区间的“最大的和值”问题">（二）固定宽度为m的区间的“最大的和值”问题</a><time datetime="2025-01-01T09:38:09.640Z" title="发表于 2025-01-01 17:38:09">2025-01-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 雪宝和七七的爸爸</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>