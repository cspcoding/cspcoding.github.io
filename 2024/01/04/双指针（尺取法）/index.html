<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>双指针与尺取法 | 宝爸编程</title><meta name="author" content="雪宝和七七的爸爸"><meta name="copyright" content="雪宝和七七的爸爸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、理论教学 1.1 “最长不重复字串”问题 “最长不重复子串”是一个经典问题。题意如下： Leetcode第3题：给定一个字符串s(s 由英文字母、数字、符号和空格组成，长度在[0, 50000])，请你找出其中不含有重复字符的 最长子串 的长度。 1.1.1 初步分析 首先我们分析一下这个问题的关键信息，主要有以下四个：  1）n的取值范围是 \(0\leq n\leq">
<meta property="og:type" content="article">
<meta property="og:title" content="双指针与尺取法">
<meta property="og:url" content="http://example.com/2024/01/04/%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%88%E5%B0%BA%E5%8F%96%E6%B3%95%EF%BC%89/index.html">
<meta property="og:site_name" content="宝爸编程">
<meta property="og:description" content="一、理论教学 1.1 “最长不重复字串”问题 “最长不重复子串”是一个经典问题。题意如下： Leetcode第3题：给定一个字符串s(s 由英文字母、数字、符号和空格组成，长度在[0, 50000])，请你找出其中不含有重复字符的 最长子串 的长度。 1.1.1 初步分析 首先我们分析一下这个问题的关键信息，主要有以下四个：  1）n的取值范围是 \(0\leq n\leq">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-01-03T16:00:00.000Z">
<meta property="article:modified_time" content="2025-02-27T06:21:42.713Z">
<meta property="article:author" content="雪宝和七七的爸爸">
<meta property="article:tag" content="信息学">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/01/04/%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%88%E5%B0%BA%E5%8F%96%E6%B3%95%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":5,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '双指针与尺取法',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2025-02-27 14:21:42'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/static/css/custom.css"><link rel="stylesheet" href="/fonts/font.css"><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="宝爸编程"><span class="site-name">宝爸编程</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">双指针与尺取法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-03T16:00:00.000Z" title="发表于 2024-01-04 00:00:00">2024-01-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-27T06:21:42.713Z" title="更新于 2025-02-27 14:21:42">2025-02-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">基础算法</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">线性结构基础算法</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/">双指针</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="双指针与尺取法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一理论教学">一、理论教学</h1>
<h2 id="最长不重复字串问题">1.1 “最长不重复字串”问题</h2>
<p>“最长不重复子串”是一个经典问题。题意如下：</p>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">Leetcode第3题</a>：给定一个字符串s(<code>s</code>
由英文字母、数字、符号和空格组成，长度在[0,
50000])，请你找出其中不含有重复字符的 <strong>最长子串</strong>
的长度。</p>
<h3 id="初步分析">1.1.1 初步分析</h3>
<p>首先我们分析一下这个问题的关键信息，主要有以下四个：</p>
<ul>
<li><p>1）n的取值范围是 <span class="math inline">\(0\leq n\leq
5*10^4\)</span> ；</p></li>
<li><p>2）最长；</p></li>
<li><p>3）所有字符不重复；</p></li>
<li><p>4）子串；</p></li>
</ul>
<p>根据以上的几个关键词，我们可以得出一些结论：</p>
<p>1)根据的范围已经能够大致确认这是一个需要<span
class="math inline">\(O(n)\)</span>或者<span
class="math inline">\(O(lon_2n)\)</span>的算法才能解决的问题；</p>
<p>2)"最长"
意味着可能是一个动态规划问题或者贪心问题，也有可能是搜索。所以这个关键词给我们的信息用处不大；</p>
<p>3)而“判断字符是否重复”可以用 <strong>哈希表</strong> 在<span
class="math inline">\(O(1)\)</span>的时间内判断；</p>
<p>4)左和右两个端点能确定出一个子串，所以<strong>枚举所有
"子串"</strong>意味着要枚举这两个端点，其时间复杂度是<span
class="math inline">\(O(n^2)\)</span>的。</p>
<h3 id="朴素算法简单了解即可">1.1.2 朴素算法（简单了解即可）</h3>
<p>由以上分析，我们可以发现第1）个和
第4）个关键词给我们得出的结论是矛盾的。那么，我们可以先尝试减小 n
的范围。当<span class="math inline">\(n\leq
10^3\)</span>时，怎么解决这个问题呢？浅显一点地来想：因为最后求的是满足条件的最长子串，所以我们如果能够枚举所有子串，那么选择长度最长的满足条件<span
class="math inline">\(^{(*)}\)</span>的子串就是答案了（这里的条件<span
class="math inline">\(^{(*)}\)</span>是指子串中所有字符都不同）。</p>
<p>用 ans 记录我们需要求的最大不重复子串的长度，用一个哈希表 h[]
来代表某个字符是否出现过（你可以理解为一个访问标记数组，类似于vis[]），一个不太成熟的算法就成型了，描述如下：</p>
<ul>
<li><p>1）外层循环枚举子串的左端点 <span class="math inline">\(i=0
\rightarrow n−1\)</span>；</p></li>
<li><p>2）清空哈希表h[]；</p></li>
<li><p>3）内层循环枚举子串的右端点 <span class="math inline">\(j=i
\rightarrow n−1\)</span> ，如果当前这个字符<span
class="math inline">\(s_j\)</span>出现过（即 <span
class="math inline">\(h[s_j]=true\)</span>），则跳出j的循环；否则令<span
class="math inline">\(h[s_j]=true\)</span>，并且用当前长度去考虑更新ans （即 <span
class="math inline">\(ans=max⁡(ans, j−i+1)\)</span>）；</p></li>
<li><p>4）回到 2）；</p></li>
</ul>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">Leetcode第3题</a>的C++实现部分代码(朴素，AC，超过6.4%)如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>            <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">int</span> h[<span class="hljs-number">50005</span>]= &#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, i, j, len;<br>            <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;           <span class="hljs-comment">// 1)</span><br>                j = i;<br>                <span class="hljs-built_in">memset</span>(h, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(h));   <span class="hljs-comment">// 2)</span><br>                <span class="hljs-keyword">while</span>(j &lt; n &amp;&amp; !h[s[j]]) &#123;<br>                    h[ s[j] ] = <span class="hljs-literal">true</span>;        <span class="hljs-comment">// 3)</span><br>                    len = j - i + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(len &gt; ans)<br>                        ans = len; <span class="hljs-comment">// 记录最长值len的同时，也记录下其左端位置i和右端位置j的值</span><br>                    ++j;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>• 1）枚举对应子串的左端点i；</p>
<p>• 2）清空哈希表h，其中<span
class="math inline">\(h[s_j]=true\)</span>代表原字符串的第j个字符<span
class="math inline">\(s_j\)</span>是否出现在以第i个字符为左端点的子串中；</p>
<p>•
3）如果字符串s[i..j]中已经出现重复的字符，那么s[i..j+1],s[i..j+2],…,s[i..n−1]
必然会有重复字符，所以这里不需要继续往下枚举，直接跳出内层循环即可。</p>
<p>这个算法执行完毕， ans就是我们要求的最长不重复子串的长度， [l,
r]代表了最长不重复子串在原字符串的区间。正确性毋庸置疑，因为已经枚举了所有子串的情况，如果字符集的个数为
z ，那么算法的时间复杂度就是O(n∗z) 。</p>
<p>上述朴素算法的求解过程，其动图和不动图如下所示：</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th><img
src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/clip_image001.gif"
alt="图片" />原图</th>
<th><img
src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/image-20240104150815148.png"
alt="image-20240104150815148" /> （i=0)</th>
<th><img
src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/image-20240104150831827.png"
alt="image-20240104150831827" />(i=1)</th>
<th><img
src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/image-20240104150853687.png"
alt="image-20240104150853687" />（i=2)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><img
src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/image-20240104151050940.png"
alt="image-20240104151050940" /> （i=3)</td>
<td><img
src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/image-20240104151122690.png"
alt="image-20240104151122690" /> （i=4)</td>
<td><img
src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/image-20240104151137103.png"
alt="image-20240104151137103" /> （i=5、6、7)</td>
<td></td>
</tr>
</tbody>
</table>
<p>结论：字符串下标从 0
开始编号，该样例最长无重复子串为：s[1:5]=“bcaed”，长度为 5。</p>
<p>复杂度分析：由于该串是字符串，而一般的字符集内最多256个不同的字符。
所以时间复杂度基本就是O(n∗256) ，当 <span class="math inline">\(1\leq
n\leq 10^7\)</span> 时，这个时间复杂度<span
class="math inline">\(O(1e7∗256) \geq
1e7\)</span>，是肯定会TLE的，必须需要想办法优化。</p>
<h3 id="对朴素算法进行优化">1.1.3 对朴素算法进行优化</h3>
<p>如果仔细思考上面例题1的朴素算法的求解过程，就会发现：枚举子串的时候有很多区间是重叠的，所以必然存在许多没有必要的重复计算。</p>
<p>我们考虑一个子串以i为左端点，j为右端点，且s[i..j−1]中不存在重复字符，s[i..j]中存在重复字符（换言之，s[j]和s[i..j−1]
中某个字符产生重复）的情况。如下图所示。</p>
<div data-align="center">
<img src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/image-20240104152821376.png" width = 40%/>
</div>
<p>在上图的情况下，我们没必要再去检测 s[i..j+1], s[i..j+2],…, s[i..n−1]
这几个字符串的合法性，因为当前情况s[i..j]是非法的，而这些字符串是完全包含s[i..j]
的，所以它们必然也是不合法的。</p>
<p>那么我们可以把枚举的左端点i自增，即：i=i+1，这时，按照朴素算法的实现，右端点需要重置，即
j=i，实际上这里的右端点可以不动。</p>
<p>可以这么考虑，由于s[j]这个字符和
s[i..j−1]中的某个字符s[k](k值未知)产生了重复，那么如果现在必须要加入s[j]且整个串不能产生重复字符，也就意味着s[x]必须要出局，即
i 必须在位置x的右侧，即满足 i&gt;k ，换言之， i可以一直自增，直到
i=k+1，如下图所示：</p>
<div data-align="center">
<img src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/image-20240104153650717.png" width = 40%/>
</div>
<p>利用上述思路，我们重新实现 最长不重复子串 的算法， c++
代码（改进，AC，超过70%）实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>            <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">-1</span>, len;   <span class="hljs-comment">// i=0, j=i-1代表 s[i:j] 为一个空串，从空串开始枚举</span><br>            <span class="hljs-type">int</span> h[<span class="hljs-number">50005</span>]= &#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-keyword">while</span> (j++ &lt; n - <span class="hljs-number">1</span>) &#123;              <span class="hljs-comment">// 外层循环看快指针j，快指针j右移前进，拓宽区间</span><br>                ++h[ s[j] ];<br>                <span class="hljs-keyword">while</span> (h[ s[j] ] &gt; <span class="hljs-number">1</span>) &#123;        <span class="hljs-comment">// 如果区间[i,j]不满足指定条件，</span><br>                    --h[ s[i] ];               <span class="hljs-comment">//   就调整慢指针i右移，收窄区间，直到满足指定条件为止</span><br>                    ++i;                       <span class="hljs-comment">//</span><br>                &#125;<br>                len = j - i + <span class="hljs-number">1</span>;               <span class="hljs-comment">// 此时的区间[i,j]是局部最优解，记录</span><br>                <span class="hljs-keyword">if</span>(len &gt; ans)                  <span class="hljs-comment">//        考虑刷新</span><br>                    ans = len;                 <span class="hljs-comment">// 可以在此处记录i和j，以记录最长区间的左右端</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>对于待定区间[i,
j]，如何确定该区间是否符合指定条件（即区间内的字符不重复）呢？其实也很简单。只需要维护h[]和判断
h[str[j]]&gt;1，如果判断成立，则表示重复，不符合条件。这是<span
class="math inline">\(O(1)\)</span>的操作，满足区间的时效性。</p>
<p>算法执行完毕后，我们就可以得到最长不重复子串的长度为 ans ，并且 i 和
j 这两个指针分别只自增 n
次。当j右移时，i未动。当i右移时，j未动。两个指针都从未回退过。所以该算法的时间复杂度为
<span class="math inline">\(O(n*2)=O(n)\)</span> 。</p>
<p>可以将第9行处的1改为k，以适应“求字符的重复次数不超过k次的最长子串”问题。</p>
<p>利用该优化算法优化后的最长不重复子串的求解过程如图所示：</p>
<figure>
<img src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/640%20(1).gif"
alt="640 (1)" />
<figcaption aria-hidden="true">640 (1)</figcaption>
</figure>
<p>对上述内容的简单总结是：当区间中存在重复（红色）字符时，左指针 i
自增；否则，右指针 j 自增。</p>
<h2 id="尺取法双指针法">1.2 尺取法（双指针法）</h2>
<h3 id="算法定义">1.2.1 算法定义</h3>
<p>如1.1.3节所述，这种利用问题特性，<strong>通过两个指针，不断调整区间，从而求出问题最优解</strong>的模型就叫
"<strong>尺取法</strong>"模型。由于利用的是两个指针，所以又叫 "双指针"
模型。</p>
<p>这里 "尺"
的含义，主要还是因为这类问题最终要求解的都是连续的序列（子串），就好比一把尺子一样，故而得名。</p>
<p><strong>双指针法</strong>（又称为“<strong>尺取法</strong>”）模型，是一个常用的优化技巧，用来解决<strong>序列的区间问题</strong>。</p>
<p>在双指针法中，会有两个指针i、j分别代表了区间的左右位置下标。它们有两种扫描方向：</p>
<p>1）反向扫描：i、j方向相反，i从左往右，j从右往左，在中间相会；</p>
<p>2）同向扫描：i、j方向相同，都从左往右，可以让j跑在i的前面。</p>
<p>其中，同向扫描的两个指针称为“<strong>快慢指针</strong>”。它们在序列上产生一个大小可变的“<strong>滑动窗口</strong>”，有多种灵活的运用。本帖研究的主要就是这种同向扫描。</p>
<h3 id="指定条件与代码模板的适用场合">1.2.2
“指定条件”与代码模板的适用场合</h3>
<p>在1.2.1节中曾指出，双指针法，是用来解决序列的区间上的问题。如果问题是“要求从原始序列中抽取分散的多个数据”，这不是区间问题，不能用双指针法模型。如果要求连续区间，但不满足下述的“单调性”，则只能采用普通的办法。反之，如果是要找满足<strong>指定条件(<span
class="citation" data-cites="1">@1</span>)</strong>的最<strong>短(<span
class="citation" data-cites="2">@2</span>)</strong>/最<strong>长(<span
class="citation"
data-cites="3">@3</span>)</strong>的连续区间，则可以使用一定的套路模板。该模板会在1.2.3节中详述。</p>
<p>这里所说的"<strong>指定条件</strong>"的内涵并未明确化。对于本题来说，<strong>指定条件</strong>就是
"字符不重复"。当然，其他题也可以是 "每个字符重复次数不超过 k
次"，"至少包含 k 种字符"，"求和不大于 k " 等等，千变万化，因题而异。</p>
<p>如果要使用双指针法的代码模板，那么这个"指定条件"必须要满足以下两点：</p>
<p>1）待定区间的<strong>单调性</strong></p>
<p>所谓“单调性”，就是说：任意一个指针的增加，条件满足与否只会出现两种情况，即
：【满足 -&gt; 不满足】或者 【不满足 -&gt; 满足】，<strong>不能出现
【满足 -&gt; 不满足 -&gt; 满足】这样反复不定的情况。</strong></p>
<p>2）待定区间的<strong>时效性</strong></p>
<p><strong>所谓“时效性”，就是说：必须在 <span
class="math inline">\(O(1)\)</span>或者 <span
class="math inline">\(O(log_2⁡n)\)</span> 的时间内就能确定出当前区间 [i,
j] 是否满足指定条件，否则无法用尺取法求解。</strong></p>
<h3 id="算法描述">1.2.3 算法描述</h3>
<p>在1.2.2节中我们提到了求最短<span
class="math inline">\((@2)\)</span>和最长<span
class="math inline">\((@3)\)</span>区间
这两种情况。这两种情况，算法有差异，下面分开进行阐述。</p>
<h4 id="求最长区间">1.2.3.1 求最长区间</h4>
<ul>
<li><p>1）初始化i=0（数组从0存）/1（数组从1存） ,j=i−1
，表示初始区间的长度为 0；</p></li>
<li><p>2）外层循环为<strong>快</strong>指针j，<strong>右拓宽</strong>区间，（右移j，j++）；</p></li>
<li><p>3）当区间<font color="red"><strong>不满足</strong></font>条件时，一直<strong>左收窄</strong>（内层循环）该新区间（慢指针i右移,i++),
直到区间满足条件，结束内层循环；</p></li>
<li><p>4）此时的区间是局部最优解，<font color="red"><strong>记录</strong></font>，回到
2）；</p></li>
</ul>
<p>之所以求最长区间，往往是因为当区间右拓宽之后，会导致区间不合法（否则直接拿[1,n]当答案得了）。所以，在步骤2）之后，需要持续检验新区间并左收窄之，直到新区间合法为止。</p>
<h4 id="求最短区间">1.2.3.2 求最短区间</h4>
<ul>
<li><p>1）初始化i=0（数组从0存）/1（数组从1存） ,j=i−1
，表示初始区间的长度为 0；</p></li>
<li><p>2）外层循环为<strong>快</strong>指针j，<strong>右拓宽</strong>区间，（右移j，j++）；</p></li>
<li><p>3）当区间<font color="red"><strong>满足</strong></font>条件时，一直<strong>左收窄</strong>（内层循环）该新区间（慢指针i右移,i++),
<font color="red"><strong>记录</strong></font>局部最优解，直到区间不满足条件，结束内层循环；</p></li>
<li><p>4）回到 2）；</p></li>
</ul>
<p>之所以求最短区间，往往是因为当区间右拓宽之后，虽然仍然合法（单调性决定），但区间不够短。所以，在步骤2）之后，需要持续检验新区间并左收窄之，尝试优化局部解，直到新区间不合法为止。</p>
<h1 id="二实战训练">二、实战训练</h1>
<h2
id="视频教学链接"><a href="https://www.bilibili.com/video/BV1Mp4y1E74K/?_blank" target="_blank">视频教学链接：</a></h2>
<h2 id="最长无重复子串问题最长">2.1 最长无重复子串问题（最长）</h2>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">Leetcode第3题</a></p>
<p>题解代码见1.1.3节。</p>
<h2 id="区间和问题最短">2.2 区间和问题（最短）</h2>
<p><a target="_blank" rel="noopener" href="http://poj.org/problem?id=3061"><strong>POJ 3061
Subsequence</strong></a></p>
<p>【中文大意】现在有t组数据，每组数组中给定 <span
class="math inline">\(n(10&lt;n&lt;10^5)\)</span> 个正数 <span
class="math inline">\(a_i (0&lt;a_i \leq 10^4)\)</span> 和一个正数 <span
class="math inline">\(p(0&lt;p&lt;10^8)\)</span>
。找到一个最短的连续子序列，满足它的和 <span class="math inline">\(s\geq
p\)</span>，输出该区间的长度值。如果全部加起来都不能&gt;=m，则该样例输出0。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">输入样例：<br>2					  // 有2组数据<br>10 15                   // 第一组数据有10个正数，阀值p为15<br>5 1 3 5 10 7 4 9 2 8    // 10个数据<br>5 11                    // 第二组数据有5个正数，阀值p为11<br>1 2 3 4 5               // 5个数据<br>输出样例：               <br>2                       // 在第一组数据中，a4+a5=15&gt;=p=15，长度2，且是最短的<br>3                       // 在第二组数据中，a3+a4+a5=12&gt;=p=11，长度3，且是最短的   <br></code></pre></td></tr></table></figure>
<p>解题分析：</p>
<p>A. 单调性分析：对于一个连续子序列a[i..j] ，它所有数之和 s[i..j]<span
class="math inline">\(=\sum_{k=i}^{j}a_k\)</span> 。如果我们已经知道
<span class="math inline">\(s[i..j] \geq p\)</span>
，那么就没必要再去求s[i..j+1] ( 因为a[j+1]&gt;0，所以s[i..j+1]= s[i..j]
+ a[j+1] &gt; s[i..j] <span class="math inline">\(\geq p\)</span>
，但题目要求找最短的区间，所以没必要再去求s[i..j+1])。所以基于这点，该题所述的“条件”满足单调性。</p>
<p>B. 时效性分析：可以定义前缀和数组 ，通过 O(1)
的代价计算出给定区间[i..j]之间的连续子序列的和。O(1)的代价，这是具有时效性的。</p>
<p>C. 本题要求满足指定条件的一个区间[i,
j]，但根据题意，有可能不存在这样的区间。（举个反例:"在1..10这个数列中找出一个区间，使得该区间数值和大于等于500万"，根本找不到这样的区间）。所以要留意区间长len=0的可能。</p>
<div data-align="center">
<img src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/image-20240111160121957.png" width = 80%/>
</div>
<p>AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//// 方法1：尺取法</span><br><span class="hljs-comment">// 基本题意：给长度为n (10 &lt; n &lt; 1e5)的数组，每个元素&lt;=1e4。另外有一个整数m(m&lt;1e9)，</span><br><span class="hljs-comment">//           求数组中数的总和&gt;=m的连续子序列的最小长度。如果全部加起来都不能&gt;=m，则</span><br><span class="hljs-comment">//           该样例输出 0</span><br><span class="hljs-comment">//  输入：</span><br><span class="hljs-comment">//  2组样例</span><br><span class="hljs-comment">//  n = 10，m = 15</span><br><span class="hljs-comment">//  5 1 3 5 10 7 4 9 2 8</span><br><span class="hljs-comment">//  输出：</span><br><span class="hljs-comment">//  2        (至少要有2个数，即5 10 这个子序列的和满足&gt;=15)</span><br><span class="hljs-comment">//  n = 5，m = 11</span><br><span class="hljs-comment">//  1 2 3 4 5</span><br><span class="hljs-comment">//  输出：</span><br><span class="hljs-comment">//  3        (至少要有3个数，即3 4 5 这个子序列的和满足&gt;=11)</span><br><br><span class="hljs-comment">//#include &lt;bits/stdc++.h&gt;</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br>LL data[maxn], le, ri, n, m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    LL t, i;<br>    cin &gt;&gt;t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        cin &gt;&gt;n &gt;&gt;m;<br>        <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>            cin&gt;&gt;data[i];<br>        &#125;<br>        le=<span class="hljs-number">1</span>;                      <span class="hljs-comment">// 区间左端至少应该是从第一个数开始</span><br>        LL minlen=n+<span class="hljs-number">1</span>;             <span class="hljs-comment">// 求符合条件的数的最小值的套路：先让最小值的初值为一个不可能的极大值，然后打擂台 </span><br>        LL sum=<span class="hljs-number">0</span>, len=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> ( ri=<span class="hljs-number">1</span>; ri&lt;=n; ri++) &#123; <span class="hljs-comment">// 快指针朝前进，作为主循环</span><br>            sum+=data[ri];         <span class="hljs-comment">// 区间已拓宽，处理相关事务（刷新sum和len）</span><br>            len++;<br>            <span class="hljs-comment">// 我们希望找到&quot;最短&quot;区间，所以每次拓宽区间的同时要想着能不能缩短区间(在符合条件的前提下)</span><br>            <span class="hljs-keyword">while</span> (sum-data[le] &gt;= m) &#123; <span class="hljs-comment">// 当区间[le+1, ri]合法时，连续尝试缩短区间</span><br>                sum= sum - data[le];  <span class="hljs-comment">// 缩短区间后，处理相关事务（刷新sum、le指针、len和minlen） </span><br>                le++;<br>                len--;<br>                <span class="hljs-keyword">if</span> (len&lt;minlen) &#123;<br>                    minlen= len;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (minlen==n+<span class="hljs-number">1</span>)       <span class="hljs-comment">// 如果全都不符合题意，即所有数加起来都不够m </span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, minlen);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入样例：</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">10 15</span><br><span class="hljs-comment">5 1 3 5 10 7 4 9 2 8</span><br><span class="hljs-comment">5 11</span><br><span class="hljs-comment">1 5 3 4 2</span><br><span class="hljs-comment">10 1000000</span><br><span class="hljs-comment">5 1 3 5 10 7 4 9 2 8</span><br><span class="hljs-comment">输出样例：</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">0 </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h2 id="luogu-p1147-连续自然数和img">2.3 <a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1147">Luogu P1147
连续自然数和</a><img
src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/1973969-20230825170629229-1325480434.png"
alt="img" /></h2>
<p>这个题，咋一看感觉像是“区间和”问题，但仔细分析发现：当区间拓宽或收窄时，都有可能会出现“不符合条件——符合——不符合”的情况。所以上面总结的两个代码模板，不适合本题。只能双指针硬干。</p>
<p>P1147 AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>,sum=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= m/<span class="hljs-number">2</span>) &#123;     <span class="hljs-comment">// 因为要求区间内至少2个数，所以左端数必然&lt;=m/2</span><br>        <span class="hljs-keyword">if</span>(sum&lt;m) &#123;       <span class="hljs-comment">// 不够就加右 </span><br>            j++;          <span class="hljs-comment">// 右拓宽 </span><br>            sum += j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum&gt;=m) &#123;      <span class="hljs-comment">// 超过就减左</span><br>            <span class="hljs-keyword">if</span>(sum==m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,i,j);<br>            sum -= i;     <span class="hljs-comment">// 左收窄</span><br>            i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>另一个类似的题目是<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1638">P1638</a>。其AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn= <span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> num,minwidth,le,j,ll,rr;<br><span class="hljs-type">int</span> n,m,a[maxn];  	<span class="hljs-comment">// a[5]=3 表示第5幅画是3号画家画的</span><br><span class="hljs-type">int</span> cnt[<span class="hljs-number">2005</span>]; 		<span class="hljs-comment">// cnt[i]表示当前区间[le, j]内画家i的图画数</span><br><span class="hljs-comment">// cnt[10]=2 表示10号画家有2幅画在当前区间【le,j】里</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n, &amp;m);  <span class="hljs-comment">// n 幅画，m个画家</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    le=<span class="hljs-number">1</span>;      <span class="hljs-comment">// 区间左端至少应该是从第一个画家开始</span><br>    num=<span class="hljs-number">0</span>;     <span class="hljs-comment">// 当前区间内画家的人数</span><br>    minwidth=maxn;<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>; j&lt;=n; j++) &#123;  <span class="hljs-comment">// 快指针作为主循环</span><br>        <span class="hljs-comment">// 快指针前进，处理相关事情，尤其是num </span><br>        cnt[ a[j] ]++;      <br>        <span class="hljs-keyword">if</span>(cnt[ a[j] ]==<span class="hljs-number">1</span>) num++;<br><br>        <span class="hljs-keyword">while</span>(num&gt;=m) &#123; <span class="hljs-comment">//本题求最短区间，所以当该区间符合条件时，持续收窄区间</span><br>            <span class="hljs-comment">// 先记录</span><br>            <span class="hljs-keyword">if</span>(minwidth &gt; j-le + <span class="hljs-number">1</span>) &#123;   <br>                minwidth = j-le+<span class="hljs-number">1</span>;      <br>                ll=le;<br>                rr=j;<br>            &#125;<br>            <span class="hljs-comment">// 再收窄</span><br>            cnt[ a[le] ]--;<br>            <span class="hljs-keyword">if</span>(cnt[ a[le] ]==<span class="hljs-number">0</span>) num--;  <span class="hljs-comment">// 收窄时一定会影响到num的值 </span><br>            le++; <br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,ll,rr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入</span><br><span class="hljs-comment">12 5</span><br><span class="hljs-comment">2 5 3 1 3 2 4 1 1 5 4 3</span><br><span class="hljs-comment">输出</span><br><span class="hljs-comment">2 7</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h2 id="luogu-p1102-a-b-数对">2.4 <a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1102">Luogu P1102 A-B
数对</a></h2>
<figure>
<img
src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/1973969-20230825170629214-1614732805.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>本题已知C，要找有多少对“A-B”对。因为A和B都可能有多个，存在重复，且ABC都是正值，所以A必然大于B。对于每一个B，在排序后，存在连续的多个A符合题意。这多个A形成一个等值区间，用i和j-1来标识这个等值区间的左右端，即慢指针和快指针。当存在多个B时，i和j不变，能在<span
class="math inline">\(O(1)\)</span>的效率内解决第二个、第三个B等，使得算法保持高效。i和j都不后退，所以算法效率为<span
class="math inline">\(O(n)\)</span>。但因为需要先sort（sort函数效率<span
class="math inline">\(O(n*log_2n)\)</span>），所以整体算法效率仍然是<span
class="math inline">\(O(n*log_2n)\)</span>。</p>
<p>P1102 AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//  方法2：尺取法  详见“D双指针(尺取法)”  233ms</span><br><span class="hljs-comment">//  该方法和方法1高度相似，只是在for循环内确定i和j时，是采用快慢针前进。</span><br><span class="hljs-comment">//  快慢指针同步向右推进，k表示B，慢指针i指向第一个A，快指针j指向最后一个A的下一个元素 </span><br><span class="hljs-comment">//  因为快慢针并不会后退，所以二重循环的效率实际上是O(n)，优于方法1的O(n*logn) </span><br><span class="hljs-comment">//  </span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7 </span><br><span class="hljs-comment">//  k     i           j                    （1）ans=0+3 =3</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//     k  i           j                    （2）ans=3+3 =6</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//        k               i/j              （3）ans=6+0 =6</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//            k           i/j              （4）ans=6+0 =6</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//                k       i/j              （5）ans=6+0 =6</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//                    k    i          j    （6）ans=6+2 =8</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//                         k         i/j   （7）ans=8+0 =8</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//                              k    i/j   （8）ans=8+0 =8</span><br><span class="hljs-comment">//  1  1  3   3   3   4    6    6     7    </span><br><span class="hljs-comment">//                                    k    i/j=len+1  （9）ans=8+0 =8</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-type">const</span> LL N=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br>LL n,c,a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	cin&gt;&gt;n&gt;&gt;c;<br>	<span class="hljs-keyword">for</span>(LL k=<span class="hljs-number">1</span>; k&lt;=n; k++) cin&gt;&gt;a[k];<br>	<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+n);<br><br>	LL ans=<span class="hljs-number">0</span>;<br>	LL i=<span class="hljs-number">1</span>, j=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span>(LL k=<span class="hljs-number">1</span>; k&lt;=n; k++) &#123; <span class="hljs-comment">//i&lt;=j</span><br>		<span class="hljs-keyword">while</span>(i&lt;=n &amp;&amp; a[i]-a[k]&lt; c) i++;   <span class="hljs-comment">// 此处不同于方法1，使用了快慢针 </span><br>		<span class="hljs-keyword">while</span>(j&lt;=n &amp;&amp; a[j]-a[k]&lt;=c) j++;  <span class="hljs-comment">// j指向相同值区间右端的下一个下标 </span><br>		ans+=j-i;<br>	&#125;<br>	cout&lt;&lt;ans&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="至少有k个重复字符的最长子串">2.5
[至少有K个重复字符的最长子串</h2>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/description/">Leetcode395</a></p>
<p>给你一个字符串s和一个整数k，请你找出s中的最长子串，要求该子串内的每一字符出现次数都不少于k。返回这一子串的长度。如果不存在这样的子字符串，则返回
0。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：s = &quot;aaabb&quot;, k = 3<br>输出：3<br>解释：最长子串为 &quot;aaa&quot; ，其中 &#x27;a&#x27; 重复了 3 次。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：s = &quot;ababbc&quot;, k = 2<br>输出：5<br>解释：最长子串为 &quot;ababb&quot; ，其中 &#x27;a&#x27; 重复了 2 次， &#x27;b&#x27; 重复了 3 次。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><span class="math inline">\(1 \leq s.length \leq 10^4\)</span></li>
<li>s仅由小写英文字母组成</li>
<li><span class="math inline">\(1 \leq k \leq 10^5\)</span></li>
</ul>
<p>解题分析：</p>
<p>A.
单调性分析：对于一个连续子序列a[i..j]，假设其区间长度为t，且满足条件（且此时
k &gt; 1），那么将该区间长度扩成 t+1时（无论是往左扩还是往右扩）：</p>
<ol type="a">
<li><p>如果新位置的字符在原有区间出现过，那必然还是满足出现次数大于 k
次，这时候该新区间仍满足要求；</p></li>
<li><p>如果新位置的字符在原有区间没出现过，那新字符的出现次数只有 1
次，这时候该新区间不满足要求；</p></li>
</ol>
<p>所以<strong>该题所要求的“条件”不满足区间的单调性</strong>，即不会随着区间的移动或者变化而肯定出现“不符合<span
class="math inline">\(\rightarrow\)</span>符合”或者反之的情况。因此我们不能使用「二分答案法」，也<strong>不能直接使用</strong>「滑动窗口」思路的双指针法。</p>
<p>那么还有什么性质可以利用呢？这时候要留意数据范围「数值小」的内容。</p>
<p>题目说明了只包含小写字母（26
个，为有限数据），如果我们把原题条件（区间内所包含的字符的重复次数至少为k次）<strong>改为新条件（区间内所包含的字符种类数量只能为
t <span class="math inline">\((1 \leq t \leq
26)\)</span>种）</strong>时，区间重新具有了单调性质。</p>
<p>当我们使用双指针的时候：</p>
<ol type="a">
<li><p>右端点往右移动必然会导致字符类型数量增加（或不变）</p></li>
<li><p>左端点往右移动必然会导致字符类型数量减少（或不变）</p></li>
</ol>
<p>然后我们可以对t进行暴力枚举，范围从1到26，毕竟这也不大。然后可以看出，原题的答案区间必然会和我们在暴力枚举t的过程中找到的某个区间是一致的。例如s
= "aaabb", k = 3的答案区间（子串aaa）必然会在我们枚举t=1时找到，而s =
"ababbc", k = 2的答案区间（子串ababb）必然会在我们枚举t=2时找到。</p>
<p>B.
时效性分析：当区间拓宽或收窄时，可以通过计数器数组来识别出从无到有的字符，或者从有到无的字符，通过
O(1) 的代价判断出给定区间[i..j]是否符合新条件，具有时效性。</p>
<p>“搂草”的同时，还要“打兔子”！本题的最终目的是要找每种字符出现至少k次的最长子串，所以在双指针右移的过程中，顺带着还要记录区间内出现的每个字符的次数。这才是我们的最终目的！可以设置<strong>不达标字符（已出现在区间中，但个数不够k个）</strong>的个数less。当新增一个从无到有的字符时less++，若次数达到k次则less--；新减掉一个原本出现仅1次的字符时less--，新减掉一个原本出现了k次的字符时less++。当less==0时意味着区间没有不达标字符，即区间内所有字符都次数&gt;=k，记录该区间。</p>
<p>C.
本题要求满足指定条件的一个区间[i,j]，但根据题意，有可能不存在这样的区间。（举个反例:"在aabbccdef这个字符串中找出一个区间，使得该区间每个字符都出现了至少10次"，根本找不到这样的区间）。所以要留意区间长len=0的可能。</p>
<p>AC代码如下：（8ms，超过45%）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestSubstring</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;                      <span class="hljs-comment">// 先假设找不到任何合法区间 </span><br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">1</span>; t &lt;= <span class="hljs-number">26</span>; t++) &#123;   <span class="hljs-comment">// 暴力枚举区间内出现的字符种数t </span><br>            <span class="hljs-comment">// 每次新的暴力枚举都需重置相关变量！ </span><br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;             <span class="hljs-comment">//  </span><br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br>            <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;             <br>            <span class="hljs-type">int</span> less = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (r &lt; n) &#123;               <span class="hljs-comment">// 双指针模板，快指针最多只到最后一个字符的下标n-1，</span><br>                <span class="hljs-comment">// 搂草，针对新进字符来处理tot</span><br>                cnt[s[r] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>                <span class="hljs-keyword">if</span> (cnt[s[r] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">1</span>) &#123;<br>                    tot++;                <span class="hljs-comment">// 处理tot </span><br>                    less++;<br>                &#125;<br>                <span class="hljs-comment">// 打兔子 </span><br>                <span class="hljs-keyword">if</span> (cnt[s[r] - <span class="hljs-string">&#x27;a&#x27;</span>] == k) &#123;<br>                    less--;<br>                &#125;<br><br>                <span class="hljs-keyword">while</span> (tot &gt; t) &#123;         <span class="hljs-comment">// 搂草，双指针模板。最长区间，当区间不合法时收窄左端 </span><br>                    cnt[s[l] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                    <span class="hljs-keyword">if</span> (cnt[s[l] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span>) &#123;<br>                        tot--;            <span class="hljs-comment">// 处理tot，模板 </span><br>                        less--;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (cnt[s[l] - <span class="hljs-string">&#x27;a&#x27;</span>] == k - <span class="hljs-number">1</span>) &#123;<br>                        less++;<br>                    &#125;<br>                    l++;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (less == <span class="hljs-number">0</span>) &#123;          <span class="hljs-comment">// 能到这里来，区间肯定合法，此时如果less也==0的话，就找到一个区间满足题意了 </span><br>                    ret = <span class="hljs-built_in">max</span>(ret, r - l + <span class="hljs-number">1</span>);<br>                &#125;<br>                r++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="poj2566-bound-found">2.6 POJ2566 Bound Found</h2>
<p>原题链接 ：<a target="_blank" rel="noopener" href="http://poj.org/problem?id=2566">POJ2566</a></p>
<p>基本题意：给定一个数组n个元素和一个值t，求一个子区间使得其和的绝对值与t的差值最小，如果存在多个，任意解都可行。1&lt;=
n &lt;= 1e5 ; 0&lt;= t &lt;= 1e9;</p>
<p>样例输入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5 1             // 第1组样例：n=5个数   t=1次查询<br>-10 -5 0 5 10<br>3               // 查区间和的绝对值最靠近3的区间<br><br>10 2            // 第2组样例：n=10个数  t=2次查询<br>-9 8 -7 6 -5 4 -3 2 -1 0<br>5 11            // 查区间和的绝对值最靠近5的区间，查区间和的绝对值最靠近11的区间<br><br>15 2            // 第3组样例：n=15个数  t=2次查询<br>-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1<br>15 100          // 查区间和的绝对值最靠近15的区间，查区间和的绝对值最靠近100的区间<br>0 0             // 结束<br></code></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5 4 4 // 区间和为5，从4号到4号(网页此处写错了！输出测试样例给的是5 2 2，即区间[2,2]，该区间只有-5这个数，绝对值为5，与3的距离为3，最接近了。[4,4]这个5的下标没有[2,2]的小)<br>5 2 8           // 区间和5  从2号 到8号<br>9 1 1           // 区间和9  从1号 到1号<br>15 1 15         // 区间和15  从1号 到15号<br>15 1 15         // 区间和15  从1号 到15号<br></code></pre></td></tr></table></figure>
<p>分析：</p>
<p>之前的POJ3061题中，序列都是正数。随着区间拓宽，其sum呈现单调递增的特性。但是现在本题有正数有负数，其区间和不再具备单调性，而取绝对值之后，更不具备单调性了。不能直接用双指针法来做，需要想一下如何重构条件或者数据。</p>
<p>这个题我们首先能想到的是，既然要求区间之和，我们可以先利用前缀和数组，它能在O(1)的效率实现原区间求和。但必须要解决两个问题：</p>
<p>1）问题是如何枚举区间的左右端呢？</p>
<p>2)如何让每一次枚举出的区间更靠近所求的答案区间呢？</p>
<p>朴素做法就是先求前缀和数组s[]，然后基于该数组，for (ri=1..len)
for(le=0..ri-1)这样去暴力枚举（因为前缀和数组有正有负，看似无规律，不单调）区间的左右端，然后用s[ri]-s[le]得到该区间和，然后看差值，求最小值。但这样做，并未解决问题2），每一次枚举都完全无视上一次枚举的比较结果，算法效率注定低下。</p>
<p>假设一个区间之和sum=data[le..ri]=s[ri]-s[le-1]，且sum&lt;t。那现在该如何调节？肯定是希望能扩大区间之和，即找到一个更大的s[<span
class="math inline">\(\acute{ri}\)</span>]
<font color="red">**(*)**</font>。但扩大区间之和，不能简单地理解为ri++,快指针在data[]上右移一格。因为data[]有正有负，s[]数组不是单调递增。所以不能简单地通过ri++来在data[]上拓宽区间。
那我们如何去找一个比原来的s[ri]值更大的s[]值呢？</p>
<p>我们可以对s[]进行递增排序产生s2[]（也可以原地排序），弃用s[]原来的数据顺序关系，反正这种前后关系没有单调性，已无任何作用。（在排序之前注意要保存元素的原始序号pos，因为我们需要表示最初的data[]中的下标的区间。）因为s2[]是经过排序的，必然是单调递增的（<del>似乎这里是句废话</del>），所以当ri++，在s2[]上右移（<strong>理解的重点：不管是le或ri，都不是在data[]上右移！给一对le和ri，不要想成了data[le..ri]，非也！</strong>）后，s2[ri(新)]必然是&gt;s2[ri(旧)]的（单调性决定）。</p>
<p>排序之后，s[]单调递增，但其原元素发生了移动，所以s[ri].value -
s[le].value 不再代表 sum(data[le+1] .. data[ri])
！它代表的是sum(data[1..s[ri].pos]) - sum(data[1..s[le].pos])
。虽然ri&gt;le，但是s[ri].pos 不一定大于 s[le].pos !
所以在表示时，ll=min(s[ri].pos, s[le].pos)且rr=max(s[ri].pos,
s[le].pos)</p>
<p>可能有人会说：因为s2[]是排序后的前缀和数组，举个例子：s2[4].v可能等于data[0..7]，根本就不等于s2[3].v+data[4]！但仔细一想，其实这个问题根本就不是什么问题。我们只需要找到比原来的s2[3].v更大一点的s2[7].v就达到
<font color="red">**(*)**</font>处所述的“让sum变大”的目的了!
看似好像在跳跃性地胡乱枚举，但实际上是递增地枚举。</p>
<p>1）当sum&lt;t时，ri在s2[]上右移；</p>
<p>2）当sum&gt;t时，此时再去ri++岂不是区间和更大？人家要最接近t值的区间和，你搞个越来越远是什么意思？果断不再ri++！此时意味着该le++，让le在s2[]上右移一格，换一个更大一点的s[<span
class="math inline">\(\acute{le}\)</span>]，从而让sum变小一点。这样才能让sum越来越靠近t，算法高效！</p>
<p>原题链接中提供的三个样例都不太具有一般性，本帖重新列举一个更具一般性的输入样例和输出样例如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">输入样例：<br>10 1             //10个数，1次查询 <br>20 -25 10 5 -10 25 15 -10 15 5 <br>22               // 查找区间和绝对值最接近22的那个区间<br></code></pre></td></tr></table></figure>
<p><img src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/image-20240119091130982.png" alt="image-20240119091130982" style="zoom:80%;" /></p>
<p>当ri=6，le=3时s2[6].v-s2[3].v= 20-5
=15;这个结果15代表的是data[0..1]-data[0..3]=s[1]-s[3]= 20-5
=15。虽然6&gt;3，但s2[6].pos=1 &lt; s2[3].pos=3
！所以(&amp;1)<strong>此处data[0..1]-data[0..3]无法表达成data[2..3]，所以在data[]上表示这个区间时，假设区间为[ll+1,
rr]，那么ll=<font color="red">min(1, 3)</font>=1 =min(s2[6].pos,
s2[3].pos)，且rr= <font color="red">max(1, 3)</font>=3 =max(s2[6].pos,
s2[3].pos)</strong>。然后把ll+1，得到2，最终得到区间为[2..3]，即data[2..3]。</p>
<p>但此时因为15&lt;22，需继续找个更大的区间，ri++，因为s2[7].v=s2[6].v=20，所以继续ri++，ri=8。</p>
<p>当ri=8，le=3时s2[8].v-s2[3].v= 30-5 =25;
这个结果25代表的是data[0..7]-data[0..3]=s[7]-s[3]= 30-5 =25。ll= min(3,
7)=3，且rr=max(3,
7)=7。然后把ll+1，得到4，最终得到区间为[4..7]，即data[4..7]，其和25更接近22。</p>
<p>不管是sum&gt;t或者sum&lt;t，都无法预知下一次尝试是否更接近t，所以都需要记录和考虑刷新。但如果当sum==t时，没有什么区间比这更优了，首次遇到就不再尝试后续，结束程序。</p>
<p>需要注意的是：</p>
<ol type="1">
<li><p>我们需要将下标为0的元素的id和sum字段都设置为0，并将该元素参与排序。这样当遇到类似s[7]-s[0]时，表示的是data[0..7]-data[0..0]=data[1..7]。</p></li>
<li><p>因为sum[j]-sum[i]表示的是[i+1,j]，此外在最后得到的答案左区间都 +
1</p></li>
<li><p>网页上输出样例的第一组数据有毒，写错了。但其OJ系统的测试数据没问题，应该就是网页上写错了而已。</p></li>
<li><p>s[0]的初始化每次都要做，而且要先做，因为后面求前缀和时会用到s[0]</p></li>
<li><p>long long类型求绝对值需要用 llabs(long long)函数</p></li>
</ol>
<p>AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>     <span class="hljs-comment">// sort()需要 </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span>         <span class="hljs-comment">// llabs()需要 </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>	LL value;<br>	LL pos;<br>&#125;;<br>LL data[maxn];<br>node s[maxn];<br>LL le, ri, n, t, k;<br>LL sum, ll, rr;<br>LL mindis;     <span class="hljs-comment">// 记录区间和与k之间的最近距离值（绝对值，正）</span><br>LL ans;        <span class="hljs-comment">// 记录具有这个最近距离值的区间之和值</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node x1, node x2)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> x1.value &lt; x2.value;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//相信自己是最棒的！请在这里写新代码...</span><br>	<span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;t), !(n==<span class="hljs-number">0</span>&amp;&amp;t==<span class="hljs-number">0</span>)) &#123;<br>    	s[<span class="hljs-number">0</span>].pos=<span class="hljs-number">0</span>;                 <span class="hljs-comment">// 别忘了先做初始化这个，排序后元素顺序会打乱，s[0]将可能会不再是(0,0)  </span><br>    	s[<span class="hljs-number">0</span>].value=<span class="hljs-number">0</span>;<br>    	<span class="hljs-keyword">for</span>(LL i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;    <span class="hljs-comment">// 需要先初始化好s[0]之后才能for，因为此处用到了原s[0] </span><br>        	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;data[i]);<br>        	s[i].value = s[i<span class="hljs-number">-1</span>].value + data[i];  <span class="hljs-comment">// 此时，s[ri].value - s[le].value代表sum(data[le+1] .. data[ri])，前缀和基本定义 </span><br>        	s[i].pos = i;<br>        &#125;<br>        <br>    	<span class="hljs-built_in">sort</span>(s, s+<span class="hljs-number">1</span>+n, cmp);        <span class="hljs-comment">// 需要把s[0]也参与排序</span><br>        <br>    	<span class="hljs-keyword">while</span>( t-- ) &#123;<br>        	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;k);<br>        	le=<span class="hljs-number">0</span>;                   <span class="hljs-comment">// 因为s[ri].value - s[le].value代表sum(data[le+1] .. data[ri])，所以le应从0号开始，这样区间左端从1开始 </span><br>        	ri=<span class="hljs-number">1</span>;<br>        	mindis = <span class="hljs-number">1e17</span>+<span class="hljs-number">10</span>;<br>        	<span class="hljs-keyword">while</span>( ri&lt;=n ) &#123;        <span class="hljs-comment">// 也可以用for(ri=1; ri&lt;=n; ri++)  </span><br>            	LL sum = s[ri].value - s[le].value; <span class="hljs-comment">// sum=sum(data[1..s[ri].pos]) - sum(data[1..s[le].pos])  &gt;0 </span><br>            	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">llabs</span>(sum-k) &lt; mindis) &#123;        <span class="hljs-comment">// 如果le和ri表示的这个区间更优（更贴近 k），则更新mindis、ans、ll和rr  </span><br>                	mindis = <span class="hljs-built_in">llabs</span>(sum-k);          <span class="hljs-comment">// </span><br>                	ans = sum;<br>                	ll=<span class="hljs-built_in">min</span>(s[ri].pos, s[le].pos)+<span class="hljs-number">1</span>; <span class="hljs-comment">// 此处解释见题解的(&amp;1)处 </span><br>                	rr=<span class="hljs-built_in">max</span>(s[ri].pos, s[le].pos);<br>                &#125;<br>                <span class="hljs-comment">// 排序后的s[]是单调递增的，所以s[ri+1].value &gt;= s[ri].value  &gt;= s[le+1].value &gt;= s[le].value的，</span><br>                <span class="hljs-comment">// 也就是说，sum(data[1..s[ri+1].pos])必然是大于等于sum(data[1..s[ri].pos])的 </span><br>                <span class="hljs-comment">// 如果区间之和值sum少于k，应想办法增大sum值。故而选择了这个s[ri+1].value。</span><br>                <span class="hljs-comment">// s[ri+1].value - s[le].value  &gt; s[ri].value - s[le].value</span><br>            	<span class="hljs-keyword">if</span> (sum &lt; k)        <br>                	ri++;<br>                <span class="hljs-comment">// 如果区间和值sum在k的右侧，应想办法减小sum值。故而选择更大一点的s[le+1].value。</span><br>                <span class="hljs-comment">// s[ri].value - s[le+1].value  &lt; s[ri].value - s[le].value</span><br>            	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; k)<br>                	le++;<br>            	<span class="hljs-keyword">else</span><br>                	<span class="hljs-keyword">break</span>;          <span class="hljs-comment">// 没有比这更完美的了，不必再算后续，跳出循环，输出 </span><br>                <br>            	<span class="hljs-keyword">if</span> (le == ri)       <span class="hljs-comment">// 不允许也不考虑空区间，所以不允许le==ri，一旦相等，ri强行前进一格 </span><br>                	ri++; <br>            &#125;<br>        	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld %lld\n&quot;</span>, ans, ll, rr);<br>        &#125;<br>    &#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">5 1</span><br><span class="hljs-comment">-10 -5 0 5 10</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">10 2</span><br><span class="hljs-comment">-9 8 -7 6 -5 4 -3 2 -1 0</span><br><span class="hljs-comment">5 11</span><br><span class="hljs-comment">15 2</span><br><span class="hljs-comment">-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1</span><br><span class="hljs-comment">15 100</span><br><span class="hljs-comment">0 0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输出</span><br><span class="hljs-comment">5 2 2  // 网页数据有误！测试数据没问题 </span><br><span class="hljs-comment">5 2 8</span><br><span class="hljs-comment">9 1 1</span><br><span class="hljs-comment">15 1 15</span><br><span class="hljs-comment">15 1 15</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h2 id="poj2739-sum-of-consecutive-prime-numbers">2.7 POJ2739 Sum of
Consecutive Prime Numbers</h2>
<p><a
target="_blank" rel="noopener" href="http://poj.org/problem?id=2739">POJ2739</a>的AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    一个整数分解为连续的素数之和，有多少种分法? 这是一个“区间和精确相等”的问题，</span><br><span class="hljs-comment">    因为“精确相等”不满足单调性，但“正数的累加和”是有单调性的，所以可在模板基础</span><br><span class="hljs-comment">    上微调即可。 </span><br><span class="hljs-comment">    思路：</span><br><span class="hljs-comment">    	1. 打表，先打出素数表</span><br><span class="hljs-comment">    	2. 然后用尺取法查询是否精确等？若s&lt;num就继续ri++，若s&gt;num就le++，若s==num就统计 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxn 10000+16        <span class="hljs-comment">// 1万以内求素数 </span></span><br>vector&lt;<span class="hljs-type">int</span>&gt; primes;<br>vector&lt;<span class="hljs-type">bool</span>&gt; is_prime;<br><br><span class="hljs-comment">// 暴力打表，也可以把这个代码单独开一个cpp文件来写，然后把打印结果复制为POJ2739的全局数组。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_prime</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化vector的前10000个元素均为true</span><br>    is_prime = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(maxn + <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 0和1都不是素数</span><br>    is_prime[<span class="hljs-number">0</span>] = is_prime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 埃氏筛法求素数，填入primes[]中。此处也可以换成欧拉筛法</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; maxn; i++) &#123;<br>        <span class="hljs-keyword">if</span> (is_prime[i]) &#123;<br>            primes.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i * <span class="hljs-number">2</span>; j &lt; maxn; j += i) &#123;<br>                is_prime[j] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-built_in">init_prime</span>();<br>    <span class="hljs-type">int</span> size = primes.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; num &amp;&amp; num) &#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>, s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>,r = <span class="hljs-number">0</span>; r&lt;size;  ) &#123;<br>            <span class="hljs-comment">// s没加够，且右边还有数可以继续加，那就一直加（因为正数的累加和是有单调性的）</span><br>            <span class="hljs-keyword">while</span> (r&lt;size &amp;&amp; s&lt;num)<br>                s = s + primes[r++];<br>            <span class="hljs-keyword">if</span> (s == num)  <span class="hljs-comment">// 找到一个方案，记上</span><br>                result++;<br>            <span class="hljs-comment">// 不管找没找到一个方案，如果r还没走到底而s已经超过num，就砍掉左端l++,s-=，然后循环上去继续r右移</span><br>            s -= primes[l++];<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, result);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入1： </span><br><span class="hljs-comment">17</span><br><span class="hljs-comment">输出1： </span><br><span class="hljs-comment">2     （2+3+5+7，17） </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h2 id="poj2100-graveyard-design">2.8 POJ2100 Graveyard Design</h2>
<p><a target="_blank" rel="noopener" href="http://poj.org/problem?id=2100">POJ2100</a>
的AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	给一个数 n （1 &lt;= n &lt;= 10^14）。</span><br><span class="hljs-comment">	求一段连续的数的数字，使得其平方和等于n。</span><br><span class="hljs-comment">	输出的时候，先输出有多少组解，然后换行，每一行输出一组解内的元素个数，及这些元素的数值。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    学习本代码，需要预先掌握尺取法的基本思想。本题思路和POJ2739很相似</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	注意typedef的这种写法，要学会</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	注意pair的使用，虽然本题还可以用其他结构来实现，但建议学会pair的使用。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;    <span class="hljs-comment">//  基本上等效于 #define LL long long</span><br>vector&lt;pair&lt;LL, LL&gt; &gt; ans;    <span class="hljs-comment">// 这里一定要注意这个&quot;&gt; &gt;&quot;之间要有空格</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(LL n)</span> </span>&#123;<br>    LL l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>, sq;<br>    <span class="hljs-comment">// 这里写成死循环比较方便一些！ </span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// r是否要右移。不在外层循环中决定，而是在内层循环中决定</span><br>        <span class="hljs-keyword">while</span> (sum &lt; n) &#123; <span class="hljs-comment">//当sum不够n时，因为区间平方和是单调的，所以右移r以扩大区间，从而扩大sum</span><br>            sq = r * r;<br>            sum += sq;<br>            r++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sq &gt; n)   <span class="hljs-comment">// 如果一个数的平方和都已经超过n，那后面不可能再有符合要求的区间了。可以输结果了 </span><br>			<span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// 当sum&gt;=n时走到这里来</span><br>        <span class="hljs-keyword">if</span> (sum == n)<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(l, r));    <span class="hljs-comment">// 注意，这里表示的是[l, r-1],因为r在while里多加了一次</span><br>        <span class="hljs-comment">// 不管有没有找到一个解，都需要慢指针右移，慢指针前行</span><br>        sum -= l * l;<br>        l++;<br>    &#125;<br><br>    <span class="hljs-comment">// 下面的代码都在凑输出</span><br>    LL size = ans.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, size);<br>    <span class="hljs-keyword">for</span> (LL i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        LL ansr = ans[i].second;<br>        LL ansl = ans[i].first;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,ansr-ansl);              <span class="hljs-comment">// 因为ansr偏大了1，所以这里算区间长度不需要再加1了</span><br>        <span class="hljs-keyword">for</span> (LL j=ansl; j&lt;ansr; j++)           <span class="hljs-comment">// ansr偏大了1，所以j最多到ansr-1就可以了</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %lld&quot;</span>, j);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);      //读入数据生成器造出来的数据</span><br><span class="hljs-comment">//    freopen(&quot;test.txt&quot;, &quot;w&quot;, stdout);   //输出答案</span><br>    <br>    LL n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;n);<br>    <span class="hljs-built_in">solve</span>(n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="p1381-单词背诵">2.9 P1381 单词背诵</h2>
<p>视频链接：<a
target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1MP411W7tk">双指针P1381（单词背诵）</a></p>
<p>原题链接：<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1381">P1381（单词背诵）</a></p>
<p><img src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/1973969-20230825182436716-225604155.png" alt="img" style="zoom: 67%;" /></p>
<p>题意表述不太准确，需要澄清：文章由 <em>m</em>
个单词构成，在该文章中找出连续的一段，其中包含<strong>最多种类</strong>（允许不包含完目标单词表的所有目标单词）的目标单词（重复的单词只算一种），且允许子串内包含其他非目标单词。并且在目标单词种类尽量多的前提下，还要使选出的文章区间尽量短。</p>
<p>举个例子：假如现在目标单词为A，B，C,D（为了表述方便，特意将每个目标单词假设为单字母大写，非目标单词假设为单字母小写），文章为hACnnBgC。其中“AC”是“包含两种目标单词”的最短子串，但“hACnnBgC”中存在有子串“ACnnB”和“ACnnBgC”这两个子串（不止这两个）包含了三种目标单词。根据题意，种类较多的胜出（哪怕长度值大于“AC”），所以最终答案在这些包含了三种目标单词的子串中选择，很明显最终答案是“ACnnB”，更短。</p>
<figure>
<img
src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/image-20240121173427411.png"
alt="1" />
<figcaption aria-hidden="true">1</figcaption>
</figure>
<p>AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    基本题意：求文章中出现单词种数最多且最短的连续区间</span><br><span class="hljs-comment">    如果种数不是最多的，不是答案！ 如果不够短，不是答案！ </span><br><span class="hljs-comment">    如果该区间内有非单词表的单词，允许！</span><br><span class="hljs-comment">*/</span> <br><span class="hljs-type">int</span> n,m;<br>string s[<span class="hljs-number">100005</span>],s1;    <span class="hljs-comment">//s[] 记录文章中的所有单词</span><br>map&lt;string,<span class="hljs-type">bool</span>&gt; wordmp;<span class="hljs-comment">//wordmp[] 记录目标单词表中的所有单词</span><br>map&lt;string,<span class="hljs-type">int</span>&gt; cntmp;  <span class="hljs-comment">//cntmp[] 记录文章当前区间内各个目标单词出现的次数</span><br><span class="hljs-type">int</span> sum;                <span class="hljs-comment">//sum 记录文章中出现单词表的单词数（不算重复的）</span><br><span class="hljs-type">int</span> len;                <span class="hljs-comment">//len 记录包含表中单词最多的区间的最短长度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    	cin&gt;&gt;s1,wordmp[s1]=<span class="hljs-number">1</span>;<br>	cin&gt;&gt;m;                   <br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>,i=<span class="hljs-number">1</span>; j&lt;=m; j++) &#123; <span class="hljs-comment">//i&lt;=j</span><br>    	cin&gt;&gt;s[j];<br>        <span class="hljs-comment">// 处理快指针j的相关事务 </span><br>    	<span class="hljs-keyword">if</span>(wordmp[s[j]])        <span class="hljs-comment">//如果新进单词是目标单词表里的单词，就累加其出现次数 </span><br>        	cntmp[s[j]]++;<br>    	<span class="hljs-keyword">if</span>(cntmp[s[j]]==<span class="hljs-number">1</span>)      <span class="hljs-comment">//如果新进单词是第一次出现，更新sum和len </span><br>        	sum++, len=j-i+<span class="hljs-number">1</span>;   <span class="hljs-comment">//重难点！区间出现新单词时，放弃原来的len值，重新存新的区间长度，因为新区间内的目标单词“更多”，但不够精简 </span><br>            <br>        <span class="hljs-comment">// 本题求最短区间，所以考虑收窄区间</span><br>        <span class="hljs-comment">// 应收窄的情况1. 左端单词出现多次，则可以放弃1次左端单词，不影响区间内单词种数</span><br>        <span class="hljs-comment">// 应收窄的情况2. 左端单词不是目标单词表内的单词，直接无视，收窄 </span><br>    	<span class="hljs-keyword">while</span>(i&lt;=j &amp;&amp; (cntmp[s[i]]&gt;=<span class="hljs-number">2</span> || !wordmp[s[i]])) &#123;<br>        	<span class="hljs-keyword">if</span>(cntmp[s[i]]&gt;=<span class="hljs-number">2</span>)     <span class="hljs-comment">// 如果区间左端的单词在区间内有重复，则可以把它忽视掉，毕竟右侧还有它的其他副本 </span><br>            	cntmp[s[i]]--,i++; <br>        	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!wordmp[s[i]]) <span class="hljs-comment">// 如果当前区间左端的单词是目标单词表里的单词，直接无视，收缩区间 </span><br>            	i++; <br>        &#125;<br>    	len=<span class="hljs-built_in">min</span>(len,j-i+<span class="hljs-number">1</span>);     <span class="hljs-comment">//收窄，更新len </span><br>    &#125;<br>	cout&lt;&lt;sum&lt;&lt;endl&lt;&lt;len&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="abc098d-xor-sum-2">2.10 [ABC098D] Xor Sum 2</h2>
<p>视频链接：<a
target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1h14y117rq">[ABC098D] Xor Sum
2</a></p>
<p>原题链接：<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_arc098_b">[ABC098D] Xor Sum
2</a></p>
<p>大致题意：</p>
<p>给你一串数a[]，求出满足<span
class="math inline">\(a_l+a_{l+1}+...+a_r=a_l \enspace xor
\enspace  a_{l+1}\enspace...\enspace xor \enspace a_r (l \leq
r)\)</span>的<span class="math inline">\((i,j)\)</span>的数量。已知<span
class="math inline">\(1 \leq n\leq2*10^5,\quad 1\leq i\leq n,\quad 0\leq
a_i\leq2^{20}\)</span>。</p>
<p>预备知识：本题涉及到了“异或”操作，这是一个按位进行的操作。</p>
<p>初步分析：这个题求"有多少个符合题意要求的连续区间"，并不求"最长区间"，也不求"最短区间"，不能用1.2.3节总结出来的套路模板,但因为是求连续区间，所以仍可以用普通的双指针法。下面做1.2.2节中讲到的单调性分析和时效性分析。</p>
<p>1）单调性分析：本题求区间的个数，有点类似于“求逆序对的个数”这种风格，必然会涉及到对两个数的暴力枚举。但如果是无脑枚举，<span
class="math inline">\(O(n^2)\)</span>的效率，复杂度为4e10，是会TLE的。不可取。题目涉及到的是连续区间。也就是说，区间内的所有数，代入公式，条件成立。如果遇到区间[l,
r]内的某一个数<span class="math inline">\(a_k\)</span>代入该公式后<span
class="math inline">\(a_l+...+a_k+...+a_r \neq a_l \enspace xor
...\enspace xor\enspace  a_k\enspace...\enspace xor \enspace a_r (l &lt;
k\le r)\)</span>，则需放弃该区间[l,
r]。对于[l,r]，假设l固定不动，随着r的右移，区间变宽，只会出现“符合<span
class="math inline">\(\Rightarrow\)</span>不符合”的情况，而不会出现“符合<span
class="math inline">\(\Rightarrow\)</span>不符合<span
class="math inline">\(\Rightarrow\)</span>符合”的情况。<strong>所以本题的“条件”具备单调性</strong>。一旦出现了上述这个<span
class="math inline">\(a_k\)</span>，则k右侧的所有端点不必再枚举了，区间必定是不符合条件的。所以这里不应该盲目地采用<span
class="math inline">\(O(n^2)\)</span>的效率去无脑枚举。</p>
<p>2）时效性分析：对于一个给定的区间[l,r]，假设该区间已经符合公式，有sum[l..r]=sumxor[l..r]。现在r尝试右移，仍然可以在O(1)的效率内计算出sum[l..r]+data[r+1]的值，以及sumxor[l..r]
xor data[r+1]的值，进而判断是否相等。即该条件的判定具有时效性。</p>
<p><img src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/1973969-20230826095827743-1068963304.png" alt="img" style="zoom:80%;" /></p>
<p><img src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/1973969-20230826095827887-317965124.png" alt="img" style="zoom:80%;" /></p>
<p>在上图的样例中，一共有9个区间符合公式条件。i不动的前提下，j指针每次尝试右移前先判定，符合就右移，答案数+1，换句话说，j右移一次，答案数加1，直到不符合条件。所以当i不动的前提下，贡献的答案数其实就是不符合之前的区间宽度，即j-i+1。然后i右移，j归位到i，再周而复始，直到i到最右侧。所以“j到最右侧”并不是外层循环的结束条件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL; <span class="hljs-comment">// 或者#define LL long long</span><br>LL a[<span class="hljs-number">200005</span>];<br>LL s1,s2,ans;<br><span class="hljs-comment">//s1:算术和, s2:异或和, ans:方案数</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) cin&gt;&gt;a[i];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>; i&lt;=n; ) &#123; <span class="hljs-comment">//外层循环以慢指针i到最右为止。可以看出，双指针法需要具体情况具体分析</span><br>        <span class="hljs-comment">// 当i不变时，让j走到不符合条件之前停下来</span><br>        <span class="hljs-keyword">while</span>(j+<span class="hljs-number">1</span>&lt;=n&amp;&amp;s1+a[j+<span class="hljs-number">1</span>]==(s2^a[j+<span class="hljs-number">1</span>])) &#123; <span class="hljs-comment">//预判，这里不能先改j的值！</span><br>            j++;<br>            s1+=a[j];    <span class="hljs-comment">// 累加和</span><br>            s2^=a[j];    <span class="hljs-comment">// 累异或和</span><br>        &#125;<br>        ans += j-i+<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 慢指针i前进，刷新</span><br>        s1-=a[i];<br>        s2^=a[i];<br>        i++;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">雪宝和七七的爸爸</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/01/04/%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%88%E5%B0%BA%E5%8F%96%E6%B3%95%EF%BC%89/">http://example.com/2024/01/04/%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%88%E5%B0%BA%E5%8F%96%E6%B3%95%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">宝爸编程</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BF%A1%E6%81%AF%E5%AD%A6/">信息学</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/30/%E4%BD%8D%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%8E%E3%80%81%E6%88%96%E3%80%81%E5%BC%82%E6%88%96%EF%BC%89%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/" title="位操作（与、或、异或）方法详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">位操作（与、或、异或）方法详解</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/03/%E5%89%8D%E7%BC%80%E5%92%8C%20%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/" title="前缀和 二维前缀和"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">前缀和 二维前缀和</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/03/02/GESP%E5%85%AB%E7%BA%A7%EF%BC%88202312-202412%EF%BC%89%E6%9C%AA%E5%AE%8C/" title="GESP八级（202312-202412）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-02</div><div class="title">GESP八级（202312-202412）</div></div></a></div><div><a href="/2024/04/25/LCS%E9%97%AE%E9%A2%98/" title="最长公共子序列（LCS）问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-25</div><div class="title">最长公共子序列（LCS）问题</div></div></a></div><div><a href="/2024/07/31/dp%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E8%AE%AD%E7%BB%83/" title="dp中的状态转移训练"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-31</div><div class="title">dp中的状态转移训练</div></div></a></div><div><a href="/2024/04/25/LIS%E9%97%AE%E9%A2%98/" title="最长不下降子序列（LIS）问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-25</div><div class="title">最长不下降子序列（LIS）问题</div></div></a></div><div><a href="/2020/03/13/hello/" title="我的第一篇博客"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-13</div><div class="title">我的第一篇博客</div></div></a></div><div><a href="/2024/03/06/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/" title="二分查找和二分答案"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-06</div><div class="title">二分查找和二分答案</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">雪宝和七七的爸爸</div><div class="author-info__description">本博客致力于信息学奥赛知识学习。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://cspcoding.github.io/"><i class="fab fa-github"></i><span>回到主页</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">玩游戏害人害己哦！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E7%90%86%E8%AE%BA%E6%95%99%E5%AD%A6"><span class="toc-text">一、理论教学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%97%E4%B8%B2%E9%97%AE%E9%A2%98"><span class="toc-text">1.1 “最长不重复字串”问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90"><span class="toc-text">1.1.1 初步分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E7%AE%97%E6%B3%95%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF"><span class="toc-text">1.1.2 朴素算法（简单了解即可）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%9C%B4%E7%B4%A0%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96"><span class="toc-text">1.1.3 对朴素算法进行优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%BA%E5%8F%96%E6%B3%95%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="toc-text">1.2 尺取法（双指针法）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="toc-text">1.2.1 算法定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E6%9D%A1%E4%BB%B6%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E5%90%88"><span class="toc-text">1.2.2
“指定条件”与代码模板的适用场合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="toc-text">1.2.3 算法描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E6%9C%80%E9%95%BF%E5%8C%BA%E9%97%B4"><span class="toc-text">1.2.3.1 求最长区间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E6%9C%80%E7%9F%AD%E5%8C%BA%E9%97%B4"><span class="toc-text">1.2.3.2 求最短区间</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%AE%9E%E6%88%98%E8%AE%AD%E7%BB%83"><span class="toc-text">二、实战训练</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E9%A2%91%E6%95%99%E5%AD%A6%E9%93%BE%E6%8E%A5"><span class="toc-text">视频教学链接：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98%E6%9C%80%E9%95%BF"><span class="toc-text">2.1 最长无重复子串问题（最长）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E5%92%8C%E9%97%AE%E9%A2%98%E6%9C%80%E7%9F%AD"><span class="toc-text">2.2 区间和问题（最短）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#luogu-p1147-%E8%BF%9E%E7%BB%AD%E8%87%AA%E7%84%B6%E6%95%B0%E5%92%8Cimg"><span class="toc-text">2.3 Luogu P1147
连续自然数和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#luogu-p1102-a-b-%E6%95%B0%E5%AF%B9"><span class="toc-text">2.4 Luogu P1102 A-B
数对</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%B3%E5%B0%91%E6%9C%89k%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-text">2.5
[至少有K个重复字符的最长子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#poj2566-bound-found"><span class="toc-text">2.6 POJ2566 Bound Found</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#poj2739-sum-of-consecutive-prime-numbers"><span class="toc-text">2.7 POJ2739 Sum of
Consecutive Prime Numbers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#poj2100-graveyard-design"><span class="toc-text">2.8 POJ2100 Graveyard Design</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#p1381-%E5%8D%95%E8%AF%8D%E8%83%8C%E8%AF%B5"><span class="toc-text">2.9 P1381 单词背诵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#abc098d-xor-sum-2"><span class="toc-text">2.10 [ABC098D] Xor Sum 2</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/GESP%E5%85%AB%E7%BA%A7%EF%BC%88202312-202412%EF%BC%89%E6%9C%AA%E5%AE%8C/" title="GESP八级（202312-202412）">GESP八级（202312-202412）</a><time datetime="2025-03-01T16:00:00.000Z" title="发表于 2025-03-02 00:00:00">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/%E5%A4%9A%E9%87%8D%E7%BB%84%E5%90%88%E6%95%B0%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/" title="多重组合数">多重组合数</a><time datetime="2025-03-01T16:00:00.000Z" title="发表于 2025-03-02 00:00:00">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/%E7%9B%92%E5%AD%90%E6%94%BE%E7%90%83%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0%E9%97%AE%E9%A2%98%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/" title="盒子放球的方案数问题">盒子放球的方案数问题</a><time datetime="2025-03-01T16:00:00.000Z" title="发表于 2025-03-02 00:00:00">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/27/%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9B%BA%E5%AE%9A%E5%AE%BD%E5%BA%A6%E4%B8%BAm%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/" title="（二）固定宽度为m的区间的“最大的和值”问题">（二）固定宽度为m的区间的“最大的和值”问题</a><time datetime="2025-02-27T06:21:42.811Z" title="发表于 2025-02-27 14:21:42">2025-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/27/%EF%BC%88%E4%B8%89%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/" title="（三）宽度小于等于m的区间的“最大的和值”问题">（三）宽度小于等于m的区间的“最大的和值”问题</a><time datetime="2025-02-27T06:21:42.809Z" title="发表于 2025-02-27 14:21:42">2025-02-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 雪宝和七七的爸爸</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script src="/js/custom.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>