<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>差分 二维差分 | 宝爸编程</title><meta name="author" content="雪宝和七七的爸爸"><meta name="copyright" content="雪宝和七七的爸爸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、理论教学 1.1 视频教学链接 差分 二维差分 1.2 相关概念 1.2.1 基本思想 差分是一种处理数据的巧妙而简单的方法，它应用于区间的修改和区间查询问题。把给定的数据元素集a数组分成很多区间，对这些区间做很多次操作，每次操作是对某个区间内的所有元素做相同的加减操作，若一个个地修改这个区间内的每个元素，非常耗时。引入差分数组D，当修改某个区间时，只需要修改这个区间的“两个端点”">
<meta property="og:type" content="article">
<meta property="og:title" content="差分 二维差分">
<meta property="og:url" content="http://example.com/2024/03/20/%E5%B7%AE%E5%88%86%20%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86/index.html">
<meta property="og:site_name" content="宝爸编程">
<meta property="og:description" content="一、理论教学 1.1 视频教学链接 差分 二维差分 1.2 相关概念 1.2.1 基本思想 差分是一种处理数据的巧妙而简单的方法，它应用于区间的修改和区间查询问题。把给定的数据元素集a数组分成很多区间，对这些区间做很多次操作，每次操作是对某个区间内的所有元素做相同的加减操作，若一个个地修改这个区间内的每个元素，非常耗时。引入差分数组D，当修改某个区间时，只需要修改这个区间的“两个端点”">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-03-19T16:00:00.000Z">
<meta property="article:modified_time" content="2025-03-27T06:07:30.515Z">
<meta property="article:author" content="雪宝和七七的爸爸">
<meta property="article:tag" content="信息学">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/03/20/%E5%B7%AE%E5%88%86%20%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":5,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '差分 二维差分',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2025-03-27 14:07:30'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/static/css/custom.css"><link rel="stylesheet" href="/fonts/font.css"><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">26</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="宝爸编程"><span class="site-name">宝爸编程</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">差分 二维差分</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-19T16:00:00.000Z" title="发表于 2024-03-20 00:00:00">2024-03-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-27T06:07:30.515Z" title="更新于 2025-03-27 14:07:30">2025-03-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">基础算法</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/">前缀和/差分</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="差分 二维差分"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一理论教学">一、理论教学</h1>
<h2 id="视频教学链接">1.1 视频教学链接</h2>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12u411L7ii">差分
二维差分</a></p>
<h2 id="相关概念">1.2 相关概念</h2>
<h3 id="基本思想">1.2.1 基本思想</h3>
<p><strong>差分</strong>是一种处理数据的巧妙而简单的方法，它应用于<strong>区间的修改和区间查询</strong>问题。把给定的数据元素集a数组分成很多区间，对这些区间做很多次操作，<strong>每次操作是对某个区间内的所有元素做相同的加减操作</strong>，若一个个地修改这个区间内的每个元素，非常耗时。引入差分数组D，当修改某个区间时，只需要修改这个区间的“两个端点”，就能记录整个区间的修改，而对端点的修改非常容易，是<span
class="math inline">\(O(1)\)</span>复杂度的。当所有的修改操作结束后，再根据当前差分数组的值恢复出新的a数组。
  a数组可以是一维的线性数组a[]、二维矩阵a[][]、三维立体a[][][]。相应地，定义差分数组D[]、D[][]、D[][][]。一维差分很容易理解，二维和三维需要一点想象力。本节后续内容如无特别说明，指的都是一维数组或序列。</p>
<h3 id="差分和前缀和的关系及互换">1.2.2 差分和前缀和的关系及互换</h3>
<p>对于一个给定的序列a[1..n]，它的差分序列D[1..n]定义为： <span
class="math display">\[
D[1]=a[1], \qquad D[i]=a[i]-a[i-1],\qquad (2 \leq i \leq n)
\]</span>
D[]是a[]的<font color="red" >差分</font>序列，反过来，a[]是D[]的<font color=#ADFF2F>前缀和</font>序列。差分操作和前缀和操作是一对互逆运算。对任何序列a[]求差分D[]，再对D[]求其前缀和序列，就能得到原来的序列a[]。</p>
<p>关于上述这一点的证明如下： <span class="math display">\[
\begin{align}a[1]&amp;=D[1] \\
a[2]&amp;=D[2]+a[1]=D[2]+D[1]\\
a[3]&amp;=D[3]+a[2]=D[3]+D[2]+D[1]\\
......
\end{align}
\]</span></p>
<p>二维、三维形式的差分数组，在还原数组时，需要用到多维数组求前缀和的计算方法。具体见本站关于“前缀和”的帖子。</p>
<h2 id="一维差分">1.3 一维差分</h2>
<h3 id="问题假设">1.3.1 问题假设</h3>
<p>讨论这样一个场景：</p>
<p>（1）给定一个长度为n的一维数组<span
class="math inline">\(a[1..n]\)</span>，数组内每个元素有初始值。</p>
<p>（2）<strong>区间修改</strong>操作：做m次区间修改，<strong>每次修改对区间内所有元素做相同的加减操作</strong>。例如第i次修改，把区间<span
class="math inline">\([L_i,\ R_i]\)</span>内所有元素加上<span
class="math inline">\(d_i\)</span>。</p>
<p>（3）<strong>单点查询</strong>操作：询问一个元素的新值是多少。</p>
<p>如果简单地用暴力法编码，那么每次区间修改的复杂度是<span
class="math inline">\(O(n)\)</span>的，m次修改共<span
class="math inline">\(O(m*n)\)</span>，总复杂度<span
class="math inline">\(O(m*n)\)</span>，效率很差。利用差分法，可以把复杂度减少到<span
class="math inline">\(O(m+n)\)</span>。模板题可见<a
target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=1556">hdu1556</a>，解法见2.1节。</p>
<h3 id="相关操作和解法">1.3.2 相关操作和解法</h3>
<h4 id="批量m次区间修改操作">1.3.2.1
“<strong>批量（m次）区间修改</strong>”操作</h4>
<p>假设a[1..n]是原始数组，D[1..n]是该数组对应的差分数组。m次区间修改，把区间<span
class="math inline">\([L_i,\ R_i]\)</span>内每个元素（在a[]中从第<span
class="math inline">\(L_i\)</span>个元素到第<span
class="math inline">\(R_i\)</span>个元素在内）全都加上<span
class="math inline">\(d_i\)</span>，<span class="math inline">\((1\leq i
\leq m)\)</span>。则区间修改的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)&#123;<br>	D[ L[i] ] += d[i];<br>	D[ R[i]+<span class="hljs-number">1</span> ] -= d[i];     <span class="hljs-comment">// 注意不要写成了R[i+1]了。做当前这个区间的修改，关下一个区间什么事？</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>for循环里的这两句代码如何理解呢？</p>
<p>举个例子：现在需要将a[]中第3个元素到第7个元素（共计7-3+1=5个）全都加上20，则代码应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">D[3] += 20;<br>D[8] -= 20;    <br></code></pre></td></tr></table></figure>
<p>注意，上述代码中不是D[7]!为什么呢？请看下图的例子：</p>
<p><img src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/image-20240321112724482.png" alt="image-20240321112724482" style="zoom:67%;" /></p>
<p>我们可以把上面的代码整合一下，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> le, <span class="hljs-type">int</span> ri, <span class="hljs-type">int</span> v)</span></span>&#123;<br>	D[le]+=v, D[ri+<span class="hljs-number">1</span>]-=v;            <span class="hljs-comment">// 注意 ri+1</span><br>&#125;<br><span class="hljs-built_in">main</span>()&#123;<br>    ......<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)          <span class="hljs-comment">// m次区间修改  </span><br>    	<span class="hljs-built_in">change</span>(L[i], R[i], val[i]);  <span class="hljs-comment">// 每次把a[]从第L[i]到第R[i]个元素全都加上val[i]</span><br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>上述的change函数是<span
class="math inline">\(O(1)\)</span>的，for循环是<span
class="math inline">\(O(m)\)</span>的。我们成功地将“m次<strong>区间</strong>操作”的<span
class="math inline">\(O(m*n)\)</span>操作变成了“m次<strong>单点</strong>修改”的<span
class="math inline">\(O(m)\)</span>，大大提高了效率。</p>
<h4 id="单点查询操作">1.3.2.2 “<strong>单点查询</strong>"操作</h4>
<p>这里说的单点查询，是指读取最终a[]数组中某一个元素的值。</p>
<p>当我们使用D[]数组做了m次<span
class="math inline">\(O(1)\)</span>修改操作后，D[]已经面目全非了。现在要查询a[]中的第k个元素的值，该如何做呢？当然需要先通过D[1..n]还原出a[1..n]，然后提取a[k]。<strong>还原过程就是对D[]做“前缀和”操作</strong>，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;    <span class="hljs-comment">// 因为是对a[]做遍历，i要到n，这里和m没任何关系了</span><br>	a[i] = a[i<span class="hljs-number">-1</span>] + D[i];   <span class="hljs-comment">// 谁加谁的值赋给谁，别晕哦！～下标别乱写～</span><br>&#125;<br>cout &lt;&lt;a[k];<br></code></pre></td></tr></table></figure>
<p><img src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/image-20240321113343953.png" alt="image-20240321113343953" style="zoom:67%;" /></p>
<p>上述的操作，时间复杂度是<span
class="math inline">\(O(n)\)</span>的，而不是<span
class="math inline">\(O(1)\)</span>，因为需要先还原。当查询次数很少时，是可以接受的。</p>
<h3 id="局限性">1.3.3 局限性</h3>
<p>局限主要出现在“查询”上。如果查询不是发生了1次，而是这样：有m次修改，有k次查询，且修改和查询的顺序是随机的。此时总复杂度是：m次修改复杂度<span
class="math inline">\(O(m)\)</span>，k次查询复杂度<span
class="math inline">\(O(k*n)\)</span>，总复杂度<span
class="math inline">\(O(m+k*n)\)</span>。当查询次数远大于修改次数时，还不如直接用暴力法（总复杂度<span
class="math inline">\(O(m*n+k)\)</span>）。</p>
<p>对于“区间修改+<strong>多次</strong>单点查询”这种题型来说，用差分数组往往不够用。因为差分数组对“区间修改”很高效，但是对“<strong>多次</strong>单点查询”并不高效。此时需要用树状数组和线段树来求解。</p>
<p>树状数组常常结合差分数组来解决更复杂的问题，具体需要查阅“树状数组”专题中的<a
target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=1556">hdu1556</a>；差分数组也常用于“树上差分”，见本博客<strong>LCA</strong>专题的“树上差分”。</p>
<h2 id="二维差分">1.4 二维差分</h2>
<p>从一维差分容易扩展到二维差分。一维是线性数组，一个区间[L,R]有两个端点；<strong>二维则是矩阵，一个区间由四个端点围成</strong>。</p>
<h3 id="问题假设-1">1.4.1 问题假设</h3>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3397">P3397
地毯</a>是一个非常典型的二维差分的模板题。我们可以不妨以该题作为二维差分的问题假设。</p>
<h3 id="原始数组a和二维差分d之间的互换">1.4.2
原始数组a[][]和二维差分D[][]之间的互换</h3>
<p>假设原始数组为a[1..R][1..C],二维差分数组D[1..R][1..C]。这里并不存在专门的前缀和数组，对D[][]进行前缀和运算，就能得到原始数组a[][]。“前缀和”只是从差分还原为原始数组时需要用到的计算方法。</p>
<h4 id="差分drightarrow原始数组a">1.4.2.1 差分D[][]<span
class="math inline">\(\Rightarrow\)</span>原始数组a[][]</h4>
<p>在一维差分中，原数组a[1..n]是从第1个元素(即D[1])开始的差分数组D[1..n]的前缀和：
<span class="math display">\[
a[k]=D[1]+D[2]+...+D[k]
\]</span>
在二维差分中，a[i][j]实际上就是差分数组D[1..i][1..j]的前缀和运算结果，即<strong>由原点坐标(1,1)和坐标(i,j)围成的矩阵中，所有的D[][]相加等于a[i][j]</strong>，用数学公式来表示就是：<span
class="math inline">\(a[i][j]=\sum_{r=1}^{i}(\sum_{c=1}^{j}D[r][c])\)</span>。所以，“根据D[][]求a[][]”的这个问题，其实就是如何求一个二维数组D的前缀和数组a的问题。可以参看本站“前缀和
二维前缀和”的帖子第3节“高维前缀和”，有更加清晰和完整的阐述。</p>
<h5 id="一按维做前缀和操作-更优">（一）按维做“前缀和”操作（ 更优 ）</h5>
<p>如下图，每个小正圆形代表了一个D[][]值，每个小正方形代表了一个a[][]。在坐标(1,1)和(i,j)所围成的矩形范围内所有小圆形内的数值之和等于a[i][j]。注意，a[0][]和a[][0]值全0，需单独处理，以便后续的二重递推能顺利进行。填写过程的二重for循环都应从1开始。</p>
<p><img src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/image-20240322114928462.png" style="zoom:67%;" /></p>
<p>相关代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 也可以“for C for R”，只是影响填写顺序，第4行代码决定了先累加横向数据，同学们可以试试。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r=<span class="hljs-number">1</span>; r&lt;=R; r++)               <span class="hljs-comment">// 每行都要做如下的事情：</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>; c&lt;=C; c++)&#123;          <span class="hljs-comment">// 对于指定的某一行，从左往右做前缀和并存于a[][]</span><br>    	a[r][c]=a[r][c<span class="hljs-number">-1</span>] + D[r][c];   <span class="hljs-comment">// 该行当前列的累加和=该行左侧列的累加和 + 当前数</span><br>    &#125;<br><span class="hljs-comment">// for R for C和for C for R都可以，但第9行一定只能纵向累加，区别于第4行的横向累加</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>; r&lt;=C; c++)               <span class="hljs-comment">// 每列都要做如下的事情：</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r=<span class="hljs-number">1</span>; r&lt;=R; r++)&#123;          <span class="hljs-comment">// 对于指定的某一列，从下往上，继续做前缀和</span><br>    	a[r][c]=a[r<span class="hljs-number">-1</span>][c] + a[r][c];   <span class="hljs-comment">// a[r][c]已经是一个横向的前缀和数值了，现在按纵向来累加</span><br>    &#125;<br></code></pre></td></tr></table></figure>
<p>对于d维数组，则这种算法的时间复杂度为<span
class="math inline">\(O(R*C*d)\)</span>，表现优异。</p>
<h5 id="二递推做法">(二)递推做法</h5>
<p>我们可以用二维的容斥原理来得到递推公式。如下图所示：</p>
<p><img src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/image-20240322120812891.png" style="zoom:67%;" /></p>
<p>总结为公式就是如下： <span class="math display">\[
\begin{cases}a[i][0]=0 \qquad (0 \leq i \leq R) \\
a[0][j]=0 \qquad (0 \leq j \leq C) \\
a[i][j]=a[i-1][j]\ +\ a[i][j-1]\ -\ a[i-1][j-1]\ +\ D[i][j] \qquad(1
\leq i \leq R, \ 1\leq j \leq C) \tag {1}
\end{cases}
\]</span> 这种优化后的递推方法，复杂度为<span
class="math inline">\(O(R*C)\)</span>。但是对于d维数组求前缀和来说，多维下的容斥原理，上面公式（1）中的第3个公式右边的数据项数不再是4项，而是有<span
class="math inline">\(2^d\)</span>项。所以其时间复杂度准确地说，应该是<span
class="math inline">\(O(R*C*2^d)\)</span>，看上去似乎没有第一种方法那么好了，而且公式复杂，书写易错，不推荐本方法。</p>
<h4 id="原始数组arightarrow差分数组d">1.4.2.2 原始数组a[][]<span
class="math inline">\(\Rightarrow\)</span>差分数组D[][]</h4>
<p>在一维情况下，<span
class="math inline">\(D[i]=a[i]−a[i−1]\)</span>。</p>
<p>在二维情况下，根据上面总结出来的公式(1)，可以很容易得到： <span
class="math display">\[
\begin{cases}D[i][0]=0 \qquad (0 \leq i \leq R) \\
D[0][j]=0 \qquad (0 \leq j \leq C) \\
D[i][j]=a[i][j]\quad\textcolor[RGB]{225,0,0}{–}a[i−1][j]\quad\textcolor[RGB]{225,0,0}{–}a[i][j−1]\quad\textcolor[RGB]{0,225,0}{+}a[i−1][j−1]
\qquad(1\leq i \leq R,\ 1\leq j \leq C) \tag{2}
\end{cases}
\]</span> 这个公式的计算复杂度是<span
class="math inline">\(O(4)\)</span>的。这个公式可以通过下图进一步，采用集合的容斥原理来分析。</p>
<p><img src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/image-20240322143341699.png" style="zoom: 67%;" /></p>
<p>同学们可以想一下，如果这里是<span
class="math inline">\(d=3\)</span>维数组，那采用容斥原理来分析，其复杂度是多少呢？<span
class="math inline">\(O(2^d)\)</span></p>
<h3 id="相关操作和解法-1">1.4.3 相关操作和解法</h3>
<h4 id="批量m次区间修改操作-1">1.4.3.1
“<strong>批量（m次）区间修改</strong>”操作</h4>
<p>在一维情况下，做区间修改只需要修改区间的两个端点的D[]值。在二维情况下，一个区间代表了一个小矩阵，有4个角点，只需要修改这4个角点的D[][]值。例如以两个坐标点<span
class="math inline">\((r1,c1)\)</span>和<span
class="math inline">\((r2,c2)\)</span>为对角点而定义的矩形区间，其修改方法如下代码所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">D[r1][c1]     += d;     <span class="hljs-comment">// 二维区间的起点，累加</span><br>D[r1][c2+<span class="hljs-number">1</span>]   -= d;     <span class="hljs-comment">// 横向看，原始数组的修改范围是列从c1到c2+1。累减</span><br>D[r2+<span class="hljs-number">1</span>][c1]   -= d;     <span class="hljs-comment">// 纵向看，原始数组的修改范围是行从r1到r2+1。累减</span><br>D[r2+<span class="hljs-number">1</span>][c2+<span class="hljs-number">1</span>] += d;     <span class="hljs-comment">// 由于前两式把d减了2次，多减了1次，这里加1次回来</span><br></code></pre></td></tr></table></figure>
<p>举个例子：现在有a[0..7][0..7]及其对应的差分数组D[0..7][0..7]的数据如下图所示，a[][]的每个元素值都是10的整倍数。现在需要在以(2，3)和（5，5）为对角点的矩形范围内把每个a[][]的值都累加上5。如果用差分数组来处理，该如何实现这个操作呢？我们需要在D[][]中找到4个坐标点，他们分别是（2，3）、（2，6）、（6，3）、（6，6），如下图左中黄色圆圈所示。然后对这四个D[][]做上面代码块中的相关操作就可以啦！注意，是<strong>累加</strong>，不是直接赋值。</p>
<figure>
<img
src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/image-20240322152409516.png"
alt="image-20240322152409516" />
<figcaption aria-hidden="true">image-20240322152409516</figcaption>
</figure>
<p>修改后的D数组和其对应代表的a数组如上图右所示。同学们可以仔细体会。</p>
<h4 id="单点查询操作-1">1.4.3.2 “单点查询”操作</h4>
<p>当我们对D[][]数组做了m次<span
class="math inline">\(O(4)\)</span>修改操作后，假如现在要查询其对应的a[][]中的第r行第c列的元素值，这就是所谓的“单点查询”操作。解决方法就是先通过D[1..R][1..C]还原出a[1..R][1..C]，然后提取a[r][c]。<strong>还原过程就是对D[][]做“前缀和”操作</strong>，从而还原得到a[][]。该操作过程请参看1.4.2.1节内容，此处不再赘述。算法复杂度为<span
class="math inline">\(O(R*C)\)</span>。</p>
<h2 id="三维差分">1.5 三维差分</h2>
<h3 id="问题假设-2">1.5.1 问题假设</h3>
<p>元素值用三维数组
a[][][]来定义，差分数组b[][][]也是三维的。与之前低维度的差分类似，把三维差分想象成立体空间的操作。与之对应的小立方块有8个顶点，所以三维的区间需要修改8个b[][][]的值。</p>
<h3 id="原始数组a和差分数组d之间的相互关系">1.5.2
原始数组a[][][]和差分数组D[][][]之间的相互关系</h3>
<p>在二维差分中，a[][] 是差分数组 b[][]的前缀和，即原点坐标(1，1)和
坐标(i，j)围成的矩阵面积。</p>
<p>在三维差分中，a[][][] 是差分数组
b[][][]的前缀和，即原点坐标(1,1,1)和坐标(r,c,h)围成的立方体体积。同样地，我们把每个b[][][]看成一个小正方体，在坐标(1，1，1)~(i，j，k)所围成的三维空间中，所有小正方体加起来的总体积即为a[r][c][h]。如下图所示，每个小立方体由8个角点定义。坐标点(i，j，k)的值是
a[r][c][h]; 图中正方体的体积是差分数组 b[i][j][k]的值。</p>
<p><img src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/image-20240322215017626.png" style="zoom:67%;" /></p>
<p>类似的，在三维情况下，差分就变成了相邻的<code>a[][][]</code>的
”体积差“。那么如何来写出差分的<strong>递推</strong>计算公式呢？</p>
<p>观察前面一、二维的前缀和我们可以发现，其前缀和规律十分吻合容斥原理:</p>
<ol type="1">
<li><p>一维：</p>
<p>A)原始a <span class="math display">\[
\begin{align} a_i = a^{i-1} + D_i \tag{3}
\end{align}
\]</span> B)差分D <span class="math display">\[
\begin{align}
D_i=a_i - a_{i-1}\end{align} \tag{4}
\]</span></p></li>
<li><p>二维：</p>
<ol type="A">
<li>原始a <span class="math display">\[
\begin{align}a_{r,c} = &amp;\ \ \ \ \ \ D_{r,c}  \tag{5}\\&amp;+\
a_{r-1,c} \ \ \ + \ \ a_{r,c-1}\quad\quad\quad(奇数个维度(1)要-1，加)
\notag \\
&amp;-\ a_{r-1,c-1}
\quad\quad\quad\quad\quad\quad\quad(偶数个维度(2)要-1，减)\notag \\
\end{align}
\]</span></li>
<li>差分D <span class="math display">\[
\begin{align}D_{r,c} = &amp;\ \ \ \ \ \ a_{r,c} \tag{6}\\&amp;-\
a_{r-1,c} \ \ \ - \ \ a_{r,c-1}\quad\quad\quad(奇数个维度(1)要-1，减)
\notag \\
&amp;+\ a_{r-1,c-1}
\quad\quad\quad\quad\quad\quad\quad(偶数个维度(2)要-1，加)\notag \\
\end{align}
\]</span></li>
</ol></li>
<li><p>三维：</p>
<ol type="A">
<li>原始a <span class="math display">\[
\begin{align}a_{r,c,h} = &amp;\ \ \ \ \ \ D_{r,c,h} \tag{7}\\&amp;+\
a_{r-1,c,h} \ \ \ + \ \ a_{r,c-1,h}\ \ \ + \
a_{r,c,h-1}\quad\quad\quad(奇数个维度(1)要-1，加) \notag \\
&amp;-\ a_{r-1,c-1,h}-\ a_{r,c-1,h-1}-\ a_{r-1,c,h-1}
\quad\quad(偶数个维度(2)要-1，减)\notag \\
&amp;+\
a_{r-1,c-1,h-1}\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\
\ \ (奇数个维度(3)要-1，加)\notag
\end{align}
\]</span> B)差分D <span class="math display">\[
\begin{align}D_{r,c,h} = &amp;\ \ \ \ \ \ a_{r,c,h}\tag{8}\\&amp;−\
a_{r-1,c,h} \ \ \ − \ \ a_{r,c-1,h}\ \ \ − \
a_{r,c,h-1}\quad\quad\quad(奇数个维度(1)要-1，减) \notag \\
&amp;+\ a_{r-1,c-1,h}+\ a_{r,c-1,h-1}+\ a_{r-1,c,h-1}
\quad\quad(偶数个维度(2)要-1，减减得加)\notag \\
&amp;−\
a_{r-1,c-1,h-1}\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\
\ \ (奇数个维度(3)要-1，减)\notag
\end{align}
\]</span>
上述A)和B)两个公式，其实是同一个公式。建议选一个来记住即可，临场现推另外一个，不必全记。</li>
</ol></li>
</ol>
<h3 id="相关操作和解法-2">1.5.3 相关操作和解法</h3>
<h4 id="批量m次区间修改操作-2">1.5.3.1
“<strong>批量（m次）区间修改</strong>”操作</h4>
<p>在三维情况下，我们修改的是一个立方体，有8个顶点，故我们只需要修改这8个顶点的
差分数组b[][][]的值即可。给出坐标点$$定义的区间，如下图所示:</p>
<p><img src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/image-20240325114915696.png" style="zoom: 50%;" /></p>
<p>那么对应的8个 D[][][]的修改如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 左侧</span><br>D[r1][c1][h1] += d;     <span class="hljs-comment">// 红点，左前下</span><br>D[r1][c1][h2 + <span class="hljs-number">1</span>] -= d;      <span class="hljs-comment">// 左前上</span><br>D[r1][c2 + <span class="hljs-number">1</span>][h1] -= d;      <span class="hljs-comment">// 左后下</span><br>D[r1][c2 + <span class="hljs-number">1</span>][h2 + <span class="hljs-number">1</span>] += d;  <span class="hljs-comment">// 左后上 </span><br><br><span class="hljs-comment">// 右侧</span><br>D[r2 + <span class="hljs-number">1</span>][c1][h1] -= d;      <span class="hljs-comment">// 右前下</span><br>D[r2 + <span class="hljs-number">1</span>][c1][h2 + <span class="hljs-number">1</span>] += d;  <span class="hljs-comment">// 右前上</span><br>D[r2 + <span class="hljs-number">1</span>][c2 + <span class="hljs-number">1</span>][h1] += d;  <span class="hljs-comment">// 右后下</span><br>D[r2 + <span class="hljs-number">1</span>][c2 + <span class="hljs-number">1</span>][h2 + <span class="hljs-number">1</span>] -= d; <span class="hljs-comment">// 绿点，右后上</span><br></code></pre></td></tr></table></figure>
<p>为了方便记忆，我们可以把它按照二进制的排列来写，若二进制中出现偶数个"正1"为正，奇数个"正1"为负，与前缀和恰好相反（前缀和是偶数个"-1"为负，奇数个"-1"为正）:
$$ <span class="math display">\[\begin{align}
{0, 0, 0}\quad&amp;\Rightarrow{r1, c1,
h1}&amp;\Rightarrow&amp;D[][][]+=d; \notag \\
{0, 0, \textcolor[RGB]{225,0,0}{1}}\quad&amp;\Rightarrow{r1, c1,
h2+1}&amp;\Rightarrow&amp;D[][][]\textcolor[RGB]{225,0,0}{-}=d; \notag
\\
{0, \textcolor[RGB]{225,0,0}{1}, 0}\quad&amp;\Rightarrow{r1, c2+1,
h1}&amp;\Rightarrow&amp;D[][][]\textcolor[RGB]{225,0,0}{-}=d; \notag \\
{0, 1, 1}\quad&amp;\Rightarrow{r1, c2+1,
h2+1}&amp;\Rightarrow&amp;D[][][]+=d; \notag \\

{\textcolor[RGB]{225,0,0}{1}, 0, 0}\quad&amp;\Rightarrow{r2+1, c1,
h1}&amp;\Rightarrow&amp;D[][][]\textcolor[RGB]{225,0,0}{-}=d; \notag \\
{1, 0, 1}\quad&amp;\Rightarrow{r2+1, c1,
h2+1}&amp;\Rightarrow&amp;D[][][]+=d; \notag \\
{1, 1, 0}\quad&amp;\Rightarrow{r2+1, c2+1,
h1}&amp;\Rightarrow&amp;D[][][]+=d; \notag \\  
{\textcolor[RGB]{225,0,0}{1}, \textcolor[RGB]{225,0,0}{1},
\textcolor[RGB]{225,0,0}{1}}\quad&amp;\Rightarrow{r2+1, c2+1,
h2+1}&amp;\Rightarrow&amp;D[][][]\textcolor[RGB]{225,0,0}{-}=d; \notag
\\
\end{align}\]</span> $$</p>
<h1 id="二实战训练">二、实战训练</h1>
<h2 id="hdu-1556一维差分模板题">2.1 HDU 1556（一维差分模板题）</h2>
<p><strong>原题链接</strong>：<a
target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=1556">HDU 1556 Color the
ball</a></p>
<p><strong>问题描述</strong>：N个气球排成一排，从左到右依次编号为1,2,3....N。每次给定2个整数L,R(L&lt;=R)，lele从气球L开始到气球R依次给每个气球涂一次颜色。但是N次以后lele已经忘记了每个气球已经涂过几次颜色了，你能帮他算出每个气球被涂过几次颜色吗？
<strong>输入</strong>：每个测试实例第一行为一个整数N，(N&lt;=100000)。接下来的N行，每行包括2个整数L,
R(1&lt;=L&lt;=R&lt;=N)。当N=0，输入结束。
<strong>输出</strong>：每个测试实例输出一行，包括N个整数，第I个数代表第I个气球总共被涂色的次数。</p>
<p><strong>分析</strong>：</p>
<p>这个例题是简单差分法的直接应用，下面给出代码。代码第13、14行是区间修改，第17行的a[i]=a[i−1]+D[i]，即利用D[]求得了最后的a[]。这个式子就是a[i]−a[i−1]=D[i]，它是差分数组的定义。</p>
<p>注意a[]的计算方法。a[i]=a[i−1]+D[i]是一个递推公式，通过它能在一个i循环中求得所有的a[]。如果不用递推，而是直接用前缀和a[k]=D[1]+D[2]+...+D[k]来求所有的a[]，就需要用两个循环i、k。</p>
<p>本题AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//hdu 1556用差分数组求解</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Maxn = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> a[Maxn],D[Maxn];               <span class="hljs-comment">//a是气球，D是差分数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)) &#123; <br>        <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a)); <span class="hljs-built_in">memset</span>(D,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(D));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> L,R; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;L,&amp;R);<br>            D[L]++;                 <span class="hljs-comment">//区间修改，这里d=1</span><br>            D[R+<span class="hljs-number">1</span>]--;<br>        &#125;<br>        <span class="hljs-comment">//小技巧：17行到20行，把a[]改成D[]也行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;              <span class="hljs-comment">//求原数组</span><br>            a[i] = a[i<span class="hljs-number">-1</span>] + D[i];           <span class="hljs-comment">//差分。求前缀和a[]，a[i]就是气球i的值</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);  		   <span class="hljs-comment">//逐个打印结果</span><br>        &#125;        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面的代码可以把第17~20行的a[]改为D[]（即不使用专门的a数组）也能通过。这个技巧在后面的二维差分、三维差分中也能用，节省一倍的空间。</p>
<h2 id="p2367-一维差分模板题">2.2 P2367 （一维差分模板题）</h2>
<p>原题链接：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2367">P2367
语文成绩</a></p>
<p>这个题和2.1节一样，是第二个裸的一维差分入门模板题。n=5e6，要求1秒完成，所以只能采用<span
class="math inline">\(O(n)\)</span>的算法才能过。</p>
<p>AC代码如下。本题代码只用了一个数组，同学们也可以试试看。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//P2367用差分数组求解</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Maxn = <span class="hljs-number">5e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> D[Maxn];            <span class="hljs-comment">//差分数组（初始也用来存原始数据）</span><br><span class="hljs-comment">// 本题也可以只定义a[]而不定义D[]，其实代码形式都一样，从内存的角度来说很容易看出来。 </span><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, p;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n, &amp;p);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;D[i]);  <span class="hljs-comment">// 先用差分数组D[]暂存a[] </span><br>    <span class="hljs-comment">// 注意循环顺序只能倒序，不能正序哦！递推公式决定的。 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n; i&gt;=<span class="hljs-number">1</span>; i--) D[i]=D[i]-D[i<span class="hljs-number">-1</span>];     <span class="hljs-comment">// 等效于D[i]=a[i]-a[i-1]，得到真正的差分数组D[] </span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=p; i++) &#123;<br>        <span class="hljs-type">int</span> L,R,s;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;L,&amp;R,&amp;s);<br>        D[L]+=s;                 <span class="hljs-comment">//区间修改的固定套路 </span><br>        D[R+<span class="hljs-number">1</span>]-=s;<br>    &#125;<br>    <span class="hljs-type">int</span> minn = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;            <br>        D[i] = D[i<span class="hljs-number">-1</span>] + D[i];    <span class="hljs-comment">//以前缀和的方法，恢复出原始数组a[i]，仍存于D[i]</span><br>        <span class="hljs-keyword">if</span> (D[i]&lt;minn)<br>            minn= D[i];<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, minn);  	 <span class="hljs-comment">//逐个打印结果</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="p4552多少次多少种">2.3 P4552（多少次，多少种）</h2>
<p>原题链接：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4552">P4552
[Poetize6] IncDec Sequence</a></p>
<p>视频讲解链接：<a
target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12u411L7ii">差分
二维差分</a>（04:53处）</p>
<p><strong>分析：</strong></p>
<p><img
src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/1973969-20230705121209012-1332416451.png" /></p>
<p><img
src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/1973969-20230705121209018-1370204910.png" /></p>
<p>AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[maxn], D[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">int</span> n;<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);<br>        D[i] = a[i] - a[i<span class="hljs-number">-1</span>];<br>    &#125;<br><br>	LL p=<span class="hljs-number">0</span>, q=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++)<br>		<span class="hljs-keyword">if</span>(D[i]&gt;<span class="hljs-number">0</span>) <br>            p += D[i];<br>		<span class="hljs-keyword">else</span> <br>            q += <span class="hljs-built_in">abs</span>(D[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n%lld&quot;</span>, <span class="hljs-built_in">max</span>(p,q), <span class="hljs-built_in">abs</span>(p-q)+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="p9011深搜为主一维差分可有">2.4
P9011（深搜为主，一维差分可有）</h2>
<p>原题链接：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P9011">P9011
[USACO23JAN] Air Cownditioning II B</a></p>
<p>题目简意：要求从M(<span class="math inline">\(1\leq
M\leq10\)</span>)个区间修改中选择若干个（次数不定）修改，对一个数组a[1..100]（初始全0）进行区间修改，每次修改的成本代价已知且不同，求将数组改造成指定要求的内容最少需要的代价之和。</p>
<p><strong>分析</strong>：</p>
<p>题意中说“从M个中选择若干个……”，且M如此之小，第一反应就是用深搜来暴力尝试。针对每个区间修改，我们有“选择它”和“不选择它”这两种选择方案。两种方案都要尝试，都要执行。</p>
<p>1）如果选择做第i个修改，则对a数组中第le[i]..ri[i]个之间的数据进行区间修改，可以采用差分数组将其降为<span
class="math inline">\(O(1)\)</span>的复杂度（也可以直接开for循环来做，<span
class="math inline">\(O(N=20)\)</span>变成<span
class="math inline">\(O(N*100=2e4)\)</span>，也不大），累计成本，对下一个修改做选择；</p>
<p>2）如果选择不做该修改，成本不变，对下一个修改做选择；</p>
<p>以上的操作一直进行到M个区间修改全都完毕，可以视为一个方案。此时的成本即为该方案的成本。当前需要求最小成本，所以在深搜的过程中可以剪枝（若当前成本已经大于曾经的最小成本，则没必要继续深搜下去了，不可能优）</p>
<p>AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> N,M,k,minmoney=<span class="hljs-number">1e9</span>;<br><span class="hljs-type">int</span> wendu[<span class="hljs-number">105</span>];   <span class="hljs-comment">// 100个围栏的温度 </span><br><span class="hljs-type">int</span> s[<span class="hljs-number">25</span>],t[<span class="hljs-number">25</span>],c[<span class="hljs-number">25</span>];  <span class="hljs-comment">// 最多20个奶牛，占据从s[]到t[]的围栏，要求温度要下降c[]度 </span><br><span class="hljs-type">int</span> a[<span class="hljs-number">25</span>],b[<span class="hljs-number">25</span>],p[<span class="hljs-number">25</span>],m[<span class="hljs-number">25</span>];  <span class="hljs-comment">// 最多10个空调，从a[]到b[]的围栏温度都能下降m[]度  </span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//是否满足</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=k; i++)&#123;<br>        <span class="hljs-keyword">if</span>(wendu[i]&gt;<span class="hljs-number">0</span>)   <span class="hljs-comment">// 如果还存在某个围栏的预设温度没有降到0及以下，说明降温不够要求 </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> dep,<span class="hljs-type">int</span> money)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (money &gt; minmoney)  <span class="hljs-comment">// 剪枝，如果继续下去，不可能再小于minnoney，放弃这个分支 </span><br>        <span class="hljs-keyword">return</span>; <br>    <span class="hljs-keyword">if</span>(dep&gt;M)&#123;     <span class="hljs-comment">// 已经处理完M个空调的选择 </span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>()) <br>            minmoney=<span class="hljs-built_in">min</span>(minmoney,money);<span class="hljs-comment">//合法就更新答案</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(dep+<span class="hljs-number">1</span>,money); <span class="hljs-comment">//不选，前进 </span><br><br>    <span class="hljs-comment">// 做完“不选第dep个修改”的尝试之后，再做“做第dep个修改”的尝试    </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a[dep]; i&lt;=b[dep]; i++) wendu[i]-=p[dep]; <span class="hljs-comment">//选，既然选，就要降温 </span><br>    <span class="hljs-built_in">dfs</span>(dep+<span class="hljs-number">1</span>,money+m[dep]);   <span class="hljs-comment">// 前进 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a[dep]; i&lt;=b[dep]; i++) wendu[i]+=p[dep]; <span class="hljs-comment">//回溯，抹掉对应的修改 </span><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt;N &gt;&gt;M;    <span class="hljs-comment">// 奶牛数N，空调数M </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=N; i++)&#123;<br>        cin &gt;&gt;s[i] &gt;&gt;t[i] &gt;&gt;c[i];<br>        k=<span class="hljs-built_in">max</span>(k,t[i]);<br>        wendu[s[i]]+=c[i];   <span class="hljs-comment">//差分的处理方式 </span><br>        wendu[t[i]+<span class="hljs-number">1</span>]-=c[i]; <span class="hljs-comment">// </span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">100</span>; i++)<br>        wendu[i]+=wendu[i<span class="hljs-number">-1</span>]; <span class="hljs-comment">//将差分数组还原成原始数组 </span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=M; i++) cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;p[i]&gt;&gt;m[i];<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);      <span class="hljs-comment">// 考虑第1个修改，已付成本为0 </span><br>    cout&lt;&lt;minmoney;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="其他简单的一维差分题训练">2.5 其他简单的一维差分题训练</h2>
<p>1）<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF44C">CF44C
Holidays</a>,原题链接点<a
target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/44/C"><strong>这里</strong></a></p>
<p>2）<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1672">P1672
[USACO05FEB] Feed Accounting S</a></p>
<p>3)<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4623">P4623
[COCI2012-2013#6] BUREK</a></p>
<h2 id="p3397二维差分模板题">2.6 P3397（二维差分模板题）</h2>
<p><strong>原题链接</strong>：<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3397">P3397 地毯</a></p>
<p><strong>分析</strong>：</p>
<p>这一题是2.1节的hdu1556的二维扩展，其修改操作和查询操作完全一样。m=1000次修改，n*n的网格范围。</p>
<p>在用差分之前，先考虑能不能用暴力法。每次修改复杂度是<span
class="math inline">\(O(n^2)\)</span>，共m次，总复杂度<span
class="math inline">\(O(m*n^2=1e9)\)</span>，超时。</p>
<p>二维差分的复杂度是多少？一维差分的一次修改是<span
class="math inline">\(O(1)\)</span>的，二维差分的修改是O(4)的；一维差分的一次查询是<span
class="math inline">\(O(n)\)</span>的，二维差分是<span
class="math inline">\(O(n^2)\)</span>的，所以二维差分的总复杂度是<span
class="math inline">\(O(4*m+n^2)\)</span>。由于计算一次二维矩阵的值需要<span
class="math inline">\(O(n^2)\)</span>的计算量，所以二维差分已经达到了最好的复杂度。</p>
<p>AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> D[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>];     <span class="hljs-comment">//差分数组</span><br><span class="hljs-comment">//int a[1010][1010];   //原数组，不定义也行</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);<br>        D[x1][y1]     += <span class="hljs-number">1</span>;        <span class="hljs-comment">//计算差分数组</span><br>        D[x2+<span class="hljs-number">1</span>][y1]   -= <span class="hljs-number">1</span>;<br>        D[x1][y2+<span class="hljs-number">1</span>]   -= <span class="hljs-number">1</span>;<br>        D[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>] += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 还原的方法1：前缀和方式 O(d * n^2)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i)           <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;n; ++j)        <span class="hljs-comment">//注意这里是j&lt;n</span><br>            D[i][j+<span class="hljs-number">1</span>] += D[i][j];     <span class="hljs-comment">//把i看成定值，先累加计算j方向</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; ++j)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; ++i)        <span class="hljs-comment">//注意这里是i&lt;n</span><br>            D[i+<span class="hljs-number">1</span>][j] += D[i][j];     <span class="hljs-comment">//把j看成定值，再累加计算i方向</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) &#123;         <span class="hljs-comment">//打印</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; ++j)<br>             <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,D[i][j]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);                 <span class="hljs-comment">//换行</span><br>    &#125;<br>     <br><span class="hljs-comment">//    // 还原的方法2：递推方式   O(2^d * n^2) </span><br><span class="hljs-comment">//    for(int i=1;i&lt;=n;++i)&#123;   //根据差分数组计算原矩阵的值（想象成求小格子的面积和）</span><br><span class="hljs-comment">//        for(int j=1;j&lt;=n;++j)&#123;      //把用过的D[][]看成a[][]，就不用再定义a[][]了</span><br><span class="hljs-comment">//            //a[i][j] = D[i][j] + a[i-1][j] + a[i][j-1] - a[i-1][j-1];</span><br><span class="hljs-comment">//            //printf(&quot;%d &quot;,a[i][j]);  //这两行和下面两行的效果一样</span><br><span class="hljs-comment">//            D[i][j] += D[i-1][j]+D[i][j-1]-D[i-1][j-1];</span><br><span class="hljs-comment">//            printf(&quot;%d &quot;,D[i][j]);</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        printf(&quot;\n&quot;);//换行</span><br><span class="hljs-comment">//    &#125;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="三体攻击三维差分模板题">2.7 三体攻击（三维差分模板题）</h2>
<p><strong>原题链接</strong>：<a
target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/180/learning/">三体攻击（蓝桥杯2018年省赛A组）</a></p>
<p><strong>问题简述</strong>：</p>
<p>三体人将对地球发起攻击。为了抵御攻击，地球人派出了<span
class="math inline">\(n = A × B × C\)</span> 艘战舰，在太空中排成一个 A
层 B 行 C 列的立方体。其中，第 i 层第 j 行第 k 列的战舰（记为战舰 <span
class="math inline">\((i, j, k)\)</span>）的生命值为 <span
class="math inline">\(s(i, j, k)\)</span>。</p>
<p>三体人将会对地球发起 m
轮“立方体攻击”，每次攻击会对一个小立方体中的所有战舰都造成相同的伤害。具体地，第t轮攻击用7个参数
x1, x2, y1, y2, z1, z2, d 来描述；</p>
<p>所有满足<span class="math inline">\(i∈[x1, x2], j∈[y1, y2],
k∈[z1, z2]\)</span> 的战舰 <span
class="math inline">\((i, j, k)\)</span>
会受到值为d的伤害。如果一个战舰累计受到的总伤害超过其防御力，那么这个战舰会爆炸。</p>
<p>地球指挥官希望你能告诉他，第一艘爆炸的战舰是在哪一轮攻击后爆炸的。</p>
<p>输入：第一行包括 4 个正整数 A, B, C, m；</p>
<p>第二行包含<span class="math inline">\(A × B ×
C\)</span>个整数，其中第<span class="math inline">\(((i − 1)×B + (j −
1)) × C + (k − 1)+1\)</span> 个数为<span
class="math inline">\(s(i, j, k)\)</span>；</p>
<p>第 3 到第 m + 2 行中，第 (t − 2) 行包含 7 个正整数 x1,
x2, y1, y2, z1, z2, d。</p>
<p><span class="math inline">\(A × B ×
C ≤ 10^6, m ≤ 10^6, 0 ≤ s(i, j, k), d ≤ 10^9\)</span>。</p>
<p>输出：输出第一个爆炸的战舰是在哪一轮攻击后爆炸的。保证一定存在这样的战舰。</p>
<p><strong>分析</strong>：</p>
<p>首先看数据规模，有<span class="math inline">\(n=10^6\)</span>个点，
<span
class="math inline">\(m=10^6\)</span>次攻击，如果用暴力法，统计每次攻击后每个点的生命值，那么复杂度是<span
class="math inline">\(O(m*n)\)</span>的，超时。</p>
<p>本题适合用三维差分，每次攻击只修改差分数组D[][][]，一次修改的复杂度是<span
class="math inline">\(O(1)\)</span>，m次修改的总复杂度只有<span
class="math inline">\(O(m)\)</span>。</p>
<p>但是光用差分数组并不能解决问题。因为在差分数组上查询区间内的原始数组中每个元素是否小于0，需要用差分数组来计算前缀和数组（即原始数组a）的值，复杂度是<span
class="math inline">\(O(n)\)</span>的。合起来的总复杂度还是<span
class="math inline">\(O(m*n)\)</span>的，跟暴力法的复杂度一样。</p>
<p>分析到这里，可以发现，本题和P1083是非常相似的（P1083的分析过程请见本站“二分查找和二分答案”帖），是存在单调性的。本题需要结合第二个算法：二分法。从第1次修改到第m次修改，肯定有一次修改是临界点。在临界点前，没有负值（战舰爆炸）；在临界点后，出现了负值，且后面一直有负值。这就是单调性。那么对m进行二分，就能在<span
class="math inline">\(O(logm)\)</span>次内找到这个临界点，这就是答案。总复杂度<span
class="math inline">\(O(n*logm)\)</span>。</p>
<p>下面给出代码。其中<code>check()</code>函数包含了三维差分的全部内容。代码有几个关键点：</p>
<p>（1）没有定义a[][][]，而是用D[][][]来代替。</p>
<p>（2）<strong>压维</strong>。直接定义三维差分数组D[][][]不太方便。虽然坐标点总数量<span
class="math inline">\(n=A×B×C=10^6\)</span>比较小，但是本题并没有明确告知每一维的最大长度，所以如果定义成三维数组，那么每一维都需要定义到<span
class="math inline">\(10^6\)</span>，那么总空间就是<span
class="math inline">\(10^{18}\)</span>。为避免这一问题，可以把三维坐标压维成一维数组D[]，总长度仍然是<span
class="math inline">\(10^6\)</span>的。这个技巧很有用。实现函数是<code>num()</code>，它把三维坐标(x,y,z)变换为一维坐标<span
class="math inline">\(h=(x−1)∗B∗C+(y−1)∗C+(z−1)+1\)</span>，当x、y、z的取值范围分别是<span
class="math inline">\([1,\ A]、[1,\ B]、[1,\
C]\)</span>时，h的范围是<span class="math inline">\([1,\  A × B ×
C]\)</span>。</p>
<p>如果希望按C语言的习惯从0开始，x、y、z的取值范围分别是<span
class="math inline">\([0,\ A-1]、[0,\ B-1]、[0,\ C-1]\)</span>，h范围是0
~ A × B × C-1，就把式子改为：<span
class="math inline">\(h=x∗B∗C+y∗C+z\)</span>。</p>
<p>同理，二维坐标(x,y)也可以压维成一维<span
class="math inline">\(h=(x−1)∗B+(y−1)+1\)</span>，当x、y的取值范围分别是<span
class="math inline">\([1,\ A]、[1,\ B]\)</span>时，hℎ的范围是<span
class="math inline">\([1,\  A × B]\)</span>。</p>
<p>（3）<code>check()</code>中19-26行，在D[1..n]上记录区间修改。</p>
<p>（4）<code>check()</code>中29-40行的3个<code>for</code>循环计算前缀和。分别从x、y、z三个方向累加小立方体的体积，计算出所有的前缀和。</p>
<p>AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> A,B,C,n,m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Maxn = <span class="hljs-number">1000005</span>;<br><span class="hljs-type">int</span> s[Maxn];   <span class="hljs-comment">//存储舰队生命值</span><br><span class="hljs-type">int</span> D[Maxn];   <span class="hljs-comment">//三维差分数组（压维）；同时也用来计算每个点的攻击值</span><br><span class="hljs-type">int</span> x2[Maxn], y2[Maxn], z2[Maxn]; <span class="hljs-comment">//存储区间修改的范围，即攻击的范围</span><br><span class="hljs-type">int</span> x1[Maxn], y1[Maxn], z1[Maxn]; <br><br><span class="hljs-type">int</span> d[Maxn];                    <span class="hljs-comment">//记录伤害，就是区间修改</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;  <br><span class="hljs-comment">//小技巧：压维，把三维坐标[(x,y,z)转为一维的((x-1)*B+(y-1))*C+(z-1)+1</span><br>    <span class="hljs-keyword">if</span> (x&gt;A || y&gt;B || z&gt;C) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> ((x<span class="hljs-number">-1</span>)*B+(y<span class="hljs-number">-1</span>))*C+(z<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;              <span class="hljs-comment">//做x次区间修改。即检查经过x次攻击后是否有战舰爆炸</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)  D[i]=<span class="hljs-number">0</span>;  <span class="hljs-comment">//差分数组的初值，本题是0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=x; i++) &#123;         <span class="hljs-comment">//用三维差分数组记录区间修改：有8个区间端点</span><br>        D[<span class="hljs-built_in">num</span>(x1[i],  y1[i],  z1[i])]   += d[i];<br>        D[<span class="hljs-built_in">num</span>(x2[i]+<span class="hljs-number">1</span>,y1[i],  z1[i])]   -= d[i];<br>        D[<span class="hljs-built_in">num</span>(x1[i],  y1[i],  z2[i]+<span class="hljs-number">1</span>)] -= d[i];<br>        D[<span class="hljs-built_in">num</span>(x2[i]+<span class="hljs-number">1</span>,y1[i],  z2[i]+<span class="hljs-number">1</span>)] += d[i];<br>        D[<span class="hljs-built_in">num</span>(x1[i],  y2[i]+<span class="hljs-number">1</span>,z1[i])]   -= d[i];<br>        D[<span class="hljs-built_in">num</span>(x2[i]+<span class="hljs-number">1</span>,y2[i]+<span class="hljs-number">1</span>,z1[i])]   += d[i];<br>        D[<span class="hljs-built_in">num</span>(x1[i],  y2[i]+<span class="hljs-number">1</span>,z2[i]+<span class="hljs-number">1</span>)] += d[i];<br>        D[<span class="hljs-built_in">num</span>(x2[i]+<span class="hljs-number">1</span>,y2[i]+<span class="hljs-number">1</span>,z2[i]+<span class="hljs-number">1</span>)] -= d[i];<br>    &#125;<br>    <span class="hljs-comment">//下面从x、y、z三个方向计算前缀和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=A; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=B; j++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;C; k++)        <span class="hljs-comment">//把x、y看成定值，累加z方向</span><br>                D[<span class="hljs-built_in">num</span>(i,j,k+<span class="hljs-number">1</span>)] += D[<span class="hljs-built_in">num</span>(i,j,k)];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=A; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=C; k++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;B; j++)        <span class="hljs-comment">//把x、z看成定值，累加y方向</span><br>                D[<span class="hljs-built_in">num</span>(i,j+<span class="hljs-number">1</span>,k)] += D[<span class="hljs-built_in">num</span>(i,j,k)];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=B; j++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=C; k++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;A; i++)        <span class="hljs-comment">//把y、z看成定值，累加x方向</span><br>                D[<span class="hljs-built_in">num</span>(i+<span class="hljs-number">1</span>,j,k)] += D[<span class="hljs-built_in">num</span>(i,j,k)];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)    <span class="hljs-comment">//最后判断是否攻击值大于生命值</span><br>        <span class="hljs-keyword">if</span> (D[i]&gt;s[i])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;A, &amp;B, &amp;C, &amp;m);<br>    n = A*B*C;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;s[i]);  <span class="hljs-comment">//读生命值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)                      <span class="hljs-comment">//读每次攻击的范围，用坐标表示</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d%d%d%d&quot;</span>,&amp;x1[i],&amp;x2[i],&amp;y1[i],&amp;y2[i],&amp;z1[i],&amp;z2[i],&amp;d[i]);<br><br>    <span class="hljs-type">int</span> L = <span class="hljs-number">1</span>,R = m;      <span class="hljs-comment">//经典的二分写法</span><br>    <span class="hljs-keyword">while</span> (L&lt;R) &#123;     <span class="hljs-comment">//对m进行二分，找到临界值。总共只循环了log(m)次</span><br>        <span class="hljs-type">int</span> mid = (L+R)&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) R = mid;<br>        <span class="hljs-keyword">else</span> L = mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, R);  <span class="hljs-comment">//打印临界值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">雪宝和七七的爸爸</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/03/20/%E5%B7%AE%E5%88%86%20%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86/">http://example.com/2024/03/20/%E5%B7%AE%E5%88%86%20%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">宝爸编程</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BF%A1%E6%81%AF%E5%AD%A6/">信息学</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/02/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/" title="记忆化搜索"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">记忆化搜索</div></div></a></div><div class="next-post pull-right"><a href="/2024/03/06/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/" title="二分查找和二分答案"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">二分查找和二分答案</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/03/02/GESP%E5%85%AB%E7%BA%A7%EF%BC%88202312-202412%EF%BC%89%E6%9C%AA%E5%AE%8C/" title="GESP八级（202312-202412）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-02</div><div class="title">GESP八级（202312-202412）</div></div></a></div><div><a href="/2024/04/25/LCS%E9%97%AE%E9%A2%98/" title="最长公共子序列（LCS）问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-25</div><div class="title">最长公共子序列（LCS）问题</div></div></a></div><div><a href="/2024/07/31/dp%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E8%AE%AD%E7%BB%83/" title="dp中的状态转移训练"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-31</div><div class="title">dp中的状态转移训练</div></div></a></div><div><a href="/2024/04/25/LIS%E9%97%AE%E9%A2%98/" title="最长不下降子序列（LIS）问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-25</div><div class="title">最长不下降子序列（LIS）问题</div></div></a></div><div><a href="/2020/03/13/hello/" title="我的第一篇博客"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-13</div><div class="title">我的第一篇博客</div></div></a></div><div><a href="/2025/03/20/int8_t-bitset-%E5%8E%9F%E5%8F%8D%E8%A1%A5%E7%A0%81%E5%92%8C%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/" title="int8_t-bitset-原反补码和移位操作详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-20</div><div class="title">int8_t-bitset-原反补码和移位操作详解</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">雪宝和七七的爸爸</div><div class="author-info__description">本博客致力于信息学奥赛知识学习。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">26</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://cspcoding.github.io/"><i class="fab fa-github"></i><span>回到主页</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">玩游戏害人害己哦！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E7%90%86%E8%AE%BA%E6%95%99%E5%AD%A6"><span class="toc-text">一、理论教学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E9%A2%91%E6%95%99%E5%AD%A6%E9%93%BE%E6%8E%A5"><span class="toc-text">1.1 视频教学链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">1.2 相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-text">1.2.1 基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C%E7%9A%84%E5%85%B3%E7%B3%BB%E5%8F%8A%E4%BA%92%E6%8D%A2"><span class="toc-text">1.2.2 差分和前缀和的关系及互换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86"><span class="toc-text">1.3 一维差分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%81%87%E8%AE%BE"><span class="toc-text">1.3.1 问题假设</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%92%8C%E8%A7%A3%E6%B3%95"><span class="toc-text">1.3.2 相关操作和解法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8Fm%E6%AC%A1%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C"><span class="toc-text">1.3.2.1
“批量（m次）区间修改”操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C"><span class="toc-text">1.3.2.2 “单点查询&quot;操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">1.3.3 局限性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86"><span class="toc-text">1.4 二维差分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%81%87%E8%AE%BE-1"><span class="toc-text">1.4.1 问题假设</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E6%95%B0%E7%BB%84a%E5%92%8C%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86d%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%92%E6%8D%A2"><span class="toc-text">1.4.2
原始数组a[][]和二维差分D[][]之间的互换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%AE%E5%88%86drightarrow%E5%8E%9F%E5%A7%8B%E6%95%B0%E7%BB%84a"><span class="toc-text">1.4.2.1 差分D[][]\(\Rightarrow\)原始数组a[][]</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E6%8C%89%E7%BB%B4%E5%81%9A%E5%89%8D%E7%BC%80%E5%92%8C%E6%93%8D%E4%BD%9C-%E6%9B%B4%E4%BC%98"><span class="toc-text">（一）按维做“前缀和”操作（ 更优 ）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E9%80%92%E6%8E%A8%E5%81%9A%E6%B3%95"><span class="toc-text">(二)递推做法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E6%95%B0%E7%BB%84arightarrow%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84d"><span class="toc-text">1.4.2.2 原始数组a[][]\(\Rightarrow\)差分数组D[][]</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%92%8C%E8%A7%A3%E6%B3%95-1"><span class="toc-text">1.4.3 相关操作和解法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8Fm%E6%AC%A1%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C-1"><span class="toc-text">1.4.3.1
“批量（m次）区间修改”操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C-1"><span class="toc-text">1.4.3.2 “单点查询”操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%BB%B4%E5%B7%AE%E5%88%86"><span class="toc-text">1.5 三维差分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%81%87%E8%AE%BE-2"><span class="toc-text">1.5.1 问题假设</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E6%95%B0%E7%BB%84a%E5%92%8C%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84d%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E5%85%B3%E7%B3%BB"><span class="toc-text">1.5.2
原始数组a[][][]和差分数组D[][][]之间的相互关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%92%8C%E8%A7%A3%E6%B3%95-2"><span class="toc-text">1.5.3 相关操作和解法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8Fm%E6%AC%A1%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C-2"><span class="toc-text">1.5.3.1
“批量（m次）区间修改”操作</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%AE%9E%E6%88%98%E8%AE%AD%E7%BB%83"><span class="toc-text">二、实战训练</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#hdu-1556%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86%E6%A8%A1%E6%9D%BF%E9%A2%98"><span class="toc-text">2.1 HDU 1556（一维差分模板题）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#p2367-%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86%E6%A8%A1%E6%9D%BF%E9%A2%98"><span class="toc-text">2.2 P2367 （一维差分模板题）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#p4552%E5%A4%9A%E5%B0%91%E6%AC%A1%E5%A4%9A%E5%B0%91%E7%A7%8D"><span class="toc-text">2.3 P4552（多少次，多少种）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#p9011%E6%B7%B1%E6%90%9C%E4%B8%BA%E4%B8%BB%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86%E5%8F%AF%E6%9C%89"><span class="toc-text">2.4
P9011（深搜为主，一维差分可有）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86%E9%A2%98%E8%AE%AD%E7%BB%83"><span class="toc-text">2.5 其他简单的一维差分题训练</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#p3397%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86%E6%A8%A1%E6%9D%BF%E9%A2%98"><span class="toc-text">2.6 P3397（二维差分模板题）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E4%BD%93%E6%94%BB%E5%87%BB%E4%B8%89%E7%BB%B4%E5%B7%AE%E5%88%86%E6%A8%A1%E6%9D%BF%E9%A2%98"><span class="toc-text">2.7 三体攻击（三维差分模板题）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/24/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%E5%92%8C%E4%BA%94%E5%A4%A7%E5%9F%BA%E7%A1%80%E9%83%A8%E4%BB%B6/" title="冯诺依曼结构和五大基础部件">冯诺依曼结构和五大基础部件</a><time datetime="2025-03-23T16:00:00.000Z" title="发表于 2025-03-24 00:00:00">2025-03-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/20/int8_t-bitset-%E5%8E%9F%E5%8F%8D%E8%A1%A5%E7%A0%81%E5%92%8C%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/" title="int8_t-bitset-原反补码和移位操作详解">int8_t-bitset-原反补码和移位操作详解</a><time datetime="2025-03-20T13:12:21.000Z" title="发表于 2025-03-20 21:12:21">2025-03-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/GESP%E5%85%AB%E7%BA%A7%EF%BC%88202312-202412%EF%BC%89%E6%9C%AA%E5%AE%8C/" title="GESP八级（202312-202412）">GESP八级（202312-202412）</a><time datetime="2025-03-01T16:00:00.000Z" title="发表于 2025-03-02 00:00:00">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/%E7%9B%92%E5%AD%90%E6%94%BE%E7%90%83%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0%E9%97%AE%E9%A2%98%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/" title="盒子放球的方案数问题">盒子放球的方案数问题</a><time datetime="2025-03-01T16:00:00.000Z" title="发表于 2025-03-02 00:00:00">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/27/%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9B%BA%E5%AE%9A%E5%AE%BD%E5%BA%A6%E4%B8%BAm%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/" title="（二）固定宽度为m的区间的“最大的和值”问题">（二）固定宽度为m的区间的“最大的和值”问题</a><time datetime="2025-02-27T06:21:42.811Z" title="发表于 2025-02-27 14:21:42">2025-02-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 雪宝和七七的爸爸</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script src="/js/custom.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>