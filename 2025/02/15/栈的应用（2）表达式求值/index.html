<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>栈的应用（2）表达式求值 | 宝爸编程</title><meta name="author" content="雪宝和七七的爸爸"><meta name="copyright" content="雪宝和七七的爸爸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、理论介绍　　表达式求值要解决的问题一般是输入一个字符串表示的表达式，要求输出它的值。当然也有变种比如表达式中是否包含括号，指数运算，含多少变量，判断多个表达式是否等价等等。一棵具有一般性的表达式树如下图所示：  　　对这棵表达式树按照树的前序、中序和后序遍历，可以分别得到三种对应的算术表达式，即前缀表达式、中缀表达式和后缀表达式。中缀表达式是日常生活中最常用的表达式；后缀表达式是计算机容易理解">
<meta property="og:type" content="article">
<meta property="og:title" content="栈的应用（2）表达式求值">
<meta property="og:url" content="http://example.com/2025/02/15/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%882%EF%BC%89%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/index.html">
<meta property="og:site_name" content="宝爸编程">
<meta property="og:description" content="一、理论介绍　　表达式求值要解决的问题一般是输入一个字符串表示的表达式，要求输出它的值。当然也有变种比如表达式中是否包含括号，指数运算，含多少变量，判断多个表达式是否等价等等。一棵具有一般性的表达式树如下图所示：  　　对这棵表达式树按照树的前序、中序和后序遍历，可以分别得到三种对应的算术表达式，即前缀表达式、中缀表达式和后缀表达式。中缀表达式是日常生活中最常用的表达式；后缀表达式是计算机容易理解">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2025-02-14T16:00:00.000Z">
<meta property="article:modified_time" content="2025-02-27T08:35:24.215Z">
<meta property="article:author" content="雪宝和七七的爸爸">
<meta property="article:tag" content="信息学">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/02/15/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%882%EF%BC%89%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":5,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '栈的应用（2）表达式求值',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2025-02-27 16:35:24'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/static/css/custom.css"><link rel="stylesheet" href="/fonts/font.css"><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="宝爸编程"><span class="site-name">宝爸编程</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">栈的应用（2）表达式求值</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-14T16:00:00.000Z" title="发表于 2025-02-15 00:00:00">2025-02-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-27T08:35:24.215Z" title="更新于 2025-02-27 16:35:24">2025-02-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/STL/">STL</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/STL/%E6%A0%88/">栈</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/STL/%E6%A0%88/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8/">栈的应用</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="栈的应用（2）表达式求值"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、理论介绍"><a href="#一、理论介绍" class="headerlink" title="一、理论介绍"></a>一、理论介绍</h1><p>　　表达式求值要解决的问题一般是输入一个字符串表示的表达式，要求输出它的值。当然也有变种比如表达式中是否包含括号，指数运算，含多少变量，判断多个表达式是否等价等等。一棵具有一般性的表达式树如下图所示：</p>
<p><img src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%882%EF%BC%89%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC1.png" alt="img" style="zoom:67%;" /></p>
<p>　　对这棵表达式树按照<a href=""><font color="red">树的前序、中序和后序遍历</font></a>，可以分别得到三种对应的算术表达式，即前缀表达式、中缀表达式和后缀表达式。中缀表达式是日常生活中最常用的表达式；<strong>后缀表达式是计算机容易理解的表达式</strong>。</p>
<p>　　１）前序遍历——前缀表达式（即波兰式）：<strong>－＋ａ＊ｂ－ｃｄ／ｅｆ</strong></p>
<p>　　２）中序遍历——中缀表达式：<strong>ａ＋ｂ＊（ｃ－ｄ）－ｅ／ｆ</strong></p>
<p>　　３）后序遍历——后缀表达式（即逆波兰式）：<strong>ａｂｃｄ－＊＋ｅｆ／－</strong></p>
<p>　　如果给定的中缀表达式被明确告知不含括号，那所有运算符的优先级比较简单，先乘除后加减，这种在求值时比较好做；如果可能含有括号，因为括号内的算式要先计算，所以会使得表达式的运算更为复杂一些。关于波兰式和逆波兰式的更详细的说明，可以看下面这张图。</p>
<p><img src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%882%EF%BC%89%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC2.png" alt="image-20250119100516336" style="zoom: 67%;" /></p>
<p>　　波兰式和逆波兰式都不需要小括号，其运算顺序和结果是唯一且无歧义的，运算相对简单点。其中，又因为后缀表达式在算法中操作起来最为方便，所以凡是遇到中缀未曾要求具体转成什么式的，都建议最好是转成后缀表达式来计算结果。</p>
<p>　　常见的一些题如下：</p>
<p>　　１）前缀表达式求值（即波兰式求值）（不需要栈）——1198</p>
<p>　　２）后缀表达式求值（即逆波兰式求值）（需OPND）——P1449／1331</p>
<p>　　３）无括号的中缀表达式求值（需OPND）——P1981／1962</p>
<p>　　４）带括号的中缀表达式求值（需OPND和OPTR）——1356、P10473、1358</p>
<p>　　５）带完整括号的中缀转后缀（需OPTR）——SP4</p>
<p>　　６）带括号的中缀转后缀（需OPTR），计算后缀值——P1175</p>
<h1 id="二、实战训练"><a href="#二、实战训练" class="headerlink" title="二、实战训练"></a>二、实战训练</h1><h2 id="2-1-前缀表达式求值-1198"><a href="#2-1-前缀表达式求值-1198" class="headerlink" title="2.1 前缀表达式求值　1198"></a>2.1 前缀表达式求值　1198</h2><h3 id="2-1-1-原题链接"><a href="#2-1-1-原题链接" class="headerlink" title="2.1.1 原题链接"></a>2.1.1 原题链接</h3><p>　　<a target="_blank" rel="noopener" href="https://ybt.ssoier.cn/problem_show.php?pid=1198">1198 ：逆波兰表达式</a>（该题面有误！）</p>
<h3 id="2-1-2-分析"><a href="#2-1-2-分析" class="headerlink" title="2.1.2 分析"></a>2.1.2 分析</h3><p>　　<strong>这个题的题面有误，这是波兰式，不是逆波兰式，应该把题面上所有的“逆波兰式”字样改成“波兰式”来理解！</strong>这个题在录入数据时，<strong>已经通过空格键把每个录入要素做了人为地隔断</strong>。因为录入的是前缀表达式，即操作符在前，操作数（也可能是另一个前缀表达式）在后。对于这样的输入，若对整个表达式做一次性的整体接收再去逐个字符拆解，会比较复杂。其实有一个比较简单的做法，就是利用递归函数的特点来，把数据录入也写到递归函数里。多说麻烦，直接上代码：</p>
<h3 id="2-1-3-AC代码"><a href="#2-1-3-AC代码" class="headerlink" title="2.1.3 AC代码"></a>2.1.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span>  <span class="hljs-comment">//针对atof函数，要加这个头文件 </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">// 函数不需要参数形式的输入，但需要返回double</span><br>	<span class="hljs-type">char</span> a[<span class="hljs-number">55</span>];     <span class="hljs-comment">// 此处需要定义成局部变量！每次调用都有专属于这次调用的a[]，不能定义成全局哈！ </span><br>	<span class="hljs-comment">// 每次调用calculate函数，都会去从输入的字符串中获得信息（以空格或回车结束）</span><br>	<span class="hljs-comment">// 递归函数每次调用的时候都需要接收界面上的输入，这种设计模式不太好，但很适用于本题的解决</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,a);  <span class="hljs-comment">// 不同的calculate函数，获得的输入信息是不同的</span><br>    <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;+&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">calculate</span>()+<span class="hljs-built_in">calculate</span>();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;-&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">calculate</span>()-<span class="hljs-built_in">calculate</span>();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;*&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">calculate</span>()*<span class="hljs-built_in">calculate</span>();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;/&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">calculate</span>()/<span class="hljs-built_in">calculate</span>();<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">atof</span>(a); <span class="hljs-comment">// 如果不是这4种操作符，则必是数字。直接调用字符串转浮点数的函数，得到double类型的数字</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,<span class="hljs-built_in">calculate</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* + 2 3 4</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h2 id="2-2-后缀表达式求值-1331／P1449"><a href="#2-2-后缀表达式求值-1331／P1449" class="headerlink" title="2.2 后缀表达式求值　1331／P1449"></a>2.2 后缀表达式求值　1331／P1449</h2><h3 id="2-2-1-原题链接"><a href="#2-2-1-原题链接" class="headerlink" title="2.2.1 原题链接"></a>2.2.1 原题链接</h3><p>　　<a target="_blank" rel="noopener" href="https://ybt.ssoier.cn/problem_show.php?pid=1331">1331：【例1-2】后缀表达式的值</a>／<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1449">P1449 后缀表达式</a></p>
<h3 id="2-2-2-分析"><a href="#2-2-2-分析" class="headerlink" title="2.2.2 分析"></a>2.2.2 分析</h3><p>　　这两个题高度相似，所以就合在一起讲了。细看题目的输入，可以发现每个操作数都是整数，且都有专门的字符来间隔，或是空格，或是’.’，但每个操作符之间并无间隔。<strong>因为操作符之间并无间隔</strong>，所以肯定不能再用<code>scanf(&quot;%s&quot;, str);</code>的方式去录入每个对象（不管是操作数或操作符）了，<strong>否则可能一下子录入很多操作符</strong>，从而引起混乱。所以只能采用更为原始的做法，就是“<strong>逐个字符地录入，再细分情况处理</strong>”。</p>
<p>　　在逐个字符录入时，如何处理遇到的整数呢？可以参照“<strong>快读</strong>”的写法来做。题上所有操作数都是整数，故适用。</p>
<p>　　对于逆波兰式求解的算法过程，需要借助一个<strong>操作数栈OPND（”操作数”的英文标识，”operand”，建议记住）</strong>来帮忙搞定。其过程如下：</p>
<p>　　１）如果<code>s[i]</code>是数字，则进行组装；</p>
<p>　　２）如果<code>s[i]</code>是空格或者’.’，说明左侧的操作数已经组装完毕，此时应该把该操作数入栈OPND，并及时对变量清零，以备后续再来组装新操作数；</p>
<p>　　３）如果<code>s[i]</code>是运算符号，则需要对OPND栈内的最后两个操作数依次出栈，并根据当前运算符号的类型分别进行运算，并将运算结果重新入栈OPND。</p>
<h3 id="2-2-3-AC代码"><a href="#2-2-3-AC代码" class="headerlink" title="2.2.3 AC代码"></a>2.2.3 AC代码</h3><h4 id="2-2-3-1-1331的AC代码"><a href="#2-2-3-1-1331的AC代码" class="headerlink" title="2.2.3.1 1331的AC代码"></a>2.2.3.1 1331的AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	因为stack没有“退栈送给xx”这种操作，所以遇到这样的情况，只能分成两步走：</span><br><span class="hljs-comment">	1. 读取栈顶元素到xx， xx = OPND.top();</span><br><span class="hljs-comment">	2. 弹出栈顶元素		  OPND.pop();</span><br><span class="hljs-comment">	本案例下面的代码都是这样写的，所以代码书写略显臃肿了一点 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 本案例中最重要的数据结构就是这个。如果自己写，会非常不便。 </span><br>stack&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; OPND;   <span class="hljs-comment">// 一个专门存放操作数及运算结果值的栈   </span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> x;            <span class="hljs-comment">// x 暂时存放操作数 ， 压栈后即完成使命 </span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans;          <span class="hljs-comment">// ans 暂时存放四则运算时的临时结果，压栈后即完成使命 </span><br><span class="hljs-type">char</span> s[<span class="hljs-number">251</span>];            <span class="hljs-comment">// 存放原始的后缀表达式序列  </span><br><span class="hljs-type">int</span> len;                <span class="hljs-comment">// 序列的长度 </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    x = ans = <span class="hljs-number">0</span>;<br>    cin.<span class="hljs-built_in">getline</span>(s, <span class="hljs-built_in">sizeof</span>(s));<br>    len = <span class="hljs-built_in">strlen</span>( s );<br>    <span class="hljs-comment">// 从左往右，一边组装操作数、运算、压栈，一边往右走</span><br>    <span class="hljs-comment">// 后缀表达式运算起来最简单，不需要考虑运算符号的优先级， &quot;遇到操作符，就出栈2个操作数来进行运算再压栈&quot;  ！ </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  i &lt; len;  i++)&#123;<br>        <span class="hljs-keyword">if</span> ( s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span> ) <br>			x = x * <span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;0&#x27;</span> ;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( s[i] == <span class="hljs-string">&#x27; &#x27;</span> )&#123;			<br>            OPND.<span class="hljs-built_in">push</span>( x ); <span class="hljs-comment">//把上一个操作数x进栈       </span><br>            x = <span class="hljs-number">0</span>;         <span class="hljs-comment">// 然后把x清零，以备接收下一个操作数 </span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( s[i] == <span class="hljs-string">&#x27;+&#x27;</span> )&#123;<br>			<span class="hljs-comment">// 出栈2次，相加后的结果ans入栈 </span><br>            ans = OPND.<span class="hljs-built_in">top</span>();<br>            OPND.<span class="hljs-built_in">pop</span>();<br>            ans += OPND.<span class="hljs-built_in">top</span>();<br>            OPND.<span class="hljs-built_in">pop</span>();<br>            OPND.<span class="hljs-built_in">push</span>( ans );<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( s[i] == <span class="hljs-string">&#x27;-&#x27;</span> )&#123;<br>			<span class="hljs-comment">// 出栈2次，相减后的结果ans入栈 </span><br>            ans = OPND.<span class="hljs-built_in">top</span>();<br>            OPND.<span class="hljs-built_in">pop</span>();<br>            ans = OPND.<span class="hljs-built_in">top</span>() - ans;<br>            OPND.<span class="hljs-built_in">pop</span>();<br>            OPND.<span class="hljs-built_in">push</span>( ans );<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( s[i] == <span class="hljs-string">&#x27;*&#x27;</span> )&#123;<br>			<span class="hljs-comment">// 出栈2次，相乘后的结果ans入栈 </span><br>            ans = OPND.<span class="hljs-built_in">top</span>();<br>            OPND.<span class="hljs-built_in">pop</span>();<br>            ans *= OPND.<span class="hljs-built_in">top</span>();<br>            OPND.<span class="hljs-built_in">pop</span>();<br>            OPND.<span class="hljs-built_in">push</span>( ans );<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( s[i] == <span class="hljs-string">&#x27;/&#x27;</span> )&#123;<br>			<span class="hljs-comment">// 出栈2次，相除后的结果ans入栈 </span><br>            ans = OPND.<span class="hljs-built_in">top</span>();<br>            OPND.<span class="hljs-built_in">pop</span>();<br>            ans = OPND.<span class="hljs-built_in">top</span>() / ans;<br>            OPND.<span class="hljs-built_in">pop</span>();<br>            OPND.<span class="hljs-built_in">push</span>( ans );<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-2-3-2-P1449的AC代码"><a href="#2-2-3-2-P1449的AC代码" class="headerlink" title="2.2.3.2 P1449的AC代码"></a>2.2.3.2 P1449的AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>stack&lt;<span class="hljs-type">int</span>&gt; sta;<br><span class="hljs-type">char</span> ch;<br><span class="hljs-type">int</span> num, x, y;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">while</span>( ch=<span class="hljs-built_in">getchar</span>(), ch!=<span class="hljs-string">&#x27;@&#x27;</span> ) &#123;<br>		<span class="hljs-keyword">switch</span>(ch) &#123;<br>			<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>				x=sta.<span class="hljs-built_in">top</span>();<br>				sta.<span class="hljs-built_in">pop</span>();<br>				y=sta.<span class="hljs-built_in">top</span>();<br>				sta.<span class="hljs-built_in">pop</span>();<br>				sta.<span class="hljs-built_in">push</span>(x+y);<br>				<span class="hljs-keyword">break</span>;<br>			<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>				x=sta.<span class="hljs-built_in">top</span>();   	<span class="hljs-comment">// 右边的操作数后进栈，所以先出 </span><br>				sta.<span class="hljs-built_in">pop</span>();<br>				y=sta.<span class="hljs-built_in">top</span>();	<span class="hljs-comment">// 左边的操作数先进栈，所以后出 </span><br>				sta.<span class="hljs-built_in">pop</span>();<br>				sta.<span class="hljs-built_in">push</span>(y-x);  <span class="hljs-comment">// 左 - 右 </span><br>				<span class="hljs-keyword">break</span>;<br>			<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>				x=sta.<span class="hljs-built_in">top</span>();<br>				sta.<span class="hljs-built_in">pop</span>();<br>				y=sta.<span class="hljs-built_in">top</span>();<br>				sta.<span class="hljs-built_in">pop</span>();<br>				sta.<span class="hljs-built_in">push</span>(x*y);<br>				<span class="hljs-keyword">break</span>;<br>			<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>				x=sta.<span class="hljs-built_in">top</span>();     <span class="hljs-comment">// 右边的操作数</span><br>				sta.<span class="hljs-built_in">pop</span>();<br>				y=sta.<span class="hljs-built_in">top</span>();     <span class="hljs-comment">// 左边的操作数 </span><br>				sta.<span class="hljs-built_in">pop</span>();<br>				sta.<span class="hljs-built_in">push</span>(y/x);   <span class="hljs-comment">// 左 / 右</span><br>				<span class="hljs-keyword">break</span>;<br>			<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;.&#x27;</span>:<br>				sta.<span class="hljs-built_in">push</span>(num);<br>				num = <span class="hljs-number">0</span>;<br>				<span class="hljs-keyword">break</span>;<br>			<span class="hljs-keyword">default</span> :<br>				num = num * <span class="hljs-number">10</span> + ch - <span class="hljs-string">&#x27;0&#x27;</span>;<br>				<span class="hljs-keyword">break</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;%d\n&quot;</span>, sta.<span class="hljs-built_in">top</span>() );<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-3-无括号的中缀表达式求值-P1981／1962"><a href="#2-3-无括号的中缀表达式求值-P1981／1962" class="headerlink" title="2.3 无括号的中缀表达式求值 P1981／1962"></a>2.3 无括号的中缀表达式求值 P1981／1962</h2><h3 id="2-3-1-原题链接"><a href="#2-3-1-原题链接" class="headerlink" title="2.3.1 原题链接"></a>2.3.1 原题链接</h3><p>　　<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1981">P1981 [NOIP2013 普及组] 表达式求值</a>／<a target="_blank" rel="noopener" href="https://ybt.ssoier.cn/problem_show.php?pid=1962">1962：【13NOIP普及组】表达式求值</a></p>
<h3 id="2-3-2-分析"><a href="#2-3-2-分析" class="headerlink" title="2.3.2 分析"></a>2.3.2 分析</h3><p>　　这两个题，是同一个题。题目给定的是一个算术表达式的字符串（不含分隔符号）。普通办法是完整接收整个串，然后逐个分拆，就像2.2节中的方法一样。这是可以的。不过因为本题的算术表达式的格式非常的工整，全是“数符数符数符……数符数”这种格式，不含任何其他闲杂字符。所以我们可以先录入第一个数，再每次同时录入一个符，一个数，从而实现字符串的分割。</p>
<p>　　解决了“字符串分割”的问题之后，再来看如何求解。表达式只有’+’和’*’这两种算术运算符号，且表达式中没有括号。这意味着表达式内的运算优先级只有两个等级，且乘法高于加法。所以当我们遇到有乘法时，可以把最近的两个数做乘法运算，把积保存下来，以便于后续的运算。既然需要存“最近”的数，所以需要用到OPND操作数栈。等读取完整个表达式后，OPND中存的是各个加数或积，依次直接累加即得本题最终结果。</p>
<p>　　关于题目中提到的“只存末四位”的问题，因为加法和乘法操作对于“取模运算”都满足分配律，所以只需要在每次加法和乘法运算后及时对１００００取模，其结果是符合题意的。</p>
<h3 id="2-3-3-AC代码"><a href="#2-3-3-AC代码" class="headerlink" title="2.3.3 AC代码"></a>2.3.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// OPND: 一个存数字并在最后把它们相加的栈;</span><br><span class="hljs-comment">// 如果遇到乘法，先弹出来相乘之后再把积入栈</span><br>stack &lt;<span class="hljs-type">int</span>&gt; OPND; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> d1,d2;<br>	<span class="hljs-type">char</span> op;<br>	cin&gt;&gt;d1;<span class="hljs-comment">//先输入一个数，以后符号+数字输入</span><br>	<span class="hljs-type">int</span> m=<span class="hljs-number">10000</span>;<br>	d1=d1 % m;<span class="hljs-comment">//必须的操作</span><br>	OPND.<span class="hljs-built_in">push</span>(d1);<span class="hljs-comment">//压入栈中</span><br>	<span class="hljs-keyword">while</span>(cin &gt;&gt;op &gt;&gt;d2)&#123;<br>		<span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;*&#x27;</span>)&#123;<span class="hljs-comment">//将*之前的数字与*之后的数字积存入</span><br>			d1=OPND.<span class="hljs-built_in">top</span>();<br>			OPND.<span class="hljs-built_in">pop</span>();<br>			OPND.<span class="hljs-built_in">push</span>(d1*d2%m);<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-comment">//将d2存入</span><br>			OPND.<span class="hljs-built_in">push</span>(d2);<br>	&#125;<br>	<span class="hljs-comment">// 累加目前栈内所有加数，即得答案，没必要再做入栈操作了 </span><br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(OPND.<span class="hljs-built_in">size</span>())&#123;<br>		ans = (ans + OPND.<span class="hljs-built_in">top</span>()) % m;<br>		OPND.<span class="hljs-built_in">pop</span>();<br>	&#125;<br>	cout&lt;&lt;ans&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-4-带括号的中缀表达式求值"><a href="#2-4-带括号的中缀表达式求值" class="headerlink" title="2.4 带括号的中缀表达式求值"></a>2.4 带括号的中缀表达式求值</h2><h3 id="2-4-1-1356-计算-calc"><a href="#2-4-1-1356-计算-calc" class="headerlink" title="2.4.1 1356 计算(calc)"></a>2.4.1 1356 计算(calc)</h3><h4 id="2-4-1-1-原题链接"><a href="#2-4-1-1-原题链接" class="headerlink" title="2.4.1.1 原题链接"></a>2.4.1.1 原题链接</h4><p>　　<a target="_blank" rel="noopener" href="https://ybt.ssoier.cn/problem_show.php?pid=1356">1356：计算(calc)</a></p>
<h4 id="2-4-1-2-分析"><a href="#2-4-1-2-分析" class="headerlink" title="2.4.1.2 分析"></a>2.4.1.2 分析</h4><p>　　这个题的字符串是正确的带括号的中缀表达式串，且可能包含乘方运算，要求表达式结果值。要对中缀表达式求值，可以有两种做法。<strong>一种是借助OPND（”operand”的缩写，只存操作数）和OPTR（”operator”的缩写，只存操作符和左括号）这两个栈来直接求解，也就是直接“硬干”</strong>；另一种是先把该串转换成后缀表达式串，然后再针对后缀表达式串去求值。本节讲解第一种做法。后面的小节再来展示如何转换。</p>
<p>　　当我们从左往右去分析中缀表达式串时，通常会存在以下几种情况（同学们自己分析时，应该拿出草稿纸，耐心地去枚举各种情况，总结规律，而不要就这么傻傻地看着题面，梦想着“突然头脑灵光一闪，三五行核心代码就这么凭空出现”）。我之所以能列出来这些情况，背后也是经过多次草稿纸上的枚举和分析，然后总结出来结果。为了公式书写方便，下面一律把<code>^</code>换成$\oplus$来表示。</p>
<div style="width: 100%; overflow-x: auto;">
  <table style="width: 100%; border-collapse: collapse; table-layout: fixed; margin: 0;">
    <colgroup>
      <col style="width: 5%;"> <!-- 番号 -->
      <col style="width: 70%;"> <!-- 处理策略 -->
      <col style="width: 25%;"> <!-- 样例 -->
    </colgroup>
    <thead>
      <tr>
        <th style="border: 1px solid #ddd; padding: 8px; text-align: center;">番号</th>
        <th style="border: 1px solid #ddd; padding: 8px; text-align: center;">处理策略</th>
        <th style="border: 1px solid #ddd; padding: 8px; text-align: center;">样例</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">1）</td>
        <td style="border: 1px solid #ddd; padding: 8px; word-wrap: break-word; white-space: normal; word-break: break-word;">
          数字<br>从当前数字开始，往后一边找数字，一边凑整数，直到遇到非数字字符
        </td>
        <td style="border: 1px solid #ddd; padding: 8px; word-wrap: break-word; white-space: normal; word-break: break-word;">
          $3+\textcolor[RGB]{255,0,0} 213...\Longrightarrow$需得到213这个整数，而不是2
        </td>
      </tr>
      <tr>
        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">2）</td>
        <td style="border: 1px solid #ddd; padding: 8px; word-wrap: break-word; white-space: normal; word-break: break-word;">
          )<br>表示一个子表达式的结束，应当即多次（因之前一边扫描一边计算，故此时所需退栈次数不多）退栈算出结果值，直到退栈遇到'('。之后应把'('出栈OPTR
        </td>
        <td style="border: 1px solid #ddd; padding: 8px; word-wrap: break-word; white-space: normal; word-break: break-word;">
          $2*(3*5+2\textcolor[RGB]{255,0,0})...\Longrig htarrow$需计算出$15+2$的结果值**17**并存下来，且把'('出栈OPTR，使双栈内容只表示$2*17$，以备后续操作；
        </td>
      </tr>
      <tr>
        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">3）</td>
        <td style="border: 1px solid #ddd; padding: 8px; word-wrap: break-word; white-space: normal; word-break: break-word;">
          (<br>为了和)匹配，遇到后需无条件把'('压入栈OPTR
        </td>
        <td style="border: 1px solid #ddd; padding: 8px; word-wrap: break-word; white-space: normal; word-break: break-word;">
          无
        </td>
      </tr>
      <tr>
        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">4）</td>
        <td style="border: 1px solid #ddd; padding: 8px; word-wrap: break-word; white-space: normal; word-break: break-word;">
          ^<br>优先级最高，直接进栈OPTR即可。注意该运算是右结合性的，靠右优先。例如$2\oplus2\oplus3=2\oplus(2\oplus3)=2\oplus8=256$。若连续遇到该字符，应入栈OPTR，而不是出栈。这点和+-*/不同。
        </td>
        <td style="border: 1px solid #ddd; padding: 8px; word-wrap: break-word; white-space: normal; word-break: break-word;">
          $3*2\textcolor[RGB]{255 ,0,0}\oplus...$，应先算乘方，所以此时只需把\^进栈OPTR
        </td>
      </tr>
      <tr>
        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">5）</td>
        <td style="border: 1px solid #ddd; padding: 8px; word-wrap: break-word; white-space: normal; word-break: break-word;">
          */<br>优先级介于乘方和加减之间。此时应看乘除号左侧的运算符号是什么，比较二者的优先级。①若乘除的优先级更高，则只需把乘除号入栈OPTR即可；②若乘除优先级更低（意味着左侧是乘方号）或③相等（左侧也是*/），则应先算左侧，结果入栈OPND，再把当前算符入栈OPTR
        </td>
        <td style="border: 1px solid #ddd; padding: 8px; word-wrap: break-word; white-space: normal; word-break: break-word;">
          $$
          \begin{aligned}
          &①\quad5+6\textcolor[RGB]{255,0,0}*...\Longrightarrow 不变\\
          &②\quad2\oplus3\textcolor[RGB]{255,0,0}*...\Longrightarrow 8*...\\
          &③\quad6/3\textcolor[RGB]{255,0,0}*.....\Longrightarrow 2*...
          \end{aligned}
          $$
        </td>
      </tr>
      <tr>
        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">6）</td>
        <td style="border: 1px solid #ddd; padding: 8px; word-wrap: break-word; white-space: normal; word-break: break-word;">
          +-<br>操作符中优先级最低，应先算左侧，将左侧的结果进栈OPND，然后再把+-号入栈OPTR
        </td>
        <td style="border: 1px solid #ddd; padding: 8px; word-wrap: break-word; white-space: normal; word-break: break-word;">
          $$
          \begin{aligned}
          &①\quad5*6\textcolor[RGB]{255,0,0}+...\Longrightarrow 30+...\\
          &②\quad2\oplus3\textcolor[RGB]{255,0,0}-...\Longrightarrow 8-...\\
          &③\quad2+3\textcolor[RGB]{255,0,0}-...\Longrightarrow 5-...
          \end{aligned}
          $$
        </td>
      </tr>
      <tr>
        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">7)</td>
        <td style="border: 1px solid #ddd; padding: 8px; word-wrap: break-word; white-space: normal; word-break: break-word;">
          '\0'<br>当遇到该字符时，表达式的括号早已全被剔除，大部分计算已经完成，OPTR和OPND中内容联合起来表示的是优先级依次增高的表达式。此时只需要依次去运算出最终结果即可
        </td>
        <td style="border: 1px solid #ddd; padding: 8px; word-wrap: break-word; white-space: normal; word-break: break-word;">
          $2+3*4\oplus5\oplus6$
        </td>
      </tr>
    </tbody>
  </table>
</div>


<div class="table-container">
<table>
<thead>
<tr>
<th>番号</th>
<th>s[i]的值</th>
<th style="text-align:left">处理策略</th>
<th>样例</th>
</tr>
</thead>
<tbody>
<tr>
<td>1）</td>
<td>数字</td>
<td style="text-align:left">从当前数字开始，往后一边找数字，一边凑整数，直到遇到非数字字符</td>
<td>$3+\textcolor[RGB]{255,0,0}213…\Longrightarrow$需得到213这个整数，而不是2</td>
</tr>
<tr>
<td>2）</td>
<td>)</td>
<td style="text-align:left">表示一个子表达式的结束，应当即多次（因之前一边扫描一边计算，故此时所需退栈次数不多）退栈算出结果值，直到退栈遇到’(‘。之后应把’(‘出栈OPTR</td>
<td>$2<em>(3</em>5+2\textcolor[RGB]{255,0,0})…\Rightarrow$需计算出$15+2$的结果值<strong>17</strong>并存下来，且把’(‘出栈OPTR，使双栈内容只表示$2*17$，以备后续操作；</td>
</tr>
<tr>
<td>3）</td>
<td>(</td>
<td style="text-align:left">为了和)匹配，遇到后需无条件把’(‘压入栈OPTR</td>
<td>无</td>
</tr>
<tr>
<td>4）</td>
<td>^</td>
<td style="text-align:left">优先级最高，直接进栈OPTR即可。注意该运算是右结合性的，靠右优先。例如$2\oplus2\oplus3=2\oplus(2\oplus3)=2\oplus8=256$。若连续遇到该字符，应入栈OPTR，而不是出栈。这点和+-*/不同。</td>
<td>$3*2\textcolor[RGB]{255,0,0}\oplus…$，应先算乘方，所以此时只需把\^进栈OPTR</td>
</tr>
<tr>
<td>5）</td>
<td>*/</td>
<td style="text-align:left">优先级介于乘方和加减之间。此时应看乘除号左侧的运算符号是什么，比较二者的优先级。①若乘除的优先级更高，则只需把乘除号入栈OPTR即可；②若乘除优先级更低（意味着左侧是乘方号）或③相等（左侧也是*/），则应先算左侧，结果入栈OPND，再把当前算符入栈OPTR</td>
<td><script type="math/tex">\begin{aligned}&①\quad5+6\textcolor[RGB]{255,0,0}*...\Longrightarrow 不变\\&②\quad2\oplus3\textcolor[RGB]{255,0,0}*...\Longrightarrow 8*...\\& ③\quad6/3\textcolor[RGB]{255,0,0}*.....\Longrightarrow 2*...\end{aligned}</script></td>
</tr>
<tr>
<td>6）</td>
<td>+-</td>
<td style="text-align:left">操作符中优先级最低，应先算左侧，将左侧的结果进栈OPND，然后再把+-号入栈OPTR</td>
<td><script type="math/tex">\begin{aligned}&①\quad5*6\textcolor[RGB]{255,0,0}+...\Longrightarrow 30+...\\&②\quad2\oplus3\textcolor[RGB]{255,0,0}-...\Longrightarrow 8-...\\&③\quad2+3\textcolor[RGB]{255,0,0}-...\Longrightarrow 5-...\end{aligned}</script></td>
</tr>
<tr>
<td>7)</td>
<td>‘\0’</td>
<td style="text-align:left">当遇到该字符时，表达式的括号早已全被剔除，大部分计算已经完成，OPTR和OPND中内容联合起来表示的是优先级依次增高的表达式。此时只需要依次去运算出最终结果即可</td>
<td>$2+3*4\oplus5\oplus6$</td>
</tr>
</tbody>
</table>
</div>
<p>　　<span id="jump1">通过设置优先级</span>，可以把情况４）、５）和６）的处理策略进行整合简化。<code>^</code>优先级最高，例如３；<code>*/</code>次之，例如２，<code>+-</code>相对最低，例如１。整合后的处理流程是<font color="red">“看当前运算符和OPTR栈顶的符号做优先级比较，可能出现两种处理策略：1. 先计算左侧的内容（当左侧运算符的优先级更高或相等(‘^’例外)），2. 或是只入栈当前运算符（当左侧运算符优先级更低，例如$a\textcolor[RGB]{0,255,0}+b\textcolor[RGB]{255,200,0}<em>…$，或者$a</em>\textcolor[RGB]{0,255,0}(b\textcolor[RGB]{255,200,0}+…$，或者$a\textcolor[RGB]{0,255,0}\oplus b\textcolor[RGB]{255,200,0}\oplus…$时）”</font>。</p>
<p>　　‘(‘是除了运算符之外，唯一还会入栈OPTR的符号，可以对它不设置优先级，在程序中进行特判，以简化逻辑（若对’(‘也设置优先级而不特判，会让代码复杂，提高了理解难度）。</p>
<p>　　至于右括号，不需要入栈OPTR，遇到后即时计算子表达式并剔除左括号，所以不需要设置优先级。</p>
<p>　　至于串尾结束符，只需要对OPTR和OPND进行反复运算，直至OPTR栈空即可，此时OPND中唯一数据即为答案。</p>
<p>　　需要把<strong>获取优先级</strong>和<strong>一次二元运算</strong>专门提取出来，写成函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">LL <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">char</span> op = OPTR.<span class="hljs-built_in">top</span>();<br>	OPTR.<span class="hljs-built_in">pop</span>();<br>	LL b = OPND.<span class="hljs-built_in">top</span>();<br>	OPND.<span class="hljs-built_in">pop</span>();<br>	LL a = OPND.<span class="hljs-built_in">top</span>();<br>	OPND.<span class="hljs-built_in">pop</span>();<br>	<span class="hljs-keyword">switch</span> (op) &#123;<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>			<span class="hljs-keyword">return</span> a + b;<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>			<span class="hljs-keyword">return</span> a - b;<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>			<span class="hljs-keyword">return</span> a * b;<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>			<span class="hljs-keyword">return</span> a / b;<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;^&#x27;</span>:<br>			<span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_pow</span>(a, b);<br>		<span class="hljs-keyword">default</span>:<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//其实用不上 </span><br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getlevel</span><span class="hljs-params">(<span class="hljs-type">char</span> op)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span> || op == <span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;*&#x27;</span> || op == <span class="hljs-string">&#x27;/&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>	<span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;^&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 其实用不上，左右括号都特判处理，不会去提取其优先级 </span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-4-1-3-AC代码"><a href="#2-4-1-3-AC代码" class="headerlink" title="2.4.1.3 AC代码"></a>2.4.1.3 AC代码</h4><p>　　</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br>stack&lt;LL&gt; OPND;<br>stack&lt;<span class="hljs-type">char</span>&gt; OPTR;<br><br><span class="hljs-comment">// 快速幂计算（处理整数幂）</span><br><span class="hljs-function">LL <span class="hljs-title">quick_pow</span><span class="hljs-params">(LL a, LL b)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (b &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 题目保证指数非负</span><br>	LL res = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span> (b) &#123;<br>		<span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res *= a;<br>		a *= a;<br>		b &gt;&gt;= <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function">LL <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">char</span> op = OPTR.<span class="hljs-built_in">top</span>();<br>	OPTR.<span class="hljs-built_in">pop</span>();<br>	LL b = OPND.<span class="hljs-built_in">top</span>();<br>	OPND.<span class="hljs-built_in">pop</span>();<br>	LL a = OPND.<span class="hljs-built_in">top</span>();<br>	OPND.<span class="hljs-built_in">pop</span>();<br>	<span class="hljs-keyword">switch</span> (op) &#123;<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>			<span class="hljs-keyword">return</span> a + b;<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>			<span class="hljs-keyword">return</span> a - b;<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>			<span class="hljs-keyword">return</span> a * b;<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>			<span class="hljs-keyword">return</span> a / b;<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;^&#x27;</span>:<br>			<span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_pow</span>(a, b);<br>		<span class="hljs-keyword">default</span>:<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//其实用不上 </span><br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getlevel</span><span class="hljs-params">(<span class="hljs-type">char</span> op)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span> || op == <span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;*&#x27;</span> || op == <span class="hljs-string">&#x27;/&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>	<span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;^&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 其实用不上，左右括号都特判处理，不会去提取其优先级 </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isOperator</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span> || c == <span class="hljs-string">&#x27;*&#x27;</span> || c == <span class="hljs-string">&#x27;/&#x27;</span> || c == <span class="hljs-string">&#x27;^&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	string s;<br>	cin &gt;&gt; s;<br>	<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> f=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span> (i &lt;= s.<span class="hljs-built_in">size</span>()) &#123;   <span class="hljs-comment">// 注意有等号，串尾结束符也处理</span><br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(s[i])) &#123;<br>			LL num = <span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(s[i])) &#123;<br>				num = num * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>				i++;<br>			&#125;<br>			OPND.<span class="hljs-built_in">push</span>(num*f);<br>			f=<span class="hljs-number">1</span>;  <span class="hljs-comment">// 用完之后别忘了重置 符号位 </span><br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>			OPTR.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>			i++;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>			<span class="hljs-keyword">while</span> (OPTR.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>) OPND.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">compute</span>());<br>			OPTR.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 弹出左括号</span><br>			i++;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>			<span class="hljs-keyword">while</span> ( !OPTR.<span class="hljs-built_in">empty</span>() ) OPND.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">compute</span>());<br>			<span class="hljs-keyword">break</span>;<br>		&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// s[i]是 +  -  *  / ^</span><br>			<span class="hljs-comment">// 处理运算符优先级和结合性</span><br>			<span class="hljs-keyword">while</span> (!OPTR.<span class="hljs-built_in">empty</span>() &amp;&amp; OPTR.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123; <span class="hljs-comment">// 在OPTR非空的前提下，只要栈顶操作符不是&#x27;(&#x27;就一直做</span><br>				<span class="hljs-type">bool</span> cond1 = ( <span class="hljs-built_in">getlevel</span>(OPTR.<span class="hljs-built_in">top</span>()) &gt;  <span class="hljs-built_in">getlevel</span>(s[i]) );    <span class="hljs-comment">// 栈顶操作符 &gt; 当前操作符的优先级</span><br>				<span class="hljs-type">bool</span> cond2 = ( <span class="hljs-built_in">getlevel</span>(OPTR.<span class="hljs-built_in">top</span>()) == <span class="hljs-built_in">getlevel</span>(s[i]) &amp;&amp; s[i]!=<span class="hljs-string">&#x27;^&#x27;</span> );  <span class="hljs-comment">// 栈顶操作符 == 当前操作符的优先级 且当前操作符不是&#x27;^&#x27;这种靠右优先的操作符</span><br>				<span class="hljs-keyword">if</span> (!(cond1 || cond2)) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// cond1和cond2，只要有一个满足，就继续往下做；否则就跳出</span><br>				<span class="hljs-comment">// 执行栈顶运算</span><br>				OPND.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">compute</span>());<br>			&#125;<br>			OPTR.<span class="hljs-built_in">push</span>(s[i]);  <span class="hljs-comment">// 上面的代码只是对前面的操作数和操作符做“及时地提前运算”而已，别忘了当前操作符还是要入栈OPTR的</span><br>			i++;<br>		&#125;<br>	&#125;<br>	cout &lt;&lt; OPND.<span class="hljs-built_in">top</span>() &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">无括号的正确表达式</span><br><span class="hljs-comment">10+2^7*3/2-50</span><br><span class="hljs-comment">152</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">带括号的正确表达式</span><br><span class="hljs-comment">1+(3+2)*(7^2+6*9)/(2)</span><br><span class="hljs-comment">258</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="2-4-2-P10473-表达式计算4"><a href="#2-4-2-P10473-表达式计算4" class="headerlink" title="2.4.2 P10473 表达式计算4"></a>2.4.2 P10473 表达式计算4</h3><h4 id="2-4-2-1-原题链接"><a href="#2-4-2-1-原题链接" class="headerlink" title="2.4.2.1 原题链接"></a>2.4.2.1 原题链接</h4><p>　　<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P10473">P10473 表达式计算4</a></p>
<h4 id="2-4-2-2-分析"><a href="#2-4-2-2-分析" class="headerlink" title="2.4.2.2 分析"></a>2.4.2.2 分析</h4><p>　　该题在1356的基础上，允许负数的存在，允许“左右括号的个数不同”或“左右括号的顺序混乱”等不合法的表达式。但P10473的题面文字说得非常模糊，甚至有歧义，故而让小朋友们难以准确理解其含义。为了消除这个错误影响，本帖特意准备了如下的一些测试样例。只要能准确输出这些测试样例的结果值，就能AC这个题了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++">样例１：无括号的正确表达式 <br><span class="hljs-number">10</span>+<span class="hljs-number">2</span>^<span class="hljs-number">7</span>*<span class="hljs-number">3</span>/<span class="hljs-number">2</span><span class="hljs-number">-50</span><br><span class="hljs-number">152</span><br><br>样例２：带括号的正确表达式 <br><span class="hljs-number">1</span>+(<span class="hljs-number">3</span>+<span class="hljs-number">2</span>)*(<span class="hljs-number">7</span>^<span class="hljs-number">2</span>+<span class="hljs-number">6</span>*<span class="hljs-number">9</span>)/(<span class="hljs-number">2</span>)<br><span class="hljs-number">258</span><br><br>样例３：减号开头的正确表达式，应理解为负数 <br><span class="hljs-number">-10</span>+<span class="hljs-number">3</span><br><span class="hljs-number">-7</span><br><br>样例４：一般的负数情况，正确的表达式 <br><span class="hljs-number">3</span>*(<span class="hljs-number">-2</span>)<br><span class="hljs-number">-6</span><br><br>样例５：多余的配对括号，正确的表达式 <br>()((<span class="hljs-number">3</span>+<span class="hljs-number">2</span>))()<br>===&gt;((<span class="hljs-number">3</span>+<span class="hljs-number">2</span>))<br><span class="hljs-number">5</span><br><br>样例６：恶心的负数，没用括号括起来，正确的表达式 <br><span class="hljs-number">3</span>+<span class="hljs-number">-2</span><br><span class="hljs-number">1</span><br><br>样例７：多余的右括号，视为直接丢弃，错误的表达式 <br>(<span class="hljs-number">3</span><span class="hljs-number">-2</span>))+)<span class="hljs-number">10</span><br><span class="hljs-number">11</span><br><br>样例８：    <br>)<span class="hljs-number">2</span>+<span class="hljs-number">3</span>(<br>===&gt; <span class="hljs-number">2</span>+<span class="hljs-number">3</span>( 丢弃多余的<span class="hljs-string">&#x27;)&#x27;</span>  ===&gt; <span class="hljs-number">2</span>+<span class="hljs-number">3</span>() 对末尾多余的左括号，直接补<span class="hljs-string">&#x27;)&#x27;</span> <br><span class="hljs-number">5</span><br><br>样例９：    <br>((((<span class="hljs-number">3</span>*<span class="hljs-number">2</span>)<br>===&gt; (<span class="hljs-number">3</span>*<span class="hljs-number">2</span>) 多余的左括号，在表达式末尾直接补<span class="hljs-string">&#x27;)&#x27;</span><br><span class="hljs-number">6</span><br><br><span class="hljs-comment">// 不存在下列的情况 </span><br>))<span class="hljs-number">5</span>((<span class="hljs-number">-2</span> <br>若非要测，结果应为<span class="hljs-number">-2</span> <br><br></code></pre></td></tr></table></figure>
<p>根据对上面的各个样例的分析，可以看到，在1356题的基础上，主要增加了２个要求：</p>
<p>１.　负数如何处理？</p>
<p>２.　多余的左括号或者右括号如何应对？</p>
<p>　　对于１：根据上面的样例３、４、６可以看出，当<strong>①’-‘号是开始的第１个字符，或者②其左侧是’(‘，或者③其左侧是任何运算符</strong>时，当前这个’-‘应视为负号，而不是减号。所以设置标记，且不再当作操作符，所以不必入栈OPTR。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( str[i]==<span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp;  str[i<span class="hljs-number">-1</span>]!=<span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; !(<span class="hljs-string">&#x27;0&#x27;</span> &lt;= str[i<span class="hljs-number">-1</span>] &amp;&amp; str[i<span class="hljs-number">-1</span>] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) ) &#123;<br>	f= <span class="hljs-number">-1</span>;<br>	<span class="hljs-keyword">continue</span>;　　<span class="hljs-comment">// 不再当作减号去入OPTR了，对str[i]的处理结束了</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>　　而其后续的那１个操作数在录入后需要反号再存入OPND中。即有如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">OPND.<span class="hljs-built_in">push</span>( f * temp );<br>temp = <span class="hljs-number">0</span>;<br>f=<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
<p>　　对于２：我们可以先对串做一个预处理，如果右括号的个数超过了左括号的个数，则当前这个右括号直接删掉；如果录入完毕之后左括号的个数多于右括号的个数，则在末尾直接把缺少的右括号补全。大致代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++">string s;<br>cin &gt;&gt; s;<br><span class="hljs-comment">// 先处理多余的&#x27;(&#x27;或者&#x27;)&#x27; ， 若不处理，第1、2个测试点会RE</span><br><span class="hljs-comment">// &#x27;)&#x27;若超出，立即删除当前的&#x27;)&#x27;</span><br><span class="hljs-comment">// &#x27;(&#x27;若超出，在表达式末尾补足，直至&#x27;(&#x27;和&#x27;)&#x27;的个数相等</span><br><span class="hljs-type">int</span> lecnt=<span class="hljs-number">0</span>, ricnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>	<span class="hljs-keyword">if</span> (s[i]==<span class="hljs-string">&#x27;(&#x27;</span>) lecnt++;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i]==<span class="hljs-string">&#x27;)&#x27;</span>) ricnt++;<br><br>	<span class="hljs-keyword">if</span> (lecnt &lt; ricnt) s.<span class="hljs-built_in">erase</span>(i,<span class="hljs-number">1</span>), ricnt--, i--;<br>&#125;<br><span class="hljs-keyword">while</span> (lecnt &gt; ricnt) &#123;<br>	s.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>	ricnt++;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-4-2-3-AC代码"><a href="#2-4-2-3-AC代码" class="headerlink" title="2.4.2.3 AC代码"></a>2.4.2.3 AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br>stack&lt;LL&gt; OPND;<br>stack&lt;<span class="hljs-type">char</span>&gt; OPTR;<br><br><span class="hljs-comment">// 快速幂计算（处理整数幂）</span><br><span class="hljs-function">LL <span class="hljs-title">quick_pow</span><span class="hljs-params">(LL a, LL b)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (b &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 题目保证指数非负</span><br>	LL res = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span> (b) &#123;<br>		<span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res *= a;<br>		a *= a;<br>		b &gt;&gt;= <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function">LL <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">char</span> op = OPTR.<span class="hljs-built_in">top</span>();<br>	OPTR.<span class="hljs-built_in">pop</span>();<br>	LL b = OPND.<span class="hljs-built_in">top</span>();<br>	OPND.<span class="hljs-built_in">pop</span>();<br>	LL a = OPND.<span class="hljs-built_in">top</span>();<br>	OPND.<span class="hljs-built_in">pop</span>();<br>	<span class="hljs-keyword">switch</span> (op) &#123;<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>			<span class="hljs-keyword">return</span> a + b;<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>			<span class="hljs-keyword">return</span> a - b;<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>			<span class="hljs-keyword">return</span> a * b;<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>			<span class="hljs-keyword">return</span> a / b;<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;^&#x27;</span>:<br>			<span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_pow</span>(a, b);<br>		<span class="hljs-keyword">default</span>:<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getlevel</span><span class="hljs-params">(<span class="hljs-type">char</span> op)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span> || op == <span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;*&#x27;</span> || op == <span class="hljs-string">&#x27;/&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>	<span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;^&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 括号</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isOperator</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span> || c == <span class="hljs-string">&#x27;*&#x27;</span> || c == <span class="hljs-string">&#x27;/&#x27;</span> || c == <span class="hljs-string">&#x27;^&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	string s;<br>	cin &gt;&gt; s;<br>	<span class="hljs-comment">// 先处理多余的&#x27;(&#x27;或者&#x27;)&#x27; ， 若不处理，第1、2个测试点会RE</span><br>	<span class="hljs-comment">// &#x27;)&#x27;若超出，立即删除当前的&#x27;)&#x27;</span><br>	<span class="hljs-comment">// &#x27;(&#x27;若超出，在表达式末尾补足，直至&#x27;(&#x27;和&#x27;)&#x27;的个数相等</span><br>	<span class="hljs-type">int</span> lecnt=<span class="hljs-number">0</span>, ricnt=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>		<span class="hljs-keyword">if</span> (s[i]==<span class="hljs-string">&#x27;(&#x27;</span>) lecnt++;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i]==<span class="hljs-string">&#x27;)&#x27;</span>) ricnt++;<br><br>		<span class="hljs-keyword">if</span> (lecnt &lt; ricnt) s.<span class="hljs-built_in">erase</span>(i,<span class="hljs-number">1</span>), ricnt--, i--;<br>	&#125;<br>	<span class="hljs-keyword">while</span> (lecnt &gt; ricnt) &#123;<br>		s.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>		ricnt++;<br>	&#125;<br><span class="hljs-comment">//    cout &lt;&lt;s &lt;&lt;&#x27;\n&#x27;;</span><br>	<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> f=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span> (i &lt;= s.<span class="hljs-built_in">size</span>()) &#123;   <span class="hljs-comment">// 注意有等号，串尾结束符也处理</span><br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(s[i])) &#123;<br>			LL num = <span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(s[i])) &#123;<br>				num = num * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>				i++;<br>			&#125;<br>			OPND.<span class="hljs-built_in">push</span>(num*f);<br>			f=<span class="hljs-number">1</span>; <br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>			OPTR.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>			i++;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>			<span class="hljs-keyword">while</span> (OPTR.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>) OPND.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">compute</span>());<br>			OPTR.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 弹出左括号</span><br>			i++;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>			<span class="hljs-keyword">while</span> ( !OPTR.<span class="hljs-built_in">empty</span>() ) OPND.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">compute</span>());<br>			<span class="hljs-keyword">break</span>;<br>		&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// s[i]是 +  -  *  / ^</span><br>			<span class="hljs-comment">// &quot;if&quot;处理负号的一元情况</span><br>			<span class="hljs-comment">//              1.当前-号在串首 或 2.左侧是&#x27;(&#x27; 或 3.左侧是+-*/^这5种运算符</span><br>			<span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; (i == <span class="hljs-number">0</span> || s[i<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;(&#x27;</span> || <span class="hljs-built_in">isOperator</span>(s[i<span class="hljs-number">-1</span>]))) &#123;<br>				f= <span class="hljs-number">-1</span>;<br>				i++;<br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<br>			<span class="hljs-comment">// 处理运算符优先级和结合性</span><br>			<span class="hljs-keyword">while</span> (!OPTR.<span class="hljs-built_in">empty</span>() &amp;&amp; OPTR.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123; <span class="hljs-comment">// 在OPTR非空的前提下，只要栈顶操作符不是&#x27;(&#x27;就一直做</span><br>				<span class="hljs-type">bool</span> cond1 = ( <span class="hljs-built_in">getlevel</span>(OPTR.<span class="hljs-built_in">top</span>()) &gt;  <span class="hljs-built_in">getlevel</span>(s[i]) );    <span class="hljs-comment">// 栈顶操作符 &gt; 当前操作符的优先级</span><br>				<span class="hljs-type">bool</span> cond2 = ( <span class="hljs-built_in">getlevel</span>(OPTR.<span class="hljs-built_in">top</span>()) == <span class="hljs-built_in">getlevel</span>(s[i]) &amp;&amp; s[i]!=<span class="hljs-string">&#x27;^&#x27;</span> );  <span class="hljs-comment">// 栈顶操作符 == 当前操作符的优先级 且当前操作符不是&#x27;^&#x27;这种靠右优先的操作符</span><br>				<span class="hljs-keyword">if</span> (!(cond1 || cond2)) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// cond1和cond2，只要有一个满足，就继续往下做；否则就跳出</span><br>				<span class="hljs-comment">// 执行栈顶运算</span><br>				OPND.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">compute</span>());<br>			&#125;<br>			OPTR.<span class="hljs-built_in">push</span>(s[i]);  <span class="hljs-comment">// 上面的代码只是对前面的操作数和操作符做“及时地提前运算”而已，别忘了当前操作符还是要入栈OPTR的</span><br>			i++;<br>		&#125;<br>	&#125;<br><br>	cout &lt;&lt; OPND.<span class="hljs-built_in">top</span>() &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">无括号的正确表达式</span><br><span class="hljs-comment">10+2^7*3/2-50</span><br><span class="hljs-comment">152</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">带括号的正确表达式</span><br><span class="hljs-comment">1+(3+2)*(7^2+6*9)/(2)</span><br><span class="hljs-comment">258</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">减号开头，应理解为负数</span><br><span class="hljs-comment">-10+3</span><br><span class="hljs-comment">-7</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">一般的负数情况</span><br><span class="hljs-comment">3*(-2)</span><br><span class="hljs-comment">-6</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">多余的配对括号</span><br><span class="hljs-comment">()((3+2))()</span><br><span class="hljs-comment">===&gt;((3+2))</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">恶心的负数，没用括号括起来</span><br><span class="hljs-comment">3+-2</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">多余的右括号，视为直接丢弃</span><br><span class="hljs-comment">(3-2))+)10</span><br><span class="hljs-comment">11</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">)2+3(</span><br><span class="hljs-comment">===&gt; 2+3() 多余的左括号，在表达式末尾直接补&#x27;)&#x27;</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">((((3*2)</span><br><span class="hljs-comment">===&gt; (3*2) 多余的左括号，在表达式末尾直接补&#x27;)&#x27;</span><br><span class="hljs-comment">6</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">// 不存在下列的情况</span><br><span class="hljs-comment">))5((-2</span><br><span class="hljs-comment">若非要测，结果应为-2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="2-4-3-1358"><a href="#2-4-3-1358" class="headerlink" title="2.4.3 1358"></a>2.4.3 1358</h3><h4 id="2-4-3-1-原题链接"><a href="#2-4-3-1-原题链接" class="headerlink" title="2.4.3.1 原题链接"></a>2.4.3.1 原题链接</h4><p>　　<a target="_blank" rel="noopener" href="https://ybt.ssoier.cn/problem_show.php?pid=1358">1358：中缀表达式值(expr)</a></p>
<h4 id="2-4-3-2-分析"><a href="#2-4-3-2-分析" class="headerlink" title="　2.4.3.2 分析"></a>　2.4.3.2 分析</h4><p>　　和P10473相比，本题也支持负数作为操作数，表达式也允许带括号，允许加减乘除。区别在于本题没有乘方运算，且本题的操作符可能连续的操作符，需要输出<code>NO</code>，类似于<code>2+*5</code>或<code>2*-(3-2)</code>。但本题认为<code>2*-3</code>这种是合法的，结果为<code>6</code>。</p>
<p>　　关于负数和括号的处理，类似上题。没有乘方运算，故代码更为简单。但需提前判定一下连续操作符的问题，只需要特判一下即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>	<span class="hljs-keyword">if</span> ( (s[i]==<span class="hljs-string">&#x27;+&#x27;</span> || s[i]==<span class="hljs-string">&#x27;*&#x27;</span> ||s[i]==<span class="hljs-string">&#x27;/&#x27;</span> ) &amp;&amp; <span class="hljs-built_in">isOperator</span>(s[i<span class="hljs-number">-1</span>])) &#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt;endl;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i]==<span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; <span class="hljs-built_in">isOperator</span>(s[i<span class="hljs-number">-1</span>]) &amp;&amp; s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;(&#x27;</span>) &#123; <span class="hljs-comment">// 题目测试数据弱，没考虑2*-(3-2) 这种非法情况</span><br>		cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt;endl;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>　　别忘了先把末尾的<code>@</code>字符删掉。</p>
<h4 id="2-4-3-3-AC代码"><a href="#2-4-3-3-AC代码" class="headerlink" title="2.4.3.3 AC代码"></a>2.4.3.3 AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br>stack&lt;<span class="hljs-type">int</span>&gt; OPND;<br>stack&lt;<span class="hljs-type">char</span>&gt; OPTR;<br><span class="hljs-comment">// 计算两个数的运算结果</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">char</span> op = OPTR.<span class="hljs-built_in">top</span>();<br>	OPTR.<span class="hljs-built_in">pop</span>();<br>	<span class="hljs-type">int</span> b = OPND.<span class="hljs-built_in">top</span>();<br>	OPND.<span class="hljs-built_in">pop</span>();<br>	<span class="hljs-type">int</span> a = OPND.<span class="hljs-built_in">top</span>();<br>	OPND.<span class="hljs-built_in">pop</span>();<br>	<span class="hljs-keyword">switch</span> (op) &#123;<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>			<span class="hljs-keyword">return</span> a + b;<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>			<span class="hljs-keyword">return</span> a - b;<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>			<span class="hljs-keyword">return</span> a * b;<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>			<span class="hljs-keyword">return</span> a / b;<br>		<span class="hljs-keyword">default</span>:<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 判断字符是否是运算符</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isOperator</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span> || c == <span class="hljs-string">&#x27;*&#x27;</span> || c == <span class="hljs-string">&#x27;/&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">// 获取运算符的优先级</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getPriority</span><span class="hljs-params">(<span class="hljs-type">char</span> op)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span> || op == <span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;*&#x27;</span> || op == <span class="hljs-string">&#x27;/&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 对于括号等特殊情况处理</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	string s;<br>	cin &gt;&gt; s;<br>	s.<span class="hljs-built_in">pop_back</span>();  <span class="hljs-comment">// 去掉串尾的&#x27;@&#x27;字符 </span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>		<span class="hljs-keyword">if</span> ( (s[i]==<span class="hljs-string">&#x27;+&#x27;</span> || s[i]==<span class="hljs-string">&#x27;*&#x27;</span> ||s[i]==<span class="hljs-string">&#x27;/&#x27;</span> ) &amp;&amp; <span class="hljs-built_in">isOperator</span>(s[i<span class="hljs-number">-1</span>])) &#123;<br>			cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt;endl;<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i]==<span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; <span class="hljs-built_in">isOperator</span>(s[i<span class="hljs-number">-1</span>]) &amp;&amp; s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;(&#x27;</span>) &#123; <span class="hljs-comment">// 题目测试数据弱，没考虑2*-(3-2) 这种非法情况</span><br>			cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt;endl;<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> f=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span> (i &lt;= s.<span class="hljs-built_in">size</span>()) &#123;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(s[i])) &#123;  <span class="hljs-comment">// 1. 如果当前字符是数字</span><br>			LL num = <span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(s[i])) &#123;<br>				num = num * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>				i++;<br>			&#125;<br>			OPND.<span class="hljs-built_in">push</span>(num*f);<br>			f=<span class="hljs-number">1</span>;  <span class="hljs-comment">// 用完之后别忘了重置 符号位</span><br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123; <span class="hljs-comment">// 2. 如果当前字符是&#x27;(&#x27;</span><br>			OPTR.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;(&#x27;</span>);       <span class="hljs-comment">//     则无条件立即入栈OPTR</span><br>			i++;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123; <span class="hljs-comment">// 3. 如果当前字符是&#x27;)&#x27;</span><br>			<span class="hljs-comment">// 处理括号内的所有运算</span><br>			<span class="hljs-keyword">while</span> (OPTR.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>) OPND.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">compute</span>());<br>			OPTR.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 弹出左括号</span><br>			i++;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i]==<span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>			<span class="hljs-comment">// 处理剩余运算符</span><br>			<span class="hljs-keyword">while</span> (!OPTR.<span class="hljs-built_in">empty</span>()) OPND.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">compute</span>());<br>			<span class="hljs-keyword">break</span>;<br>		&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// s[i]是 +  -  *  /</span><br>			<span class="hljs-comment">// &quot;if&quot;处理负号的一元情况</span><br>			<span class="hljs-comment">//              1.当前-号在串首 或 2.左侧是&#x27;(&#x27; 或 3.左侧是+-*/这4种运算符</span><br>			<span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; (i == <span class="hljs-number">0</span> || s[i<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;(&#x27;</span> || <span class="hljs-built_in">isOperator</span>(s[i<span class="hljs-number">-1</span>]))) &#123;<br>				f= <span class="hljs-number">-1</span>;<br>				i++;<br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<br>			<span class="hljs-comment">// 处理当前运算符的优先级</span><br>			<span class="hljs-keyword">while</span> (!OPTR.<span class="hljs-built_in">empty</span>() &amp;&amp; OPTR.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; <span class="hljs-built_in">getPriority</span>(OPTR.<span class="hljs-built_in">top</span>()) &gt;= <span class="hljs-built_in">getPriority</span>(s[i])) &#123;<br>				OPND.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">compute</span>());<br>			&#125;<br>			OPTR.<span class="hljs-built_in">push</span>(s[i]);<br>			i++;<br>		&#125;<br>	&#125;<br>	cout &lt;&lt; OPND.<span class="hljs-built_in">top</span>() &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">-1-(-2*3+2)@</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2*-3@</span><br><span class="hljs-comment">-6</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">-2-(-2*3+2)-10@</span><br><span class="hljs-comment">-8</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">3+*2@</span><br><span class="hljs-comment">NO</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">(2+4)*-(8-5)@  // 不会出现这种样例</span><br><span class="hljs-comment">NO             // 应判定为非法</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h2 id="2-5-中缀转后缀表达式（带完整括号的中缀表达式生成后缀表达式）SP4"><a href="#2-5-中缀转后缀表达式（带完整括号的中缀表达式生成后缀表达式）SP4" class="headerlink" title="2.5  中缀转后缀表达式（带完整括号的中缀表达式生成后缀表达式）SP4"></a>2.5  中缀转后缀表达式（带完整括号的中缀表达式生成后缀表达式）SP4</h2><h3 id="2-5-1-原题链接"><a href="#2-5-1-原题链接" class="headerlink" title="2.5 1 原题链接"></a>2.5 1 原题链接</h3><p>　　<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/SP4">ONP - Transform the Expression</a></p>
<h3 id="2-5-2-分析"><a href="#2-5-2-分析" class="headerlink" title="2.5.2 分析"></a>2.5.2 分析</h3><p>　　这里说的“完整括号”，不是指表达式不缺失括号，而是指<strong>每一次二元运算都是被括号包裹起来</strong>的。也就是说，不存在$a-b<em>c+d$这种情况。即使要表达这种情况，也会写成$((a-(b</em>c))+d)$。</p>
<p>　　本题表达式中的操作符限于$+-<em>/\textasciicircum$这５种二元运算符。操作数仅限于单个的小写字母，假设不存在$a\ast b\ast c$的这种情况。洛谷上的很多题解都告知了转换的规律是什么，但没有一篇在讲这些规律是怎么得来的。这些规律肯定不会从天上掉下来。我们看看上面理论章节中的那张图，明确指出了“<em>*将中缀表达式依据优先级关系括起来，将运算符移到对应括号的后方，去掉括号，即得逆波兰表达式</em></em>”。这段文字说得不够具体，这个时候需要我们拿出草稿纸和笔，枚举几个具有代表性的样例，去细化和总结规律，而不是就这样傻看着题目期待灵光一闪，或者天降攻略。</p>
<script type="math/tex; mode=display">
\begin{align}
&(a+(b*c)^{\textcolor[RGB]{255,0,0}\swarrow}) \tag{4} \\
\Longrightarrow &(a+(bc*))^{\textcolor[RGB]{255,0,0}\swarrow} \tag{}\\
\Longrightarrow &(a(bc*)+) \tag{}\\ 
\Longrightarrow &abc*+ \tag{}\\ \tag{}\\

&(((a+b)^{\textcolor[RGB]{255,0,0}\swarrow}-c)*d) \tag{5} \\
\Longrightarrow &(((a\ \ b+)-c)^{\textcolor[RGB]{255,0,0}\swarrow}*d) \tag{}\\
\Longrightarrow &(((a\ \ b+)\ \ c-)*d)^{\textcolor[RGB]{255,0,0}\swarrow} \tag{}\\
\Longrightarrow &(((a\ \ b+)\ \ c-)\ d*) \tag{}\\
\Longrightarrow &ab+c-d* \tag{}\\\tag{}\\

&((a+b)^{\textcolor[RGB]{255,0,0}\swarrow}*(z+x)) \tag{6} \\
\Longrightarrow &((ab+)*(z+x)^{\textcolor[RGB]{255,0,0}\swarrow})  \tag{}\\
\Longrightarrow &((ab+)*(zx+))^{\textcolor[RGB]{255,0,0}\swarrow}  \tag{}\\
\Longrightarrow &((ab+)(zx+)*)  \tag{}\\
\Longrightarrow &ab+zx+*  \tag{}\\ \tag{}\\

&( (a+t)^{\textcolor[RGB]{255,0,0}\swarrow} * \textcolor[RGB]{50,255,50}(\textcolor[RGB]{255,200,0}(b+(a+c)\textcolor[RGB]{255,200,0}) \textasciicircum(c+d)\textcolor[RGB]{50,255,50}) ) \tag{7} \\
\Longrightarrow &( (at+) \ \ * \textcolor[RGB]{50,255,50}(\textcolor[RGB]{255,200,0}(b+(a+c)^{\textcolor[RGB]{255,0,0}\swarrow}\textcolor[RGB]{255,200,0}) \textasciicircum(c+d)\textcolor[RGB]{50,255,50}) ) \tag{} \\
\Longrightarrow &( (at+) \ \ * \textcolor[RGB]{50,255,50}(\textcolor[RGB]{255,200,0}(b+(a\ \ c+)\textcolor[RGB]{255,200,0})^{\textcolor[RGB]{255,0,0}\swarrow} \textasciicircum(c+d)\textcolor[RGB]{50,255,50}) ) \tag{} \\
\Longrightarrow &( (at+) \ \ * \textcolor[RGB]{50,255,50}(\textcolor[RGB]{255,200,0}(b\ \ (a\ \ c+)+\textcolor[RGB]{255,200,0}) \textasciicircum(c+d)^{\textcolor[RGB]{255,0,0}\swarrow}\textcolor[RGB]{50,255,50}) ) \tag{} \\
\Longrightarrow &( (at+) \ \ * \textcolor[RGB]{50,255,50}(\textcolor[RGB]{255,200,0}(b\ \ (a\ \ c+)+\textcolor[RGB]{255,200,0}) \textasciicircum(c\ \ d+)\textcolor[RGB]{50,255,50})^{\textcolor[RGB]{255,0,0}\swarrow} ) \tag{} \\
\Longrightarrow &( (at+) \ \ * \textcolor[RGB]{50,255,50}(\textcolor[RGB]{255,200,0}(b\ \ (a\ \ c+)+\textcolor[RGB]{255,200,0}) (c\ \ d+)\textasciicircum\textcolor[RGB]{50,255,50}) )^{\textcolor[RGB]{255,0,0}\swarrow} \tag{} \\
\Longrightarrow &( (at+) \ \ \textcolor[RGB]{50,255,50}(\textcolor[RGB]{255,200,0}(b\ \ (a\ \ c+)+\textcolor[RGB]{255,200,0}) (c\ \ d+)\textasciicircum\textcolor[RGB]{50,255,50}) *) \tag{} \\
\Longrightarrow &at+bac++cd+\textasciicircum*

\end{align}</script><p>　　因为题目录入的表达式串有点特殊，全是用括号括起来的，不存在$a+b-e+c*d$这种情况，甚至连$a+b$都会提供成$(a+b)$。每个运算都会被左右括号包起来，在这种模式下，实际上无论操作符之间的优先级是什么，已经不重要了。为什么呢？因为优先级只会在没有括号的时候才有意义。一旦全都加了括号，肯定是按照括号的嵌套关系来决定先算什么，后算什么。</p>
<p>　　每对括号内肯定都有左操作数（可以是数，也可以是表达式，都假设为$X$）、操作符（假设为$op$）和右操作数（和左操作数类似，假设为$Y$）这３个东西，不会多，也不会缺少。这就为我们简化算法提供了方便。从上面的几个例子可以看到，发生变化主要是在处理右括号的时候。我们借助一个栈OPTR来存储操作符。当遇到右括号时，此时的OPTR栈顶的那个运算符正好就是这个右括号包起来的那个二元运算表达式的操作符。只需要将其输出并出栈即可。</p>
<p>　　规律总结如下：</p>
<p>　　当从左往右扫描表达式串的每个字符<code>s[i]</code>时：</p>
<p>１）若<code>s[i]</code>是操作数，直接输出即可；</p>
<p>２）若<code>s[i]</code>是<code>(</code>，直接无视，不用做任何操作；</p>
<p>３）若<code>s[i]</code>是操作符，将其入栈OPTR；</p>
<p>４）若<code>s[i]</code>是<code>)</code>，输出栈OPTR的栈顶元素并将其出栈；</p>
<h3 id="2-5-3-AC代码"><a href="#2-5-3-AC代码" class="headerlink" title="2.5.3 AC代码"></a>2.5.3 AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">while</span>(n--)&#123;<br>		string s;<br>		stack&lt;<span class="hljs-type">char</span>&gt; sta;<br>		cin&gt;&gt;s;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>			<span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>			<span class="hljs-keyword">if</span>(s[i]&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;s[i]&lt;=<span class="hljs-string">&#x27;z&#x27;</span>)&#123;<br>				cout&lt;&lt;s[i];<br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<br>			<span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>				cout&lt;&lt;sta.<span class="hljs-built_in">top</span>();<br>				sta.<span class="hljs-built_in">pop</span>();<br>			&#125;<br>			<span class="hljs-keyword">else</span> sta.<span class="hljs-built_in">push</span>(s[i]);<br>		&#125;<br>		<span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>	&#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">(((a+b)-c)+d)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h2 id="2-6-中缀转后缀，计算后缀值——P1175"><a href="#2-6-中缀转后缀，计算后缀值——P1175" class="headerlink" title="2.6 中缀转后缀，计算后缀值——P1175"></a>2.6 中缀转后缀，计算后缀值——P1175</h2><h3 id="2-6-1-P1175"><a href="#2-6-1-P1175" class="headerlink" title="2.6.1 P1175"></a>2.6.1 P1175</h3><h4 id="2-6-1-1-原题链接"><a href="#2-6-1-1-原题链接" class="headerlink" title="2.6.1.1 原题链接"></a>2.6.1.1 原题链接</h4><p>　　<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1175">P1175 表达式的转换</a></p>
<h4 id="2-6-1-2-分析"><a href="#2-6-1-2-分析" class="headerlink" title="2.6.1.2 分析"></a>2.6.1.2 分析</h4><p>　　这是一个绿标题，有一定的难度。录入一个普通的可能带括号的正确的中缀表达式串，打印每一次二元运算时该后缀表达式串的内容变化，并输出最终的结果值。这个需求，和２.４节的需求很类似，都是带普通括号的中缀表达式串作为输入。区别在于2.4节是要求在<font color="red">得到每次运算的两个操作数和一个操作符之后</font>，立刻进行二元运算，并将结果值存入OPND栈；而本节是要求先转换成后缀表达式串，并没有要求马上运算。要做到这一点也很简单，只需要在上述的红字状态下，<font color="orange">打印输出2数1符</font>即可。但要具体去做橙色字体这部分内容，需要考虑几个细节：1）打印的时机是什么时候呢？2）是一次性打印三个数据，或是有其他时机上的规律？这个时候，光空想是肯定想不到这么细致的，需要孩子们拿出纸笔，举一个一般性的表达式例子，然后一步一步地去演变，找出其中的规律。</p>
<p>　　如果同学们已经忘了２.４节的内容，可以看<a href="#jump1"><font color="red">这里</font></a>。既然要转成后缀表达式，则在草稿纸上的演变内容，大致（不需要这么详细，但你的样例最好别太过于简单）应该如下：</p>
<p><img src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%882%EF%BC%89%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC3.png" alt=""></p>
<p>　　可以看出，操作符存在优先级的差异。可以针对所有的非数字字符，设定如下的优先级值：</p>
<p><img src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/image-20250209201559703.png" alt="image-20250209201559703" style="zoom:80%;" /></p>
<p>　　针对这个表格，可以自定义一个函数来返回优先级值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getlevel</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;+&#x27;</span> || ch==<span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;*&#x27;</span> || ch==<span class="hljs-string">&#x27;/&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">20</span>;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;^&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">30</span>;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;(&#x27;</span> || ch==<span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-10</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>　　我们可以把录入的中缀表达式串，从左往右逐个扫描，针对不同的情况做不同的处理。具体分为下面几种情况：</p>
<p>　　１.　若当前操作符是’(‘，它左侧的任何操作符优先级低于该’(‘，而’(‘右侧的任何操作符优先级又高于该’(。为了简化代码逻辑，可以通过<strong>对’(‘特判，强制将其入栈OPTR，以便于在处理’)’时找到截止位置</strong>来解决这类问题。</p>
<p>　　２.　若当前操作符是’)’；左侧必然是操作数，而且括号内的运算应优先处理，所以应把括号内当前所剩的运算处理掉，然后把’(‘从栈内扔掉。</p>
<p>　　３.　若当前是操作数，只需叠加即可。并不马上处理，因为不知道右侧是否还有数字。</p>
<p>　　４.　若当前字符是’\0’结束符，优先级最低，故需要<font color="red">对OPTR栈内优先级不低于它的操作符（即所有操作符）全都输出</font>。另外，’\0’<font color="orange">左侧肯定是操作数或者’)’。若左侧字符是’)’，则ｘ已经被处理，不应再处理它；否则应处理ｘ。故此处需区分对待</font>。</p>
<p>　　５.　若当前字符是操作符+-*/^这５种，也需要看左侧是否是’)’来区分对待（对待策略同４），然后需要比较栈顶操作符和当前操作符之间的优先级，更进一步的策略如下：</p>
<p>　　　　１）若栈顶操作符优先级 &lt; 当前操作符优先级：把当前操作符入栈；</p>
<p>　　　　２）若栈顶操作符是\’\^’ 且 当前操作符也是\’\^’：把当前操作符\’\^’入栈；（体现出\‘\^’的靠右优先的原则，即$2\textasciicircum2\textasciicircum3=2\textasciicircum(2\textasciicircum3)=2\textasciicircum8=256$，而+-*/则不是，例如$2+3+4=5+4=9$，若先算$3+4$，虽结果对，但后缀表达式未按照表达式计算的顺序来表示，是错的）</p>
<p>　　　　３）若栈顶操作符优先级 &gt;= 当前操作符优先级：情况和４类似，同样需要做红色字体，也需要做橙色字体所写的内容。所以可以考虑将４和５合并处理。</p>
<p>　　因为本题要求对转换后的后缀字符串内容进行逐步处理并打印，一个相对来说比较简单的做法就是把后缀表达式存为一个string串，然后分割成多个子串，然后去查找操作符，计算，删除子串等。这会涉及到对一个string对象的分割操作（需单独写，string类没提供这个运算，char[]也没有现成的函数）。所涉及到的函数如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">1.</span> <span class="hljs-function">istream&amp; <span class="hljs-title">istream::getline</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">int</span> bufSize)</span></span>;	<span class="hljs-comment">// 读到 \n 为止</span><br>样例： <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>];  cin.<span class="hljs-built_in">getline</span>(s, <span class="hljs-built_in">sizeof</span>(s)); <br>    备注：每次调用getline后，流指针会自动指向<span class="hljs-string">&#x27;\n&#x27;</span>后的下一个字符位置。<br><br><span class="hljs-number">2.</span> <span class="hljs-function">istream&amp; <span class="hljs-title">istream::getline</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">int</span> bufSize, <span class="hljs-type">char</span> spchar)</span></span>; <span class="hljs-comment">//读到 spchar 字符为止</span><br>			         	<span class="hljs-comment">// \n 或 spchar 都不会被读入 buf，但会被从文件输入流缓冲区中取走</span><br>样例： <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>];  cin.<span class="hljs-built_in">getline</span>(s, <span class="hljs-built_in">sizeof</span>(s), <span class="hljs-string">&#x27; &#x27;</span>); 		<span class="hljs-comment">// 读一个串，遇到空格停止读入</span><br>    备注：每次调用getline后，流指针会自动指向spchar后的下一个字符位置。 <br><br><span class="hljs-number">3.</span> <span class="hljs-function">istream&amp; <span class="hljs-title">getline</span> <span class="hljs-params">(istream&amp; is, string&amp; substr)</span></span>;	<span class="hljs-comment">// 读到\n为止</span><br>    is：输入流对象，可以是 std::cin（标准输入）、文件流对象（std::ifstream）、字符串流对象（std::istringstream）等等。<br>样例： string str; <span class="hljs-function">ifstream <span class="hljs-title">fs</span><span class="hljs-params">(<span class="hljs-string">&quot;example.txt&quot;</span>)</span></span>; <span class="hljs-function">istringstream <span class="hljs-title">ss</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello World!\nThis is a new line.&quot;</span>)</span></span>;<br>    <span class="hljs-built_in">getline</span>(cin, substr); <span class="hljs-built_in">getline</span>(fs, substr); <span class="hljs-built_in">getline</span>(ss, substr);<br>    备注：每次调用getline后，流指针会自动指向<span class="hljs-string">&#x27;\n&#x27;</span>后的下一个字符位置。<br><br><span class="hljs-number">4.</span> <span class="hljs-function">istream&amp; <span class="hljs-title">getline</span> <span class="hljs-params">(istream&amp; is, string&amp; substr, <span class="hljs-type">char</span> spchar)</span></span>;	<span class="hljs-comment">// 读到spchar为止</span><br>    is：同 <span class="hljs-number">3</span> 理解。<br>样例： string str; <span class="hljs-function">ifstream <span class="hljs-title">fs</span><span class="hljs-params">(<span class="hljs-string">&quot;example.txt&quot;</span>)</span></span>; <span class="hljs-function">istringstream <span class="hljs-title">ss</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello World!\nThis is a new line.&quot;</span>)</span></span>;<br>    <span class="hljs-built_in">getline</span>(cin, substr, <span class="hljs-string">&#x27; &#x27;</span>); <span class="hljs-built_in">getline</span>(fs, substr, <span class="hljs-string">&#x27; &#x27;</span>);   <span class="hljs-built_in">getline</span>(ss, substr, <span class="hljs-string">&#x27; &#x27;</span>);<br>    备注：每次调用getline后，流指针会自动指向spchar后的下一个字符位置。<br></code></pre></td></tr></table></figure>
<p>我们可以采用上面的第４个函数来写我们自己的split分割函数mysplit：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mysplit</span><span class="hljs-params">(string str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> spchar, vector&lt;string&gt;&amp; rst)</span> </span>&#123;<br>	<span class="hljs-function">istringstream <span class="hljs-title">mycin</span><span class="hljs-params">(str)</span></span>;	<span class="hljs-comment">// 字符串输入流</span><br>	string substr;			<span class="hljs-comment">// 接收缓冲区</span><br>	<span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(mycin, substr, spchar)) &#123;	<span class="hljs-comment">// 以spchar为分隔符.读到 spchar 字符为止，spchar字符不会被读入 buf，但会被从文件输入流缓冲区中取走</span><br>		rst.<span class="hljs-built_in">push_back</span>(substr);<br>	&#125;<br>&#125;<br>......<br>vector&lt;string&gt; strList;<br><span class="hljs-built_in">mysplit</span>(post, <span class="hljs-string">&#x27; &#x27;</span>, strList);	<span class="hljs-comment">// 将子串存放到strList中</span><br></code></pre></td></tr></table></figure>
<p>另外还需要知道string如何在尾部拼接一个int整数，或一个单字符；vector如何删除一个元素等STL操作。还有一个小细节是为了避免栈空时提取OPTR.top()失败，可先放置一个特殊符号#在里面，优先级为$-10$。</p>
<h4 id="2-6-1-3-AC代码"><a href="#2-6-1-3-AC代码" class="headerlink" title="2.6.1.3 AC代码"></a>2.6.1.3 AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1. istream&amp; istream::getline(char* buf, int bufSize);	// 读到 \n 为止</span><br><span class="hljs-comment">    样例： char s[100];  cin.getline(s, sizeof(s)); </span><br><span class="hljs-comment">    备注：每次调用getline后，流指针会自动指向&#x27;\n&#x27;后的下一个字符位置。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2. istream&amp; istream::getline(char* buf, int bufSize, char spchar); //读到 spchar 字符为止</span><br><span class="hljs-comment">			         	// \n 或 spchar 都不会被读入 buf，但会被从文件输入流缓冲区中取走</span><br><span class="hljs-comment">    样例： char s[100];  cin.getline(s, sizeof(s), &#x27; &#x27;); 		// 读一个串，遇到空格停止读入</span><br><span class="hljs-comment">    备注：每次调用getline后，流指针会自动指向spchar后的下一个字符位置。 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">3. istream&amp; getline (istream&amp; is, string&amp; substr);	// 读到\n为止</span><br><span class="hljs-comment">    is：输入流对象，可以是 std::cin（标准输入）、文件流对象（std::ifstream）、字符串流对象（std::istringstream）等等。</span><br><span class="hljs-comment">	样例： string str; ifstream fs(&quot;example.txt&quot;); istringstream ss(&quot;Hello World!\nThis is a new line.&quot;);</span><br><span class="hljs-comment">           getline(cin, substr);    getline(fs, substr); getline(ss, substr);</span><br><span class="hljs-comment">    备注：每次调用getline后，流指针会自动指向&#x27;\n&#x27;后的下一个字符位置。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">4. istream&amp; getline (istream&amp; is, string&amp; substr, char spchar);	// 读到spchar为止</span><br><span class="hljs-comment">    is：同 3 </span><br><span class="hljs-comment">	样例： string str; ifstream fs(&quot;example.txt&quot;); istringstream ss(&quot;Hello World!\nThis is a new line.&quot;);</span><br><span class="hljs-comment">           getline(cin, substr, &#x27; &#x27;);    getline(fs, substr, &#x27; &#x27;);   getline(ss, substr, &#x27; &#x27;);</span><br><span class="hljs-comment">    备注：每次调用getline后，流指针会自动指向spchar后的下一个字符位置。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br>string mid, post;<br>stack&lt;<span class="hljs-type">char</span>&gt; OPTR;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getlevel</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;+&#x27;</span> || ch==<span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;*&#x27;</span> || ch==<span class="hljs-string">&#x27;/&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">20</span>;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;^&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">30</span>;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;(&#x27;</span> || ch==<span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-10</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mysplit</span><span class="hljs-params">(string str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> spchar, vector&lt;string&gt;&amp; rst)</span> </span>&#123;<br>	<span class="hljs-function">istringstream <span class="hljs-title">mycin</span><span class="hljs-params">(str)</span></span>;	<span class="hljs-comment">// 字符串输入流</span><br>	string substr;			<span class="hljs-comment">// 接收缓冲区</span><br>	<span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(mycin, substr, spchar)) &#123;	<span class="hljs-comment">// 以spchar为分隔符.读到 spchar 字符为止，spchar字符不会被读入 buf，但会被从文件输入流缓冲区中取走</span><br>		<span class="hljs-comment">//cout &lt;&lt; substr &lt;&lt; endl; // 输出</span><br>		rst.<span class="hljs-built_in">push_back</span>(substr);<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-comment">// 从这里开始...</span><br>	cin &gt;&gt; mid;<br>	<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;<br>	OPTR.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;#&#x27;</span>);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=mid.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 末尾的空字符也参与处理</span><br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(mid[i]))            <span class="hljs-comment">// 如果是数字</span><br>			x=x*<span class="hljs-number">10</span> + mid[i]- <span class="hljs-string">&#x27;0&#x27;</span>;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mid[i]==<span class="hljs-string">&#x27;(&#x27;</span> )          <span class="hljs-comment">// 遇到&#x27;(&#x27; ，无条件入栈OPTR ，作为后续处理&#x27;)&#x27;时的截止标记</span><br>			OPTR.<span class="hljs-built_in">push</span>(mid[i]);<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mid[i]==<span class="hljs-string">&#x27;)&#x27;</span> ) &#123;        <span class="hljs-comment">// 遇到&#x27;)&#x27; ，左侧必然有操作数，先处理数，然后处理残留的操作符</span><br>			post.<span class="hljs-built_in">append</span>(<span class="hljs-built_in">to_string</span>(x));<br>			x=<span class="hljs-number">0</span>;<br>			post.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>			<span class="hljs-keyword">while</span>(OPTR.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;(&#x27;</span>) &#123;    <span class="hljs-comment">// ()内残留的操作符可能有多个，必然从左往右优先级依次增高，倒序输出即可</span><br>				post.<span class="hljs-built_in">push_back</span>(OPTR.<span class="hljs-built_in">top</span>());<br>				post.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>				OPTR.<span class="hljs-built_in">pop</span>();<br>			&#125;<br>			OPTR.<span class="hljs-built_in">pop</span>();                 <span class="hljs-comment">// 把OPTR 中的&#x27;(&#x27; 也扔掉，但不输出</span><br>		&#125; <br>		<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// +  -  *  /   ^   &#x27;\0&#x27;</span><br>			<span class="hljs-comment">// 若其左侧是&#x27;)&#x27;，则已经在处理&#x27;)&#x27;时处理过x，则不必再管x了</span><br>			<span class="hljs-comment">// 否则需要处理左侧的操作数x</span><br>			<span class="hljs-keyword">if</span> (mid[i<span class="hljs-number">-1</span>] != <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>				post.<span class="hljs-built_in">append</span>(<span class="hljs-built_in">to_string</span>(x));<br>				x=<span class="hljs-number">0</span>;<br>				post.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>			&#125;<br>			<span class="hljs-comment">// 2种情况需入栈当前操作符： 1.当前操作符优先级更高 2.当前和左侧的操作符都是&#x27;^&#x27;，它是靠右优先的，先算右侧的那个乘方</span><br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">getlevel</span>(OPTR.<span class="hljs-built_in">top</span>()) &lt; <span class="hljs-built_in">getlevel</span>(mid[i]) || OPTR.<span class="hljs-built_in">top</span>()==<span class="hljs-string">&#x27;^&#x27;</span> &amp;&amp; mid[i]==<span class="hljs-string">&#x27;^&#x27;</span>)<br>				OPTR.<span class="hljs-built_in">push</span>(mid[i]);<br>			<span class="hljs-keyword">else</span> &#123;   <span class="hljs-comment">// 若当前操作符优先级比左侧操作符优先级更低，或相等， 则需先处理左侧</span><br>				<span class="hljs-type">char</span> ch=OPTR.<span class="hljs-built_in">top</span>();<br>				<span class="hljs-keyword">while</span> (<span class="hljs-built_in">getlevel</span>(ch)&gt;=<span class="hljs-built_in">getlevel</span>(mid[i])) &#123;  <span class="hljs-comment">// 可能会做多次，参看表格中i=10或15时</span><br>					OPTR.<span class="hljs-built_in">pop</span>();<br>					post.<span class="hljs-built_in">push_back</span>(ch);<br>					post.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>					ch=OPTR.<span class="hljs-built_in">top</span>();<br>					<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">break</span>;<br>				&#125;<br>				<span class="hljs-keyword">if</span> (mid[i]!=<span class="hljs-string">&#x27;\0&#x27;</span>) OPTR.<span class="hljs-built_in">push</span>(mid[i]);      <span class="hljs-comment">// 别忘了当前操作符还是要入栈OPTR的 </span><br>			&#125;<br>		&#125;<br><br>	&#125;<br>	cout &lt;&lt;post &lt;&lt;endl;<br>	vector&lt;string&gt; strList;<br>	<span class="hljs-built_in">mysplit</span>(post, <span class="hljs-string">&#x27; &#x27;</span>, strList);	<span class="hljs-comment">// 将子串存放到strList中</span><br><br>	<span class="hljs-keyword">while</span> (strList.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-comment">// 后缀串，操作符不可能在第0和1号位，直接从2号开始</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;strList.<span class="hljs-built_in">size</span>(); i++) &#123;<br>			<span class="hljs-keyword">if</span> (strList[i]==<span class="hljs-string">&quot;+&quot;</span> || strList[i]==<span class="hljs-string">&quot;-&quot;</span> || strList[i]==<span class="hljs-string">&quot;*&quot;</span> || strList[i]==<span class="hljs-string">&quot;/&quot;</span> || strList[i]==<span class="hljs-string">&quot;^&quot;</span> ) &#123;<br>				<span class="hljs-type">int</span> le= <span class="hljs-built_in">stoi</span>(strList[i<span class="hljs-number">-2</span>]);<br>				<span class="hljs-type">int</span> ri= <span class="hljs-built_in">stoi</span>(strList[i<span class="hljs-number">-1</span>]);<br>				<span class="hljs-keyword">if</span> (strList[i]==<span class="hljs-string">&quot;+&quot;</span>)<br>					strList[i<span class="hljs-number">-2</span>]=<span class="hljs-built_in">to_string</span>(le + ri);<br>				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strList[i]==<span class="hljs-string">&quot;-&quot;</span>)<br>					strList[i<span class="hljs-number">-2</span>]=<span class="hljs-built_in">to_string</span>(le - ri);<br>				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strList[i]==<span class="hljs-string">&quot;*&quot;</span>)<br>					strList[i<span class="hljs-number">-2</span>]=<span class="hljs-built_in">to_string</span>(le * ri);<br>				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strList[i]==<span class="hljs-string">&quot;/&quot;</span>)<br>					strList[i<span class="hljs-number">-2</span>]=<span class="hljs-built_in">to_string</span>(le / ri);<br>				<span class="hljs-keyword">else</span><br>					strList[i<span class="hljs-number">-2</span>]=<span class="hljs-built_in">to_string</span>((<span class="hljs-type">int</span>)(<span class="hljs-built_in">pow</span>(le, ri)));<br><br>				strList.<span class="hljs-built_in">erase</span>(strList.<span class="hljs-built_in">begin</span>()+i<span class="hljs-number">-1</span>); <span class="hljs-comment">// 连续删掉第i-2个串后续的两个串</span><br>				strList.<span class="hljs-built_in">erase</span>(strList.<span class="hljs-built_in">begin</span>()+i<span class="hljs-number">-1</span>);<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> s:strList)<br>			cout &lt;&lt; s &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>		cout &lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">18-(13+2*6-1)/5+4</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">1+2+5</span><br><span class="hljs-comment">1 2 + 5 +</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2^2^3</span><br><span class="hljs-comment">2 2 3 ^ ^ </span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure>
<p>　　</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">雪宝和七七的爸爸</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/02/15/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%882%EF%BC%89%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/">http://example.com/2025/02/15/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%882%EF%BC%89%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">宝爸编程</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BF%A1%E6%81%AF%E5%AD%A6/">信息学</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/02/20/%E5%8D%95%E8%B0%83%E6%A0%88%E5%85%A5%E9%97%A8&amp;%E6%89%BE%E9%99%84%E8%BF%91%E6%9B%B4%E5%A4%A7%EF%BC%8F%E5%B0%8F%E5%80%BC/" title="单调栈入门&amp;找附近更大／小值"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">单调栈入门&amp;找附近更大／小值</div></div></a></div><div class="next-post pull-right"><a href="/2025/02/14/%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%92%8C%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F/" title="栈的基本操作和简单模拟"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">栈的基本操作和简单模拟</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/04/25/LCS%E9%97%AE%E9%A2%98/" title="最长公共子序列（LCS）问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-25</div><div class="title">最长公共子序列（LCS）问题</div></div></a></div><div><a href="/2024/04/25/LIS%E9%97%AE%E9%A2%98/" title="最长不下降子序列（LIS）问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-25</div><div class="title">最长不下降子序列（LIS）问题</div></div></a></div><div><a href="/2024/07/31/dp%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E8%AE%AD%E7%BB%83/" title="dp中的状态转移训练"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-31</div><div class="title">dp中的状态转移训练</div></div></a></div><div><a href="/2025/03/02/GESP%E5%85%AB%E7%BA%A7%EF%BC%88202312-202412%EF%BC%89%E6%9C%AA%E5%AE%8C/" title="GESP八级（202312-202412）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-02</div><div class="title">GESP八级（202312-202412）</div></div></a></div><div><a href="/2024/07/02/%E4%B8%89%E7%A7%8D%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E7%9A%84%E5%A4%84%E7%90%86/" title="三种分组背包的处理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-02</div><div class="title">三种分组背包的处理</div></div></a></div><div><a href="/2025/01/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D-%E4%B8%AD-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/" title="二叉树的前-中-后序遍历"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-10</div><div class="title">二叉树的前-中-后序遍历</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">雪宝和七七的爸爸</div><div class="author-info__description">本博客致力于信息学奥赛知识学习。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://cspcoding.github.io/"><i class="fab fa-github"></i><span>回到主页</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">玩游戏害人害己哦！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%90%86%E8%AE%BA%E4%BB%8B%E7%BB%8D"><span class="toc-text">一、理论介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%9E%E6%88%98%E8%AE%AD%E7%BB%83"><span class="toc-text">二、实战训练</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC-1198"><span class="toc-text">2.1 前缀表达式求值　1198</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5"><span class="toc-text">2.1.1 原题链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E5%88%86%E6%9E%90"><span class="toc-text">2.1.2 分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-AC%E4%BB%A3%E7%A0%81"><span class="toc-text">2.1.3 AC代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC-1331%EF%BC%8FP1449"><span class="toc-text">2.2 后缀表达式求值　1331／P1449</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5"><span class="toc-text">2.2.1 原题链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E5%88%86%E6%9E%90"><span class="toc-text">2.2.2 分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-AC%E4%BB%A3%E7%A0%81"><span class="toc-text">2.2.3 AC代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-1-1331%E7%9A%84AC%E4%BB%A3%E7%A0%81"><span class="toc-text">2.2.3.1 1331的AC代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-2-P1449%E7%9A%84AC%E4%BB%A3%E7%A0%81"><span class="toc-text">2.2.3.2 P1449的AC代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%97%A0%E6%8B%AC%E5%8F%B7%E7%9A%84%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC-P1981%EF%BC%8F1962"><span class="toc-text">2.3 无括号的中缀表达式求值 P1981／1962</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5"><span class="toc-text">2.3.1 原题链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E5%88%86%E6%9E%90"><span class="toc-text">2.3.2 分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-AC%E4%BB%A3%E7%A0%81"><span class="toc-text">2.3.3 AC代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%B8%A6%E6%8B%AC%E5%8F%B7%E7%9A%84%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-text">2.4 带括号的中缀表达式求值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-1356-%E8%AE%A1%E7%AE%97-calc"><span class="toc-text">2.4.1 1356 计算(calc)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-1-%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5"><span class="toc-text">2.4.1.1 原题链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-2-%E5%88%86%E6%9E%90"><span class="toc-text">2.4.1.2 分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-3-AC%E4%BB%A3%E7%A0%81"><span class="toc-text">2.4.1.3 AC代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-P10473-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%974"><span class="toc-text">2.4.2 P10473 表达式计算4</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-1-%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5"><span class="toc-text">2.4.2.1 原题链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-2-%E5%88%86%E6%9E%90"><span class="toc-text">2.4.2.2 分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-3-AC%E4%BB%A3%E7%A0%81"><span class="toc-text">2.4.2.3 AC代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-1358"><span class="toc-text">2.4.3 1358</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-1-%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5"><span class="toc-text">2.4.3.1 原题链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-2-%E5%88%86%E6%9E%90"><span class="toc-text">　2.4.3.2 分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-3-AC%E4%BB%A3%E7%A0%81"><span class="toc-text">2.4.3.3 AC代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E5%B8%A6%E5%AE%8C%E6%95%B4%E6%8B%AC%E5%8F%B7%E7%9A%84%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%9F%E6%88%90%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89SP4"><span class="toc-text">2.5  中缀转后缀表达式（带完整括号的中缀表达式生成后缀表达式）SP4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5"><span class="toc-text">2.5 1 原题链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-%E5%88%86%E6%9E%90"><span class="toc-text">2.5.2 分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-AC%E4%BB%A3%E7%A0%81"><span class="toc-text">2.5.3 AC代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%90%8E%E7%BC%80%EF%BC%8C%E8%AE%A1%E7%AE%97%E5%90%8E%E7%BC%80%E5%80%BC%E2%80%94%E2%80%94P1175"><span class="toc-text">2.6 中缀转后缀，计算后缀值——P1175</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-P1175"><span class="toc-text">2.6.1 P1175</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-1-%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5"><span class="toc-text">2.6.1.1 原题链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-2-%E5%88%86%E6%9E%90"><span class="toc-text">2.6.1.2 分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-3-AC%E4%BB%A3%E7%A0%81"><span class="toc-text">2.6.1.3 AC代码</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/GESP%E5%85%AB%E7%BA%A7%EF%BC%88202312-202412%EF%BC%89%E6%9C%AA%E5%AE%8C/" title="GESP八级（202312-202412）">GESP八级（202312-202412）</a><time datetime="2025-03-01T16:00:00.000Z" title="发表于 2025-03-02 00:00:00">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/%E5%A4%9A%E9%87%8D%E7%BB%84%E5%90%88%E6%95%B0%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/" title="多重组合数">多重组合数</a><time datetime="2025-03-01T16:00:00.000Z" title="发表于 2025-03-02 00:00:00">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/%E7%9B%92%E5%AD%90%E6%94%BE%E7%90%83%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0%E9%97%AE%E9%A2%98%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/" title="盒子放球的方案数问题">盒子放球的方案数问题</a><time datetime="2025-03-01T16:00:00.000Z" title="发表于 2025-03-02 00:00:00">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/27/%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9B%BA%E5%AE%9A%E5%AE%BD%E5%BA%A6%E4%B8%BAm%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/" title="（二）固定宽度为m的区间的“最大的和值”问题">（二）固定宽度为m的区间的“最大的和值”问题</a><time datetime="2025-02-27T06:21:42.811Z" title="发表于 2025-02-27 14:21:42">2025-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/27/%EF%BC%88%E4%B8%89%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/" title="（三）宽度小于等于m的区间的“最大的和值”问题">（三）宽度小于等于m的区间的“最大的和值”问题</a><time datetime="2025-02-27T06:21:42.809Z" title="发表于 2025-02-27 14:21:42">2025-02-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 雪宝和七七的爸爸</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script src="/js/custom.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>