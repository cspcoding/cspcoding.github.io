<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>（七）不限宽的m子段的“最大的和值”问题 | 宝爸编程</title><meta name="author" content="雪宝和七七的爸爸"><meta name="copyright" content="雪宝和七七的爸爸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本帖是“最大子段和”系列问题的第7帖，主要研究不限宽的m子段的“最大的和值”问题。 一. 原题链接 　　HDU1024 Max Sum Plus Plus 　　中文大意如下： 　　给定一个连续的整数序列 \(a[1:n]&#x3D;\{a_1、a_2、a_3、a_4、 ... a_i、... a_n\} (1 ≤ i ≤ n ≤ 1,000,000，-32768 ≤ a_i ≤ 32767)">
<meta property="og:type" content="article">
<meta property="og:title" content="（七）不限宽的m子段的“最大的和值”问题">
<meta property="og:url" content="http://example.com/2025/01/01/%EF%BC%88%E4%B8%83%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84m%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/index.html">
<meta property="og:site_name" content="宝爸编程">
<meta property="og:description" content="本帖是“最大子段和”系列问题的第7帖，主要研究不限宽的m子段的“最大的和值”问题。 一. 原题链接 　　HDU1024 Max Sum Plus Plus 　　中文大意如下： 　　给定一个连续的整数序列 \(a[1:n]&#x3D;\{a_1、a_2、a_3、a_4、 ... a_i、... a_n\} (1 ≤ i ≤ n ≤ 1,000,000，-32768 ≤ a_i ≤ 32767)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-12-31T16:00:00.000Z">
<meta property="article:modified_time" content="2025-02-27T06:21:42.806Z">
<meta property="article:author" content="雪宝和七七的爸爸">
<meta property="article:tag" content="信息学">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/01/01/%EF%BC%88%E4%B8%83%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84m%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":5,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '（七）不限宽的m子段的“最大的和值”问题',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2025-02-27 14:21:42'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/static/css/custom.css"><link rel="stylesheet" href="/fonts/font.css"><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="宝爸编程"><span class="site-name">宝爸编程</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">（七）不限宽的m子段的“最大的和值”问题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-31T16:00:00.000Z" title="发表于 2025-01-01 00:00:00">2025-01-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-27T06:21:42.806Z" title="更新于 2025-02-27 14:21:42">2025-02-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/">线性结构编程技巧</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/">最大子段和</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="（七）不限宽的m子段的“最大的和值”问题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>　　本帖是“最大子段和”系列问题的第7帖，主要研究不限宽的m子段的“最大的和值”问题。</p>
<h1 id="一.-原题链接">一. 原题链接</h1>
<p>　　<a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=1024">HDU1024
Max Sum Plus Plus</a></p>
<p>　　中文大意如下：</p>
<p>　　给定一个连续的整数序列 <span
class="math inline">\(a[1:n]=\{a_1、a_2、a_3、a_4、 ... a_i、... a_n\}
(1 ≤ i ≤ n ≤ 1,000,000，-32768 ≤ a_i ≤ 32767)\)</span>。有函数 <span
class="math inline">\(sum(le, ri) = a_{le} + ... + a_{ri} \quad(1 ≤ le ≤
ri ≤ n)\)</span>。现在给定一个整数 <span class="math inline">\(m (m &gt;
0)\)</span>，你的任务是找出$ m $（不能多，也不能少）对 <span
class="math inline">\(le\)</span> 和<span
class="math inline">\(ri\)</span>，使得 $sum(le_1 , ri_1 ) + sum(le_2 ,
ri_2 ) + ... + sum(le_m , ri_m ) <span
class="math inline">\(最大。（不允许\)</span>le_i ≤ le_j ≤ ri_i<span
class="math inline">\(或\)</span> le_i ≤ ri_j ≤
ri_i$，即不允许区间之间有重叠或交叉）。</p>
<p>　　输入的行数不确定，每一行代表了一个测试样例，该行第１个数是<span
class="math inline">\(m\)</span>，第２个数是<span
class="math inline">\(n\)</span>，后续跟着<span
class="math inline">\(n\)</span>个整数。</p>
<p>　　输出多行，和输入行数一致，每行为一个测试样例中的ｍ段最大和值。</p>
<h1 id="二.-分析">二. 分析</h1>
<p>　　之前我们学过不限宽的２段的最大的和值问题，本题要做的是<span
class="math inline">\(ｍ(m&gt;0)\)</span>段。感觉这个题是之前旧题的升级版。能不能在原有题型的基础上进行拓展来解决本题型呢？对于２段，我们枚举了分隔点，利用它把整个数组分成了左半段和右半段，然后正推，逆推。但如果是４段、１０段等，明显原来的方法不再适用了。需要重新换思路了，怎么搞？</p>
<p>　　目前已经学过的方法有贪心、分治、递推（ｄｐ）、深搜、二分等。对于给定的数组<span
class="math inline">\(a[1..n]\)</span>，原始顺序肯定不能随意改变，否则题解肯定会大变。所以肯定不能排序了。分治和递推实际上是同一种思路，只不过是范围从大到小或从小到大的区别。深搜肯定不行，绝对TLE。二分主要用于在单调性函数中确定一个点的值，这里好像对不上。现在试着来递推一下看看。</p>
<p>　　递推和ｄｐ是相通的。下面尝试采用ｄｐ的思路来思考。</p>
<p>　　本题要求在ｎ个数中选择ｍ个连续子段，求其最大子段和。ｎ不同，结果不同；ｍ不同，结果也会不同。所以，ｎ和ｍ都会影响最终的结果值。一个状态由数组元素个数ｊ和子段数ｉ共同确定。鉴于子段数据的连续性，为了方便研究，所以有如下：</p>
<p>一）状态数组定义</p>
<p>　　<span class="math inline">\(dp[i][j]\)</span>表示在<span
class="math inline">\(a[1..j]\)</span>中选择<span
class="math inline">\(i\)</span>个子段，且<span
class="math inline">\(a[j]\)</span>属于第<span
class="math inline">\(i\)</span>个子段后的最大子段和值。（之所以让子段数在第一维，是为后续的dp数组空间优化做准备，这纯属经验；之所以要求<span
class="math inline">\(a[j]\)</span>必须要在最末子段内，也属经验）</p>
<p>二）所求目标</p>
<p>　　<span class="math inline">\(max(\ dp[m][m:n]\ )\)</span></p>
<p>三）状态转移方程</p>
<p>　　因为每个子段内的数据必然是连续性的，所以对于每个新元素<span
class="math inline">\(a[j]\)</span>有如下两种情况：</p>
<p>　　１）已有<span
class="math inline">\(i-1\)</span>个子段，新开第<span
class="math inline">\(i\)</span>个子段，且把<span
class="math inline">\(a[j]\)</span>作为该新子段的第一个元素；</p>
<p>　　　　<span class="math inline">\(a[j]\)</span>左侧已经选出了<span
class="math inline">\(i-1\)</span>个子段，可以模拟个数据来分析一下。假设<span
class="math inline">\(m=5,n=7\)</span>，现在要求<span
class="math inline">\(dp[3][5]\)</span>，则在情况１）下，有"前５个数选３个子段的和＝max(前２个数各自成子段且第５个数成第３子段，前３个数选出２子段且第５个数成第３子段，　前４个数选出２个子段且第５个数成第３子段)"，写成公式如下：
<span class="math display">\[
dp[3][5]=max(\ a[5]+dp[2][2],\ \ \ a[5]+dp[2][3],\ \ \ a[5]+dp[2][4]\ )
\]</span> 　　　　将其一般化，有下面的公式（１）： <span
class="math display">\[
dp[i][j]=a[j]\ +\ max(\ dp[i-1][k]\ );\quad(i \in [1:m];\
j\in[i:i+n-m];\ k \in[i-1:j-1]\ )\tag{1}
\]</span> 　　２）已有<span
class="math inline">\(i\)</span>个子段，把<span
class="math inline">\(a[j]\)</span>作为第<span
class="math inline">\(i\)</span>个子段的元素，总的子段数不变仍为<span
class="math inline">\(i\)</span>个； <span class="math display">\[
dp[i][j]=a[j]+dp[i][j-1];\quad (\ i\in[1:m];\ j\in[i:i+n-m]\ )\tag{2}
\]</span> 　　将公式（１）和（２）整合一下，得到最后的状态转移方程如下：
<span class="math display">\[
dp[i][j]=a[j]+max\textcolor[RGB]{255,0,0}(\ dp[i][j-1]\
+\  max\textcolor[RGB]{255,255,0}(\ dp[i-1][k]\
\textcolor[RGB]{255,255,0})\ \textcolor[RGB]{255,0,0});\quad(i \in
[1:m];\ j\in[i:i+n-m];\ k \in[i-1:j-1]\ )\tag{3}
\]</span> 四）循环顺序和边界</p>
<p><img src="https://cspimg.oss-cn-chengdu.aliyuncs.com/img/%EF%BC%88%E4%B8%83%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84m%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%981.png" alt="image-20250101143316213" style="zoom: 80%;" /></p>
<p>　　对于<span class="math inline">\(i\)</span>，肯定是<span
class="math inline">\([1:m]\)</span>，根据公式（３），需要用到上一行的内容，所以<span
class="math inline">\(i\)</span>只能从上往下增序。</p>
<p>　　对于<span
class="math inline">\(j\)</span>，我们的目的是要算出<span
class="math inline">\(dp[m][m:n]\)</span>，例如求<span
class="math inline">\(dp[4][7]\)</span>，我们没必要去计算和填写<span
class="math inline">\(dp[1][5]、dp[2][6]\)</span>等数据，为什么呢？因为要想在前７个数中选出４个子段，那么就不可能在前６个数中选出２个子段，因为仅剩７－６＝１个数了，没办法把１个数划分出4－２＝２个子段，也没办法把２个数划分出４－１＝３个子段。所以虽然<span
class="math inline">\(dp[1][5]、dp[2][6]\)</span>存在，但对我们的所求目标没有任何贡献，自然不需要去计算了（如上图灰色区域格子）。准确地说，剩余的数的个数<span
class="math inline">\(n-j\)</span>要大于等于剩余的子段数<span
class="math inline">\(m-i\)</span>，即有<span
class="math inline">\(n-j\geq m-i\quad \Rightarrow\quad j \leq i+n-m\
\)</span>。另外，我们也没必要去填写诸如<span
class="math inline">\(dp[5][2]\)</span>这类数据（如上图红色区域格子），因为前２个数据不可能被分为５个子段，因为每个子段至少要有１个数据。也就是说，<span
class="math inline">\(j\geq i\)</span>。归纳一下得<span
class="math inline">\(j \in[i:i+n-m]\)</span>，每行填写<span
class="math inline">\(n-m+1\)</span>个数即可。因为需要用到第<span
class="math inline">\(j-1\)</span>列的数据，所以<span
class="math inline">\(j\)</span>只能从左往右增序。</p>
<p>　　对于<span
class="math inline">\(k\)</span>，来自于公式（３）中的<span
class="math inline">\(max(dp[i-1][k])\)</span>，对应的<span
class="math inline">\(dp[][]\)</span>数据来自于上一行，全都已知，故<span
class="math inline">\(k\)</span>增序降序都可以。假设第<span
class="math inline">\(i-1\)</span>个子段的最右侧元素下标为<span
class="math inline">\(k\)</span>，则<span
class="math inline">\(k\)</span>可能的最小值为<span
class="math inline">\(i-1\)</span>（前面的每１个元素都自成１个子段，则第<span
class="math inline">\(i-1\)</span>个子段为<span
class="math inline">\(a[i-1:i-1]\)</span>）。<span
class="math inline">\(k\)</span>可能的最大值是<span
class="math inline">\(j-1\)</span>。总结后<span
class="math inline">\(k\)</span>的范围就是<span
class="math inline">\([i-1:j-1]\)</span>。</p>
<p>五）特例和初始化</p>
<p>　　对于对角线和第１行的数据，均来自于左侧一列、上一行和<span
class="math inline">\(a[]\)</span>，当默认数据为０时公式（３）并不冲突，所以直接初始化<span
class="math inline">\(dp[0:m][0:n]\)</span>为全０即可。</p>
<p>六）复杂度分析</p>
<p>　　可以看到，公式（３）的时间复杂度和空间复杂度都是比较高的，时间复杂度为<span
class="math inline">\(O(m*(n-m)^2)\)</span>，空间复杂度为<span
class="math inline">\(O(m*n)\)</span>。</p>
<p>七）时间复杂度优化</p>
<p>　　对于上图中求红色长方框内区域的最大值，没必要针对每个<span
class="math inline">\(dp[i][j]\)</span>去循环<span
class="math inline">\(k\)</span>来重新计算当前的最大值，完全可以利用上一轮计算的结果来刷新最大值。需要注意的是，随着<span
class="math inline">\(j\)</span>的循环，需要比较最大值的元素是<span
class="math inline">\(dp[i-1][j-1]\)</span>。这样可以把三重循环降为二重循环，时间复杂度变为<span
class="math inline">\(O(m*(n-m))\)</span>。</p>
<p>八）空间复杂度优化</p>
<p>　　从上图和公式（３）可以看到，每次填写一个网格，只需要用到上一行和当前行左侧一格的数据，但此处不能用滚动数组，因为根据分析，我们必须要从左往右去循环<span
class="math inline">\(j\)</span>（不能从右往左），且需要用到的是<span
class="math inline">\(dp[i-1][i-1:j-1]\)</span>，而不是<span
class="math inline">\(dp[i][i-1:j-1]\)</span>。但所幸的是，只需要用到当前行和上一行的完整数据，所以没必要设定<span
class="math inline">\(dp[][]\)</span>为<span
class="math inline">\(m\)</span>行。故而只需要设定<span
class="math inline">\(dp[2][0..n]\)</span>这２行即可，空间复杂度降为<span
class="math inline">\(O(2*n)\)</span>。</p>
<p>　　我们没必要每次填完之后去来回复制整行，这里可以学习一个小的编程技巧。我们知道<span
class="math inline">\(0\oplus 1=1;1\oplus 1=0;\)</span>（<span
class="math inline">\(\oplus\)</span>表示“按位异或”），也就是说，不管起初变量a=1或者a=0，在做<span
class="math inline">\(\oplus
1\)</span>操作后的算式值都会恰好相反（即从０变成１，或从１变成０），所以在提取上一行值时可以用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">maxpre=<span class="hljs-built_in">max</span>(maxpre, dp[k^<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]);  <span class="hljs-comment">// k^1表示上一行。当k==0时k^1的值为1,当k==1时k^1的值为0</span><br></code></pre></td></tr></table></figure>
<p>　　这样设置后，第<span
class="math inline">\(m\)</span>行的结果最后是存放在<span
class="math inline">\(dp[0][...]\)</span>或者<span
class="math inline">\(dp[1][...]\)</span>呢？当<span
class="math inline">\(m=1\)</span>时最终结果在第１行，当<span
class="math inline">\(m=2\)</span>时最终结果在第０行，当<span
class="math inline">\(m=3\)</span>时最终结果在第１行，当<span
class="math inline">\(m=4\)</span>时最终结果在第０行，当<span
class="math inline">\(m=5\)</span>时最终结果在第１行，……。可以看出，ｍ若为奇数则在１，ｍ若为偶数则在０。故结果可以写成<span
class="math inline">\(dp[m\%2][...]\)</span>或者<span
class="math inline">\(dp[m\&amp;1][...]\)</span>。</p>
<h1 id="三.-ac代码">三. AC代码</h1>
<p>　　注意一下，long
long类型的最大值为LLONG_MAX。不过本题数据弱，使用INT_MAX也没报错～～</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>; <br><span class="hljs-type">int</span> n,m;<br>ll a[N],dp[<span class="hljs-number">2</span>][N];   <span class="hljs-comment">//只保存上一行和当前行 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;m,&amp;n))&#123;   <span class="hljs-comment">//n个数字，m子段和 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,a+i);  <br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) dp[<span class="hljs-number">0</span>][i]=<span class="hljs-number">0</span>,dp[<span class="hljs-number">1</span>][i]=<span class="hljs-number">0</span>;    <br>		<span class="hljs-comment">// 仍然需要设定i来标识出j的左右边界值，k只是0或1，无法代替这一个功能，k只在存入和读取dp的时候起作用 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,k=<span class="hljs-number">1</span>; i&lt;=m; i++,k^=<span class="hljs-number">1</span>)&#123;    <span class="hljs-comment">//分为i段，k为两行之间的切换</span><br>        	dp[k][i<span class="hljs-number">-1</span>]= -LLONG_MAX;    <span class="hljs-comment">// 让同行左侧的dp[i][i-1]值不去影响dp[i][i]的填写，此时也需用到 k </span><br>            ll maxpre = -LLONG_MAX;    <span class="hljs-comment">// maxpre记录上一行的最大值，在每一行开始时需要重新置初始值 </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n-m+i;j++)&#123;<br>                maxpre=<span class="hljs-built_in">max</span>(maxpre,dp[k^<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]);      <span class="hljs-comment">//随时更新上一行最大值</span><br>                dp[k][j]=<span class="hljs-built_in">max</span>(dp[k][j<span class="hljs-number">-1</span>],maxpre)+a[j]; <span class="hljs-comment">//对应公式３</span><br>            &#125;<br>        &#125;<br>        ll ans= -LLONG_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m;i&lt;=n;i++) ans=<span class="hljs-built_in">max</span>(ans,dp[m&amp;<span class="hljs-number">1</span>][i]);  <span class="hljs-comment">//找到第m行的最大值，即为答案</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>    &#125;  <br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入 </span><br><span class="hljs-comment">4 7 -2 11 -4 13 -5 6 -2</span><br><span class="hljs-comment">输出</span><br><span class="hljs-comment">28 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">雪宝和七七的爸爸</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/01/01/%EF%BC%88%E4%B8%83%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84m%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/">http://example.com/2025/01/01/%EF%BC%88%E4%B8%83%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%84m%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">宝爸编程</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BF%A1%E6%81%AF%E5%AD%A6/">信息学</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/01/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D-%E4%B8%AD-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/" title="二叉树的前-中-后序遍历"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">二叉树的前-中-后序遍历</div></div></a></div><div class="next-post pull-right"><a href="/2024/12/31/%EF%BC%88%E5%85%AD%EF%BC%89%E4%B8%8D%E9%99%90%E5%AE%BD%E7%9A%842%E5%AD%90%E6%AE%B5%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/" title="（六）不限宽的2子段的“最大的和值”问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">（六）不限宽的2子段的“最大的和值”问题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/03/02/GESP%E5%85%AB%E7%BA%A7%EF%BC%88202312-202412%EF%BC%89%E6%9C%AA%E5%AE%8C/" title="GESP八级（202312-202412）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-02</div><div class="title">GESP八级（202312-202412）</div></div></a></div><div><a href="/2024/04/25/LCS%E9%97%AE%E9%A2%98/" title="最长公共子序列（LCS）问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-25</div><div class="title">最长公共子序列（LCS）问题</div></div></a></div><div><a href="/2024/07/31/dp%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E8%AE%AD%E7%BB%83/" title="dp中的状态转移训练"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-31</div><div class="title">dp中的状态转移训练</div></div></a></div><div><a href="/2024/04/25/LIS%E9%97%AE%E9%A2%98/" title="最长不下降子序列（LIS）问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-25</div><div class="title">最长不下降子序列（LIS）问题</div></div></a></div><div><a href="/2020/03/13/hello/" title="我的第一篇博客"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-13</div><div class="title">我的第一篇博客</div></div></a></div><div><a href="/2024/03/06/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/" title="二分查找和二分答案"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-06</div><div class="title">二分查找和二分答案</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">雪宝和七七的爸爸</div><div class="author-info__description">本博客致力于信息学奥赛知识学习。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://cspcoding.github.io/"><i class="fab fa-github"></i><span>回到主页</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">玩游戏害人害己哦！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80.-%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5"><span class="toc-text">一. 原题链接</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C.-%E5%88%86%E6%9E%90"><span class="toc-text">二. 分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89.-ac%E4%BB%A3%E7%A0%81"><span class="toc-text">三. AC代码</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/GESP%E5%85%AB%E7%BA%A7%EF%BC%88202312-202412%EF%BC%89%E6%9C%AA%E5%AE%8C/" title="GESP八级（202312-202412）">GESP八级（202312-202412）</a><time datetime="2025-03-01T16:00:00.000Z" title="发表于 2025-03-02 00:00:00">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/%E5%A4%9A%E9%87%8D%E7%BB%84%E5%90%88%E6%95%B0%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/" title="多重组合数">多重组合数</a><time datetime="2025-03-01T16:00:00.000Z" title="发表于 2025-03-02 00:00:00">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/%E7%9B%92%E5%AD%90%E6%94%BE%E7%90%83%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0%E9%97%AE%E9%A2%98%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/" title="盒子放球的方案数问题">盒子放球的方案数问题</a><time datetime="2025-03-01T16:00:00.000Z" title="发表于 2025-03-02 00:00:00">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/27/%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9B%BA%E5%AE%9A%E5%AE%BD%E5%BA%A6%E4%B8%BAm%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/" title="（二）固定宽度为m的区间的“最大的和值”问题">（二）固定宽度为m的区间的“最大的和值”问题</a><time datetime="2025-02-27T06:21:42.811Z" title="发表于 2025-02-27 14:21:42">2025-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/27/%EF%BC%88%E4%B8%89%EF%BC%89%E5%AE%BD%E5%BA%A6%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Em%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E2%80%9C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C%E5%80%BC%E2%80%9D%E9%97%AE%E9%A2%98/" title="（三）宽度小于等于m的区间的“最大的和值”问题">（三）宽度小于等于m的区间的“最大的和值”问题</a><time datetime="2025-02-27T06:21:42.809Z" title="发表于 2025-02-27 14:21:42">2025-02-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 雪宝和七七的爸爸</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script src="/js/custom.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>